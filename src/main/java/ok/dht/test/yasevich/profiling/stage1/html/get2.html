<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BFwNABNlBuIhLl{EG????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????@??????????????????????``RPPQHPQHIPHQIPQIIGPQIAPPQIPPIHHPOIPQAPHIAIHQPIXPQHIPPQHPHIIPPQIIPOQIPQ@HPQIIHYIIPPPAPHQIH`RIIPOQIHOQIIPPQIQPPQIAHHPPQIIPQIIOQIIIPQKHPPPPIPHHQIPPQIPIIPPQIPQIHPQHIHHQIPPPPIPQIIIPQIIPPQIPQIQIAHQIPPQIHPQHPIIIPQIIPQAIQPIIAPPIHIPQHHPIQQHIQIPOQAIPPIII@HPHPPQHIQIHHPQIPXQIIPPIAPPQIPQIPPPQHPIIPOQIHPQIOPPQIIPOIPQIPPIPQAIPPQIHPIIHPPQIIPQIIPPQIPOPIIOPQIPPQIPQIHPGPIHIPPIIPQIIHIIPPPIPQIIOPQHIPPIIPPIIPOQPPQIPPQHPQIIOQIIHHQAPHIHPPQIOPPQIPQHIHHQIPQIIHPIIPQIPQIIPIIPPIPPIHPQIIPPQIPQIHPPHQIIPPIIIPQIPOQIQIPPQIPPQAIIPQIIHQAIPP@QHIPIIIPPQIPPAIIPQHPQIIHPQIIPPQIPPQHHIPQIIPQIPPQAPQIIPPIHPPQIPQIIPQIPPQIHPQHIHPQIIHPQIHQIHPQIHPYIPQIIPQIPQIIIPPQIPQIPQIIPQAPQOH@PAAPHPIIPIIPQIPPQIPXQIPOPIAOQHOPQIPIIGPQIPQAIHQIIQIIPPQIIPPHPPQIIPPIHPIHPPQP@IAPQIPPQIPHQIAIIIPPQIIQHPQIPQHPPHIIIG@PIPPQIIQIPPPIIIPPIPPPQIPQIHHIIXPQIAPHPIHHPAIPPIIPQIHPPIAOPPIIIP@QIHPPIPPQIPQIIHPQIIKIIPHHIIPPQHHPPQIPPQIPPQPPQ@PPHIhIIPPQHPQIIPIIPPIIIPIHIPQHIPPQIOQIIPQIIPQIOQIP@QIIPPQIHPIHPHIIPHYHIHOQIPQIHOHIIPQIIHPHQIPPQIHOQIAPPQAIPHIHPQIIPPQIIPIIPPIHIGPQIIHPQIPQHPPQIOIHIQIIHPIIPPIHPQIIHHIHPPQIHPPHPHIPPQIPPQIPPPQIPPQHIPPQHIPQIPQIIHPQIPHPIIIIPPQHHHQIHIHPQIPOIIIPQIIPQJIPQOPQIPIIIPQAHPPIIHPHIPGQIPPPIIPQIIPPPQ@PPAIAIPPIHQIIPPYIHPQIQIPQIHOQIIPPQIIPPQHQIIPQIPOQIIPQIPPQIIPHPIPPPAHPHPHIPPPIIPQHPPHQOPQIIOIIIPPPIPQIPPQPHQIIOQHIPQAIHPPYIIPQIIHQIHOPIPPQIIOPQIIPPQIAOHPPIIIIIQHPPAIPOIHIHQIHPPQIIPPQIIPPPIPPQHHPAHHIIPQIIHYIPPIIIPPQIIPOPPPIIPPPIPY@PPHPIIIPQPPPpPPPPPPQIPPIIHQ@IPPQPOQHIHPIPQIHPQAIIPQIHOQIPHQIPQIAPQIIPQIIPQIPQHPQIPQHPPQIIOQPHIIIPPQIHQIPOQIIPPQAIHPIIPQHPPQIPQIIPQIPOQHPPQIPQIPPPIPPPPPQHPOQIPPQIHPPPJHPQHIPQIPQIIPQHIPIIQIPIHPPIOPQIPPQIIPPQIPPQIPPQIPPQIXQIIIPPQAPQIIPPQIPQQHPQAIOPQIPPOQHPQIPPQIPQIIPPOIIPPIIPPQHPIIAPQPPIIOPQIAPHQHPQAHPQPPPQPPHAHQIPPQIPQAIPHQPPQAPHQIHPPQIPPQPPP@GIIPQIHPIHPPQIIPQIXHQIHPQIIOHQIPQIIPQIIPQIAPQIPPPQHQQIPPQIHPHIIPPQIHPQIIPQHPOPIIHPQQHPPQIPQIIOQIIGPIIIHPQIPPTHH@AQIIHPQIPQHPQIIPQHIPQIIPPIIIPQII`IIPQI@PIIIHQIIPPIIPQAPPIQPQIPHQIPPPIHOPQIQIPPIIPPIPPQIPPIAPPIIIPPIIHHIHQIHQIHPPPPPPIAPHQIIHQIIOPQPIIIXPIHPPQIPQIHPPAIPQIIPQHPPPQIIOQIPPQIOOIIIHPQIPQIIPHQIIPQIPPQHPHQIHPPPIHQIPOIIHPPQIIGPQIPPIIPPIIHHQHIPHIIQIPQIHPQIIHPQIPYIJHPHIIPPIIIPIIIPPPIPHQIAHQIOPQIIPPQPPIHPPIHIPPHQIPPIIIPPQIPHQHIPPQIPPQIPPQIHQHIPQPHHHHPPIIHHPPQAGIPQI@PIHPQIIQAIIPIIPQIIPOPIIPIIIOHQIPPPQJPIIIPQIIIPPQIIPPQIIPPQIPPQIIPPQHPQIIPQHHIHIHQIIPPQAAXQHIPQIIPIIIHPQIPQIAOHQIHHPQHPPPIIHQIHPPQIIQIAPPQIHPIIHPQIHPQIPPQ@IPPQIHPPIIPPPHIPPQIPPPIPPQIIPHQIPPQJHPQHIPQIIPQIPPQHIQIJPOQIIPQPPQIHHHQQPQIPIHIIHIPHIIPHIHHQIAPHIHIPQHPQIIIPPQIHPIIHXQIPPQIAPPIPPIIPPIPQ@IPPIPPQIIPOQIPQI@HQAHHHPQIPQIIPPPIXPQHAPPQPQIIPHIIIQIIPQAPHQIIPQAHPQIPHQHIPQIIPQIIPPIAPQIOQIPPQIQPPQIPPQIPIIPHHQIIOHIIHPIIHHQIPPIAPQIQOHAIPIGHOQIIIPQPPQPPQIGPPQHIOIIIPQIIPXP@PPPIHPQIPQIIHQIIPPIHPIIPPQIIPPQHOPQIPPQIIPPIIAPHQIHPQIHPPQIPOQHHHQhQIIYGPQIPPQPPQIIHQHPPQIPPQIPPIIPPP@OQIHPHQIHHQAHPQHIPPQIPPQIHIIIPQIPPQHPPQHPPQIIPQAIPQIIPQIIPPQIIHQIPPQHIGHQIIxHHPHQI@PQIOPQHHHIIPPOQIHQHILIIPQIPIHHOQIIPQHHHQHIIPIIHHPQIAHAIIIPIIIPOIIPQAGPQHAPQIPHQIPPQHIPQIHPPPIPHQIIPOQIPQIPPQIPHIIIPHQIPPQIGPIIHPIIPQIAPIIXPQIPPIIPQIIQIIPPIPPQAPQIIPOQGg]nf@ze@je@fd@g]nd@bf@ye@rg@fh@of@mf@qg@}k@oe@`e@ci@`m@ai@cn@bq@le@qh@bg@jh@vg@up@~d@mm@pg@cj@yo@yh@ke@sg@og@am@ym@xk@`p@re@fi@lf@`i@dh@hj@co@dg@bi@rl@wg@}n@ve@|o@wd@xo@_q@fo@do@so@lt@nm@}j@om@{o@}p@ts@ks@~j@nl@~p@kv@ol@pm@yt@sd@jd@as@ms@kc@dd@xj@yl@zo@nr@t_@kd@ri@fr@|s@}s@{v@l_@lc@`q@gr@|b@ec@uc@ud@kf@wh@xh@qi@aj@_o@tt@cu@`^m^b`@}`@ib@ub@gc@pc@bd@md@|d@ie@me@ue@we@vh@ij@ok@un@vo@wo@_p@cp@lp@|q@`r@ut@yv@q]~]h^l^`_@e_@g_@v_@e`@l`@m`@o`@ca@ea@db@hb@wb@yb@nc@xc@|c@~c@se@af@gf@hf@jf@pf@kg@mg@ng@bh@gh@ph@ki@ti@dj@ik@tk@dl@pl@zl@bm@qm@xm@rn@{n@eo@jo@ko@ro@cq@vq@xq@kr@or@qr@|r@js@ls@us@`t@kt@zt@ku@lu@nu@iv@jv@`x@i]k]l]m]o]p]r]s]u]w]x]y]z]{]|]}]_^a^c^e^f^g^i^j^k^n^o^p^q^t^v^x^y^{^b_@c_@d_@f_@n_@o_@q_@r_@x_@y_@{_@}_@_`@``@a`@f`@g`@h`@i`@j`@n`@p`@q`@r`@_a@aa@ba@da@ga@ha@ja@la@ma@na@oa@qa@va@}a@`b@fb@jb@kb@rb@tb@vb@_c@`c@cc@dc@fc@hc@ic@jc@mc@tc@zc@_d@gd@hd@pd@qd@zd@{d@}d@ce@de@fe@ge@he@pe@|e@}e@~e@_f@`f@cf@ef@ff@fg@ig@jg@lg@yg@{g@|g@}g@~g@_h@`h@ah@ch@ih@kh@mh@nh@oh@rh@th@uh@zh@~h@di@ei@gi@ii@ji@li@ni@oi@vi@wi@xi@yi@zi@{i@|i@}i@~i@_j@`j@mj@pj@qj@rj@sj@uj@vj@wj@{j@|j@kk@lk@mk@nk@vk@yk@{k@~k@`l@al@bl@cl@fl@gl@il@jl@kl@ml@ql@sl@ul@vl@xl@|l@}l@_m@dm@fm@gm@hm@jm@lm@sm@um@wm@zm@|m@}m@_n@dn@fn@gn@hn@in@kn@mn@on@pn@wn@xn@yn@zn@|n@bo@go@mo@no@oo@po@qo@to@}o@ap@ep@mp@np@op@qp@rp@tp@vp@xp@yp@zp@{p@eq@gq@iq@jq@kq@mq@oq@pq@rq@sq@tq@uq@yq@zq@~q@_r@ar@cr@er@ir@sr@ur@vr@xr@{r@`s@bs@es@hs@ns@rs@vs@xs@~s@ct@ft@nt@pt@qt@|t@du@ru@tu@vu@}u@~u@`v@av@cv@dv@ev@fv@lv@nv@pv@tv@zv@|v@_w@`w@cw@ew@hw@sw@tw@vw@xw@yw@zw@bx@zx@~x@gy@iy@ky@my@`z@dz@pz@vz@b{@d{@h]j]n]t]v]b^d^r^s^u^w^z^|^}^~^__@a_@h_@i_@j_@k_@m_@p_@s_@u_@w_@z_@|_@~_@c`@d`@k`@s`@t`@u`@v`@w`@x`@y`@z`@{`@|`@~`@`a@fa@ia@ka@pa@ra@sa@ta@ua@wa@xa@ya@za@{a@|a@~a@_b@ab@bb@cb@eb@gb@lb@mb@nb@ob@pb@qb@sb@xb@zb@{b@}b@~b@ac@bc@oc@qc@rc@sc@vc@wc@yc@{c@}c@`d@ad@cd@ed@id@ld@od@rd@td@vd@xd@yd@_e@ae@be@ee@ne@qe@te@xe@{e@df@if@qf@rf@sf@tf@uf@vf@wf@xf@yf@zf@{f@|f@}f@~f@_g@`g@ag@cg@eg@gg@hg@tg@ug@xg@zg@eh@hh@lh@sh@{h@|h@}h@_i@hi@mi@pi@si@ui@bj@ej@fj@gj@jj@kj@lj@nj@oj@tj@yj@zj@_k@`k@ak@bk@ck@dk@ek@fk@gk@hk@jk@pk@qk@rk@sk@uk@wk@zk@|k@_l@el@hl@ll@tl@wl@{l@~l@cm@em@im@km@rm@tm@vm@{m@~m@`n@an@bn@en@jn@ln@nn@qn@sn@tn@vn@~n@`o@ao@ho@io@lo@uo@~o@bp@dp@fp@gp@hp@ip@jp@kp@pp@sp@wp@|p@aq@dq@fq@hq@lq@nq@qq@wq@{q@}q@br@dr@hr@jr@lr@mr@pr@rr@tr@wr@yr@zr@}r@~r@_s@cs@ds@fs@gs@is@os@ps@qs@ss@ws@ys@zs@{s@_t@at@bt@dt@et@gt@ht@it@jt@mt@ot@rt@st@vt@wt@xt@{t@}t@~t@_u@`u@au@bu@eu@fu@gu@hu@iu@ju@mu@ou@pu@qu@su@uu@wu@xu@yu@zu@{u@|u@_v@bv@gv@hv@mv@ov@qv@rv@sv@uv@vv@wv@xv@}v@~v@aw@bw@dw@fw@gw@iw@jw@kw@lw@mw@nw@ow@pw@qw@rw@uw@ww@{w@|w@}w@~w@_x@ax@cx@dx@ex@fx@gx@hx@ix@jx@kx@lx@mx@nx@ox@px@qx@rx@sx@tx@ux@vx@wx@xx@yx@{x@|x@}x@_y@`y@ay@by@cy@dy@ey@fy@hy@jy@ly@ny@oy@py@qy@ry@sy@ty@uy@vy@wy@xy@yy@zy@{y@|y@}y@~y@_z@az@bz@cz@ez@fz@gz@hz@iz@jz@kz@lz@mz@nz@oz@qz@rz@sz@tz@uz@wz@xz@yz@zz@{z@|z@}z@~z@_{@`{@a{@c{@e{@f{@g{@h{@i{@j{@k{@l{@m{@n{@dyGCCCCCCCCCCCCCCCCCwCC|GCCCCCCeHCCCCCnACCCCCtBCDCu@CCCDCCAoHCDCM|ACNCDBCDCCCACACFAwGBCCAC?CETAFCCCB`@?I?D@CTCJCAD@CCDC\CC?CCVb@@JqBCEJDCED@?CC?@KZCXAC?EDACBdHC?DFC@IEBCA@EFIC?C?DCB?|AB@BBDo@D@ACGkAI_@n@q@AZAj@ACGNKCNEIo@@hDa@H_DBA}CD_@@B?EJEMFAEBXBGEFGB@CC?DC?D?VBCCCaD??@N@?ACU@zICGD?@GE?@GJC?HCC]EKC?Ng@CCCNCCCBCB@WWCEBJJFvBD?BJA@AX@E@CEAQg@?AM\AB]`@k@gBHFDBNKEHdBWAAj@EFZZGDfDl@B?@G@C???X@FBKQEAEECDC?I?H?D?EJAa@A?hDDaDg@Dh@CWV@u@CBXBGXl@vBFo@?DEBECgKCEFh@??@BD?DDQI}C@KB@?AGA?C?AKD?Hh@?@A@BND]GCBD?iDB?NVc@H?DKAGs@?E@XAMAgBEj@?J?j@BXEUDJKe@TEAI?fDX@C@PADD?B|ACALC@@@LF?e@OC@IAB@JF?HE@i@?KjIUA]?@AB?p@A@?EK??@CNCGC@GAFGl@DE|B?CICHi@@tBTb@EEA?FDM?AEV?~CE@?EAAh@CCD`@EKMBGHE?HDQEDED?pA?ZsDCUDWDIh@p@@i@NVDEjACa@D?ABAE?D_L@@C?BDEHA@EAFCHC[??CDKALBh@@VH@d@d@CZDwKAB?LXVBc@BCB@L?_@BA[?J@?KABCGDA?EJ?dAG@AF?R??PEK?q@B@D@G?GB@FH??LMFIBKAMLDAQb@TFq@ACIDHx@DJC?EIDkAO|BN?EPA@WDG@EWZo@F?BAFh@BHK`@g@GACTa@C??Ee@EVQBG\c@m@E@|@DHIGDa@KB[BBB@B??]BA?IGJ?EK?KCFIDHLu@Ky@_@EHVCm@Xb@A?HZ?A@Wm@?oA?@DCJQDLHA?[MUm@?Bp@@L?E@@@_@GDAI@JCRJg@?F@AEHIE@FBBDD@CCD?O@@E@G@Xn@_@i@C@?KOg@R?v@PPAFU?gB?@_AA?E}@\RW_@K?O?ACDDBi@H?CUj@@ELFB?`@Q@A?}@J@s@Bo@Bg@B@Hf@DI?ZDUBKA?@DH@DAF?@G?EBDy@Cc@bK?Ej@L@DF^AF@@p@???`@kAJ^M@RGA?@iDF@??@?C?b@j@?sDW?DUHALMBXl@BIEVm@C@?v@|BHA?BBZKEt@P@@CFBALDU@@DB?^}@?X@RFm@G??ZDA@IIAGAA???Yh@g@?DIrADE@IA_@JPB?W@@CEVHBBCCf@J?KA@HHVHHgBAz@s@\Q?FGjAQHEZPNRCJ@^A@H?@z@GCI@DD_A?t@AU?MLJ]LDz@@I@Xj@JTY?DA[o@jA@CLYz@?A^BP@BkADTHAFf@??BB?Bn@@Bp@ITUFEANpADDRE?CXB@WKNc@EFB@I???@LAIWBBGMER@q@ABj@TAGBANVeDBG?ABB?Z~@Q??~@A@@EGq@?`AFm@p@z@[DG?A@M??C@?D??@A@@?DcABBNBo@w@ETBT@LJ@UNPIe@??Fq@`@`@BDIAP?FGhAC\GO?YBBDDDGEAGh@IT^E@@ABCDc@EUBA?Gi@ED^?x@BEDD@ENMAMOm@Bc@MA@[GBE\Lv@@\C_@ABLAGF\?DERgAF\AFBNAUD@pAp@y@BALDyDD@GD`AE@_@??ABDSB?o@@E@DBKBoAQCMyDf@BD?]WP@@?DSPE@FGDGEG@O??h@ADk@w@@SCFBARFHE?Bz@@Eu@|@ELj@GFb@BAW@@AAV?ADE@D?BBQWB@CDBAN@BADA??y@uBx@D@Ex@z@wDLDI@@oDMD@a@EGB]A@Bg@~@y@R?CDS@G@D?v@GB@AE@y@AAfLQE?@GAOE?]Dl@m@FRE?Tg@?EAuBBD@K@[AOMIGo@C_@f@HKDu@TY@G@@`COCDRAf@?\?EYb@HEd@PFSBx@A?@B@H@]?@]\VCIRSUCNj@Gf@J]AEEd@D|@ABDF?HIOEOI[h@GYAKB???e@Xy@|@@ZCrAAGDC@Ai@uDH`@FDHL^?AO?B@u@NDR@@MB?B?a@I@N@OFBGQF@?@CNBSDVADGS@GKo@EBPGAD?@?P\DBADVA?[EDOOEAl@I]IDRQDKLD?FFG@uBz@Su@X?G@e@b@??@?W?AYWdAAo@BGABdA?N@?ADIR]BJ?@?B[JGC`AMM@?j@BHBy@|@_@a@?^D\G?AD?r@H@TB?ABASAZAB??GE?m@?TMDB]?CB@EBKB@QCPLP??BT?AAYHX?BEWCEh@A}@`@@VE]XEBEGv@[EGAN?EJBF??AFAMNE?G@DIT?KO?UAVATFBKx@AYA?Ii@Ev@PBJLJ?BHMJf@AcAE^EQAQDEBA?@Ie@ZAO]E@BFm@?a@LH?S?CQBA~@j@LLA@S@cAFPHTBMA?@ACEN^p@@CVRUr@BEd@DEDCzM@AJFD@@s@IG@M@DDD@?c@@Fd@KA@D?\y@?CEDLAMBDFA`AABCFCCz@A@_Ab@AFB@@MB?QaAd@q@W@BEDBUD@@R^B?IAa@ESDBH[@DB?RICx@DBAEABG?APBMy@?@KKZJAAFCD@BDGBA@A@E@DFEGBQS?V[JGB@TWFbCv@DE?ABLGk@W?FB?QsA?FADDHABH@ANf@JEAQf@E\?Ft@C@f@VMLABEf@BD?D@BAD@H@DNCJQl@@x@BE@a@OXn@AG?@J?w@@BB`@?KJq@UWAB@`@??DEB?AFYA?@?@LLHOc@D@QD@IEIBDm@HEAdAk@@EE@AGPGAUpACB@De@HOWN?i@Y?@B??BHADp@T??@?UKD@?EYD@E@YADHu@AD@TCNDGDRMBXAf@EE?@G@i@?h@B@AhA?HDCC_CCWOB?eAEC?g@Gb@?Db@@BBAXI??KA??AMX\Fk@BPl@BF?^HKNRLODNo@?@G?@u@BCa@NDI@_AHBFRJHBBBu@EDOVf@H@H?F?@BQMPbAj@K{@{@{@{@?E@j@?ZXZD@YGDLE\XERRE?`@E@PGWn@JMAZAXmACp@EBAd@cAf@?T?Lj@D?I\@E\IDAAr@yAY@BJFD@c@K@gA@Y?GB@f@d@DBAi@?x@B?QDFF??Bc@d@JA_@Sb@BRJHAw@FUCWDvAEIBRA?@GOC|@bCGG?p@@ANa@Bf@OH?VJAQJc@FjJ@@p@Q?@@WA@g@i@\Q@?E?BO?f@BSMD?o@?@t@@@RJA?K[b@OPCq@?EDx@??VAFs@`@BBN?@f@@DD?A@_@@Fh@GB@?@H_AA?GQP@DLZ[GB??Vu@IC`AA@AEa@EJ@z@GALAo@A??LGBBP@EBMmAE?OYX@m@EGBBi@a@UE@E|@p@ADR?JEBAAH?BAF@KQACVDBMe@g@Yf@ANw@AB[@AHIBNB]A@BO@Y@BSLB?@??ARDIOZy@OCa@@z@t@AU?KEFK?T@?AGG?BJ[FDB?O?N`@@TA@?Rr@[M@D@@@FPJh@I@@@EABEEBQBADf@KO??JMKTBR]L@^TJEa@AKWj@ELD@E\GwAG???q@AJZA@UD?N?@DREDbAo@E[PA??D?ODFG?r@j@FDFKQFm@?ODB?@BDTDATu@EVAjAABA^iAAIXE?tBATrADoAACFE??DBv@d@ASB?D?o@?XY?DE?Ej@RT?BEC@SUE@J?N@P?l@`A?]DEEp@XlA@?GJ@RD?{@?sADXGDXyALd@DBL?@@[DH?@S_@}@uDEPD?U?HE@A?A?EA?_@\EDEr@]?ADBBSDz@g@REEV@b@f@BE\lAc@K@BAS?y@F^R@K@Sq@@EDv@D@i@DB@H?e@f@?@bADDk@i@t@[AcAI@YDn@WFJG^`CuM?@@Q??AANBAPBKSAH[D?i@A@@@[B?o@@DGDA?Vk@aAj@g@D?TEt@FW?BF@F??q@aACBV?FI@eAFr@DGt@AEFb@Oi@]DDEPS?HU\D@x@F_Ak@H?EDM@?A@?i@DQADgAm@A@DDOGiABBAB?GZu@_@A|@@A?]C@r@AA@[?FQl@?H?EB@Uc@[D??FDAx@JA??Fq@?_CLBQ@\D?@f@H?AK?D?AZHe@G@E^@Im@?DEn@J@t@FWn@FCDl@@r@M?PAD[Q?D@~CMKA[ASl@BA?Df@NI?b@BB@GU?I@Al@]VA?^h@@@wDB\Ej@?o@BT@?AAG@O@D?@A[r@@?@_@OH?EPEAIFAAe@E\FEAA[u@YH?BXDJADI_AbAE]DF@Eq@AZA@BN@HDHA`@PABEK?DN@@f@DUX?EWND[_@D?BJPGOJT@Qv@F?v@@E@Fe@H@AM@AHALDJAz@@?]?^j@@_@@t@KOQ@K]??AHUBIAk@?FOQg@]YDJOD@@DI\E?I@IJ?A@w@aEw@e@c@F@?D?DD?Ui@JxAy@Lg@EBi@G@`@IEGl@I?D?d@E?u@LEAAA?Hd@dBWJ@SIXDQJVn@f@AHA@DBAiAEMD@N?M??A[b@X@T?p@SREABHAD?Li@@BeDEYQb@OFNd@@~@AAAT?DlAe@?@B?n@E@NDa@A\@@@ISOOF?iAb@BBBd@DD@KA@ADQdCQT?O\KBJCUAMzLME@AZDEADB^NAK?AD@@DAy@TJHEM?Nf@T?ER?@GYG?DFLBe@JSUBFbAF?\?E?cEPADGY@??}@@E@BEE?BDWSu@eAAEDSB@?|@x@AFn@a@MXwADBBBBbAAUd@?@n@KFGPAEYEEQECM?DIdBEEORAk@@AABABD^c@DO@K?Ot@j@Fb@F??EFAEZASHA@DD[x@t@CBDFF?[SN@NEBo@L@VGZWc@F@DWv@@^@@fAGVQBj@BDB@@QP?GiAKZ??ODEg@Ds@?@s@?E?O?COIa@iB@{@C{@{@{@m@W@AD@SAEA?AIU??DA@B?E??h@AB?BRHCD?@DAGODMNE?F@?KbAKDH@?k@?DBrAaNDFJADE\h@ALj@Dn@VBGFSB?BF@AxAbAn@?YO??@@w@EHDL@ZAm@MF?@OHA@UGD?\BP`@h@@@?j@QDM?AIX]BS@Ci@?TY@?AiAyAr@@@N_Ac@?w@Ax@?h@DOMAWA[ACDNHJSBEE`@AEi@EeAr@AJM]@DIISEe@U^g@?BSDAHEE??AKS`@@Dr@D]eA?LT@gE?D?v@@?DBiABSB@k@@mA?^xAPJ\NDk@q@F`A?AN?FcAEKBOC}@?JG?T???AG@@D@LBD?K_@T?EBWPCAb@A?^f@GE?Gt@DG?ES@E@ANAHEP?GZ?]BEG?GBDKH?Ht@^A@I@IJAD?b@B?NAh@c@U@T@B?F?AJBo@c@BhA?TPXDfA@E?SGe@g@h@FDH@?EDOHIEEEIEBW??[Q]IG?@HPVAF[Z?s@DWVeA?@YB@EBIARAEM^b@TA?Rd@?I@?g@EL}@QC`@AAJ@ORPEUBUWz@?\EPHv@DfAw@IMJI??A@DnA?Z@K@KA@QE?k@Dn@EHw@E?`@ELPfCRQALh@???EG]Hz@A?@Bi@QMYDJ]b@UE@OA?BAPSj@JE@RGJ?Y?@B?ADAWg@IJBm@BFHK?@BF?@VPE@??QA@Ii@?_@AB@JLB_@AE@@AD]D???HFBBIs@AWDNGTS?C~@GE@a@UB@MODDm@B??zABr@EaAFIDBADBPDfAr@Q@|@AZTaAWEm@BTFD??@IG@F@a@v@YKJ[DRXJiB?UTl@F@h@?s@??H?CA?F?BBv@q@[??B?LQBBQ?ED?r@?D@`@@l@A?BAAAGE?SPIFEKn@^BB?@AOE@W?RIVD@@?X?GZCYFDJd@BBLIQIEBDOk@B\??jE@JMTEdAPpAV~@@t@@O?B@c@d@?@E[E?A?u@Dd@SHBgEQHFs@By@??FH?[O@?s@BQq@W?IB@A?WB`AAKUw@D?RPD?ESFA@@?AE?XU???B?Hc@g@BEW{@{@BFEINAt@EB[l@c@k@BIFSI?DEA^E@?OJ\Rp@?_@Ar@?SD??QBBKDa@RHE??GD@Bg@L\EEM?BJD?ADE@@BE@ITL?a@DDNGQp@?DBQ}@A@FEAEhA]FE\?q@B?GDd@b@DEBjBZBA@B|@RH?BBRB?A?KRA?j@ODSbADDAEB\cEx@e@@FHDF@^f@BGy@@?E?ABHGOMAz@BIr@x@LI@?EACBR@QNB?r@AGJ?CS@HS@B?@?Qe@d@?JGAK?B_ADo@EPPXHA@QBGAOD?QHAEFBFEBAA?K@HO?Bn@?SH?BHO?E@PDB?@FBZEh@NFK@QAA@d@GA@J~@|@DfALN@E?a@|@Dv@NCJBSC@I^Q@L?DDBD@QGOQ\ID?J?@ETF?jBAABv@?Kx@ZBBPS@e@[?F?hAc@\]NXAD?KOB?ANsAJF[I@@?@@EABh@@BOL_C_@c@ANDDDAODOE`Aw@JB?[?E@@wAMt@A?Kp@g@A@B@F@NDl@BKDDA@Ie@o@?HZ?C@@I^@AY??S@LPXDEJXA\@u@ECCC{@ANLi@K?FT@E@MA?LHD?EBO?EV@A@By@EA@HFq@q@REBE^wAEi@\DDDH@A_MAAd@y@p@p@DBAHBMGDDB?DEIG`@DBAAADB@UH@c@J?a@v@p@AC@}@h@z@AGEDFDH{@{@{@n@AdA@OE@HDUBDOUGLPDBTD?BEv@@e@@?@D@Bi@c@?WG@F?EJXE_@GEVFE?@EIBA@EEY@L?AC??E@AECLGBBBAH@@DB@@qMXODn@G[@D_@RADI?B@g@fCBBD?H~@ADU?FCl@EDBAAIUPz@H@@eAZEc@RoAHBD?@RPD@?DET`@DCe@Jm@@@@Dl@|@R?c@DBCO@eADBJBEAZ?AEb@n@BT@?}@Nz@FDBNBBZMy@a@N`ADBDUD?D?E@\g@Gk@Bw@o@YK?EAASBF?mADUDBH@EB?A?BADJEA@NE?Y?@dAK?B}@UDABTZ^D`@I@BDBSF@QAD?AE@w@Op@IM?RP?@D@EDDBB?CvNXiA@PH@i@@i@EBZAQk@G^DSDA[Ga@FXCUDBAD?HB?Ph@??TFA?C??GKGD\f@Uu@?UA?VKWBF]BHEGH\D_AE[RBDVbAE~@AAGD@@RPw@DAABgAEEBBVGu@n@@@?DEH@?Do@DWl@?YBIDs@?A?UEj@@X?LgA@Kl@PEjBAC@MXA?FL?H?YMGLP??Q~@E?@]@AhAHEDH?A?DV?DQQWAv@q@BBI?z@A@TUDLFD@Aa@[zAEHWCEUZP@EGV?B?EPA^GFGWKEAMN?DAA]ABDJA?HTF@DDABQaADDN?U@@DaAEK@@EBd@YRALdCo@c@@KDP[E?DAAs@BB?W@ELSPDF?K?@Ap@?E@w@]Bh@\GEFh@k@PG_A_@G?BKADFH]?IAB]x@WHAxLDJR@l@EA?Dj@bOA[?FPfAVRILAYDXfA@?K?EA?j@D@x@KDb@`@BFBAa@FADTG_@S?@FDQ?GEMG@E?FNMe@?NA@Tk@R???BGDBB]@GAw@}@?d@q@BWE?@FAEEHA@Ab@A]DB@ExAFEEK|@^jBDo@A?DDc@C?g@RFXBBSKs@@M_@BB?EN_@Ed@Xp@V~ADb@T@aAFB`@?@BAt@BIU?PIw@AD?D?IBGF@@@D??RP?B?u@?ED_@HQv@@EAcCABL@ZEq@@@La@sAl@LKDOIBb@D[Ux@?xAGr@`A?DEw@N_@cA_@I@@ZTEDn@@?TEo@PYF@O?O?@B?An@[IA[?IAX@@EDID_@I@@?ABSyA@w@]x@u@Ga@?@?AHFEVvAD@MFB[ZA\I?@?ADwA?BAm@KAI`@EI@@MZ?Bn@|@@s@Hd@BR?SGAWA?s@@@j@B@F?PBq@@Bi@F@HBNBBBK?aACq@m@D??}@Ma@@DBDDS@@?DALBBX?A?@gALDDBANdA?iAD}@@EAD`ALAfABmABbA???g@Hc@?PSa@e@p@AH?_@BSBBE?^s@A[E[A@AHGYBBb@Qk@Nf@?d@HZFMEt@WAt@?@??BNQO?HY?@Im@l@BIUAx@l@u@BENIH?Fn@qBB@??L?FDc@@Do@FARd@@v@BAa@B?@PNSKXDEi@S??A?@^L?XI]N?D?BAa@`A@?EQFA@DHAW?AYSHIJ?r@zAOAB?|@WA??BREm@a@?{Ny@B@PDDe@Dv@F?Ec@FF?AEw@@XT?B@@@\KPYBAHm@eA@Hv@?AG@ATF|@?RG\ADADj@[E?MHTEs@Dg@JHAMn@y@FMTARa@BODYGBOj@VBKBGR?k@SU@A?EF?D[~@ENA?sA@?ZBHX@Af@?DVp@AAOATM@@ABHDVP[AAEBQUAl@D`@?U?HPD?EE@@FmATI@EGHCt@BM^A@AXz@OQ@BHR?AwAPDIE@@B@DLs@?FQ@EED?G`@Xr@@SBBG?DB?B@RBHEYe@DEp@DXG@???K]?ABp@LBAFCYAZRAdCM??u@Fb@T?ADD?EHr@U?@?EZ@YDAV@IDFsAAd@{@CAl@Qa@A?L]e@g@?gAAABGjEE?GG@g@GAEA@D[W^D?`ABP@Sn@Al@c@S^UE?@@WDo@l@LDSw@_@E_@?fA??@E?A?Bl@YHWEhAq@EMAB\aAPKyAY@JA??MJd@E@?EGVF?@@WFW@FBfA??hA?aAM?S?_Ac@?Ir@L?DT??B?k@?@EBSEh@??B@Mc@PAm@ZVDd@?FEEEBv@b@e@?\Th@BR@@EXAKDPHQPIXEy@FQBY?FgAL@B??@A@@EAIDKb@@GEJP?D?LJH[Aw@?BAr@J_@?@IFl@?QOT@?C?e@A?EVT@AeAMXJA?dAXUHx@Vb@BG?I?UGAH?D?VA@@@AED@M@}@HBY?FABH^AEAE??@B@BPF@@O??NE?w@A?e@e@HXR@U@EFr@c@AELc@@Ai@NAJ\A@R@t@MABYLB?q@DHC@h@h@M@DD?_@@GODBEIUD??ADGA?VN@Bn@IYBp@HOE?JDBi@f@@EzAAV@AA@?d@??D??@D@EN??BYMi@_@p@`@P?h@SG@KIGyA?DRc@@I???Gn@BLDRNGB@?B?JAM?D`CABADADR@SAn@m@A@?QYKCBEx@Dv@l@D@`@GDEV~@IB?Db@B?@?r@FJVFIB?PMT?EYEHk@?DLOJvB?m@RE`@???BC@iBHA@JM?bABAjAFG?G?II?H?o@EQAB?OMb@P^ABGET@Wj@^AUEASATzADDB]i@?Au@Os@@h@a@ZAE~@s@Mr@I?EAAA@D?V@BJB??f@i@QCAD?\NDk@?D@@P\DBP@E??BJAAEBb@EEAi@Bi@B?a@??CHA?e@u@@^@D@@u@KDKF@@@@NBq@D]WPE@@DAC?LAEDDr@MD?Ad@?RQD?N?@O@?@?t@E]ABBTH?@@NBEf@A@@?g@I`OKDE?BAM?CDIABHB?LDb@d@@t@?Kk@Qj@AL?Hs@@@FBKUMMGRt@HA?@?NADSJGABFGkAXAfAVFS`@DQEOR?Eg@@b@DDDZE?AJ?UAc@B?@Z?Kf@?@FT@g@s@rA?OLD@YBOA?MDZKAa@HDU?DjNBKVc@O@A@ATDAK?K?oAIJNBd@DMIADf@o@@@g@a@?HAq@I?BS?b@JA?|@SFBE@As@g@IsAM@EHQLEVA?BBTj@EIDr@VJA@J_@JDM@AG@a@B^Ac@cA@m@?AE?I?DF?@B\?AUAEAOBECLAB?b@l@xAADFdA^?BBNd@KiAAF{@{@C{@{@AK\QD?JZ@A\zAXRDAKTRYMEFBw@[GDHQ?@UP^Cp@H@CM?TJ?CRB_AUESK?FFo@j@D@D?Fq@}@EE@OBA?D@@DPEHBBXAAk@?HWBPGg@r@@SLAKVD~@?[DNe@Q??W@^@?EDWZA^w@IMMr@LB??N@A@QJs@E@Ld@B@DBEKUI@h@m@ADDAGKo@@BDe@TI?@D@GDCLAk@??Hg@GEPt@Re@@D^bCH^?\DB@AS@ZB@LKB?A|@?HD?f@?Bz@?N@h@[_@@h@@GhAMEE@?]EB\I?A@E_@P@AFAIEAH?@??@N@?F?BgOF?d@@E@Gn@bEh@Ei@EB@DQ[gAE@RD@B?KA?PPLVEABHkMA~@Fe@Hf@l@GLNVaAB@AB@DAUs@j@S@H@Zp@?w@@AA{@dOCCaEdB@DEEVv@IA?N?AH???@?@GGBpA?bEAABQJh@AIBIE?]MKE@AHGAb@DGk@D\F@?ECDDAJrArAKw@ADg@IXIT?YPUhM{@C{@{@MHBAA?JB?m@UAk@@UZUd@o@G?Ys@mAm@A@K?WEODHWG@@vAIK_@@PUKb@A?b@GBmOKSIOs@H?FA}Fd@Vt@DLQGt@FDy@J?D`@\_@NZ?F?AD??HDEo@[y@I_@@D?e@UDE@AJAACBET_@G@EFKs@BBNe@LFiB?TE|@FABBBADFSDWs@Zd@QE@E@Q?Yt@Lm@@B?H?@B?AD@]@@gALg@r@BBp@@Jt@Ak@?F?p@mAE\kAaAAq@_AG??KIq@eAHSBt@BjA??QEAe@Kh@E?JPB`@DHQ@Bk@EBEAjA??PJIEBt@M^O@BLXDa@AB@@@F?EKKIDXAFDD?ADZ?]z@_ANADe@R?@HDB@cCBLDJ@DBXAV@@m@IF[A?DS?O@c@KAf@F@HW@??Qi@D?DDG@@B?CAADRWBCt@INUs@Op@FP?l@Rk@DAA@FF@f@YY?dAGHHDz@B???AB?H?A]u@^n@Vd@F\??JG@?DN@J`@BAWH@MJ@e@f@a@?UBJr@v@HAS?@_@CBY?JF@c@CACBCCCDCECFCGCHCICJCKCLCMCNCOCPCQCRCSCTCUCVCWCXCYCZC[mECnEEpE\C]C^C_@C`@Ca@Cb@Cc@Cd@cFa@eFc@lB`@dFb@jCe@Cf@Cg@Ch@_FDoEFC\aF^iCi@Cj@Ck@Cl@Cm@jFn@uEOvEQxESzEU|EW}EY~Eo@Cp@Cq@Cr@Cs@Ct@kCPwERyET{EVhCu@Cv@Cw@Cx@kFE`F]bF_@Cy@Cz@C{@C|@{AQoFTtFWlCZCo@mCq@C}@tAFlF]nC`@iFc@lB~@fFb@jCd@C~@_Gc@hFa@gFd@bGd@qC`@oCd@cGa@pC~@qC~@aG`@oC_AC`ACaACbACcACdACeACfACgAyFRsFUqFXkBhACiACjACkAClACmACnACoACpACqAmB\mF_@dGb@`G`@rC`@pGa@pC`@qGb@oGa@eG`@rC~@CrACsACtACuACvACwACxACyAmG]nCi@CzAC{AC|AC}AC~AnBSpFVhCXkB_BC`BCaBCbBtG^iCy@CcBCdBCeBCfBCgBuCTzFXkBhBvCaBCiBCjBCkBClBCmBCnByGUgGYChBpBiB_BVvGYrFp@CoBCpBCqBCrBCsBCtBCuBCvBCwBCxBCyB}GWlC_ByCXzG`BoBiBCzBC{BrBYC_BvC|BaBhBpB}BaB_BpBbBzC`BoB}BaBZ{Fp@~GpB`B~B{CaB{GzBsBiBwCkBsB}B|Co@mC_CnA`CoAjBhHp@CaCCbCkAkBCcCCdC{CeCCfCDgCChCfH`BoBbBDcCjHwBCiCuAoB_HqBCjCuAaCDkCkGlCu@dCnAmCCnCCoCzCiAiGkAjGmACpCCqCCrCnHbCNwB`@mCuAq@CsCTnCbBtCCuCuA_CnAxBCvCg@wBoAzBZoAlGqAyBlCs@{BCwClHpB`BrBqBtBCxCCyCCzCjAhCpHjAsC{CC|CC}CC~CzHkAqHpCsHrCbBaB`@`CMoCcBbBbB|BxG_@nGc@~F~@fG`@rGc@lB_DC`DCaDCbDCcDCdDCeDCfDCgDsGtAChDCiDCjDxBxBCkDuHqB`HsB`D{C{H}CClD_DmDCnDCoDCpDCqDCrDxB`C`@sDVkDtHuCkHfCnBtDCuDwB}@uAvDnAwDkCxDCyDCzDC{DC|DC}DC~DC_EC`ECaEn@rBq@wB|AvC`@bEyBpACcECdEu@eExCfECgEChECiECjECkEVyBtAlECmECnECoECpECqEk@xBeByBbDy@wFrECsECtE}H|C|H~CVvCwBsCk@`CiIsBaHuBcHwBn@jCaIyDbI{DdI}DfI_EhIaEkIgElIiEnIkEyIhEmIjEsI}COtBbHvBuCuECvECwECxECyECzEC{EC|EC}EC~EC_FC`FCaFCbFrBcF@wCbDi@nFk@CdFCeFeBfFrIz@xFgFChFCiF`DlAtCpC{B{@{IiEuAjFCkFyCu@uFw@ClFCmFCnFfBlD~HnDcDoFCpFCqFq@rF`@xBCsFkDtFCuFCvFCwFCxFCyFCzFC{F{B|FjDvE|IxE~IzE`J|EbJ~EdJ`FfJbFkDzAuG|AC}FC~FvAuBC_G{B`GCaGMbGyBcGCdGgJmArHqCiJkFlDwE}IyE_J{EaJ}EcJ_FeJaFtAeGCfGqIpEvIzDcI|DeI~DgI`E~J{DwI~D`KaExBbEeBkDhJjEwJpC`@iCvAxCyHzCcKqCtAgGChGCiGfKhGqAjGCkGClGCmGCnGmDvBoDkEeBvCaK|D_K_ExJxEqJ{EzJ~EtJaFqD}DxI`EDoGCpGjKwBoKpGgDqAwBqGgDcEqArGCsGCtGCuGkKyEyJ|EsJ_F|JbFhAdErKzErJ}E{J`FfBvGCwGCxGCyGCzGC{GeKrCkJv@vFlFC|GgHaCdKyCpA~CCmD_IoD`IqDvA}GC~GC_HtK{ElK_F{A`HCaHCbH|KmD}KpDdDcHoJqFCdHCeHCfH~K~G`@gHuJhH}BnDcDpDdDiHCjHeL_HTkHvKwG{KzCmBGqEIgClHCmH_BnHCoHCpHCqHCrHCsHCtHCuH`@vH`L|EsK`FnDfG}JqEmD_GfB~CMwHpKxBcAvC|CnFCxHkAyHvJdGmL}EuKaFxKw@lJmFnJzH`B{HnB|HC}HC~HC_IC`I}BaInK~DqL_EoL~EmKbFsL_FrL`ECbItL`FuLaEsBbBCcIcAyBcBdICeIvLaFwLcIjAyCFfIcBiBhBoDCoF{LbFaClFmJnFCzH`BjCxDoHhLqHjLsHlLuHzD|GzKbC}LpHiLrHkLtHtAgIChICiICjICkIClICmICnICoICpIaMqH~LtH}ApDaLqICrICsIhBtIzDmFpLqBCuICvIC{CcB}BcCqDCiHlMnF|LqB~AcHbLdHCwIn@xI`Mo@|FsCoMzHvHsBtIvBnAyInLxHtDzIC{IC|IC}IC~I~A_JgLHrEJsELC`JCaJ_EqB}DqIjMsItDbJCcJCdJCeJoImEpIoEzBqEk@wDcAsF~ArDqDfJCgJChJCiJqAjJhBkJ`@lJaCmJmMvInMmHvDxGCnJCoJCpJlAjCNrF~BoEzBqJ}DpFpJrJ{AsJpDkGhKmGCtJ~MlGiKoEzBuJCvJCwJ_NmGqAiG_ExJlArBwHuBuIyI~AiHjDyJCzJlA{H~Dp@CjF`E{JC|J_AyBcMhIdMjIfMlI{D}JC~JC_KC`KCaKCbKaBcKeCaCxCmBCdKCeKCfKCgKChKyLeIdEqFcLeH`EIgCKtE`JhEeHfEiIeMkIgMmICiKCjKCkKClKCmKCnKCoKCpKxMnE`NsBpMwBCyIiNtBxHyC{M{ChNoEmNpE}AoF}BqKlAxIfBrK}MpEkEqE{AsKwMdJCtKCuKCvKCwKCxKCyKrDsGqKzKC{KC|KC}KlA~BkNuBnNqEpNcJC~KC_LqApIlD`LCaLCbLCcLCdLxDeLCfLCgLtNvBChLCiLCjLCkLClLCmLCnL~BoL}ApLkEuJ`@yIiMrHbMuH_BqLCrLCsLCtLCuLmBvLaCwLyKo@iHwB|AyBqAxLCyLeNjIcNmICzLC{L|DpIlE|L|NsHiEJlNmHnD}LC~L}A_MfC`MrBaMCbMhGjAsClAtCcMCdMqAeMCfMvDgMChMbNjHtMfHrDiMCjMbBkMwNaLClMCmMeCoBmHrB_BnMdEoMfEpMCqM|DiGtA}LyNfLCrMCsMCtMCuM|MvM~DwMCxMCyMCzMC{McObLxNdLdNbCuNdJqNuKrNwKC|MC}MC~MiE_NC`NCaN}NrL~NtLhBbNCoLzNwBhOsL_OuLlEtGCcNyMdNCeNCfN{AgNrM{IsMhNCiNhEdHdLfHCjJeOrMfOtMvMrIaOkIfNzLpDjNCkNClNCmNCnNCoNCpNCqNCrNeEtJeEoElOpEiOyIkOlI{DiKgNoIsNtGCsNeCq@}AqDoNtN~BuNjOvN?wN</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C?????s`?D??E??B?????D??F??B?????G??H??C?????G??I??C?????G??J??C?????G??K??C?????L??M??C?????L??N??C?????L??O??C?????G??P??C?????G??Q??C?????G??R??C?????S??T??pS?WC?U??V??@U?wL?W??X??PJ?sC?W??Y??@A@sK?W??Z??PD??H?[??\??PG?GC?]??\??@B????^??\??`N?[C?^??_??@A?{C?`??a??P@?W@?`??a??pD?KC?b??a??PG?{H?b??c??`[?{F?d??e??@??_??G??f??C?????G??g??C?????G??h??C?????G??i??C?????G??j??C?????G??k??C?????G??l??C?????G??m??C?????G??n??C?????G??o??C?????G??p??C?????G??q??C?????G??r??C?????G??s??C?????G??t??C?????G??u??C?????G??v??C?????G??w??C?????G??x??C?????d??e??PA?_??d??e??`??C@?y??z??pY?SJ?y??{??`P?gL?|??}??`B?cM?|??~??OI?{N?`??a??`A?CC??@?a??P@?wB?@@?a??`???Q@@@?A@?eT?Wa?G??B@?C?????G??C@?C?????G??D@?C?????G??E@?C?????y??{??q[?SM?G??F@?C?????G??G@?C?????G??H@?C?????G??I@?C?????G??J@?C?????G??K@?C?????G??L@?C?????G??M@?C?????G??N@?C?????G??O@?C?????b??c??pT?oF?P@?Q@?P@?WO?P@?Q@?@F?{_?R@?S@?@S?cM?T@?U@?PH????V@?W@?`B????X@?a??PL?GF?|??Y@?a@?s]A|??Z@?QC?c^A[@?Y@?Q@?k\BG??\@?C?????G??]@?C?????G??^@?C?????G??_@?C?????G??`@?C?????G??a@?C?????G??b@?C?????G??c@?C?????G??d@?C?????G??e@?C?????G??f@?C?????G??g@?C?????G??h@?C?????b??c??`F??F?P@?Q@?Q@?WO?P@?Q@?AF?{_?R@?S@?qP?cM?G??i@?C?????G??j@?C?????G??k@?C?????G??l@?C?????G??m@?C?????b??c??`??oE?R@?S@?AS?cM?T@?U@?QH????V@?W@?aB????S??T??@M?KC?n@?o@?P??_E?n@?p@?qC?{F?y??z??PP?GJ?P@?q@?a??kd?P@?r@?aA?cE?R@?s@?AS?g}?t@?U@?QH????u@?W@?aB????v@?a??aB?CF?v@?w@?qB??D?y??x@?aE?cT?y??y@?AJ?KW?y??z@?Q??KX?T@?U@?QC????{@?W@?aA????P@?Q@?aB?{_?R@?S@?qQ?cM?R@?s@?qM?c}?y??z??@G?cI?y??y@?AH??W?y??z??PK?oI?y??|@?A@?wT?X@?a??aB?CF?X@?w@?qB??D?P@?Q@?a@?w_?}@?~@?Q??{K?X@?a??QF?KF?y???A?A??kU?y??y@?qE??W?R@?s@?aA?W}?X@?a??QL?GF?|??Z@?Q@?[^Ay??y@?Q???W?y??@A?a??CT?y??AA?a@?CV?X@?a??PF?KF?y???A?P??kU?y??z??@??SI?y??{??aF?OL?P@?Q@?Q??s_?}@?~@?A??{K?y??z@?Q@?KX?BA?CA?Q??[E?v@?a??QF?KF?y???A?Q??kU?DA?EA?Q??cE?G??FA?C?????G??GA?C?????G??HA?C?????IA?JA?B?????G??KA?C?????G??LA?C?????G??MA?C?????G??NA?C?????G??OA?C?????G??PA?C?????G??QA?C?????G??RA?C?????G??SA?C?????G??TA?C?????G??UA?C?????G??VA?C?????y??z@?AC?KX?G??WA?C?????L??XA?C?????L??YA?C?????G??ZA?C?????G??[A?C?????G??\A?C?????IA?]A?B?????y??y@?AD??W?[??\??`??oB?[??^A?@@?cF?y??z??@I?gI?y??y@?QI?KW?W??X??@F?WC?U??_A?@A??G?`A?_A?`D?CF?aA?_A?@Z?CY?bA?_A?@A?KO?bA?_A?@U?_Q?bA?cA?@`?gS?dA?_A?@@?{A?dA?eA?@?????fA?_A?B?????y??y@?A@??W?[@?Y@?AA?k\B[@?gA?A??KmBX@?w@?Q??{C?n@?o@?@A?cE?hA?o@?P@?GH?hA?iA?`I?CG?jA?kA?pW?gF?lA?mA?@?????fA?nA?B?????G??oA?C?????G??pA?C?????G??qA?C?????G??rA?C?????G??sA?C?????fA?tA?B?????G??uA?C?????G??vA?C?????G??wA?C?????]??\??pB????W??xA?@W?GN?W??yA?pA?gO?U??zA?@B?WH?U??zA?PG?OI?{A?zA?pE?WQ?`A?zA?`D?[D?aA?zA?pH?O`?bA?zA?@A?SB?bA?zA?@a?CE?bA?|A?@`?OG?dA?zA?@@?wB?}A?~A?@?????fA?zA?B?????b??a??PD?wH?G???B?C?????G??@B?C?????y??z@?qB?KX?G??AB?C?????G??BB?C?????G??CB?C?????y??z??`D?_I?DB?EB?q??{f@@@?A@?PW?[a?@@?FB?q@?cW?d??e??QA?_??G??GB?C?????G??HB?C?????G??IB?C?????y??x@?a??WT?y??z@?A??KX?G??JB?C?????G??KB?C?????G??LB?C?????G??MB?C?????G??NB?C?????G??OB?C?????G??PB?C?????G??QB?C?????G??RB?C?????G??SB?C?????G??TB?C?????v@?w@?Q??{C?G??UB?C?????G??VB?C?????y??AA?Q??CV?|??Z@?qD?k^AWB?XB?A??se?G??YB?C?????G??ZB?C?????G??[B?C?????G??\B?C?????fA?]B?B?????G??^B?C?????G??_B?C?????G??`B?C?????G??aB?C?????D??bB?B?????X@?a??QJ?OF?X@?cB?Q??{D?y??{??AC?KL?G??dB?C?????G??eB?C?????G??fB?C?????G??gB?C?????G??hB?C?????G??iB?C?????G??jB?C?????G??kB?C?????G??lB?C?????G??mB?C?????@@?FB?p@?cW?v@?a??AE?GF?y??nB?Q??[B?y??nB?A??{W?W??Y??Pf?cJ?W??oB?aH?oL?pB?qB?Q@?wN?G??rB?C?????G??sB?C?????G??tB?C?????G??uB?C?????y??y@?qG??W?G??vB?C?????G??wB?C?????G??xB?C?????y??@A?A??CT?G??yB?C?????D??zB?B?????^??_??P@?{C?^??{B?@B?CE?|B?}B?P??We?DA?~B?@F?oF?DA?C??p@?oE??C?C??@A?[B?y??C??PC?oC?b??c??@??oE?y??y@?AB??W?y??AA?aB?CV?d??e??a??C@?V@?W@?Q?????d??e??aJ?o@?R@?s@?q@?W}?[??\??`D?wB?@C?AC?a??CB?BC?a??a??oa?BC?CC?qN?gb?DC?EC?AJ?Wq@fA?FC?B?????G??GC?C?????HC?IC?Q@?st?R@?S@?q??OM?JC?KC?A@?g~@LC?|@?A@?wC?G??MC?C?????G??NC?C?????G??OC?C?????G??PC?C?????G??QC?C?????G??RC?C?????G??SC?C?????G??TC?C?????G??UC?C?????fA?VC?B?????G??WC?C?????G??XC?C?????G??YC?C?????fA?ZC?B?????A??[C?B?????A??\C?B?????G??]C?C?????R@?s@?q??S}?y??y@?AF??W?W??oB?`L?sL?pB?_A?@A?SG?pB?_A?PA?cG?pB?^C?@D?GI?_C?`C?@??[N?G??aC?C?????G??bC?C?????G??cC?C?????W??oB?aL?sL?pB?_A?AA?SG?pB?_A?aC?gG?pB?dC?Q??sJ?bA?_A?pP?SQ?eC?fC?qB?[M?gC?a??AC?SI?hC?iC?AA?GZ?jC?kC?B?????G??lC?C?????y??y@?A???W?@@?A@?@^?{a?G??mC?C?????G??nC?C?????fA?oC?B?????fA?pC?B?????G??qC?C?????W??Y??@`?KJ?G??rC?B?????D??sC?B?????D??tC?B?????D??uC?B?????P@?r@?A??_E?W??xA?`R??N?vC?wC?QJ?GG?L??xC?C?????fA?yC?B?????G??zC?C?????G??{C?C?????G??|C?C?????G??}C?C?????G??~C?C?????G???D?C?????b??c??@e?[G?n@?p@?A@?wF?@D?mA?aO?kW?@D?AD?aD?SQ?R@?BD?QJ?SB?CD?DD?qF?oI?G??ED?C?????G??FD?C?????G??GD?C?????G??HD?C?????G??ID?C?????G??JD?C?????KD?LD?B?????KD?MD?B?????G??ND?C?????G??OD?C?????W??Y??@o?oJ?pB?dC?QC?wJ?PD?QD?qA?sb?[@?QD?QA??q?[@?RD?QC?Cs?[@?SD?qB?Kc?[@?TD?aA?{a?G??UD?C?????G??VD?C?????G??WD?C?????G??XD?C?????pB?_A?QA?cG?pB?^C?AY?SJ?W??yA?`??cO?vC?YD?`V?OJ?ZD?[D?aD?sE?pB?zA?QB?kC?pB?zA?aq?gD?^??{B?AB?CE?|B?}B?Q??We?DA?~B?aB?oF?W??xA?@W?GN?W??yA?qA?gO?U??zA?AB?WH?U??zA?qS?wI?G??\D?C?????]D?^D?B?????fA?_D?B?????fA?`D?B?????G??aD?C?????^??_??`J?KD?y??bD?aB?WQ?y??cD?a??_S?dD?eD?Q??Gf@dD?fD?aC?wGBG??gD?C?????@@?A@?pn?cb?G??hD?C?????G??iD?C?????G??jD?C?????G??kD?C?????G??lD?C?????G??mD?C?????G??nD?C?????G??oD?C?????pD?qD?AA?OF?b??a??PK?CI?b??rD?`A?wG?X@?a??@E?GF?@@?A@?@??k`?G??sD?C?????G??tD?C?????G??uD?C?????G??vD?C?????G??wD?C?????G??xD?C?????P@?Q@?A??s_?ZD?[D?a??oE?pB?yD?qM?wA?^??_??pI?KD?G??zD?C?????G??{D?C?????G??|D?C?????DA?~B?AF?oF?DA?C??q@?oE??C?C??AA?[B?y??C??QC?oC?G??}D?C?????d??e??`J?o@?P@?r@?`A?cE?R@?s@?@S?g}?t@?U@?PH????u@?W@?`B????[@?SD?q??{b?[@?~D?qB?Ga?[@??E?A@?c^?L??@E?C?????L??AE?C?????fA?BE?B?????L??CE?C?????G??DE?C?????eC?fC?@E?_M?EE?a??@e?kI?A??FE?B?????W??Y??@g?cJ?pB?^C?`@?GI?A??GE?B?????G??HE?C?????G??IE?C?????G??JE?C?????G??KE?C?????G??LE?C?????G??ME?C?????G??NE?C?????G??OE?C?????G??PE?C?????G??QE?C?????G??RE?C?????G??SE?C?????G??TE?C?????</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1664370878422;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","java.lang.Thread","<init>","libsystem_pthread.dylib","thread_start","_pthread_start","libjvm.dylib","thread_native_entry","Thread::call_run","JavaThread::thread_main_inner","JvmtiAgentThread::call_start_function","libasyncProfiler.so","Profiler::timerLoop","Profiler::flushJfr","Profiler::updateThreadName","jvmti_GetThreadInfo","JvmtiEnv::GetThreadInfo","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<286822ull, G1BarrierSet>, ","one.nio.server.SelectorThread","run","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","handleParsedRequest","one.nio.http.HttpServer","handleRequest","RequestHandler0_handleRequest","ok.dht.test.yasevich.ServiceImpl","handleGet","ok.dht.test.yasevich.artyomdrozdov.MemorySegmentDao","get","ok.dht.test.yasevich.artyomdrozdov.Storage","entryIndex","ok.dht.test.yasevich.artyomdrozdov.MemorySegmentComparator","compare","CompileBroker::compiler_thread_loop","CompileBroker::invoke_compiler_on_method","C2Compiler::compile_method","Compile::Compile","ParseGenerator::generate","Parse::Parse","Parse::do_all_blocks","Parse::do_one_block","Parse::do_call","Parse::do_one_bytecode","PhaseTransform::makecon","Type::hashcons","Dict::Insert","Compile::Optimize","PhaseIterGVN::optimize","PhaseIterGVN::transform_old","AddNode::Value","AddNode::add_of_identity","TypeInt::hash","jdk.internal.foreign.AbstractMemorySegmentImpl","mismatch","vectorizedMismatchLargeForBytes","jdk.internal.misc.ScopedMemoryAccess","vectorizedMismatch","vectorizedMismatchInternal","ok.dht.test.yasevich.artyomdrozdov.Memory","java.util.concurrent.ConcurrentSkipListMap","doGet","Compile::Code_Gen","PhaseChaitin::Register_Allocate","PhaseChaitin::Split","loadLNode::rule","PredictedCallGenerator::generate","Parse::do_field_access","Parse::do_get_xxx","GraphKit::access_load_at","BarrierSetC2::load_at","G1BarrierSetC2::load_at_resolved","BarrierSetC2::load_at_resolved","GraphKit::make_load","PhaseGVN::transform_no_reclaim","CmpPNode::Opcode","jdk.incubator.foreign.MemoryAccess","getLongAtOffset","java.lang.invoke.VarHandleGuards","guard_LJ_J","java.lang.invoke.LambdaForm$MH.0x0000000800c1c400","invoke","java.lang.invoke.LambdaForm$DMH.0x0000000800c1b800","invokeStatic","java.lang.invoke.MemoryAccessVarHandleLongHelper","getLongUnaligned","getLongUnalignedInternal","jdk.internal.misc.Unsafe","ciMethod::get_method_at_bci","ciBytecodeStream::get_method","ciEnv::get_method_by_index_impl","ciEnv::lookup_method","LinkResolver::linktime_resolve_virtual_method_or_null","LinkResolver::linktime_resolve_virtual_method","LinkResolver::resolve_method","methodHandle::~methodHandle","PhaseIdealLoop::optimize","PhaseIdealLoop::PhaseIdealLoop","PhaseIdealLoop::build_and_optimize","PhaseIdealLoop::build_loop_late","PhaseIdealLoop::build_loop_late_post_work","PhaseCFG::do_global_code_motion","PhaseCFG::global_code_motion","PhaseCFG::schedule_late","PhaseCFG::hoist_to_cheaper_block","PhaseCFG::partial_latency_of_defs","one.nio.net.JavaSelector","select","registerPendingSessions","getByte","getByteAtOffset","guard_LJ_I","java.lang.invoke.LambdaForm$MH.0x0000000800cc9400","java.lang.invoke.LambdaForm$DMH.0x0000000800cc8800","java.lang.invoke.MemoryAccessVarHandleByteHelper","checkAddress","checkAccess","checkBounds","checkBoundsSmall","java.lang.invoke.DirectMethodHandle$Holder","checkValidState","java.util.Objects","requireNonNull","unsafeGetBase","isSmall","isSet","jdk.internal.foreign.Utils","filterSegment","jdk.internal.foreign.HeapMemorySegmentImpl$OfChar","base","OptoRuntime::new_instance_C","InstanceKlass::allocate_instance","MemAllocator::allocate","libsystem_platform.dylib","_sigtramp","Compile::call_generator","InlineTree::ok_to_inline","ciMethod::get_flow_analysis","ciTypeFlow::do_flow","ciTypeFlow::flow_types","ciTypeFlow::df_flow_types","ciTypeFlow::flow_block","ciTypeFlow::StateVector::apply_one_bytecode","ciTypeFlow::StateVector::do_invoke","ciEnv::get_klass_by_index_impl","ciObjectFactory::get_symbol","vmSymbols::find_sid","MemAllocator::Allocation::notify_allocation","AllocTracer::trapHandler","Profiler::recordSample","JvmtiEnvBase::get_stack_trace","vframe::java_sender","compiledVFrame::sender","_platform_memmove","findHandlerByHost","read","one.nio.net.JavaSocket","sun.nio.ch.SocketChannelImpl","sun.nio.ch.IOUtil","readIntoNativeBuffer","sun.nio.ch.SocketDispatcher","read0","libsystem_kernel.dylib","convEndian","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","sun.nio.ch.KQueue","poll","kevent","ConcurrentGCThread::run","G1ServiceThread::run_service","G1ServiceThread::sleep_before_next_cycle","Monitor::wait_without_safepoint_check","os::PlatformMonitor::wait","__psynch_cvwait","PhaseChaitin::build_ifg_physical","PhaseChaitin::add_input_to_liveout","IndexSet::alloc_block_containing","sendResponse","writeResponse","write","one.nio.net.Session$ArrayQueueItem","writeFromNativeBuffer","sun.nio.ch.FileDispatcherImpl","write0","NodeHash::hash_find_insert","BoolNode::hash","PhaseChaitin::split_USE","PhaseChaitin::get_spillcopy_wide","RegMask::is_aligned_pairs","java.lang.Math","min","cpr","JavaThread::last_java_vframe","vframe::new_vframe","compiledVFrame::compiledVFrame","PhaseCCP::PhaseCCP","PhaseCCP::analyze","LoadNode::Value","MemNode::can_see_stored_value","Compile::find_alias_type","Compile::flatten_alias_type","TypeInstPtr::make","TypeOopPtr::TypeOopPtr","PhaseChaitin::gather_lrg_masks","PhaseIdealLoop::Dominators","Node::is_CFG","PhaseChaitin::post_allocate_copy_removal","RegMask::num_registers","java.lang.ref.Reference","reachabilityFence","WatcherThread::run","WatcherThread::sleep","GangWorker::initialize","GangWorker::loop","semaphore_wait_trap","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsBaseTask::evacuate_live_objects","G1ParEvacuateFollowersClosure::do_void","TaskTerminator::offer_termination","_pthread_mutex_firstfit_unlock_slow","offsetNoVMAlignCheck","G1BatchedGangTask::work","G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::do_work","G1CollectionSet::iterate_part_from","HeapRegionClaimer::claim_region","MemAllocator::allocate_inside_tlab_slow","G1CollectedHeap::allocate_new_tlab","G1CollectedHeap::attempt_allocation_slow","G1AllocRegion::new_alloc_region_and_allocate","G1CollectedHeap::new_mutator_alloc_region","HeapRegionType::get_trace_type","scope","parseRequest","one.nio.util.Utf8","startsWith","vframe::sender","CompiledMethod::scope_desc_at","ScopeDesc::ScopeDesc","ScopeDesc::decode_body","PhaseChaitin::elide_copy","vframe::vframe","RegisterMap::RegisterMap","long const static_fast_get_field_wrapper<11, long const>","pthread_jit_write_protect_np","fromString","jdk.incubator.foreign.MemorySegment","ofArray","fromArray","jdk.internal.foreign.HeapMemorySegmentImpl","one.nio.http.PathMapper","find","java.util.HashMap","getNode","java.lang.String","equals","thread_self_trap","int const static_fast_get_field_wrapper<10, int const>","java.lang.invoke.MethodHandle","asType","java.lang.invoke.VarHandle","checkExactAccessMode","jdk.internal.foreign.SharedScope","VMThread::run","VMThread::inner_execute","VMThread::evaluate_operation","VM_Operation::evaluate","VM_G1CollectForAllocation::doit","G1CollectedHeap::do_collection_pause_at_safepoint","G1CollectedHeap::do_collection_pause_at_safepoint_helper","G1CollectedHeap::pre_evacuate_collection_set","WorkGang::run_task","semaphore_signal_trap","frame::real_sender","frame::sender","frame::sender_for_compiled_frame","_kernelrpc_mach_port_deallocate_trap","unknown_Java","_new_instance_Java","PcDescContainer::find_pc_desc_internal","isAsciiString","one.nio.http.Request","getHeader","ScopeDesc::sender","java_lang_String::as_utf8_string","char* UNICODE::as_utf8<signed char>","toAsciiString","sun.nio.ch.Util","getTemporaryDirectBuffer","java.lang.ThreadLocal","java.lang.ThreadLocal$ThreadLocalMap","getEntry","libdyld.dylib","tlv_get_addr","JavaThread::is_Java_thread","VMThread::execute","VMThread::wait_until_executed","__psynch_cvbroad","__gettimeofday","CompiledMethod::is_compiled","SpinPause","_pthread_cond_wait","_pthread_mutex_firstfit_lock_slow","_pthread_mutex_firstfit_lock_wait","one.nio.http.Response","addHeader","Recording::cpuMonitorCycle","getrusage","G1CollectedHeap::gc_prologue","CollectedHeap::ensure_parsability","ThreadLocalAllocBuffer::retire","ThreadLocalAllocBuffer::accumulate_and_reset_statistics","G1CollectedHeap::tlab_capacity","G1SurvivorRegions::length","java.util.concurrent.ConcurrentLinkedQueue","updateHead","guard_LL_V","java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite","setRelease","G1CollectedHeap::post_evacuate_collection_set","G1CollectedHeap::post_evacuate_cleanup_2","G1PostEvacuateCollectionSetCleanupTask2::G1PostEvacuateCollectionSetCleanupTask2","HeapRegionClaimer::HeapRegionClaimer","AllocateHeap","os::malloc","libsystem_malloc.dylib","_malloc_zone_malloc","nanov2_malloc","JvmtiEnv::GetStackTrace","AllocTracer::send_allocation_in_new_tlab","sun.misc.Unsafe","copyMemory","copyMemoryChecks","checkPrimitivePointer","checkPrimitiveArray","FreeCSetClosure::do_heap_region","G1CollectedHeap::free_region","HeapRegion::hr_clear","G1BlockOffsetTablePart::initialize_threshold_raw","toBytes","one.nio.util.ByteArrayBuilder","append","os::javaTimeMillis","libsystem_c.dylib","clock_gettime","__commpage_gettimeofday_internal","mach_absolute_time","Method::jmethod_id","toByteArray","toArray","java.lang.Class","getSimpleName","reflectionData","MonitorDeflationThread::monitor_deflation_thread_entry","G1MergeHeapRootsTask::work","G1HotCardCache::drain","G1CollectedHeap::evacuate_initial_collection_set","G1RemSet::merge_heap_roots","G1GCPhaseTimes::record_or_add_thread_work_item","PeriodicTask::real_time_tick","PerfLongVariant::sample","javaVFrame::is_java_frame","java.lang.invoke.IndirectVarHandle","getMethodHandle","entryAt","void WeakProcessor::Task::work<G1STWIsAliveClosure, G1KeepAliveClosure>","G1KeepAliveClosure::do_oop","G1Allocator::attempt_allocation","G1NUMA::index_of_current_thread","G1ParScanThreadStateSet::flush","G1ParScanThreadState::flush","length","resource_allocate_bytes","SafepointSynchronize::begin","SafepointSynchronize::do_cleanup_tasks","VM_Operation::set_calling_thread","checkPointer","checkOffset","Profiler::updateNativeThreadNames","MacThreadList::~MacThreadList","_kernelrpc_mach_vm_deallocate_trap","FlightRecorder::recordEvent","OtherRegionsTable::is_empty","sun.nio.ch.Util$BufferCache","unsafe_arraycopy","jbyte_disjoint_arraycopy","G1EvacuateRegionsTask::scan_roots","G1RootProcessor::evacuate_roots","G1RootProcessor::process_java_roots","Threads::possibly_parallel_oops_do","Threads::possibly_parallel_threads_do","ParallelOopsDoThreadClosure::do_thread","JavaThread::oops_do_no_frames","JNIHandleBlock::oops_do","void G1ParCopyClosure<","TruncatedSeq::add","CodeCache::find_blob","PerfByteArray::~PerfByteArray","ScopeDesc::decode_object_values",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
