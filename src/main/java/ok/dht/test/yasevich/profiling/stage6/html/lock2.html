<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BCtAAQjAacB?????????????????????????????????????????????????????????????????????????????????????????????????????WWj`jijihibijabasM\MVTUUVU[KKNNN^MNUU[VIqjjqpbihyapkK]]K`sLShpqyqdKhidK^[T[[`pyjcL\TVKV`qrqqxha`hjz`qib}MVUK`kKT^L^[VVSTSVK`dMMNVUUUL]NUS\LN]NLJqxbxpxydNVS`qzjybqjziypajyicLNS`irq{M]M]STNK]N`pihaircK`cNMTL^VS`jqhhjsMVNS`rxbbtMT[Rrz[\UUU]NUT[\^UVT[]M]hqrpcLSK`apyqrbxari`hqzpsKS]^TS`biT[TM`aabiprxxiqzjqxpVNSSSU\`iqaidK]SRxqapiaippcMK`aCTS[`aryarbzcL`qaaqyaiabsMVSUVLT^L^`p^N^VUULLTULU\TML[]LS`abbbqryjiibzabyzxyqh`q`kKSU]`rkNV^[hrbpbxaxyhiyyyyqabqyzyra{L^V`qbsMT^K[`r{KU^`iylLUK`tKTS`izh`pkIxbzq\KKSUPbpyabjqjjrkKTT^^US`ybkL`jpjz`xiTUSTU[^^KVMK`bdM[[S][`zip\]]VMM`airbx\\[]KTSU\[ULUUS^V]V\\[S`jjyqkLX?H[LSULLUNHYhhNKLIxTNGJh`[KVMKH`VVLSUKTLLMKKIR\L`[NJKJ[IOh`LTSVLIFH`ZTHxLOSLKXh[JWxh[JiJIpXR`THhH`H???Npj`SLNLUOhJBrHSJxhWaJPh]UJX@?Kh{LLTS`iY[JHkKKYEMPxh`pUNRq`ahiyAP?HhhyhMKNISIGPODUVNP``axIxaKOMTTQiXiK`CKKKIaBp`NHQxx`PxxCMIVNHTMJQhpG`?A?mMI`\HCG?EpsN^KNUSXi]IqTLO@AhSMLKSN]TKL]ILJEJhhiMLSJHixzNICHINPP``qqJH?CXhqlLLUM]GhDQhPP??@Mprhxx`G??{MK]SMZ`\IpY``WQ`iaQ^Z`h`p`ppZNKXLMKIL]IPh`V[KNMH`hiqy^OSPqZhaqzxP[KJEVMZ`HZQ`BYhLG??M^UhyxpahaI\XhxaRp``VGkKJ\MOpJQRXRpBKIITIPHALNI[JLJW`SICXaKXaNGi[JXYLILKGhqVI``ihPh]MHph?]I```SKJZQpq`Qph`AZ\I@`IO??K`y`hqy`FJiXRWOaWhhxQHAOG?yeLhhahaH?Azq`bRiQS[VLQRSLGHXHh`xh`ph`OxhRPW?[LKKPOTJhhWp`ipUNJ`RDKKQ`[QJ``ASMMJ`QGGBHJG??HkLSLGTZ`xY``QX??HrxhxTH`UIEG`Y``RLNGx[HPhOKJ`XTKIKJTKJp`XyRQPYY^GJ`hXMJTSHQIPG?E[K``HITPCKQKHI`^KGO^I`hS[J`WHPX?QLNSI``hPxXpUHyxySIFIIkHJ@ITHHWAPh`xH[LIpaIx`OHHWhSRy`^MKJULKKHhHSSTHQRGYBGGYRIhHhpZhpx`aDGULVGjZ[H`QXX\ILK\JJKIxyxip]LKG??@FSPDHGOB?xqxOHGKH`aIIHQCUGLI@VKNJQ`WXSG`AGKLNGLHh[KLHI]P`hBhYxQxaIxYhJPUH[TSGxAWUKJXYhSKGPJY`JpJSKIQSQhEKJzIQRHHhPh@ZIhKIVGh?`GJRGCHSJMLPhPibCKKHSHTGIaQpKRp?`UKQQXRZPx[IX@[HX]IO??E\pJq``hKGSSIhpQG?@hahx@QHbTZSZqHZLGA\JMHGGXP`hhKIUGOha`KJ`xXHhxKPXxYVLIQKLPh`xA`LVJTHG`apLLJ@GXZh`CNNIhQh`QKJP`XXh`Xh?G??VLHAxa[IBFHTJP`@?@?XAqxGSI`ApW`IRI@ZKNIAqUG@[Q`@TXCGHZI[Gy`?ASGhx`p?NTJPLJp`@``R`???yiDNJR@x[IH@Y\HxHGKGbhYhI@ZAHB@FGG@?O@`Q`PGJBX`GpY`I`R`P`GpQGJQDGx@p`EGFJKHJG`HIO???xKKJa??EJGAGEHCHPPG@KI`pCKGp]MJHCIIDGhIKG?@FKVJRFGELI@MHKI@ZMHhYh?O@?AHHP?@KMJZCHX??@jSGG`??GpaTJG@BQ`TKHhI@XIIiRKJIH`HYQ@I???DHLIG??AIxG`JY``G?ASGXXOQHyG?RSICXJPhaAXb``AKHyH?H`ADIHpYhQIWAG?JH]RRhAIX`HNHhO???`kJJ[ORhXpITPP`R@]H@qAGFHDIPHMH`hUJHhAWOWXUIRWY`Ah`RTKJ`I]HxHH????T`LKHHPB[IAX`GQhA`IoNdMcNqN`NtMfN`IjQkQuIbKwQlI|JiQxKbLxLqQtPrNzNuPeImIeJ}JjKmKcLvN{O`P_QaQbQdQaIcIdIfIhIiIjIkIpIqIrIsItIvIxIyIzI{I|I}I~I_J`JaJbJcJdJgJhJiJjJkJmJnJqJrJsJtJuJwJxJyJzJ{J~J`KaKcKeKfKgKhKiKlKoKpKrKsKuKvKwKyKzK{K|K}K~K`LaLeLfLhLjLkLlLmLnLoLqLrLsLtLuLwLyLzL{L|L}L~L_M`MbMcMeMfMgMhMiMjMkMlMnMoMpMqMsMuMvMwMxMyMzM|M}M~MaNbNdNgNhNiNjNkNlNmNnNpNtNuNxNyN{N~N_O`OaObOcOdOeOfOgOhOiOjOkOlOmOnOoOpOqOrOsOtOuOvOwOxOyOzO|O}O~O_PaPbPcPdPePfPgPiPkPlPmPnPpPrPsPwPxPzP{P}P~PeQfQgQhQlQnQpQrQtQuQvQxQyQ|Q}Q`RaRbReRfRhRiRjRkRlRnRoRqRwRxR|RbIgInIoIwIfJlJoJpJvJ_KdKkKnKqKtK_LdLgLiLpLvLaMmMrM{M_NeNsNwN|N}NhPjPoPqPvPyP|P`QcQmQoQsQzQ{Q~Q_RcRdRgRmRpRrRsRtRuRvRyRzR{R}R~R_S`SnqLFFLFFLFeAFILJIFOLJFPMIPMIMLJFIOJJPQMQLFI@IJMM@MILOLFJOL@PJcAQJFMJFDA@A@IAAAFOPIAQ@@@MJI@CDAL@F@@?A@@AC?@L@??AF@DAECBBCB?AA????@?A@@CB??BA@EDAAD?@C@AAC@@@AD???CAAE?ACA@?C?EE@A?A????CACDC?ED@AA@@@@A@C@?AAAE?DBA@E?D@@?C?C@@@B@AEACCA?ABACCD?@@@??EAAADBCBB@D?B?@@EBEB@@?CADAB@?E?E?DAEB@A?@?CC?AD@B?A?AE@ABD??A?A?D@AAA@C?D@C@BA?EAA@??@A??DD@D@??AB??DB?@?A@D@?@?D??BEB?CBBBA?@@B@A?@@??@@??BE?EEAB@?AAAD@?@ABAA?D@BB@C@CA??C?D@?A???@@AC@@@D@@A@@D@@@A@@BC???????@?A?C@CC@?B@A@BAEBBD?AA@???@C@DB@??ABD@BADBCBE???B?D?C?E@@??DA??B@?C@?B?E?CEBC?AAAABC@??A??C@E?@????C@C?@CA?@?@????@CAEBD??B?EE?@?@@?CAC@B???CC?A?ADE@?A?CA??AA@?B?D@@EBAB?BAAC?B@C?ADDCB@@?AAE?@C@EBE??BEADBB@@B?BBBDDBEB???@A?@DD?@BA??D?EA?C?@@E?E???BB@CA@CCEABB??CAA?EBB?BC@BEBA?C?A???C?@BDB?E@?ACC????B?AD@A??BB?AA@?ACDCC@@A?@??A@@@C?A@AAA@AEBCA@EC?BC@@B@A?BC???????@EE?A?C?DCCBB?D@?D?D?A?ACD?AEE?E?BB@A?B??@CB??@?AADADA?EA?CC@AA?B@DE@D@ABEABACCA?CAB????@@DB@@A??A?@?@D?@?A?A@E@BCBE@DABAAD?AD@@CCA??C??B@ED@E@???CA@AAA?DBAA@BAA???@?CAABA@CB@C?@@CA?AB?C?@??B@??AC?CAA?AD@@C?B????ABAA?CDB?C@B@@????ED?BAABCAD?D@B@@CA?A@BCE@BE@?C@CCD???B?C?CADE@E?CC??@?D?C@??AC?@CA?BC?D?E@DB???C@C?A??CEAAD@@BCA@??DA@?A@?E?@@ABC?B?CB@?A@B@BEB?@?EBE@@AECDADD?E@ADDA@C?B?DAB?CA?@B?B??B?CC@DB@BA?BBCC@AD@??A?@ADB?@?A@A@C@?@EABDC?EA@@??@A?A?BCC?A@?A?A@C??BD?CC@AE@??BCBE?@CACB??B@@A@?@C?A@@BB@A?CCC@?D??@DAA@AC@@C@BDE@BA?BCC@CDDD@@A@?ACB??E??EBB?E?EADB?A?A?@@?????B?C@?DCAAB@B?EE?BB??@BCDCA@?BDC@@A?E?EC?@AA@@BBB?A@DBA?@?@?ACCEB@@A?CA@?@@?A@BC@?@A?B?@??C??@@@???C?A?@AA@@ABB@EAC@?B???BC?AA@??@??AAC?A@@@@@DB???C?B@D@B@C@@?DB@A?AAC?@BDB?EAC@DC@?DB@A@C??@CBE@@???A??@A?CA??B????@@@@@AAACC?@?A?DC?@CECC?E?BBA@B?E?B?D?C?DABA?C@@@AAA@A@DA?CBC??ABD?A@?CAB???@AB?@CBA@@C@@?@A@@B??@@CA@D@AD@EEBC?A?D?@C??A???AB@CAEB?A@@@@CBBCAA@???AEB?AE@?DCA?D?BB?A@?DBDCCAC@AD@@CC@ACAB@?@CB@AEDA?EA?@C?@@B@ABDAA@E?CD@?@A@B??EC@@DE@@AABBBDAB?@BAC?@C@A@?AC@EBCC?@A@@BA?D?AAA?A??AA@AB@??CD?@?CEEAEA??C@???AAD?A?EEC@ECDB??C@EABA@AC??ACBCACE?ECE?C?D?C@DEDE?A??@B@?@A@A?CB?D??@??@B@C@C@ACAA@A?C@@??@@?ACA??C@@ABBE?@@D??B?@C@D??AC?@??EBA??DD@?B@A@@DB?BA@@BDA@C@BEDA?DBCDDA??DD??B??@B?ACB?AEA@ECEAA@?E?EA@@CEDBE@B??ACAA@C@A@A?CEAB?@@D@C@?CAAA?@A?@E@B?ADCCC@@AA?BCB@AC??EDB?@?@?EEC@?@DC???@B@?AAEB??@CDAE?AA??A@AA?CB@?DBB?A@B@A@@AE@?B@CD@BD?BBA??A?AACC@ACB?E???BCAE@@C@ED@CDCEBA?A@AA@@?A@ADA@@AC?@AEA@BCA??C?DCDC@E@C@EA@@??C@D?A@B@@@AD?@@CB@CA??EC@DCDA@@?@@BAB@CB?BC?C??@B??ED@@B@BAA?B@E@A@???C@?B???@A?AB@D?@BB????B??AB?BD@D@?BCBB@@C@AA?BBAE???CD@@A@C?A?A@?@BC??B@AA?@??B@??@DACCCDB?C?AAA@?@C@@CAD?@A@A@@?@?@??????E?C?A??D?E?@B?BA@@B@DD?C??D@?@@C@DC@C@?DD??C@@AC?@@?????AAB@DAB@CD?E@C???BBCA?@C@A@?C?E????@AB@@ADCAB??@BAABAAAEA?A@B@@EB?@@?@DAA@AA@@CD@CD??CD@A??A?@ABBBC@@?AC@CE?AA@@ACA@@ADA?AED?ACCAEBA@@CD??D??BBECC@@A@C??@?@C??ADDDA?AECEB???A?C@??@?@D@??DA@?A@??E@B@A@C@?@ABABA?B@AA?AA@BA?@BD?D@?@@@CB?B@AD?C?C@@@EA?BE?@EEDA?AD?EAA?@@@?CBEC@?DAAA?CCA?A?@?AE??BCE?@@E??D??CBCE?CA?B@A@?@?ACCADA??E@?CEBC@A?E@EAA?CABAD?EC@D@@AE?BB@?EACCE@CABA??EC?A???DDA?DCABB?D??ACACA??C@@CC?CCAABEAAA@@AA?CB?CDBC@E@@FUCE?BB?A???AAAA?@??EDADA@?BACB??BC??C?A@??CAED?C@CAEBA?@CC@C?ABA???CADE??A@D?CAC@D?@A?BAAA?E@C@@BCDABAA?DC@D@@?B@DE??C?@??E?@??@C??EBCCC@AD@DB@A?@B@AAADACDEDB?A@A??@??ECDC@C?DBD?@CAC???C?B@BB?AB?C?EE?DCBA?@??@CCBEABBC?E??DCAECC?C?DA??@B?DB?DEAEDA@@CD?@BE???BE?C@@EE@@CADDA???@?@A@?D@@A@@@@DA@?AA?DB?A?A@?B?@??D?C??@BDBBC@C@@?ABA@?E@@@??A??EE@CBBC@AB?E?B?DBBAA?B?CCAAA??@?@@D??B?D@?@CC@@?C?@A?@@C?DAAA@?@@@C?ACA@B?@AD?@?A@@??B@?A?DBBB@@CA@@@??A@DB@?@DAEB?BAB@@@?C????@DD?@??E@?@@CA@CDAB@CCAC??B?@?@C???B?A??A@?AA?@C???DCA?BAC@@C@BEAD??@AC@BAE@??C???BB?DD@ED@D????@@C@?@AAC@BCD@?B?AA?B@BA@C?ACC@CE@DC?DBEAA@C?CE??@DAA??E@??B?A@DB@?CB?B@?BCBBE?D??@C@C?@AA??EB@A@CA?@ECA@E??A?@BB?@CA??ED?A@EC@D?A?BBCCA??CE?BAEA@?B@AA@????EB@AD@B??@AC@CE?BAA@EC?CE?@@?BD?A?A@AA???@?B?B?D?@C?B?DE@B??@EEAE?CC@@?@AB?A??E@EBA@?DBE?BB?D?BE?@@?B??DBA?CA@B@@BD@BAEA@??B?C@?CA?E@BD?@?CAB?D?AA@@?BA??C@BBAA?@AC@?@C@@???B@AB@CDA?DD@AB?E?DA@??C?C??B@@@@BAAAB???@?@BCADA?BC@??@?B?@ABCB@DDA?A?EA@@@@?A?@???@BBC@@??@@A@@@ED@?@?@?@C??B???DABBBB?B@B@AAE?BECCA?D?@?B?EDC@AABB@@?DA@@CC@@?@A@EAC?@@??B??AA?DC@?C??@CB??C@C@@DCAB?A?A@??BA@EAB?EAA?@A@D@EAC??@@????C???E@EA?C@@@?EBD@??BA?B@?AAC@E@EA@@?D@??AEE@@?C??@@C?B@CAD@C??AACA@@?C@B@?@BCACEA@???AAAAAC??C@A??@@?C@ABE@BE@AAC@A?AC??@@AA?E??@?E@AE?@BC@@DC@E??@?????BAA@C?@@A@???@AA????D?@@@?B@BEEBBD?@@@C?BECD???AA@DBB?B@BAB????@???@@AB?CB@BD??EB@CCAD@?C@@???@@??BBACBCBCBD@?AB@?@?AEAAB@DE@DBC?CADA?AB??DEEDC@@AECB@C?@D?B?C?ADAB@@E@C@CA?A@?ADAEADB??@B?AA@?DB??A@@CD?E?BCB@A?E?@???@?@?B??A@?@@A??AB?@@@AA???BEBA@D?@CC??@@?CDB@A?D???B?B?@??AED?@?CD@??DAAA?B@DAABCDD?C@CE@@?ADDB@BB?@D@EC?BA?CAEBA?C?D@E?@?CADBC@@CC?BEB??DBA?@ABCAAAEA?EDC?AA@@C?A?@D??AD@?A?EAB@@D@B?CD?C@?C@@CE?@EB??@@?C@A??AAB?A??C@@BD@B@C??A@@BC@?@B???CAD?@@C@?AEB????A?????C?@C@C@?@CC??A?AAA?@C?@EEC?BEE???DABBA?AAECB?AEAC@???ECC?A@EEB@CA?BAC?????@???DD@EEEC@@BAC?A?C@AB??BD??A@D@@C@@D@BB@?C@?@DADBD@DDECACAB?C?B?ABBAD?E?E@@?@AEA?AB@C?AB?@EDA@@DC?A???AEAE@??AA?CABBEE?BABD?E?BCCBDB?@??B???EC@?AAE?E?A@ABDA???A???A?D??AD??B@@DB?BBDAD?B??A@??@?@CBAAAED?@?@@?AADACB?E@AE?EAD???@DDA?BA?A?D?AAD?BA?B@?BAEABBAD@?A?DABB?CAAC?BBB@DC?DCBEB@CC?CAAEB?AEA@BB?EAAAABBCC@A@??@AA?@?@@A@?E@??DB??DCE@???C@B@D???CB??BA?C@EA@??D@?@A?@@@?DCACCDB?EEBA??AED?CD??@?BDE@B@D@?@A@A?E@?C??CAC@C?A?@?C@?@BAA?E?AB??EBDCC@?C?C??CB@DAA??A??ECA?CAA??E?A?@EDEC?DE??@ADDA??AC??AE@??A@?@DBBB??@?@AEB@D?DA?B?CBDA?@?EAE@BABB@@A?D??ABEA?AEBDC?D?DC???D?@BBC@BEBBA????@A???EADEA@CB?A??B@AC?B@?D@DA?@EAD?BC@B?C?@B@DB??E?A?C???AACBEC@D?@CB@AB@???@BBC@@@BAB@ACEB@@@@@@@?DB??EA?AD?C@B?@?DA?@??B?D??CB??B?C?A?D@CC??@ACEB??D@@BA?BCE@@BDDB?@???@@C@@ABDEDCB?DEC?B?D@?C@@C@@C???BAA@@C??D?AA?BAC?@??AA@?@DA?@@?CC?@?B?E@@@?ED?C@?E@@CCCC?C@AA?ADCCE??BA@D?@B@??DA??EDA@?CBB@AC?C@C@B@?@C?@C?@ADB@B???B?DD@?@AAA?A?A@D?A@?DCCA??D@ACACA?DADA?AB???@??@??BDCC@D??A??@??B?AB@A@@EAB?AAEEB@?AE???BA?EACAA?A??BA??BC@A@C@B??AB?CC??BA??@@BAC???A@?B@?DBDBA???CDA?CAAAEBEAC@DC@BA?A?@C@AD??C@@DAD@A@CBDBA?B?C@C@?AAAAC@??D@@CB????CB@AB@??EDEDBAB?C??D?DC???C?B@?@A??ADCBD@BB?@AD??BD?AB??BAA@???@@A?CAC?A@?????@A@@?CAB???BDCE???CC@BDD@?E@B?AOPOPQO?A?@DA@?AABAAA?A?BB??FSSB?BA?BDB@?AC@A??ABA??BB?AD???@?DB???@?@C?E?@@@B??????A???????@@@B@?@?DC??????@@@?????A???@?@??@???@@CC@AA@B??C?@C????DB?D????DB@???BA???B??BAA@A??A@@@C@@C@??A?A???B??CBB???????AA??C??A?A@?BB????@??C?BCD@???D?D????B?A????D@C@??DA?D??ABAA?@?A?????????@@C@@CA??@??@AA???@?CA@@D???@BB???A??@?A??@@D??E?@BB??@???BAB????A??@?????D?@@??BA??A?@AD????????BE??A???A???DBB???@?A?@@???@?????A@????????AD@@BA?@C??D@@B????C?E@?@C?B@B??A@D@@EEB@C@????DB@?@?B?C?C?@??@?@@ACA@C@??AC@?@BB??D?C@?CB??@?@B@B?@?@@C@?B?@??B@??OE??BA?E@A@EAAB?AA@?A?@ECB@CAE??B??CD@@D@C@?E?D??EA??A??B?B@?@DA?A??A????D?D?AC?AD?D@@B?B?AC@@@?@????BB??E??@@C@B@?ECABEE?????@@B@DBB??A?AA?@BCC???@?BC???E????????????@@AB???AC??BDBBD?EB?DC?@?@CBED@?AE@BAA@@DBC@AAAAE@?A@C?BAB?BBDA?C@??B??C????BB@CB?B?@A?C@C?DD??A?BE?ACCE?@B@A@??A?@@@?@SFFb@d@SSFNEEE???@A@???A?BFGGGGFN??AB????@@?????B@C@@A??????A?A??A?B?A?????@B?EEE??@??????@?@DBED???GHGGGNNN???A???????????D@CC???B??B????C??A???@@???AB?????EE???C???A????B@?BB??BE@B?????B??????BA??CB@?@@@CBA@C??ADDB?BBAB??@@?AB??AB@CD??BA?@?CC????B@BD??????????BBBC@BBB?ABEC@?BBB@C@???C?AB??????A?D????C@@D??B?A@?????D???????D@A??E??????????EC??@??E???E?????ABGGGGGGGHNEB??C@A@????CC@???@@FFUFRR?P???@???CD?C@D??@???B?ECEB@?A??D@?A??AC????B@?A?B@D??BA?A???@?A?????D@??C????????BDCA@B@B???B?AAA?D??A@?B@@B@?C???@??D?A@?A?B?A@D???AA?@B???EEA?A@AE@?B???D??BA@BBDAB?AA?AA?Gb@GHG@?A????@??CA@???D?BCD?ECD?EA?A@CAACEDA@??C??GGGd@H????????@B@BBA@@@???A?D?BAAABD?????@C@C@@@???????C@?DA?BB??????D????E@@@@?AD@???????C?B@A??B????????@?CC@B@GGHSB?EB???@A?@@@@BACA?BBAC??EA???C?D???B??A@ABB??D@BAD?AB?D?@D?EA?CC@CD?B??A@?A??@C@????AC??CA@C?C????BCAABB???C???B?@??@B@@@A??A@DEC@????@CC@?D?B?CDECBDBA@@A??C?GFHK????????GN??B??B@@?@@BE?B@@C?B@???????@???D?CE??????CBC??????@BB???@?B@EC@D?BEB???C@??????@CBB?@??@?A@@B?ACA?A??DAC@A?EEC@D?B@???@?ABB?B??@????A@?@B@@C@?CC?BCAC?A????@@????EA??CB?????????DB?@CB?@CDBDD?@AA????DA??CBC?CABBAABA@?A@?B???ABD???????BCB?????BB@?A?B?B??B?B???@CA???A?EA?@?A?E???C??DBD?A@?BCB?D??A?ADDEB?DB@BDKH????N??B?BD?B?ADE?EBE??E@@D@@EEE?DC?BA?A@?@CACAE?@C????????@C??DA??C?A???BB??@????@????A?????A??C??B?@@D?A??ABB????AB???CBB??CCD???C@??@@@CA??????@???C@B@AB?B?@@@@?BE???CC??AD?DCC??BCBD@CA@C???AA@?AB@?E?A?D????@AE@@EB@C@???????A?@?????????B???@???A@??@D@?@??@??????????????@EAA?@????????CC??D????????@@??B???D?CA?B@?B??@???AA?@?B???C@?B@C????????@@B???A?B@C???????A@@@E?????B??@?EABB@@???A@C?@@GGGGGGHN@C@???DEEBA@C??????@EB?B@BB?C@@?A??DD?OE??A?B??@??@?C@??@BE??EAA????@?C@??@?C@??B?ADEBAAAB?AAD@DAA?@B??AAED@BD@????DB?@?AD??????B???????AA?@BA??????A@@CDD???E?B?C??????H??B@C?@???@C?????A???@???D?B@CC???????@???@?B??@QPMMA@@DKH????????BBBB@@BA@DBB?C?CE@A?A????????C?@B???@@???AE@EBBD??B@BA??BB???@@B@A@C@E???BC?E@B?@@A??E?AECC??@?????A??B@?@@@@??????CAD?@???@?BB@C@@C??A@??BC@A?????????C@????????????BA?D?B?????BBA????????B????EB?????A@C@EEEAEAB??AE??A???B?B??CBBA??@ACE?????B@??E??@?????BB@?@C???BDB?@@@@@?@@?A??@B????AC@?@?@E???BCC@@C??BB?????A?????D??????C?@D@D??DD?B?D@CC@B?DA??BE@A??C@B?@CC@??BD@CC????ABE??A????@D@??@@@???@@@???????CAA@??B?@D?@?BA?????@???E??AB??@@A@CBBDC?A?BCB??A?DB?@DDDB?BA?BBBA???CE??????CB??A?CE??A??CC?A?@BB@CEAD@D?????B?AEBAB?@???CB??A?B???AB??E????B@@??????AD?B??BC?E@?B?@CA@@C?BCC??@@C??@?@@C@@@C?????@?@CBB??AAB@AB@@?B?@B?@D??@K??@?B???@DCA?@?@@????EAC??AB@A@?ADE?@D???BAA@??B?@@??DCD?AB@C?@CACAC@?ABA?A???????????AC@?@BKH?????????@??C@EB??BEBAB@??CABBB?@?@??@DADDBB?C??A??E@@?B@?????????@@@???C@?A??AB@?????A?ACDA?BE?AE?ECC?@C????A@B?BA??@?D??DA@AA??E?E@C@????A?B????B?@CD??CEC???A???@???@BCA?D??CB?@C@???D????E?D???A?BED??AB???E?C?B?BB@?AB@C?A??D?????EE?A??E?CB@EDE?EBBDEEE???B??BEEB?D@????JIJI?B?A????@C@D@AA@B@C@?B??C????D?@ACBB@@C@??B??@?@A?D@A??@E?BBBC??BAAA????????C???C@C??AC??????CC?E@?@?@?DB??DDB@?@D????@D?ED????D??AB??AA?@@???@?B?@A?ACA?B??@BA??DD??B?B?@?@?????B??A????C???E?B@B@CBAC?D?C@???BE?????BC??BD?BBB???@@A??E?D??DB?????C?A????AB????AE?D???@?BB?BB????C???B?E@A?C??A?C@BDBDE???@A@@?????@??@???D?KHK???????CB??BED?B@?????D???BC?@?@?D????BC?@??@????A@@??EEBB??B@?@@B???????C????A?EB?C???@BCDC@E@C????????BCC@??E???B???A?@?@@??A????B?BE?B??????????A?B??B??@C@???B?C?D?DC?B?B?B?????A???E@CCB?????B?A????@@?E?A@B??D@D??C?????@???@B?AD@C???C@B??B?BB??@@EEEEEAE?BB@????C?B@C?????C??C@???BAB@?A@?BB??B??B??@@@B????E???@?C@@AD??@@??B??DCAC?A???E???AD?DACAB?@C???E????@C@????A??GKH???????BG?B?????@??CA@?@?ARRE??C????B?????@?BD??AB??@?AR?E?A@B????D?B?B?AB??@B@@B????@@??????@?@A??@@?EEEE?B?AA?@?@D?C???B??A?A??B@@A@B?B?@@E@@B???BCB????B????????AC?@@@?E?@@?@?????B@@C???@B@?AB?@????????@????@B?BC@D?C?BDB???A??B@C??A@@BEB@@?BCA??EA????@C?@B@???B@@@???BC????A?ACB??BBB?CDA??D???????@@C@BD???C@@C@BE?DA??@??????B@@A?@????@B????C@AABB?C?BE?CD??@CE?????????B???A???B??CAB?B?@CB?ADADC@@@?@@?C@E@?B?C??A??BA?B??CAB@?A?D???@???@A??????A?BDB@?A??B@?@@@?B?????@A?B?ADE@???@??@@?A@A?D?@A?DB???@@??A?C?GGKHP@???DEEA???CC?C??B?ACA???@??D@CDBC@?A?C???KHGGB@B?@?CD?A?C@C?????BD?@B?D@??D?AB?@@B??@@D???ACABA?????E???@R?@@CA?BD?C@?EB@??B?C@??B?@@@?CA?D???D??A?BBC?A@CC@@??B?A?@????E??DC@C??EBBBC@BB@?EA@@???@@?@??C@@BA??C??@B??@B@?????????AA?@@???CBC??????@??BA?D@A?BBAC?@@CB?B@@@?A?BB?DB???@B@C???E??CA@?CD@?A????C?@D??BD??@A?A?E?????@D@D@C?A???EBBEAEB?@@EBB?CBB??C?????D?A@????B??@@DB?????@?BB?B??A???AACAB?@@CC??A?????BA?A@@E????E??E??B??CD????A???????@C??@@?A??AC??AD??BB?@?@A?B?@@???@?CB??EA?BCAD??C@A??C??????D@??A???BE@?@???BEED?A??@BB???B??A?@?E@C@??@??@CB??@??AE?EDB??@@?@C@???B@B?ACAA????EAB?D?@A??@@???@B?@?ABAC????AA?B?@?????EBC@@??A??E?D??A@EC??C@@?@CB?B??A???@??B??@@@A?B@B@D?@A?ACB@A??D?@@?@?C???D???BC@???@B???B@E???@@?AA@@?????????@?A??A@A@AA?????????@ADAADD?EB@?EB?@AA?AA@?@BA??A????B?A?B??B??@B?A?????E@@?@EE@C???????@?@@ABBC@??D????AC?C?B?A?@?@BBACEC??AB??@??A?BBCEEE?EE???@C????@BDEE??@@C????@@DBB????@?@ABB?CB@C@DC????????A???@??@?C@B?BE??@E@?A??A??????@C??CCBA?C@??@?@D??BA??A??A???BA?A?CB?????????BC??DAC@???@C??@@@ABA?BABAC@DBB???ED?B?AE?@?B?B?C?B@???@???BA??AA?@@?BBDA???@?@??????????@????@??AC@E?C?????@@??A??AB???????CAEDA??@BE@@C??B@@D@????DADC???BBA??BCA?CB??@CA?@?A???@???@??A@C@??E??A?B?E@CB?B??@@@@@?@CBAB?CCC?@???A????@?B@@C????@C?A@@BD??AA??DA?B@B????E?C@@?@B@@BB@?D@?CA@B@BB????CD?C????BBEE?BDE?EEEA????E?A?BA??A@B??A@C?AB?BB?????BB@@?D@@?C?@@B?D???A??R@CCQL?E?QAC??@C????@BBE??CCD?CBBB?@?DEEAABE???AA?????BD??AE?A????B@@?????AB??@???A??A@??A?B?DH????????C@??CAEA?C@???B@@???E?EEE@??GKH????????@E@E?C@@?AA?@?????????@@??A?C???????@B@????@@?@@B???@@E??????B@?B??D??A?@@?????@C@@????B???@D?E???C?@@BD@AEEEEBEDA?@@??BD@?B????CD@?BC@@?B@B@?@?BA?EB@A??????A?ECB?AB?ECD??AA?CBB??@@@A???EA??A@A?@??@@H?????A???@?A?EEAEE?E?@???C@??@@AAEECE??E??E?DAEEE@@@@??BBABC?@?@B@@E??@@????????CAA???A?BC@CD@??????ADBC?C@AB@A@@@CB?ADA??????A????@B@B?A??UACA?D??BB@?C@@@B?DE?A?B??B??A@??????@B@??@?@C@??A@???C@?@?C??????A@B??D?BA@C??B?CBA@C?E@DD?????BA?AA???AA???????A????????@CAC@B?@BC?A?@BBB@?A?@?B@??C?D??DE@A????C?D???????????C@@D@C@A???BC?@@?E?????B???@@DB@E???E?C???EC??@???A@DAE???B?E??AAEC?CB?BD?BA?EEB?D?CBEB???AB?A?@?EB???@BA?CC@@??A@@@@A???A??@????@@@???AE@BE?E??M?@@A?@BA?@?EC??A?BB?BBA?????A?@@@?C@??CC??@B@A@?C????B@???@CC?A??D??????C?@???@CE??AB?D?@?C@?DBD?B@?BBA@D??@EBHGGGG??BEE?BBC@??@??C?BCBA??A??BA???@BE?@BDC?DC@D@EC?AD?C????@???????CD?@?@@?CE?@D?????@C?ABDA???C???EB@C?C???@@?A?@?D?BE?@@ACDC@C?D??@C??D??@A?E?B????@????C@?EEC?D?EBB?BAD@B??????????@?A?@@CA@??A??E@?@???BA@????BH???????GG@NE???@C@@?????@@BKH????????DACB?B@@?@?@C????B?C???????BC?@??C@?BA??C@????BD?EEAEEEBC@????????@B????????EC?AAE?EEEEEEEAEEEEEE????EE?DGKN??EB@DC?DD??@E@B@AAD@ADE?AEAEEEAE@@EA??????C@?A??B?B@@??@CB@EA?B?EC@?????A???A@D?B??DEBC@@B???C@C???A@???A?B???AE??A@??C@??B?A?B????B@C@?@@C?BB@??@BBAC@?????@B@@CB??B@???C@C@?CA??D???A@???B?????@CBBADBC??B?ABCB???BB??BD?B@@?@C?BAB@?C@A?B?@?AA??A?@A?????C??B@???@??CB@?CCA?C??@AC??E?ADE?@E??@CE@AD?A?@A@?CA?EEA@EADAE@C??B????H?E?A?BB?A???@FAFBFCFDFEFFFGFHFIFJFKFLe@Bf@DWFFMFNFOFPj@Jl@LFQFRFSFTFUFVFWFXFYFZF[F\n@Op@Ik@KX]F^F_@F`@Fa@Fb@Y^`A`@bAb@XCg@EFc@Fd@Fe@}@Pq@KdA_@aAf@Fg@Fh@z@[|@No@PjALkA`@fADWc@gAe@iAI_ALr@Rs@Tu@Vw@Xy@Z{@\sAJqAEh@MyAK[Fm@NpAI[c@rAN{AJtASt@Uv@Wx@YnA\zAL\MbBN}AK\Gi@I~ATuAW`BZxANdBL|Ad@hANeBH]i@fBJZf@lAh@aBNkBHcBO~@JoBPgBU_BXwA[oAOpBKqBIlBg@mAZiBOuBLvBJ]e@jBInBIzBN}BO~BPrBVvAYmBOyBKbCL{BJ|BJ_CIwBh@aCPfCZxBP`CWhB[tBPeCJcCKjCXsB\dCKoCLhC[kCIpC\lCKrCNnCYgCIZa@tCOuCZiCIsCLwCPyCImCLxC[qCJvCb@{C\|CNzCJ}CO_DP`DIaDJbDKcDL~CKdDLYj@Fk@Fl@Fm@Fn@Fo@Fp@Fq@Fr@Tk@eDm@^o@gDq@Ts@Ft@Fu@Fv@Fw@Fx@Fy@Fz@F{@F|@F}@F~@F_AF`AFaAkDt@mDv@oDx@qDz@sD|@uD~@wD`AyDNzDu@nDw@pDy@rD{@tD}@vD_AxDaAbEv@|Dy@eE|@_E_AgENhEw@dEz@~D}@_@bAkEOTcAFdAlDu@cEx@}D{@fE~@`EaAiDl@fDn@FeAFfAFgAFhAFiAFjAFkAVlATmAFnAFoAvEm@^eAFpAxEhA}En@wEpA_FiAa@eA~EgAyEiAc@pA`FgAaFhAVkAzEiAbFiAcFiAa@o@jDr@dFp@hDr@eFq@fFr@{EnA|ENc@fAhFgAiFhAjFiAgFoAlEx@sE|@`@`AaEOqEdArEv@iEz@nE~@uENlFy@jE}@_@`AmFPqFz@oF_ApEPsF{@tE_AtFIuF|@`@bAwFJxF}@oE`ArFInFt@{Dw@mE{@vF`A{FJkFNzF~@pFO}F_AyFK|FOVqAFrAFsA~FP?tA</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??`E?GE@E??G??pc?WA@H??I??P??[??H??I??@C?CB?J??K??`D?G^?L??M??`d?Ge@N??O??pU@kk?P??Q??`B?KL?R??Q??@?????S??A??A?????J??K??`@?w]?T??U??@@?GS?V??U??PA?cH?N??O??pB?gy?W??C??pS?WC?X??Y??@U?wL?Z??[??PJ?sC?Z??\??@A@sK?Z??]??PD??H?^??_??pW??C?^??`??`P?{C?^??a??@B?oF?^??b??`??CG?E??c??PN?sS@J??d??`??gf?J??e??pE?CU?E??F??@V??F@f??C??@A????^??g??`??oF?h??i??`??CB?Z??i??@??SM?j??A??A?????H??I??@A?{A?J??I??P??Ci?J??k??`@?C]?Z??i??@W?GN?j??l??pC?c@?j??m??pA?cA?J??k??`D?S]?n??C??@A????j??o??P@?kA?p??q??@A?WA?p??r??`E??A?s??t??P@?oS?u??v??@a?cG?w??x??pB?SG?w??y??@??{C?z??A??A?????j??o??@H??B?{??|??@B?gL?}??~??pB?wS?}???@?pE?cK?@@?~??PC?oo?@@?A@?PM?GW?@@?B@?pE?gY?@@?C@?pA?KO?@@?D@?@B??P?E@?D@?@G?KB?F@?G@?PY?SD?H@?I@?`A?WE?H@?J@?`E?OM?H@?K@?PB?CK?H@?L@?`B?_K?M@?K@?PC?cP?j??o??`L?CB?h??i??PD?KB?u??v??@I?cF?N@?O@?`^?OI?P@?Q@?@??GS?R@?Q@?P@?OQ?S@?A??A?????T@?C??@??[L?R@?U@?@A?{N?R@?U@?`N?sO?j??o??@A?kA?V@?W@?PC?_H?X@?W@?PA?s_?N@?O@?`I?KG?R@?U@?`L?cO?w??Y@?P??sG?w??Z@?@??gD?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, LOCK</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1669194622445;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","java.lang.Thread","run","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","getTask","ok.dht.test.yasevich.utils.AlmostLifoQueue","take","java.util.concurrent.LinkedBlockingDeque","takeLast","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquire","java.util.concurrent.locks.LockSupport","park","jdk.internal.misc.Unsafe","java.util.concurrent.locks.ReentrantLock$NonfairSync","java.util.concurrent.locks.ReentrantLock","lock","java.util.concurrent.locks.ReentrantLock$Sync","one.nio.server.SelectorThread","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","handleParsedRequest","ok.dht.test.yasevich.service.CustomHttpServer","handleRequest","handleChunked","sendResponseAsync","submitOrSendUnavailable","execute","offer","offerLast","ok.dht.test.yasevich.service.CustomHttpServer$$Lambda$216.0x0000000800dc7348","lambda$sendResponseAsync$4","ok.dht.test.yasevich.service.ServiceImpl","sendResponse","ok.dht.test.yasevich.service.CustomHttpSession","takeFirst","writeResponse","writeAsync","ok.dht.test.yasevich.service.CustomHttpSession$$Lambda$225.0x0000000800dcc228","lambda$writeAsync$0","ok.dht.test.yasevich.chunking.ChunkedResponse","getChunks","init","java.nio.ByteBuffer","allocateDirect","java.nio.DirectByteBuffer","<init>","jdk.internal.ref.Cleaner","create","add","java.lang.Class","org.apache.commons.logging.impl.Log4JLogger","error","org.apache.log4j.Category","log","differentiatedLog","ch.qos.logback.classic.Logger","filterAndLog_0_Or3Plus","buildLoggingEventAndAppend","callAppenders","appendLoopOnAppenders","ch.qos.logback.core.spi.AppenderAttachableImpl","ch.qos.logback.core.UnsynchronizedAppenderBase","doAppend","ch.qos.logback.core.OutputStreamAppender","append","subAppend","writeOut","writeBytes","ch.qos.logback.core.FileAppender","java.nio.Bits","reserveMemory","java.lang.ref.Reference$1","waitForReferenceProcessing","java.lang.ref.Reference","java.lang.Object","java.lang.ref.Reference$ReferenceHandler","processPendingReferences","one.nio.net.JavaSocket","write","sun.nio.ch.SocketChannelImpl","clean","remove",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
