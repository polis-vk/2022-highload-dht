## Наблюдения
* В случае с методом PUT на новой реализации с очередью RPS выросла на 5.6%.
* В случае с методом PUT на новой реализации со стеком RPS не выросла значительно.
* В случае с методом GET все новые реализации показали результат строго хуже. У всех RPS упал примерно на 6%.
* В случае с очередью и стеком на CPU Flame Graph-ах видно, что 20-25% времени уходит на синхронизацию.
* В случае с очередью и стеком на Lock Flame Graph-ах видно, что 70-90% локов уходит на Thread Pool.
* По аллокациям значительно ничего не поменялось.
* У очереди Майкла Скотта очень много времени уходит на взятие элемента из головы очереди. От 20% до 33%.
* В случае использования очереди Майкла Скотта процент взятых блокировок в Thread Pool-е сократился до 30%.
* В случае использования MultiQueue RPS на PUT вырос на 9.4%. На GET RPS незначительно уменьшился.
* В случае использования MultiQueue 6% времени тратится на синхронизацию в Thread Pool-е и в нем берется 15% локов.

## Выводы
* Многие проблемы у реализаций с очередью и стеком, такие как незначительный рост RPS в случае PUT или вообще уменьшение RPS в случае GET, 
скорее всего связаны с затратами на синхронизацию. Данную проблему возможно удасться решить при помощи неблокирующей очереди.
* Неблокирующая очередь Майкла Скотта оказалась не лучше старой реализации. У этого возможны две причины.
Первая это то, что наша очередь неограничена и те запросы, что появились там давно успели устареть.
Вторая причина в том, что в очереди Майкла Скотта операцию "взять элемент" довольно медленна из-за
конкуренции потоков за голову очереди.
* MultiQueue показала результат немного лучше обычной блокирующей очереди. 
Стоит протестировать ее на большем числе потоков с большим количество очередей внутри.