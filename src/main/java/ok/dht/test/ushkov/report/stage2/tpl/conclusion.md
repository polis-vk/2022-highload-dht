## Наблюдения
* В случае с методом PUT на новой реализации с очередью RPS выросла на 5.6%.
* В случае с методом PUT на новой реализации со стеком RPS значительно выросла.
* В случае с методом GET все новые реализации показали результат строго хуже. Все примерно на 6%.
* На CPU Flame Graph-ах видно, что 20-25% времени уходит на синхронизацию.
* На Lock Flame Graph-ах видно, что 70-90% локов уходит на Thread Pool.
* По аллокациям значительно ничего не поменялось.

## Выводы
* Многие проблемы, такие как незначительный рост RPS в случае PUT или вообще уменьшение RPS в случае GET, 
скорее всего связаны с затратами на синхронизацию. Данную проблему возможно удасться решить при помощи неблокирующей очереди
(ее реализацию вы уже можете в [исходниках](../queue/MSQueue.java), мне осталось подогнать под нужный интерфейс и протестировать).
* Вообще говоря, можно залезть в недры one.nio и возможно убрать лишние аллокации на конвертации byte[] -> String и String -> []byte.
