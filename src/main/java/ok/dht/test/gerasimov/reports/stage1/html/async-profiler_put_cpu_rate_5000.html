<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BHlWAHh@sFzIuOfS~Tw|AH?H@AH@H@?O@G@@G@OHGP?GOHPHA@@IPPQAHOAIIIHP@HGQHI@HH?@T\X??HPI@HHIHGIH@@HPIH@O@A@GI@?H@HO@@A?H@PGPPGAHi^NMHH?AP@PAOHHIIQGHH?PA@H@HHG?IH@AOHGIG@AHHHHHHPHOGJHPGIIP@AIPHHHHH@@H?HGL[P@?@@HPGOHH?QGHGHHHPHGH@@@?GGH@H??P?AHH@G@@P@@@?A@@I?@H@I?@QAHAGGHPS[PI@@H@IH?G@APGPGG@GIHH?IPHP@HIG??HA@??OGI@?GG??GA@HH?OP@@@P@?IGHGIGGPHAHAPHHGGPHIGHGPHHHOPA@HHI?OPG?HAPOP@GIGGHHHHPPQIIHPOGH@HPHHP?@?@@L\XHG?@IGGGHH@PGGHG?@GGHPGPPQGG@POA@@HH@GO??A@??IHGHHHHAHI@AIQH?H@?Q@?P@G@Q@PGGIGHGOH@PI?@@?I?HjaGI?IPIGG@PAHGPH?I@HHAGH??HHH@PHGH?HH@P@OHG@IG?AHH?@AI@AQGPOG@GCTYa`p`HQ@QI?HHHPHHH?@IO@GHHGGAHIH@A@@HHQPHGHHPI@GOHGH@GOHIHGGIHPGHIQGHLXA?GH@?HOH@?HHG@@IIOHHIGGQHG@GOOH@?@IHIGH@PIQOHH?OPG?QGH@I?GH@QH@@HPHH?G@IGIHAIPAPGGAbQG@IHHPGP@IG@GPAGI@OA@?@HA?HHAG@II@@HPIOQGHHPGI?H@@PGOAHH?HPIHGGGAHGH@IHIHOO?HH@@HQHTXAGQHHHOHQHHH?HH@?H@PH@H@GP@@HPHO@@@HPGHG@HI?@@HG@GH?PH@OGPQO@@HA@@?@APHI?GI?@I@PPG@H?I?@?IH?HQP??PI@OHQ@G@QHQOGGHQGPI@GQHQAIGHHG@?@I@PHH@O?PP@HGGQ@G@G?HHH@QPHAGHGAHHHHHIHHHQIQGAHH@G@HPAGHHOOP@HQHGI?D[VR??@@PPG@@?PHGGHIHIIH?HHH?IO@GOPPAHH@@@@H@P?@?I@QGO?AGG?H@GGIHHII?GGHG?IHP?HGGGP@A@OH??HH@IIQHOI@HHHAP@P@HIH?O?HGP?HGQHPGH@P@@GH?I@GHHIH?GCTZja@H@HHIIGH@@AAOHHH@IP?@@PI?Q?I?O?G@@HPQIHGHHPGOH?@HI@I@P@IHIHQ@HA@@GA?@POPAHIH@HHH@O@??H@PAHaxP@HGH?@??I?GHA@GHPAPPOIG@IHHA?PAHHIHGG@AAHH@HH@IHHP@IGGH@O@@@GHHP?@QAGGAAOOOHGOSSSSNNJxX@@OA?HHH@PH?@H?AGQ@@PHHOI@HIOPHIGHGGGO?I@HOHPPHAPGOQHHIHHQA@Q@IHHHQ@@HIIOI?I@HACT]HG?@I@GPGH@QAGHP@PGHHHHHPH@A@OIHI@@GHP@?AHH?GA@GHIAA@?QIP@HAH??IH@OG@HOG?POG@Q?PPGHI?@GG@@@G@GPH?IH?GPAOPAP?GHIIIIPGQ?GHHI@HHPaj?@lkAlkAa|AztA{yAgwAm`Be|A~`BytAmbBxxAtkBpmBhgBqvAyyAzyAcqAu|Ao|At|AqlAh}A{`BbxB~qA_xAd`BiuA|mBflA}rAeuA|zAu{Ai}A_iBpmAjpA}qAnsAwvAdyAc`Be`BxbB{bBynBnlA|mAxnAxqA{qA`sA~wAh|AcaBigBrhBwiB}mBooBqxBc}B~dC|fCblAglAomA|oAipAmrAjsAdtA}tAfuAuvAvvAxwAnzAs|A~cB_dB`dBzdB`fB{gB}hBhjByjB~jBlkBfmBdnBxnBznBlpBzpBtrBxtBxxBkyBdzBl{B}kAalAelAllAqmAinAjnAynA~oA_pAapAwpAhqAcrAetAhtApuAtuAwuAzuAdvAnvA|vAawAcwAyxAkyAlzA}zAm{A|{An|Ag}Aq}Aw}A_~Aa~Af~A`_Bq_By_Bh`By`BtaBecBjcBddBfdBodB}dBseBxeByeB{eBuiB`jBzjB}jBbkBskBmlB_mBamBdmBhmBjmBymB|nBqrBrsBtsBzsBptB~tBk}Br}BvbCccCcdCweC}eCpgCarCzkA|kAclAolAxlAqnAznAdoAeoAzoAgpAhpArpA{pAfqAjqAyqAzqA|qAlrAorAqrAbtAjuAruAgvAhvAywA{wA|wAdxAnyAsyAvzAr{Az{A~{Ad|Am|Au}Az}A~}Al~Ao~Ag_Bk_Bm_B{_Bl`Bn`BhaBpaBuaByaBubBhcBlcBmcBocBrcBzcB{cBbdBedBudBmeBueB|eBnfBwfBbgBggBlgBqgBjhBshB~hBiiB{iB|iBbjBdjBujBckBikBkkB_nBknBlnBaoBloBpoB}oBepBkpBiqBoqBvqBlrBrrBzrB|rB`sBmsBctBgtBrtBduBkuBcvBjwBexBgxBjxBkxBfzB~zBj{Br{B~{Bk|Bg}B~}B~~Ba_Cf_Ch_Cq_CmaClbCnbCacCncCbdC}dCagCsgCxhCriC}jCinC}oCrsCxkA_lA`lAjlA~lAkmAxmAymAzmAwnAioAnoAtoAmpAqpAspAbqAdqAeqAgqAlqAmqAvqA_rAkrAsrAwrA_sAdsAmsApsArsAvsAysA|sA~sActAftAvtA{tA_uAduAevAmvAxvAzvA~vAbwAzwA`xAbxAhyAvyAxyA~yAezAmzApzAszAtzAwzAxzAzzAb{Ad{Ag{Ai{Ao{A}{A_|A`|Ac|Ax|A||Af}Al}Am}Av}A{}Ak~An~Au~A|~Ad_Bh_Bj_Bn_Bp_Bv_Bw_Bx_B_`Bf`Bj`Bp`Bt`Bx`Bz`BfaBkaBvaBwaBlbBwbB_cBbcBgcBwcBadBkdBvdBceBreBzeB~eB_fBlfB|fB_gBcgBmgBpgBrgBzgB|gBihBlhBthBxhB`iBbiBhiBjiBviBziBcjBwjB|jBjkBokB}kB~kB`lBdlBelBglBolBqlBvlBwlBkmBnmBrmBtmBzmB~mBanBcnBhnBinBsnB}nBcoBjoBmoBuoBvoB~oBjpBspBtpBxpBkqBnqBrqBzqB~qB_rBdrBjrBvrBwrB_sBbsBdsBlsBosBqsBvsB}sBdtBytBquBruBuuB|uB~uBfvBovBxvB}vBpwBuwB~wBcxBrxBqyB~yBezB_{Bf{Bg{Bn{Bf|Bj|Bl|Bm|Bs|Bt|Be}Bj}Bq}Bu}Bw}Bx}Be~Bq~Br~Bt~B{~Be_Ck_Cw_Cc`Ct`Cz`C|`CcaCqaC~aCgbCsbCtbC_cCfcCycCzcC~cCadC_eCkeCafCdfCgfCifCsfC_gClgCvgCiiCyiCejCrjCvjCwjC~jC_kCtkC}kCllColCvmCanCsnC_oCpoCnpCjqCcrCmsCmkAokApkAtkAvkAykA{kA~kAdlAklAmlAplAslAulAvlAzlA{lA|lA}lA_mAamAbmAdmAfmAgmAhmAimAjmAlmAmmAnmAtmAumAvmAwmA{mA~mA_nA`nAanAbnAcnAdnAenAfnAgnAhnAmnAnnAonApnArnAtnAunAvnA{nA}nA~nA_oA`oAaoAboAcoAgoAhoAjoAkoApoAroAsoAvoAyoA{oA}oAcpAepAfpAkpAlpAopAvpAypAzpA}pA~pA`qAaqAnqApqAqqAsqAtqAuqAwqAarAbrAdrAerAfrAhrAirAjrAprArrAurAvrAyrAzrA{rA|rAasAcsAfsAgsAhsAisAksAssAusAwsA{sA`tAatAgtAjtAltAmtAotAptAqtArtAstAttAutAwtAauAbuAguAhuAmuAnuAouAvuA|uA~uA_vAavAbvAcvAfvAjvAlvAovAsvA{vA}vA`wAdwAfwAiwAkwAlwAmwAnwAswAuwAvwAwwAexAgxAhxAixAjxAkxAlxAmxAnxAoxApxAqxAsxAtxAuxAvxAwxA{xA|xA}xA~xA_yAayAbyAcyAfyAgyAjyAlyAoyAqyAtyA|yA`zAazAbzAczAgzAkzArzAuzA{zA_{Aa{Ac{Ae{Ak{Al{An{Aq{As{Av{Aw{Ax{Ay{Ab|Af|Ai|Ak|Al|Ap|Az|A{|A~|A_}Ac}Ad}Ae}Aj}Ao}Ar}As}Ay}A|}A}}Ac~Ae~Ag~Ah~Ai~Am~Ap~Ar~As~At~Av~Aw~Ax~Ay~Az~A~~Aa_Bc_Be_Bf_Bl_Br_Bs_Bt_Bu_Bz_B|_Bg`Bi`Br`Bs`Bv`B|`B_aBaaBbaBdaBeaBlaBnaBoaBraBsaB}aB_bB`bBabBbbBcbBdbBebBfbBgbBhbBibBjbBnbBpbBqbBsbBtbBybBzbB|bB~bB`cBacBkcBpcBqcBtcBxcB|cB}cBcdBgdBhdBidBmdBpdBqdBtdBwdBxdBydB{dB|dB_eB`eBaeBeeBheBjeBleBneBpeBveB}eBbfBdfBefBffBgfBifBkfBofBqfBtfBufBxfBzfB{fB}fB~fB`gBdgBegBfgBjgBsgBugBvgBxgBygB}gB`hBbhBdhBehBfhBghBhhBnhBphBuhBvhBwhByhBdiBeiBkiBmiBpiBsiBxiByiB}iB~iB_jBajBfjBijBkjBojBpjBqjBrjBtjBvjBxjB_kB`kBfkBgkBmkBnkBqkBukBxkBykBzkB{kBalBilBklBplBrlBtlBulBxlBzlB}lBbmBcmBemBlmBmmBomBqmBvmBxmB`nBenBgnBjnBonBqnBrnBtnBvnB{nB~nBboBeoBfoBgoBhoBioBkoBroBxoBzoB{oB|oBapBbpBcpBdpBipBmpBopBppBqpBrpBvpB{pB}pB~pB_qB`qBaqBcqBdqBeqBfqBjqBmqBpqBsqBuqBxqByqB|qBarBbrBcrBgrBkrBmrBprBurBxrByrB{rB~rBcsBesBhsBisBpsBssBusBxsB`tBltBmtBntButBvtBztB{tB|tB_uBauBcuBeuBguBjuBmuBouBsuBtuBwuByuBzuB{uB_vBavBbvBevBhvBjvBlvBmvBpvBrvBsvBuvBwvByvBzvB{vB|vB~vB_wB`wBbwBewBfwBiwBlwBmwBowBswBtwBxwBywB{wB_xBixBmxBsxBwxByxB{xBmyBoyBpyBryBtyBuyBwyB{yB}yB_zBazBhzBizBjzBkzBlzBmzBszBtzBzzBa{Bc{Bd{Be{Bo{Bp{Bs{B|{B`|Bb|Bd|Be|Bg|Bh|Bn|Bq|Br|Bx|By|B}|B~|B`}Bd}Bi}Bl}Bm}Bp}Bs}By}B|}B_~B`~Ba~Bd~Bf~Bg~Bn~Bu~Bx~Bz~Bc_Cg_Cj_Ct_Cu_Cv_Cx_Cz_Cd`Cf`Ch`Cj`Ck`Cm`Cn`Cu`Cv`Cx`C}`C_aC`aCbaCfaChaCiaCjaClaCnaCpaCsaCtaCuaCvaCxaC{aChbCibCjbCkbCobCxbCybC{bC~bC`cCbcCdcCgcChcCicCkcClcCpcCrcCtcCwcC{cCddCedCfdCgdCidCmdCndCpdCvdCwdCxdCaeCceCdeCfeCjeCneCqeCseC~eC_fCbfCefClfCqfC}fCbgCdgCegCfgChgCjgCngCogC_hCahCfhChhClhCohCshCthC{hCdiCeiCfiCkiC|iC~iC_jC`jCcjCgjCijCjjCkjCojCujCxjCyjCbkCgkCikCmkCqkCrkC{kC~kC`lCflChlCjlCklCplCqlCslC`mCcmCfmCgmChmCkmC|mCbnCenClnCqnCunC|nC~nCeoCfoCmoCyoCcpCgpChpCipCopCqpCrpC}pCdqCiqClqCnqCoqCpqCtqCwqC{qC|qC}qC~qCgrCirCyrC{rC|rC}rC`sCgsChsCksCpsCqsCssCctCetCitCotCrtC}tC_uCvuCzuC}uC{vCnkAqkArkAskAukAwkAhlAilArlAtlAwlAylA`mAcmAemArmAsmA}mAknAlnAsnA|nAfoAloAmoAooAqoAuoAwoAxoA`pAbpAdpAnpAppAtpAupAxpA|pA_qAiqAkqAoqArqA`rAgrAnrAtrAxrA~rAbsAesAlsAosAqsAtsAxsAzsA}sA_tAitAktAntAxtA|tA~tA`uAcuAkuAluAquAsuAuuAxuAyuA{uA}uA`vAivAkvApvArvAtvAyvA_wAewAhwAjwAowApwAqwArwAtwA}wAaxAcxAfxArxAzxA`yAeyAiyAmyApyAryAuyAwyA}yA_zAdzAfzAhzAizAjzAozAqzAyzA~zA`{Af{Ah{Aj{Ap{At{A{{Ag|Aj|Aq|Ar|Av|Aw|Ay|A}|A`}Aa}Ab}Ak}An}Ap}At}Ax}A`~Ab~Ad~Aj~Aq~A{~A}~A__Bb_Bi_Bo_B}_B~_B``Ba`Bb`Bk`Bo`Bq`Bu`Bw`B}`B`aBgaBiaBjaBmaBqaBxaBzaB{aB|aB~aBkbBobBrbBvbB}bBccBdcBfcBicBncBscBucBvcBycBjdBldBndBrdBsdB~dBbeBdeBfeBgeBieBkeBoeBqeBteBweBafBcfBhfBjfBmfBpfBrfBsfBvfByfBagBkgBngBogBtgBwgB~gB_hBahBchBkhBmhBohBqhBzhB{hB|hBaiBciBfiBgiBliBniBoiBqiBriBtiBejBgjBjjBljBmjBnjBsjB{jBakBdkBekBhkBpkBrkBvkBwkB|kB_lBblBclBflBhlBjlBllBnlBslBylB{lB|lB~lB`mBgmBimBsmBumBwmB{mBbnBfnBmnBnnBpnBunBwnB_oB`oBdoBnoBqoBsoBtoBwoByoB_pB`pBfpBgpBhpBnpBupBwpBypB|pBbqBgqBhqBlqBqqBtqBwqB{qB}qB`rBerBfrBhrBirBnrBorBsrB}rBasBfsBgsBjsBksBnsBwsBysB{sB|sB~sB_tBatBbtBetBftBhtBitBjtBktBotBqtBstBttBwtB}tB`uBbuBfuBhuBiuBluBnuBpuBvuBxuB}uB`vBdvBgvBivBkvBnvBqvBtvBvvBawBcwBdwBgwBhwBkwBnwBqwBrwBvwBwwBzwB|wB}wB`xBaxBdxBfxBhxBlxBnxBoxBpxBtxBuxBvxBzxB|xB}xB~xB_yB`yBayBbyBcyBdyBeyBfyBgyBhyBiyBjyBlyBnyBsyBvyBxyByyBzyB|yB`zBbzBczBgzBnzBozBpzBqzBrzBuzBvzBwzBxzByzB{zB|zB}zB`{Bb{Bh{Bi{Bk{Bm{Bq{Bt{Bu{Bv{Bw{Bx{By{Bz{B{{B}{B_|Ba|Bc|Bi|Bo|Bp|Bu|Bv|Bw|Bz|B{|B||B_}Ba}Bb}Bf}Bh}Bn}Bo}Bt}Bv}Bz}B{}B}}Bb~Bc~Bh~Bi~Bj~Bk~Bl~Bm~Bo~Bp~Bs~Bv~Bw~By~B|~B}~B__C`_Cb_Cd_Ci_Cl_Cm_Cn_Co_Cp_Cr_Cs_Cy_C{_C|_C}_C~_C_`C``Ca`Cb`Ce`Cg`Ci`Cl`Co`Cp`Cq`Cr`Cs`Cw`Cy`C{`C~`CaaCdaCeaCgaCkaCoaCraCwaCyaCzaC|aC}aC_bC`bCabCbbCcbCdbCebCfbCmbCpbCqbCrbCubCwbCzbC|bC}bCecCjcCmcCocCqcCscCucCvcCxcC|cC}cC_dC`dChdCjdCkdCldCodCqdCrdCsdCtdCudCydCzdC{dC|dC`eCbeCeeCgeCheCieCleCmeCoeCpeCreCteCueCveCxeCyeCzeC{eC|eC`fCcfCffChfCjfCkfCmfCnfCofCpfCrfCtfCufCvfCwfCxfCyfCzfC{fC~fC`gCcgCggCigCkgCmgCqgCrgCtgCugCwgCxgCygCzgC{gC|gC}gC~gC`hCbhCchCdhCehCghCihCjhCkhCmhCnhCphCqhCrhCuhCvhCwhCyhCzhC|hC}hC~hC_iC`iCaiCbiCciCgiChiCjiCliCmiCniCoiCpiCqiCsiCtiCuiCviCwiCxiCziC{iC}iCajCbjCdjCfjChjCljCmjCnjCpjCqjCsjCtjCzjC{jC|jC`kCakCckCdkCekCfkChkCjkCkkClkCnkCokCpkCskCukCvkCwkCxkCykCzkC|kC_lCalCblCclCdlCelCglCilCmlCnlCrlCtlCulCvlCwlCxlCylCzlC{lC|lC}lC~lC_mCamCbmCdmCemCimCjmClmCmmCnmComCpmCqmCrmCsmCtmCumCwmCxmCymCzmC{mC}mC~mC_nC`nCcnCdnCfnCgnChnCjnCknCmnCnnConCpnCrnCtnCvnCwnCxnCynCznC{nC}nC`oCaoCboCcoCdoCgoChoCioCjoCkoCloCnoCooCqoCroCsoCtoCuoCvoCwoCxoCzoC{oC|oC~oC_pC`pCapCbpCdpCepCfpCjpCkpClpCmpCppCspCtpCupCvpCwpCxpCypCzpC{pC|pC~pC_qC`qCaqCbqCcqCeqCfqCgqChqCkqCmqCqqCrqCsqCuqCvqCxqCyqCzqC_rC`rCbrCdrCerCfrChrCjrCkrClrCmrCnrCorCprCqrCrrCsrCtrCurCvrCwrCxrCzrC~rC_sCasCbsCcsCdsCesCfsCisCjsClsCnsCosCtsCusCvsCwsCxsCysCzsC{sC|sC}sC~sC_tC`tCatCbtCdtCftCgtChtCjtCktCltCmtCntCptCqtCstCttCutCvtCwtCxtCytCztC{tC|tC~tC`uCauCbuCcuCduCeuCfuCguChuCiuCjuCkuCluCmuCnuCouCpuCquCruCsuCtuCuuCwuCxuCyuC{uC|uC~uC_vC`vCavCbvCcvCdvCevCfvCgvChvCivCjvCkvClvCmvCnvCovCpvCqvCrvCsvCtvCuvCvvCwvCxvCyvCzvC|vC}vC~vC_wC`wCawCbwCcwCdwCewCfwCgwChwCiwCjwCkwClwCmwCnwCowCpwCqwCrwCswCtwCuwCvwCwwCxwCi}A?????mI?????????????????fE??uS?????aElBd@?lB????yI???_E?aEmI?PbT?e@A????A??AzD??pU??AAiJ_EAyIqT????aE???lA_@??AA???lBA??aAC??III??aC?I?aCzEI?BBBBOByEyEaCyEzE??iJbACeA?[A??_ElBuB??CoB????]?CuB???~B??XlAA??AG?S?uB?AE?hK?@fTd@A@?A@@AC?@@?A???E???A?_@Cd@?[BBBBBBBBBBB???mC?fF??hF|K??cL]aLbLZcLk@j@_J????D???G?@D?`EcE?AC??[@?@D????ACD@D@_@D?D?@oT?ADDEzD??AD?C??G??gA?DV@?C???iF???X?C~Z@?F@@[rA??hJ????vB?nF??DD}B@E@SDC@lC@?V?C?D?~E?@ACD@?A?D??ID????BBBBBBNBBBBNBaCzEIBI??B?A~EAjA?u@AX??yFCEqA??@?AyLcFI?DCH@A?CA?lAVArF?@pL??@?CwCF?uCA@A]A?A??@@Al]?pBpZcM?I?CEoM???HG??@??kL?@??@HF?|]G??AS@?zCABBBBB?BBBBBB?BBBBBBBsJ@?@qAe@@A@?????@CJ?f@F?JEmAArC|CC?AtCA???A@zC@@?@?D?@AuB?gC???b@??CAV?A?p[???CA???xLARS?yChJ?CICc@D?rA?xA@?A@I??Q?ACC??Em@D?GA????mA?A@A@u@oCwAD??JC??H?qG????mL@D?_@?_@CAHlCCX????AeN@???jND?C?bA??DDqG??rACDA?@??SDDVC?ExC~A?A@qGA???DAoKDoChD?@??A?A@mAC?@@?jNQ?j\@@?D@D@VhUhE@?BBBBBBBBBBBBBBNBBBBBBBBBBBU?C?A@@Au[ACmA?e@K_@?uF??rCgB@C[@AC???@?EAEA}XuA?c@@A?AAgAA??h@@@C??uMvG\?E?@C?CI??C?pG@??EFdCA?pGdGvEICJzL@A??GA?xK?@@~CJ`B?@@@?A@An@?SCw@@A?zC?@oM@@cb@?CA??~E?o@ACt@eHAA?iF?@yLHgAC???BBBBBBBBBub@B?BBBBBBBBA@??@ACCaDC_DFDC@?@??@b@?tC@??A?iY?{@AwI?AF_F?AjDHoN?CwN@|GCCA@h@?@\sE??@?AAhExAkI?ArN?C_c@sE@?|@?|@lE@_F??A?dS?AWnF@FAa@n_@AA???b@C?~BnABBBBBBBBBBBBBBBBBBBBBfFnC_L???nC?`LcB??dBZk@k@ZZk@?jFfb@jF?A@[@|B?C?????}B?D@vE@u@gNGFD?DhNF?~G?CbB?A?@?A@A\K?pGA?_BuA??lAA?v@_MHD?DeAdHpb@GDA?ChE?@nNf_@w`@@A@D{_@}@??vC?Knc@A@A?mED?j`@?`@K@DeHAc@??rHxM?DAAPS~M?DC?@??D@?FvE@BBBBBBBBBBBOB???@@AA?`B?@CAmL?@?AzAA@A?@ErA@@@tC}a@APXC?ECmD?I@@nAAe@d_@@?@@Q?A?C@@lCfHC?@AqD|CbKC@eC@?A?KC}@?@iFDC~@mH@eA???fE?????V{O@AFhHC@CdCA?oN?I??DDA@A@DGS@?KDI`@??`B?oG@DgA?A@GxO??rCAA?F}CDBOBOnGBBBBBBNBoY@aD?Az@yFk_@?nI?DmG?D@GK?fGEJmA??n@|d@sc@?fB@zN@qDw@kDE?CJy`@?FaOaJC?_Bh@?C?D?C??KA?bD?AnH@gAKsEca@~AC@@@?@FA?na@xC~d@@??A@HAAuG|@i^eHrDCCGdD?@JfG@CXbDvOw@oA?_BD?HAEkCCia@??A\AuCoD?A}A|@gKA?rD@AC`MD@tAlAyHC?cc@~@?@@Q?@CNBBBBBnOBBBBBB@yFPK?hd@??D?A@IRjA@?qD@C@A??AuACCt[@oA~@@ya@r@_Nrf@@nDjDEA?@?AAA?AG@J?EAAA?D?@K?CoA??d@FAW?C?I?Cd@?]CC?xJ{MA~@E?Cnb@K?C`B??C??gE?}AC?Ade@A?ECE?@FA??@?}AX@??pCAc@AAECrP@??DC???bH@?xA`I??kP?CiP@??AAn@@@|A?rL@_M@@CCFkPyACKD??DSAADA?AzG???CDaHuYE@CGD@?AqMJxC@zGE[Y?D?D?@@@eFC@?@DD@xIga@CbUC@jf@eDD?@?G?{O}@fH?Aag@@rB|CD?@@qH@?@w@?HA?_H@?CDbQ?zHCCC?D@}@@?oF`ICuNeFE??~AACY?Qn@xAne@DD_BiOgG@H_H@w@]D@?l@ACDJ??JC????D@A?@?vKDJAJ@AC?bBeCAH?D@?hH?sh@{AjOsG`P~CC?ApP@?BBBBOOBBBBBBBNBBBBBBBBONnGNBBBN?BBB????C@?A?eD?@tD?oGAwG?G@??@zP@H?@aIC??AHC??_b@|@CbH?mHc@ee@A?Cq`@A??SAtKCH@@u@wDjC?bg@{g@?@@AAA??A@pP?DC?gCWQkD??@A?D@~@@@uC@?@?@AaDCeAoE@nHA??AUAlLaPqO@@CDA?i_@??U@?@uG~@vNA?tDAcF?tg@?eM?tA?AAjAiBK?bGmM@?jQC??_P@A?`PDeA@?C?tCHA?vG@@wH??qDCfHDC??Cc@C?Q@@eOA~O??AA?@??qH@AC_IeIA??[pg@iAA?@?QpQC|B@ai@@?BBBBBBBBBBBBBBBBBBBBaGBBLBx@LBBLLx@LBBBLLLBx@x@LLCzf@??@J@?@`@CCQI?ACvDhf@C@@A??CmQAqOea@?CD@Jq\@Az@A?|BApQA?@@?CwHvK@C@?EyA@@P?HGCGA@A?}i@JnNK@W?A?pCE?vi@@sa@u@A?aj@pa@A@AAAgi@qQ@yP@??WAC@W?@CAA`M@~PCpA@@?W@??@l@`@CA?C?wh@rD_BE?@@qe@?wA@o[~P?Wh@@@@fLdN??@C@ue@_Iyb@Aqd@BB~JBnG?BBx@BLBL?yh@eC@A?ah@?_]KAJK_i@b@@lg@jH?J@A?F??gDA@KK\FCC?mJ}LF@rM@?CGCA@?[?S@C@H@AC?xC{AzGCyi@?E@gN]C??AAVbO?m@???~AC?JvDA@?C?{A?@qf@b@FC@?AiD@?@Azh@oOvCAnDzH?Id@C@}AuNCA?h@HCnFeK~QE?@nj@Aw@HyAwA?rCBBBBBB?NBLBBB?mCmCcBoCgFcB~K@gFcB?u@cBhFfF@?hFk@dBdBdBZk@dBI?Zj@j@j@ZaOmE?ZZ_R?jF?H|AoOW?Ahj@vNDb@uKFDA_D@?kf@fEsP??DpHC?D?sQaDF@EtDyQkD?D@DjCkg@@@]?@ACC??D@?CwQ?nD@CD?WaI?D@AlRGIvg@tA??rMmEpd@D?|@?_F?bi@Coh@DtD?`@hA?@?K?DjQjDhk@DlNCwN?FpD?@?C?|GvPD{b@]@Ac@C?xMD@jAb@@ACV\AD?A_Nb@yQ@{FD???FuQki@C\@??ab@BBBBBBNBOBx@LBLLLNBBaGBBBBLLxd@vD`ED?CAwd@A?C@sj@e@oA?yA@}@AE?@_@AAzHrj@}@|f@bD@?{PAAn@mGC}`@jh@bDr`@bOSVACC@@_@???CA@@@CrAA@?@A}Q?c@?ve@@C?@CHbHn@CpLE?CCbc@@A_IgKoP?@rH?aIvDC?AAp_@VAH??CqAClj@?A?CA}DCJ?AA`g@ig@W?C@?dCGtk@@A@?uk@DC@S~O????@D`E@CDrH?lk@@???CAyA@sQ?@xOA@D?K@}f@|B?oAE?@EADqj@J@AA{Mwa@FhHI?H?CUX?C@CE|Vkk@DrDCD`I?FoG??CjOpADNBOBOOBBBNBBBOBBBBBBB??A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?ZdRIeRKiI[?\?]{DQ?^?_@?`@?a@bAJ?b@?c@?d@?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@~Di@pRk@rRm@Tb@mRo@?p@?q@?r@?s@?t@?u@?v@?w@zDOjBRjIThBV|Dx@vRc@?o@?y@?z@?{@?|@?}@?~@?_A?`A?aAkBo@wRbA?cA?dA?eA?fA?gA?hA?iA?jA?kA?lA?mA?nAp@p@?bAeSdAgSfAiShAkSjAmSlAoSnAtRj@qRl@sRn@ToAlI]~RSkIUaAW?x@bApA?qA?rA?sA?tA?uA?vA?wA?xA?yAp@zA?{A?|A?}A?~A?_BbE{A`T}AsI`B?aB?bBmBq@xRcB}RPgBdBbEeB?fB?gB?hB?iBlIjBjRPgBR_SUnBkB?lB?mB?nBtSk@uRn@uIfBgThB?oBwSPiTSq@V?pBTqB?rB?sBp@y@`S{@bS}@oI_AqItB?uBp@vB?wB?xB?yBvIz@aS|@cS~@pI`ArB{@pT~@sTtBxSqAySsA{SuA}SwA_TyAe@rBcEQhRSeEpBqBl@TKiIzB?{B?|B?}BeTQ{IThB~B?_Cp@`C?aC?bC?cCiEdCnT]rITcAW?kBoBmB?eC?fC?gC?hCmBbA?iC?jCmTQxTU?kC?lC~DmC?nC?oC?pC?qC?rC?sCsBLfRNgRPdEThBkC?tCuTrAzStA|SvA~SxA`JcAfSeAhSgAjSiAlSkAnSmA`JiC_U\zIRdAVbJsAvTvAjUyAcJdApSgAlUjAsSmAfAM~IRdAuCqBvC?wCP]~TU?~B?xCyTyC?zCeJeAkUhArSkAnUnAoUtAiUwAfAzBiE|B}IrBdJSq@{CdTr@yRt@{Rv@nINnEQtBkC?|C?}CkTgBtUSeEWjE~CvUfAqSiAmUlAqB_D?`D?aD?bD?cD?dD?eD|UTr@fD?gDxUuAwTxA|Im@Gn@cT|AaT~AfJP?hDpJ}AsI_BfA[`UR?{CfAiD?jD^jCiVSvBkBkEkDzTaC{TcCiElD?mD?nD_JPgUUaApBjJ{B?oDlJs@zRu@|Rw@xIwB?pD?qDqBrD?sD?tD?uDgVvA_V`D`VbDbVdDdVNpERt@WxBNuVSq@uC}UgAqUkAtEhAwUlAqVwAyBxB^vDhV\cEwDqJ~A?xDxBt@zUw@eVU?uCxVxAzVu@oVNvVTfVeCs@fCf@yDPzD?{DsJOg@VsUNvJUbJ|D?}D?~Dh@yAM_EbA`E?aE?bE?cE?dE?eE?fE?gE?hE?iEqEbC|T{B?lDlVnDnVQtBuCjA\kJTcApBwViA~UmAGjEiAQkR_@}Da@nJhBlT\yJUaRBbRD?kE?lE?mE?nE?oE?pE?qE?rE?sE?tEiWCcRkEkWmEmWoEoWqEqWsEsWuE?kDtWDjWlElWnEnWpEpWrErWtE`CkEuWnE{WqExWtE?uE~WlEzWoEwWrE}WuEi@mEvWpE|WsEyWkD|JnE_XrEcXkDeXoEbXsEfXpEdXtEaXkDgXqE`XuEhXrE?vE}JsE~JtENuEOkD|JwE?xEiXxE?yE_KsE_KyEjXtEwEjArUnA`WaEaWzE?{E?|E?}E?~EmXkAvS\xEVY^?_F{JoBjVTr@kBM`F?aF?bF?cF?dF?eF?fFjJgFoXlArXmA~DhF?iF?jF?kF?lFkAkChAmFcKaFqXcF?nF?oF?pF?qF?rF}VPgB^YR{BkB?sF?tFlJcBkAV|DkBoBuFdCSqJrBaKpBuJv@{UO~BWiRY?vFuJN_CuCbC]g@kC`@nAxJO}EfDs@kDM_BrE|ByU]a@Th@wF?xFuE]}EkBkEeClEgCv@UrVaDaVcD?yFPzFzB{FT|F?}F?~FfA_G?`GhT]oK|CkBd@nRf@?aG?bGwEcG?dG?eGqKfGcCgGfYPwBkCnKPRViKhG`YPsKmFa@iG?jG?kGeYbDsVeD|EW?yDzXNvJlG?mG?nGnYcDcVeDhCx@gCQtBV|DfDs@zD?oG?pG?qGQrG?sG?tG?uG?vGtKjG~Xw@~IwGqExG?yGvYN_CVyV]jB^?zGQ{G?|G?}G?~G?_H?`H?aH?bH?cHhCkBi@dH?eHcCiFsXkFtXNnEfHbZeHi@gH?hH?iH?jH?kH?lH?mHdZhHeZjHfZlH}KiH|KkHgZmHgFjH~KmH_LkH}KnHi@oH?pH?qH?rH?sH?tH?uHqK`GlYQwKpBiZpHkZrHaLtHnZqHlZsHbLuH?vHdLrHj@sHZtHaY}BcYPwBVd@wHxKO{DxH?fHrJjDmYQ?yHzY|G{Y~G}Y`H~YbH`ZNpEzH~V}D_W{HyYPpCWjElBpBkDgE|@rT`ARuCeWcC}TrBaKWbK\iC|HiKbF{EnFjKpFkKrF`KbEbWdE?}H?~HxB_I?`I_YPqCkBuZ{BfWmDmVrBvZx@tJyBRaI?bImBcI?dI?eI?fI?gI?hIuIiI?jI?kI?lI?mI?nI?oI?pI?qI?rI?sI?tI?uI?vI?wIxYyGUpBgL}G|Y_HzKaH_ZcHwYxIbCzFMyI?zIPgD?{IRkChA|I?}IUW?fDoJ{IbYxFfLPwBuCkCsGtYuG?~I?_JsB`J?aJbFRiLQ{IbJ?cJkFRyXlBsZ~D?dJw[SvBfDs@~C`KeJ?fJmFlDgWrBxEkCoZQmF|B}INdFWjLmB?gJ?zDcFpG?hJ?iJqLQwKWwFeCfChC?jJtFToE|C?mFuLRrFkJ{KjF?lJ?mJhCgDoC\?jBvLlJb\N?nJm@kBsLSkVlBpBgJ}[oGjChJxZcFeKeF?oJlCkGa@_C?yCsCaJ?pJ?qJtLRt@rJgLsJ?tJ?uJ`CvJ?wJ?xJ?yJ?zJa\SpJ{J?|J?}J|EpBpF_A{FTcA~Jm@fDz[mD}Z]}Ex@e\lBxLSvBx@vCUnBfDs@eC?~C?_KeCZwE`K?aK?bK?cK?dKzKeK?fKl[~GqZaHn[NuL^?gKkY\c\]jByDiCdDtVOzCwH`@xFzBsDpVhK{CmBpYOg@~BgJ_Ca]P|ZlBpBeClEuF?iKtZ}@oIjKzFThBuCkXsEg]tElXuEh]uEaGkDi]kDeLNnExHjYN{KkK?lK?mKzLTpXlB?kJr\|Js\NdFpBk]}J|EnKwXQxFkB`FfCf@hCbGOpKgDlFoK?pKwCjBdJTMqKdKhG~\eDaZlBf\zDt\nDhWRrFmBwJoGjCrK^sK?tK?uK?vKtJuG?wK`GUbMUjTlBn]RmKOrIiG|FgD{\_Hm[bHhLOyK`@yCUnBx@?wHv@lG?xKq]]{DdB_GeC{JiBmZR{BXiBvFs]NvFx@v\aKw\cKy\`H?yK?zK?{K?|K~F}Km]NvCyDeGV{XlBy@V|X]dYlB}CpBvAVnMmBkFwGtL^o@~K?|I?_Lz]Sx[eC}BgC?`Ld\mJt]mBkGhC{]PdEyDnLdIoFaL?bL?cLQdL?eL?fLeMPwByDsAgLnA_@?~K~C}I?hL?iLm^eLo^jLeGuC}CWwFkDc^O~FjByJlGaF{CsAnFjKkLzFlLgGOOmL?nLw^nLdGpGqAiJhGWwFgJg\pGnJN_CoLwZ]jBpLvAuCMxD_^\}\PpCpBkMPxX_@r^|Ir[hLxAqL~]fC_DfL?jLk^QmFdCw]S`DXlMZ`_@rBkJbJrBrL?sL?tL?uL?vL?wL|FeCwAxLsFdJyM]v^P}^`@~C_L{[}BkAuCjGTr@x@tMOgYmF}]`HrZcHqYwH`Dx@rKyL{^jBxEuCm@x@vA~BgJiG|^Qo]lBsAdFfKfFcDeCfCjJ}FViGkDdD]g@uCm_@PqCx@_GkDlKzLv]rBzIdBj^NpEyHxB{LkA~Bb]yCmGoF`NQl_@mBzAx@z@WjLkJXjJg_@P~LmB|[zDpAhJl@|Ct^PsK|CqMhLvMjLaN]e^mBsF{Hf]~@pItBv@|LT}Ln^~L?_M?`M?aM?bM?cMlKtFcDdMsMrKMeMvAkCq[}Is^iL?qLh_@aH|\OyK_@}D|Is_@QgEfM?gM?hM?iM?jM?kM?lM?mM?nMhDWs[eCl@oMMpMyBqM?rMgMtKx]sM{FiGuKkG^tMfDyHq_@NdFrJ`DfD{LfCf@`L?uMt_@QtBaIbFwG?xIrEdCzAkBkEgJy^hJ^vM?wM?xMc]QxFfDh`@gCUrJpNRt@oL`DkBdMuFkCyMhNPa@bJz^PqCXfDRdAkCp^QzJ~Ku_@iLQ}F?zMj]O~BpBtNRfMkDrKe@oR{M?|M?}M?~McC_N?`N?aN}MUaU|C`BqLiMhJzAfDxGhC?bNqFRdA~Br_@zCm@XiBcN?dNp`@lBUdBq^oF?eNp@fN?gN?hNoFiNsNQxFx@M`BtIbBu^]}AjNg`@eC}BkNYlNlFcEcW}HlLmN|MQwMR{Bx@f`@Og@nNyN^h^|I__@iLyBpD?oN{AeFRpNl`@lB}FkCx`@SwJ{DyGViGeC|L_KUoLha@Pra@Qja@dEdWqNn\tJjMrNvAaIvLkFcZOg@sNla@P{@kBdDtNnLuN?vNoa@T~MwNva@lBcMhCeLrB~GW~[fCgDfCuAjJtGx@pFxNn`@RqFlNiDkL?yNuEnJlDkB`F~C?zN`a@eCkG`L`OdJ}GqDt`@Sq@~B?jK{GmBYdB`HeE?qN|F{Nka@SwLkJbMlGaFrNz`@f@hYbGuGrM?|N?}N?~Nd^P~LkJgOTcOmBcK_O{@x@iMiJiLfHlG`@ua@QzJ`@zZ`I{ZQzNwHT`OuFaO?bO?cO?dOnKyDdO]{NkDYyD_ORt@iKrG_AqIeOe_@NTfOtN^~_@Rgb@bOhb@gO?hO?iOs`@QYjOcNR|NRdAaI{a@eCfC`LvGkO?lO?mO}JvE?nO?oOgHnOgHpOta@lFkAaIzMqO?rO?sO?tOyClG`OjD?uO?vO?wO}_@bHhL}KlOSpMkDzFbJvb@NmMwHyNRfMeCfCxO?yOnA~KoDaGbF^o@vHlFzEnX_AlDwNtGfDib@Po_@wHec@_@sG}I\wHy@~Bob@R|b@cHhK|Iqb@SqEzO?{O{GiKc_@PeNkDjc@S}L_@ic@hLza@ScUnCdUpCfUrC?|OnDyNkc@N`c@SrO}OrLvGsFjDmb@SpMeC{@fDa@dBfc@{EtTuBda@pFkb@`Ay@kChA}CtOOfOmBsB~OyB_PcHkDiOOnCiHhZlHeGkC?oM`LlHvc@mH{NeCrb@uM?kOsb@mO?`P`CaP?bP?cP?dP?eP?fP?gP?hP?iP?jP?kP?lP?mPk@uHj@nPi@oPjZpP?qP?rPmc@Qyc@pH?pPzc@rP|c@pP}c@fHtGkBlHsPaMtP?uP^vP?wPcDzDfNiJzBxP?yPr]aFvXdFfKzPbBUhMmBT{P?|P?}P?~P?_Q?`Q?aQlc@TzMsLa_@uLb_@bQsCcQ?dQ|A}CkOcO?eQ?fQ?gQvIhQ?iQcHgJ?jQeJkQ?lQ}NkJ`HmQ?nQ?oQ?pQwORac@fCdc@bGy]wKaHUPqQ{CuFgc@eCwAbNeBVeBrQaa@SnHhCv`@PdEiGeb@w@pOO`CsQ?tQ?uQ?vQ?wQ?xQ?yQ?pOsd@P?{NiDpFkKzQtc@PdD{QjH_AwIuBlGzGYwGsA|QlDx@pHNvFfDsYoGh\iJyd@wHad@oGoc@Tr@XcJ}Q?~Q|a@Tud@QmJ|C`\}Cjd@jJaB_RaB`RxNgNfa@eI?aR?bRuOTsOTr@cRrc@ToEoMrEoDy@uClG~Kid@UyOkDjb@Sq@aIhDpB}d@UaArJiCdRbNOp]hJsHbJnd@SmDgCkHeOzd@Ov_@kD`b@QcPeRvOPMfRwO^o@{CzAlBmH|Pdd@gR{d@Uo`@Sba@YgPRjIbJ\wNsLbJrd@QtHVoD{M{`@hR~b@cJRiRkHtBoDg@tM`P?jR~`@`N?kRaBoJke@TcArJfOlBjPRod@gC?xOdb@R|GwHmPmBdH|N?lR?mRl^eI?nRlHiR}NmBz@rJkOoRgP^o@`@qHqF?zQtd@QqNgDxHRkBpRyMzDGqR|Aa@gCrRwM^o@zG`GlGRWge@TcGkJR~Bwe@SwLmB?sR_[jI`[lIb[nId[pIf[rIh[tIj[vI|ItR?jEbPR{BfD?dMaMlK?uR?vR?wRxe@UhPQpO}K}b@T{VzDpAqGbExR?yR?zR{@gDhc@Qbe@UpD|IPPaf@RfBnNpc@oCeUqCae@UyOeCuCjJbd@yPqPTcAdBpFpRy@aIvHeC?uFcC{Ra@|RsPRme@Smf@TcG~CtAcNkHaAtPpCqc@jKR}Rje@}Ped@_Qgd@aQfD^oP|IkNgM_`@iMa`@kMc`@mMd`@~R?_S?`S?aSif@U{GkJkBbS?cS?dS?eSuFfJwHzQ{CkDre@S{e@eCkF^?fS}OTuPVnM~C{f@UpN^iHzDtEgS?hSrPSq@kCuXjJlPU_a@mFvPbIwP~Pfd@`Q{HWdNhCqPiGoLjDiHeCiAiS`e@UcDkDz@pBlf@Sxf@fCsDVqa@fCzPTdf@V~f@_QxH^ma@}IfPuMsf@_@~^}IjDqLvMjSe`@uK?kS}FuCUyHjg@lSm\mSl@}CsCnS|HVv[tG?oSdOpSyPTcGmBQqS}HVePuC}PWmNeC_HvF|HaIlb@_@sG_Lkd@gOeDwNff@S{P|C_GgJwGiJ_QrJtPrStIsSTtS}HkCtHuCiAuSbNnJ_D~Lx_@`MiNbM?vSb^|KdHwShOkDfBWxa@gCfDwGtExS?ySfe@PuDx@rGjKePVdg@gCuUzS?{SxPVrYeCy[_KPpS`^bKx\dKz\fKyGkC|_@hLnf@Ugf@fCuAbNz@oLfBpB}CrJpHOef@_LrO|SmDuF_QWaQpBsHT_\lCaQWx^zDfNqGeg@UhMkJzB}Scg@Tye@hCrB~S?_Tmg@uGcd@bF{EdF?`T?aT~H`@oe@WbQhCuDkBjH|E?bT?cTyCsP~A|C?eRg^_@wCpSMdT?eT?fTlH|CgO_Ck\zCMgThCfD_PpGqAqGeBkCrJuJse@S`GkCbf@UfGwHeOwHUnN_d@lB`d@wPfg@WhDoL?hThQlBd]fCf@yObh@UaAiK_e@hN~N|Cie@_@xNiT?jTiQ}CkCkTcN^hg@hLhOeCph@_@eFvHbBlTmKmTMnT?oT?pTk`@uJoLdJnPoDw_@eL?~Lxg@aMz_@cM?qTxDx@|AlCbBlGeBaIxDX~a@mG?rT`]tD?sTl@sPrh@oTyf@_@_h@|Cxh@tT?uT?vT?wTkMyDnOoOi@xTrG`Apf@qCaJsChGpB`QUdh@hCdPVcQkDbb@wHrg@hOaNgDvHgJ|OuC|h@WjEjJwCnJ}OcJuO_CcIhKsDaIn@N_CkChAa@hh@NvFkBdMgCXbNnP}N`AyTdIx@yGuCfh@kBmh@ViGgJwGqG`AzT}g@Wch@oGuMgCbCnJ}PrJlO{Cwb@rOxb@tO{CkJzg@QcP|ItO}Kei@hCeDwH`h@VcQeCth@~L?{T`N|TlPlGkQVlh@T|HuCug@aB?sS`H}HmOfCf@xOqg@zG_AyDsM}T?~TwDfDvHkDoHzDoHkDoQR}e@eCbG}KsDuC_AfD{L~CaBfFfQUnBXwDx@iPN`@_UM`UnA`@uDfDsNjOeQVmi@SeErJ|OVhi@fCf@uMtFbJjP^yHdNxDfDxG`LbImBs@jJtQV?rJrQUiCaU?bU~HzG_g@x@dIkBm`@zDpA{IcHeCe]iK`i@~N~g@cKa^yK?cUgD~CtAdUmDhC~NyDzOeU?fU_AkBvQaIy@pNOgU?hU?iUdQkB~h@hC|PeCog@Z^jUmQOpKeC|e@kIa[mIc[oIe[qIg[sIi[uIk[wIpD}Ie@zFhe@PqCfDxGxO`AeTgh@eT?kUdKlUyZoFhQmUo\wJp\yJfJyDTnUiDeNvh@mG`AkU`j@cFi\zP?oUnQW}HuCeIpBwDkBtFiGa@yDxHwG?zH_j@PeBsNvQVfBoLuf@hM``@jMb`@lMlNnM?~Rwf@`S?pUsAqUle@dNqi@Tri@WmNzDji@~H?mNfj@rUyg@ySlQkCii@_My_@aMuh@qThGrJ~F`P^sU?tUxQQqNeCcIuD|g@WkQaIv@uUfi@sO{i@hU?vUi@wU?xUfIfDoi@_KpDa@`QuUbIkJgMyU?zUwi@wHuH{U?|U?}UzOnQmd@pQeQtCdPkCdj@QbCpSfIkBoBkD|QkB~GpB|MxHfPhCsg@zDmOuFqF^yHvHsi@~UgI_Vcj@lBsB`VaHlGaFnGwc@fCi`@uMxc@lOtb@aVuPuCRrJcIbV}h@Og@aIci@fDoJhJjj@Rt@pBuEcVaBzPhPwDnh@mBlQV~H~KmBdV?eV?fV?gV?hV?iV?jV?kVeh@cF~i@fCzQWli@eCgIlVgHmVmCmHuc@jHnCjH}j@kH~j@lH_k@mH|j@kHgj@Uu\eCj@mVdLnV?oV_RnP~c@qP{c@fH`k@rPak@fHl@lCdQfDjGiGsOiGvd@`A?tBPpVuj@kDwg@qV?rV?sV?tVyDaIrQlGce@|IzQoLpj@oG{QfDkj@vFjMmG?uVpi@eCkGxO|N^kNvVgQwV?xV?yVze@xC?iGsH_CxP~Bkh@|Cni@eC~QWng@~C}GzV?{VsC|V{h@rC|PkDqLwGdIfDu`@~Fti@gJm@}VtHkC{@dBaPnBiAjObP^tf@}Ij_@xCej@iMvf@lMsD~Bpe@|M|`@~Vtj@S|CwHnQrJM_Wmj@Rzb@vOwQvH`Rx@`A`WlDXxi@lB~e@uR_f@aW`f@VmPjJyDV}QjJbI~Cof@dNYzHui@WjGbJv@sPhIjKqk@W{HrJvj@eVwj@gVyj@bWoQ^}GoNok@Smk@}MuQWdi@pGgQ_Toj@lBsk@fVxj@hV?bWfImUrk@x@ik@|IkDcW`RfDih@hJwPgR{Qx@|Qx@hI|Obj@aF?lU{EgLkLqF{A`TiHgDxDkB`FjJfk@eC_O^_Ax@zi@lBu]oGyDkCgk@_CoHeC|LvFvk@lBl\pJ_AgDdk@gDf^pLij@`MiNdWgg@_@te@kDbk@}IyDuC{HpBgIeWjk@fWzj@nFgDnBtQ~BdGrKPnJeIWnk@Tcf@oGxQwDiQjK_AXlMdUuDXiBZqQWuHgW{j@zDrNcJgGpSfQlG?hW|i@lBpk@mBwk@fDek@ZRtCcOkJhIsCqh@fC`AiWck@pGMjW}MaIld@zDuHkW?lW</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??B?????B??D??B?????E??F??C?????E??G??C?????E??H??C?????E??I??C?????J??K??B?????L??M??pS?WC?N??O??@U?wL?P??Q??PJ?sC?P??R??pr??K?S??T??pH?gN?S??U??@F??T?E??V??C?????E??W??C?????E??X??C?????E??Y??C?????E??Z??C?????E??[??C?????E??\??C?????]??^??C?????]??_??C?????E??`??C?????E??a??C?????E??b??C?????B??c??B?????S??U??@I??T?E??d??C?????E??e??C?????E??f??C?????E??g??C?????E??h??C?????i??j??B?????P??R??@A@sK?P??k??PD??H?l??m??`D?wB?n??o??a??CB?p??q??a??oa?p??r??QT?sb?L??M??@M?KC?s??t??@A?cE?u??t??P@?GH?u??v??`I?CG?w??x??pW?gF?y??z??@?????J??{??B?????l??m??PG?GC?|??m??pB????P??}??pI?wM?~???@?PG?wy@~??@@?`W?WJAA@?B@?PT?OX?C@?D@?P@?OKIE@?D@?@@?oG?E@?F@?p@?gC?E??G@?C?????|??m??AB????H@?I@?Q@?WE?J@?K@?AC?S??L@?M@?Q@?Ka?N@?O@?QE?wF?P@?Q@?AC?WL?E??R@?C?????S@?T@?B?????S@?U@?B?????P??}??@W?GN?P??V@?pA?gO?N??W@?@B?WH?N??W@?PG?OI?X@?W@?pE?WQ?Y@?W@?`D?[D?Z@?W@?pH?O`?[@?W@?@A?SB?[@?W@?@a?CE?[@?\@?@`?OG?]@?W@?@@?wB?^@?_@?@?????J??W@?B?????P??R??@x?GK?P??Q??@F?WC?N??`@?@A??G?Y@?`@?`D?CF?Z@?`@?@Z?CY?[@?`@?@A?KO?[@?`@?@U?_Q?[@?a@?@`?gS?]@?`@?@@?{A?]@?b@?@?????J??`@?B?????|??m??@B????H@?I@?@L?sE?c@?d@?PG?GD?e@?f@?pE?[A?g@?f@?@C?KS@g@?h@?P\?Se?g@?h@?PM@cg?i@?j@?aK?OC?k@?l@?AJ?OJ?~??@@?P??_IAE??m@?C?????H@?I@?P@?WE?J@?K@?P??S??~??n@?P??kbB~??o@?pA?ShBA@?o@?p@?kd?E??p@?C?????E??q@?C?????E??r@?C?????E??s@?C?????E??t@?C?????A@?o@?P??cd?J??u@?B?????P??R??@g?cJ?E??v@?C?????E??w@?C?????S@?x@?B?????J??y@?B?????|??m??AA????S??z@?a???J?S??{@?aC?{F?~??|@?Q??SVAS??U??@L?CT?~??}@?PI?_hAA@?~@?@C?Co??A?@A?PI?wmBE??AA?C?????i??BA?B?????|??m??@A????S??z@?`???J?S??{@?`N?GG?~??}@?`@?_fAA@?~@?p@?Co?E??CA?C?????E??DA?C?????E??EA?C?????E??FA?C?????P??V@?`??cO?GA?HA?PV?OJ?E??IA?C?????E??JA?C?????s??t??P??_E?s??KA?A@?wF?LA?z??AK?[W?LA?MA?aD?SQ?i@?NA?QJ?SB?k@?OA?qF?oI?J??PA?B?????E??QA?C?????J??RA?B?????w??x??pN?OF?u??SA?aJ?[O?E??TA?C?????i??UA?B?????i??VA?B?????E??WA?C?????E??XA?C?????E??YA?C?????E??ZA?C?????w??x??pr?kG?w??[A?`d?OM?u??\A?PY?KR?]A?^A?@A?sL?p??f@?PA?Ge?p??_A?@e??g?p??`A?@??su@E??aA?C?????E??bA?C?????E??cA?C?????S??U??@B?{S?A??dA?B?????eA?fA?B?????A@?~@?@D?Co?~??Q@?P??cZCgA?Q@?@??oA?A@?~@?q@?Co?S??{@?AF??G?~??hA?qL?gLAw??x??pM?KF?w??iA?aO?gH?p??jA?QA?_F@p??_A?qM?Sf?GA?HA?@??cI?E??kA?C?????g@?h@?pZ?Se?lA?mA?B?????E??nA?C?????E??oA?C?????Z@?`@?PA?CX?pA?qA?@@?GS?rA?qA?P??_H?g@?h@?pe?_e?P??Q??AF?WC?N??`@?AA??G?Y@?`@?aD?CF?Z@?`@?AZ?CY?[@?`@?AA?KO?[@?`@?AU?_Q?[@?a@?A`?gS?]@?`@?A@?{A?]@?b@?A?????sA?tA?B?????sA?uA?B?????E??vA?C?????E??wA?C?????E??xA?C?????E??yA?C?????E??zA?C?????E??{A?C?????E??|A?C?????E??}A?C?????E??~A?C?????E???B?C?????E??@B?C?????E??AB?C?????E??BB?C?????E??CB?C?????E??DB?C?????Z@?`@?QA?CX?pA?qA?A@?GS?rA?qA?Q??_H?EB?FB?qB?GM?GB?HB?a??gC?E??IB?C?????g@?h@?@e?_e?g@?JB?p@?cW?KB?LB?QA?_??KB?LB?a??C@?MB?NB?ak?CK?OB?PB?aA?cE?i@?QB?qQ?g}?~??}@?@??GhAs??t??@N?KF?s??RB?pB?{G?SB?TB?@@?CU?]A?TB?@@?wI?p??UB?@??_w?E??VB?C?????MB?NB?AG?cI?MB?WB?aE?cT?MB?XB?Q???W?MB?YB?a??CT?MB?ZB?aB?CV?L??M??PN?KC?[B?\B?Q??oH?E??]B?C?????E??^B?C?????sA?_B?B?????sA?`B?B?????p??_A?qq?Wg?E??aB?C?????w??iA?A??GH?P??R??Pf?cJ?P??bB?aH?oL?cB?hA?aA?{N?S??U??pG??T?~??dB?P??g]@p??r??qN?gb?~??eB?AJ?Wq@[@?W@?`g?_E?fB?gB?`I?_Q?hB?iB?@??GJ?~??dB?@@?g]@s??RB?pE?{G?KB?LB?a@?_??i??jB?B?????i??kB?B?????i??lB?B?????E??mB?C?????E??nB?C?????E??oB?C?????E??pB?C?????E??qB?C?????E??rB?C?????P??bB?AT?wL?S??Q@?aK?SD?~??|@?q??gSA~??|@?QB?SVAA@?|@?AG?SL?E??sB?C?????S??{@?`C?{F?~??|@?P??SVAE??tB?C?????P??bB?`L?sL?cB?`@?@A?SG?cB?`@?`C?gG?cB?uB?PC?wJ?vB?wB?pA?sb?xB?wB?PA??q?xB?yB?PC?Cs?xB?zB?p??{b?xB?{B?pB?Ga?E??|B?C?????E??}B?C?????eA?~B?B?????E???C?C?????E??@C?C?????E??AC?C?????E??BC?C?????E??CC?C?????E??DC?C?????E??EC?C?????E??FC?C?????E??GC?C?????E??HC?C?????E??IC?C?????E??JC?C?????E??KC?C?????E??LC?C?????E??MC?C?????E??NC?C?????E??OC?C?????E??PC?C?????E??QC?C?????E??RC?C?????A??SC?B?????p??_A?qH@Wh?[@?`@?qY?kQ?TC?f@?Q??GN?A@?B@?pN??X?E@?UC?@@?_H?]??VC?C?????eA?WC?B?????P??}??PF?oM?S??T??`E?cN?~??@@?aW?WJAA@?B@?qN??X?E@?UC?A@?_H?E@?F@?q@?gC?J@?K@?@C?S??L@?M@?@A?Ka?XC?YC?@U?gM?P@?ZC?p??OK?P@?ZC?`B?WM?XC?[C?PB?K^?XC?\C?PK?C_?XC?]C?@G?{_?L@?^C?`E?KI?_C?`C?pK?Cs?aC?bC?@B?[F?cC?dC?P?????C@?eC?P@??hIE@?eC?`??GM?E@?F@?@??cC?E??fC?C?????g@?h@?@??Sd?A??gC?B?????E??hC?C?????E??iC?C?????i??jC?B?????A@?|@?Q??kK?A@?kC?A@?WB?S??T??qH?gN?S??U??qG??T?E??lC?C?????E??mC?C?????A??nC?B?????Y@?`@?qC?CF?oC?pC?QB?gX?E??qC?C?????E??rC?C?????E??sC?C?????E??tC?C?????E??uC?C?????]A?TB?@??wI?vC?TB?@??[|?E??wC?C?????i@?QB?q@?W}?~??dB?AB?k]@A@?dB?aE?GB?]??xC?C?????cB?`@?PA?cG?cB?yC?@W?OJ?A??zC?B?????E??{C?C?????E??|C?C?????E??}C?C?????E??~C?C?????J???D?B?????e@?f@?pG?_A?@D?AD?P??wF?BD?CD?pK?W@?E??DD?C?????E??ED?C?????[@?W@?pY?oD?oC?f@?@X?C~?oC?FD?`[?wC@GD?wB?@B?SH?GD?HD?@G?[I?xB?yB?p??{r?xB?ID?@??{[?E??JD?C?????p??_A?q@?Gf?E??KD?C?????E??LD?C?????SB?TB?A@?CU?]A?TB?A??wI?vC?TB?Q@?[|?J??MD?B?????Z@?`@?QE?[X?Z@?ND?Q??_U?g@?h@?@E@Wg?E??OD?C?????GA?HA?`V?OJ?PD?QD?aD?sE?cB?W@?QB?kC?cB?W@?aL?sD?A@?|@?A@?kK?E??RD?C?????xB?yB?PA??s?xB?zB?pB?Kc?xB?SD?Q??wa?TD?UD?Q??kK@E??VD?C?????E??WD?C?????i??XD?B?????E??YD?C?????A@?B@?AS?OX?C@?D@?Q@?OKIE@?D@?aC?wG?P??bB?aL?sL?cB?`@?AA?SG?cB?`@?QA?cG?MB?NB?AI?gI?i??ZD?B?????i??[D?B?????cB?yC?AW?OJ?MB?XB?AJ?KW?E??\D?C?????E??]D?C?????E??^D?C?????]??_D?C?????E??`D?C?????i??aD?B?????J@?K@?AA?S??~??bD?qH?K}BcD?dD?aA?kG?eD?Q@?A@?[d?L@?Q@?A@??D?XC?Q@?AC?_J?E??fD?C?????n??o??QG?_B?[B?\B?Q@?oH?A@?B@?PL?{W?E??gD?C?????P??R??@o?oJ?cB?`@?aC?gG?cB?uB?QC?wJ?vB?wB?qA?sb?xB?wB?QA??q?xB?yB?QA??s?xB?zB?q??{b?E??hD?C?????g@?h@?P|??g?L@?M@?AA?Ka?XC?YC?AU?gM?P@?ZC?q??OK?P@?ZC?aB?WM?XC?[C?QB?K^?XC?\C?QK?C_?XC?]C?AG?{_?L@?^C?aE?KI?_C?`C?qK?Cs?E??iD?C?????g@?h@?pV?Ke?S??{@?aN?GG?~??}@?a@?_fAcB?W@?aq?gD?GA?HA?`F?kI?E??jD?C?????GA?HA?`P?GJ?PD?QD?P@?gD?PD?QD?@C?{D?S??Q@?qO?[D?cB?hA?QB?{N?p??r??qD?_b?p??kD?QA?GT?~??lD?qE?WQAA@?lD?A??KK?s??RB?pF?{G?mD?nD?Q??Od@oD?pD?qT?Cc@E??qD?C?????E??rD?C?????B??sD?B?????MB?XB?AD??W?|??m??qB????P??}??qI?wM?~???@?QG?wy@A@?B@?QC?gW?E??tD?C?????E??uD?C?????E??vD?C?????wD?xD?Q??Ko?]??yD?C?????~??hA?qP?kLAE??zD?B?????[@?a@?Qd?sS?E??{D?C?????E??|D?C?????E??}D?C?????S??T??P??[N?~??~D?A@?[[@E???E?C?????N??O??@??GL?MB?@E?Q??KX?E??AE?C?????eA?BE?B?????~??}@?QI?_hAA@?~@?AD?Co?~??Q@?a@?gZCg@?JB?@??cW?P??R??@??kH?oC?pC?AA?_X?TC?Q@?AB?wC?oC?Q@?AA??Q?wD?Q@?a@??L?J??CE?B?????P??R??PC@{I?wD?Q@?QJ?WN?oC?DE?a??kO?oC?DE?A??o]@E??EE?C?????E??FE?C?????E??GE?C?????E??HE?C?????E??IE?C?????E??JE?C?????E??KE?C?????~??bD?aC?O}B_C?Q@?a@?wp?_C?Q@?Q??Cq?gA?Q@?A??oA?L??M??@J?CC?s??LE?A@?KB?ME?LE?A@?WH?E??NE?C?????E??OE?C?????S??{@?PP?KG?PE?QE?@??kC?E??RE?C?????PE?QE?p??kC?S??T??AB?_N?S??{@?Q??sF?E??SE?C?????E??TE?C?????E??UE?C?????E??VE?C?????E??WE?C?????E??XE?C?????E??YE?C?????E??ZE?C?????E??[E?C?????E??\E?C?????E??]E?C?????E??^E?C?????E??_E?C?????E??`E?C?????E??aE?C?????E??bE?C?????E??cE?C?????E??dE?C?????E??eE?C?????eA?fE?B?????]A?TB?A@?wI?p??UB?AD?kw?GA?HA?`N?CJ?PD?Q@?a@?GA?w??iA?AG?WH?gE?hE?QC?oV?i@?QB?AS?g}?P??R??Px?GK?P??iE?P??kF?jE?kE?p??Gp?jE?kE?`n?gh?C@?lE?a??CVIC@?lE?a@?SYIE@?lE?q@?WK?XC?Q@?qA?[J?S??U??AB?{S?~??dB?Q??g]@wD?Q@?qH?SN?oC?mE?a??kO?oC?mE?a??c^@H@?I@?aO?{E?GA?Q@?AL?cD?E??nE?C?????N??W@?`H?SI?X@?oE?@??CQ?[@?`@?qP?SQ?fB?pE?qB?[M?qE?q??a@?KI?qE?rE?Q??wN?E??sE?C?????E??tE?C?????E??uE?C?????E??vE?C?????E??wE?C?????E??xE?C?????E??yE?C?????E??zE?C?????E??{E?C?????MB?ZB?a@?CV?E??|E?C?????MB?NB?QA?WI?N??W@?P??WH?A??}E?B?????i@?QB?A??S}?i@?QB?q??S}?A@?B@?QL?{W?E@?UC?aE?oH?E??~E?C?????p??_A?AD?Kf?eA??F?B?????g@?h@?`g?oe?jE?kE?@??Sf?~??lD?aM?wQAE??@F?C?????E??AF?C?????oD?pD?QL??c@A@?~@?AC?Co??A?@A?QI?wmBA@?B@?qQ?GX?oC?Q@?QH?CQ?l??m??@??oB?sA?BF?B?????E??CF?C?????E??DF?C?????y??z??A?????vC?TB?AA?[|?mD?Q@?q@?Gd@oD?Q@?AQ?Cb@H@?I@?PF?kE?EF?FF?P??kd?GF?HF?`B?SE?s??RB?`L?CH?E??IF?C?????E??JF?C?????aC?bC?AB?[F?cC?dC?Q?????C@?eC?Q@??hIE@?eC?aB?KM?l??m??pB?wB?S??KF?AC?SF?~??}@?AA?KhA~??LF?Q??k^CL??M??`O?KC?Z@?W@?pf??a?MF?NF?@??oB?E??OF?C?????cB?yC?qY?SJ?cB?W@?as?cE?cB?W@?QF?kD?A@?dB?QD?GB?S??U??AL?CT?~??|@?A??SVAE??PF?C?????P??bB?qM?wL?LA?MA?qA?OQ?k@?l@?aC?OJ?P??R??pj?kJ?E??QF?C?????xB?zB?qB?Kc?~??}@?A??GhAZ@?W@?`W?o`?Z@?RF?@??w^?u??SA?AM?cO?gE?hE?qD?sV?PE?QE?`A?oC?w??iA?QK?[H?J@?K@?Q??S??~??n@?Q@?kbBOB?PB?Q??_E?SF?TF?Q??{K?EB?FB?qK?_M?UF?VF?a??s`?g@?h@?`q@Gi?g@?WF?Pj?kl?g@?WF?po?{l?g@?h@?Pe@oh?]??XF?C?????P??}??AW?GN?P??V@?aA?gO?S??Q@?aH?KD?]??YF?C?????E??ZF?C?????g@?h@?@FAki?g@?[F?qF?cZ?\F?^A?Q??[D?xB?{B?qB?Ga?E??]F?C?????p??_A?AI?Of?\F?^A?QD?[D?^F?_F?a@?SJ?i@?`F?qK?oK?aF?bF?QF?CN?J??cF?B?????g@?WF?@G?Wk?g@?WF?P`?Wl?cB?uB?QF??K?E??dF?C?????E??eF?C?????L??M??pZ?oC?sA?fF?B?????g@?h@?PU?Ke?p??_A?AM?Sf?p??`A?A??su@xB?zB?@??{b?B??gF?B?????fB?pE?AE?_M?hB?q??AI?GH?E??hF?C?????E??iF?C?????E??jF?C?????GA?HA?`E?kI?g@?WF?`W?sk?KB?LB?PA?_??E??kF?C?????P??R??po?oJ?lF?mF?QC????E@?eC?a??GM?MB?NB?aD?_I?nF?oF?q??{f@GA?HA?pW?OJ?PD?QD?aD?_F?E??pF?C?????E??qF?C?????E??rF?C?????E??sF?C?????PD?QD?a??oE?cB?~D?AC?{A?A@?B@?QT?OX?C@?D@?Q??OKItF?uF?q??_C?E??vF?C?????cB?~D?AM?wA?S??T??Q??[N?E??wF?C?????p??_A?q|?wg?E??xF?C?????P??}??pD?gM?yF?zF?@@?SL?\F?{F?`??SE?\F?^A?PD?[D?^F?_F?`@?SJ?i@?`F?pK?oK?aF?bF?PF?CN?A??|F?B?????cB?~D?qM?wA?E??}F?C?????E??~F?C?????E???G?C?????E??@G?C?????cB?uB?aE??K?AG?BG?AD????CG?DG?AA????EG?FG?AB?__?E??GG?C?????XC?YC?AS?gM?~??n@?Q??kbB~??o@?qA?ShBA@?o@?qJ?Ge?~??hA?a@?CLA~??~D?a@?[[@S??U??qF??T?E??HG?C?????A@?lD?QB?OK?g@?h@?`]?Se?g@?WF?pH?Wk?oD?Q@?QK?Cb@i@?`F?@K?oK?i??IG?B?????xB?yB?QC?Cs?cB?~D?q??sA?~??JG?q@?{ZCA@?B@?qE?kW?E??KG?C?????g@?WF?PN?_k?g@?h@?pT?Ke?A@?B@?aB?gW?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2400179189;
    let startMs = 1664313676168;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","libsystem_pthread.dylib","thread_start","_pthread_start","libjvm.dylib","thread_native_entry","Thread::call_run","JavaThread::thread_main_inner","attach_listener_thread_entry","libsystem_kernel.dylib","close","one.nio.server.SelectorThread","run","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","one.nio.http.Request","getHeader","trim","OptoRuntime::new_instance_C","InstanceKlass::allocate_instance","MemAllocator::allocate","MemAllocator::Allocation::notify_allocation_jvmti_sampler","JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector","JvmtiObjectAllocEventCollector::generate_call_for_allocated","JvmtiExport::post_sampled_object_alloc","libasyncProfiler.so","ObjectSampler::recordAllocation","Profiler::recordSample","JvmtiEnvBase::get_stack_trace","Chunk::next_chop","Chunk::operator delete","pthread_mutex_lock","OptoRuntime::new_array_C","CollectedHeap::array_allocate","ThreadHeapSampler::check_for_sampling","JvmtiObjectAllocEventCollector::record_allocation","ResourceObj::operator new","libsystem_malloc.dylib","malloc","handleParsedRequest","one.nio.http.HttpServer","handleRequest","one.nio.http.PathMapper","find","java.util.HashMap","get","getNode","one.nio.net.JavaSelector","select","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","sun.nio.ch.KQueue","poll","kevent","RequestHandler1_handlePutRequest","sendResponse","java.lang.String","equalsIgnoreCase","regionMatches","java.lang.StringLatin1","regionMatchesCI","java.lang.Character","toLowerCase","java.lang.CharacterDataLatin1","getProperties","Method::jmethod_id","ok.dht.test.gerasimov.ServiceImpl","handlePutRequest","ok.dht.test.gerasimov.ValidationService","checkId","java.util.stream.IntPipeline","noneMatch","java.util.stream.MatchOps","makeInt","java.util.stream.MatchOps$MatchOp","<init>","os::javaTimeMillis","libsystem_c.dylib","clock_gettime","advance_directory.cold.1","writeResponse","write","one.nio.net.Session$ArrayQueueItem","one.nio.net.JavaSocket","sun.nio.ch.SocketChannelImpl","sun.nio.ch.IOUtil","writeFromNativeBuffer","sun.nio.ch.SocketDispatcher","sun.nio.ch.FileDispatcherImpl","write0","read","readIntoNativeBuffer","read0","ok.dht.test.gerasimov.lsm.artyomdrozdov.MemorySegmentDao","upsert","ok.dht.test.gerasimov.lsm.artyomdrozdov.Memory","put","java.util.concurrent.ConcurrentSkipListMap","doPut","java.lang.invoke.VarHandleGuards","guard_LLL_Z","java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite","compareAndSet","HandleMark::initialize","isBlank","indexOfNonWhitespace","InstanceKlass::allocate_objArray","vframe::java_sender","compiledVFrame::sender","vframe::sender","CompiledMethod::is_compiled","_kernelrpc_mach_port_deallocate_trap","OptoRuntime::new_array_nozero_C","Klass::check_array_allocation_length","gettimeofday","__commpage_gettimeofday_internal","getRequiredParameter","getParameter","indexOf","substring","newString","java.util.Arrays","copyOfRange","jvmti_Deallocate","free","vframe::new_vframe","compiledVFrame::compiledVFrame","CompiledMethod::scope_desc_at","ScopeDesc::decode_body","one.nio.http.Response","toBytes","jvmti_GetClassSignature","Klass::signature_name","registerPendingSessions","java.util.concurrent.ConcurrentLinkedQueue","updateHead","guard_LL_V","setRelease","mach_absolute_time","ThreadShadow::clear_pending_exception","thread_self_trap","processDeregisterQueue","JvmtiEnv::Deallocate","szone_size","tiny_size","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ull, G1BarrierSet>, ","JvmtiEnv::GetClassSignature","Symbol::as_C_string","Arena::grow","processEvents","processReadyEvents","java.util.HashSet","add","putVal","newNode","JavaThread::last_java_vframe","JavaThread::pd_last_frame","ThreadLocalAllocBuffer::retire_before_allocation","jbyte_disjoint_arraycopy","libsystem_platform.dylib","_platform_memmove$VARIANT$Haswell","java.lang.Object","startsWith","processUpdateQueue","putIfAbsent","MemAllocator::finish","libdyld.dylib","tlv_get_addr","frame::sender","VMError::is_error_reported","java.util.concurrent.locks.ReentrantLock","lock","java.util.concurrent.locks.ReentrantLock$Sync","libnio.dylib","convertReturnVal","Java_sun_nio_ch_KQueue_poll","GangWorker::run","GangWorker::loop","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsTask::scan_roots","G1RemSet::scan_heap_roots","G1ScanHRForRegionClosure::do_heap_region","G1ScanHRForRegionClosure::scan_heap_roots","G1ScanHRForRegionClosure::scan_memregion","G1ParScanThreadState::trim_queue_to_threshold","void G1ParScanThreadState::do_oop_evac<narrowOop>","G1ParScanThreadState::do_copy_to_survivor_space","HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<true, G1ScanCardClosure>","G1EvacuateRegionsBaseTask::evacuate_live_objects","G1ParEvacuateFollowersClosure::do_void","G1ParScanThreadState::steal_and_trim_queue","java.util.concurrent.locks.ReentrantLock$NonfairSync","initialTryLock","java.util.concurrent.locks.AbstractOwnableSynchronizer","setExclusiveOwnerThread","JvmtiExport::record_sampled_internal_object_allocation","cpr","ok.dht.test.gerasimov.lsm.artyomdrozdov.MemorySegmentComparator","compare","jdk.internal.foreign.AbstractMemorySegmentImpl","mismatch","jdk.incubator.foreign.MemoryAccess","getByteAtOffset","guard_LJ_I","iteratorFor","sun.nio.ch.Util$2","iterator","keySet","InstanceKlass::signature_name","checkAccess","checkBounds","isSmall","isSet","one.nio.net.JavaSelector$1","hasNext","vframe::vframe","ThreadCritical::ThreadCritical","Java_sun_nio_ch_SocketDispatcher_read0","fdval","TypeArrayKlass::allocate_common","parseRequest","one.nio.util.Utf8","charAt","equals","sun.nio.ch.Util","offerFirstTemporaryDirectBuffer","sun.nio.ch.Util$BufferCache","offerFirst","free_tiny","tiny_free_no_lock","tiny_free_list_add_ptr","JvmtiObjectAllocEventMark::JvmtiObjectAllocEventMark","JvmtiClassEventMark::JvmtiClassEventMark","JNIHandleBlock::allocate_block","frame::sender_raw","frame::sender_for_compiled_frame","nmethod::is_zombie","JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector","OopStorage::allocate","toAsciiString","sun.misc.Unsafe","copyMemory","jdk.internal.misc.Unsafe","copyMemoryChecks","checkPrimitivePointer","checkPointer","G1CMRootRegionScanTask::work","G1ConcurrentMark::scan_root_region","_platform_bzero$VARIANT$Haswell","G1CMConcurrentMarkingTask::work","G1CMTask::do_marking_step","G1CMTask::drain_local_queue","void G1CMTask::process_grey_task_entry<true>","void OopOopIterateDispatch<G1CMOopClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","G1CMTask::make_reference_grey","G1ConcurrentMark::mark_in_next_bitmap","G1CMBitMap::iterate","G1RebuildRemSetTask::work","HeapRegionManager::par_iterate","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::do_heap_region","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::rebuild_rem_set_in_region","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::scan_for_references","void OopOopIterateDispatch<G1RebuildRemSetClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","OtherRegionsTable::add_reference","Mutex::lock_without_safepoint_check","InstanceKlass::get_jmethod_id","ObjAllocator::initialize","JavaThread::is_Java_thread","JvmtiEventCollector::is_dynamic_code_event","jint_disjoint_arraycopy","java.nio.HeapByteBuffer","toUpperCase","Dictionary::lookup","_platform_strncmp","java.util.stream.AbstractPipeline","evaluate","evaluateSequential","wrapAndCopyInto","copyInto","copyIntoWithCancel","forEachWithCancel","java.lang.StringLatin1$CharsSpliterator","tryAdvance","java.util.stream.MatchOps$2MatchSink","accept","ok.dht.test.gerasimov.ValidationService$$Lambda$77.0x0000000800cc8cd0","test","isWhitespace","JvmtiEventCollector::setup_jvmti_thread_state","unknown_Java","CodeBlob::is_zombie","os::malloc","_malloc_zone_malloc","canEncode","OopStorage::release","OopStorage::Block::release_entries","unsafe_arraycopy","java.nio.ByteBuffer","wrap","frame::real_sender","CodeCache::find_blob","CodeHeap::find_blob_unsafe","resource_allocate_bytes","ScopeDesc::sender","java.util.HashMap$KeySet","CardTableBarrierSet::on_slowpath_allocation_exit","CallTraceStorage::put","isAsciiString","jbyte_arraycopy","WatcherThread::run","WatcherThread::sleep","Monitor::wait_without_safepoint_check","os::PlatformMonitor::wait","__psynch_cvwait","ok.dht.test.gerasimov.lsm.artyomdrozdov.Storage","getSizeOnDisk","ok.dht.test.gerasimov.lsm.artyomdrozdov.StorageUtils","getSize","compiledVFrame::bci","ChunkPool::allocate","putBuffer","jdk.internal.misc.ScopedMemoryAccess","copyMemoryInternal","checkSize","GrowableArrayCHeapAllocator::allocate","RegisterMap::RegisterMap","PerfByteArray::~PerfByteArray","mach_port_deallocate","beginRead","OopMapSet::update_register_map","one.nio.util.ByteArrayBuilder","append","JNIHandles::make_local","checkPrimitiveArray","java.lang.Class","getComponentType","G1CardTable::is_in_young","AllocateHeap","default_zone_malloc","ScopeDesc::ScopeDesc","szone_malloc_should_clear","tiny_malloc_should_clear","os::free","void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>","void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>","FlightRecorder::recordEvent","JvmtiEventCollector::is_vm_object_alloc_event","tiny_malloc_from_free_list","chars","java.util.stream.StreamSupport","intStream","java.util.stream.IntPipeline$Head","nmethod::metadata_addr_at","JNIHandleBlock::release_block","frame::is_interpreted_frame","PreserveExceptionMark::~PreserveExceptionMark","ScopeDesc::decode_object_values","hash","hashCode","java.util.HashMap$KeyIterator","next","java.util.HashMap$HashIterator","nextNode","nmethod::metadata_at","ThreadCritical::~ThreadCritical","pthread_mutex_unlock","ImmutableOopMapSet::find_map_at_offset","nmethod::scopes_pcs_begin","Thread::is_Compiler_thread","java.nio.Buffer","checkScope","Profiler::getNativeTrace","jni_GetEnv","JavaFrameAnchor::make_walkable","Thread::is_Named_thread","InstanceKlass::array_klass","length","methodHandle::~methodHandle","checkBoundsSmall","Chunk::operator new","_os_semaphore_wait.cold.1","__commpage_gettimeofday","position","ThreadLocalAllocBuffer::set_sample_end","DebugInfoReadStream::read_object_value","ObjectValue::read_object","ScopeValue::read_from","void OopOopIterateDispatch<G1ScanCardClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","void G1ScanCardClosure::do_oop_work<narrowOop>","HeapRegion::is_obj_dead_with_size","isOpen","java.nio.channels.spi.AbstractSelector","PcDescContainer::find_pc_desc_internal","PcDescCache::find_pc_desc","one.nio.util.URLEncoder","decode","os::javaTimeNanos","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<598116ull, G1BarrierSet>, ","VMThread::run","VMThread::inner_execute","VMThread::evaluate_operation","VM_Operation::evaluate","VM_G1Concurrent::doit","G1ConcurrentMark::remark","G1CollectedHeap::resize_heap_if_necessary","G1CollectedHeap::expand","HeapRegionManager::expand_by","HeapRegionManager::expand","G1CollectedHeap::new_heap_region","HeapRegion::HeapRegion","HeapRegionRemSet::HeapRegionRemSet","HeapRegion::block_size","G1ClearBitMapTask::work","G1ClearBitMapTask::G1ClearBitmapHRClosure::do_heap_region","MarkBitMap::do_clear","BitMap::clear_range","_platform_strlen","java.util.ArrayDeque","pollFirst","startParsingRequestBody","java.lang.Integer","parseInt","digit","limit","CodeBlob::is_runtime_stub","remaining","getTemporaryDirectBuffer","java.lang.ThreadLocal","getMap","CodeBlob::is_compiled","JvmtiEnvBase::is_valid","ConcurrentGCThread::run","G1ConcurrentRefineThread::run_service","G1ConcurrentRefine::do_refinement_step","G1DirtyCardQueueSet::refine_completed_buffer_concurrently","G1DirtyCardQueueSet::refine_buffer","G1RemSet::refine_card_concurrently","HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<false, G1ConcurrentRefineOopClosure>","ObjArrayKlass::array_klass","_new_instance_Java","compiledVFrame::method","_platform_strcpy","JvmtiEnvBase::phase","G1BarrierSet::enqueue","JNI_OnLoad","MemAllocator::allocate_inside_tlab_slow","frame::entry_frame_is_first","jdk.incubator.foreign.MemorySegment","ofArray","jdk.internal.foreign.HeapMemorySegmentImpl$OfByte","fromArray","HandleMark::~HandleMark","PreserveExceptionMark::PreserveExceptionMark","getPath","checkBoundsBeginEnd","sun.nio.ch.IOStatus","normalize","ObjArrayAllocator::initialize","SharedRuntime::on_slowpath_allocation_exit","MemAllocator::Allocation::check_out_of_memory","endWrite","java.util.Objects","requireNonNull","java.util.concurrent.locks.AbstractQueuedSynchronizer","setState","addIndices","Recording::recordAllocationInNewTLAB","std::__1::vector<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample> > >::vector<std::__1::__map_iterator<std::__1::__tree_iterator<std::__1::__value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample>, std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample>, void*>*, long> > >","ClassLoaderData::holder_phantom","addCount","java.util.concurrent.atomic.LongAdder","JNIHandleBlock::allocate_handle","java.util.concurrent.atomic.Striped64","casBase","guard_LJJ_Z","java.lang.invoke.VarHandleLongs$FieldInstanceReadWrite","weakCompareAndSetRelease","semaphore_wait_trap","MemAllocator::Allocation::notify_allocation","CodeBlob::oop_map_for_return_address","Java_sun_nio_ch_FileDispatcherImpl_write0","pthread_self","G1ParScanThreadState::allocate_copy_slow","G1PLABAllocator::allocate_direct_or_new_plab","G1Allocator::survivor_attempt_allocation","javaVFrame::is_java_frame","java.lang.invoke.LambdaForm$MH.0x0000000800cce400","invoke","java.lang.Math","min","JvmtiJavaThreadEventTransition::JvmtiJavaThreadEventTransition","PLABStats::desired_plab_sz","void WeakProcessor::Task::work<G1STWIsAliveClosure, G1KeepAliveClosure>","G1KeepAliveClosure::do_oop","java.lang.CharacterData","of","frame::is_runtime_frame","DebugInfoReadStream::read_oop","oopFactory::new_typeArray","one.nio.server.Server","incRequestsProcessed","increment","jlong_disjoint_arraycopy","G1BlockOffsetTablePart::forward_to_block_containing_addr_slow","CompositeElapsedCounterSource::now","os::elapsed_counter","StackWatermarkSet::on_iteration","java.lang.invoke.LambdaForm$MH.0x0000000800ccc400","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800cce800","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<2646116ull, G1BarrierSet>, ","Arena::set_size_in_bytes","set_tiny_meta_header_in_use","coder","JavaThread::threadObj",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
