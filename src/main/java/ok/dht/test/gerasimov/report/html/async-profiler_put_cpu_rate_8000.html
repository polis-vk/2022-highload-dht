<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BFqVAT{@sM{N`Tx|AIAGG?PGH@HHA@@@GH@G?HQ@G?GPHG?P?GGIA@GGAIHHHH@H?IIPHOP@AQGAHQH@OPPG@@@ihaGAAHGI@GPO@@?@?HPG@?@GHG@H@GHI@@?H?@O@A?GG?PHGHA?IHA@HO?GHHGHIG@GA@GG?H?IGPG@@HG?O@I?HGHI@GI@HAPHHGQIP@PGA?I?IAHH?GHQH@?PH@I@G@H@OG@G@IGI@HG@@@@?Q@HI@?@IGQHQQH?@I?QA@HP@GG@H@@HP@G?QGjajhipAHPP?G?HGAHG?@@GHGGGGOGH?IHOPI@OH?GAHO@?H@GI?H?IGH?HHGHG?@PGGH@?I?GPG@G?@GG@HHOHHGG@@GHOHP@@HO@?@??HO@@@HGPAI@GOGHPA@A@@H@jajjh@HOHPHH@Q@?GH?AIHHAA@@GGGGHPGHAQG?@@GHHGP?IH@H@?PHA@AHHO@H@PH@?IHP?HAHIAHG@????SVT\LYQQHPOG@GGHAGGI@OGAG??GGHPOO?G?HGA?H?@HH?@@HH@G?I@@GHHH?@GG@GG@@H@GI@HOODT\Yxx^NNKHP@@?@IG?OHHH@@H?IPIAGHHHH?PIII?GH?P@HGHPI@IIP@GO@GH?PGHGQGH@?II@??IGGOHHAAHGKTWIGG?@GH@G?I?QHIGIO@H@G@HIH??@@@?@PAHGA?IAOHG@O?@@PP?H?HH?H@@GGGG?@OH@H@GOGOGH@GH?jjAHHH??@P?GGGP@IGH@H@@?G@@??OGIGGGHP@GGPI@I@HH?PAP@HO@?QGH@@?HPI?Q?GAH?H@GG@??HA?HajHA@H@HA@GQP@@OIGGG@GHGGAH@?HGH?GQG@@HG?OHAP??GH@?@OHAOP?@?OA?HHAA@H?@HAOAI@HH?@HOIG@H@?@@@O@@II@OHGG?QGGHIII@@IGQ@AGAHIHOHI@@Q@HHG?A??GOHHHH?H@?HII?OIAQP@H@G@I@OI@G?G@GIAOGOA@?H?HGH@KT\[KPHH@GGHHHGH?O?HHI@?@OGGHHGGIG@G@?GG??HHA?HHG?@G@G?GGH?@QGH@@GH?IHGGHO@I??A@GPAA@O?H?AHO?HAH??@@H???H?@?@H?GHHHHGPA??HH?@HGG?@ajhaI@GGG?GI@H@GGGH@GH@OIIAH?I?H@H?HHP@P?H@A?GOGG?I?@PO?@GGGHIGOH@?GPAGHGI?H?HH@GHPPIHKT\XOA?GGGGGHH?APOHHH??A@OPG?H@HPO@?H?GI@@A?GOH??H?H@HOHHOG?HOHH?HI@A??GG?IG@?@@I@?OL[KUKNLNNJpxQIHPPGA?IHAI?GG?GIOHGIHPOP@H@@HIAGGGHPH?@?OIP@HAHHHAA@IHO?@@GQHHH@?PHHIHPIHLRjPPGH@IGHIG@GHG@P?GGH?IHHHIG@G@H?G?GAPHHG?@PH??I@HHA@HIHHHIG@IA@GHH??HI@HG?PGHIHOHGIHHGOIOI?@@HH@HAHHHHIG??GPPGHO@PH@IOIHT[T\HG@HHGQ@IGOHP?@GOGGHAG?@HGPGPHP@@H@HngAngAuxAarAsuAktAczAkqA|{AsxAtxAgnAwsAidBt_BusA`pAadBcuByxA{kA_yA_jAouAvxA`kBmrBqrBgkAduA|yA|lAepAirAbtAqvAk{Av`BkdB~hBjrB{lAoqA|tArxAf`BqhB_jBhiAakAtkAqlAdrAftAhtA{tAfuAxuA~wAzxAiyAx|Aa}Aw}AoeBhpBcqBwqBorBnvBaiCahAiiAujAglAulAzlAhnAnnAloA`rAosAvsAjtAptApvArvAdzAvzAa{Ag{Ak|An|A~|Am_Bw_BqeBvfByfBkhBoiBmqBrrB{sBfiAliA_oAhoAkoAgpAupA_qAbrAerAgrA_tAitAruAswAnxA{xAbzAn{A}{As|A||A}}A~}A`~Ac~Ae~Ax~A|~Aq_Bp`Bw`BybBfcBedB~dBmeBnfB|fB_gBggB_iB`iB}jBqlBulBcnBgnB~nBqqBrqB|qBvuBtwBrxBkyBebClhAuhAyhAaiAmiAniAvjAilAjlAylAfmAtmAumA|mAbnAcnAenAfnA`oAcoAuoAbpAcpAfpAmpAppAxpA|pA}pAeqAmqAzqA{qA~qAfrAyrAasAhsAksAmsA`tActAutAvtAwtAytAztA}tAeuAquA{uA`vAhvAjvAlvAovAbxAhxAkxAqxAwxAayAcyAkyA{yA_zAezAgzAhzAe|Aq|Aw|Ac}Ab~Au_Bx_B{`BeaBraBibBsbBxbB_cBecB}cBbdBneBafBgfBqgBrgBsgBzgBbhBohBuhBxhBliB}iBijBujBxjB{jB_kBekBkkBqkBklB`mBloBnoBfpBjpBlpBqpBtpBwpBxpBhsBpsBbtBhtBvtBmvB|wB}wB_yBlzB_|Bf|B}}Bd~Bz~Bx_C|`CheC~eCgmC`hAghAshA_iAciAeiAjiAsiAtiA~iAejA{jAhkAskAvkAalAelAflAklAtlA}lA`mAemAgmAhmAmmAqmArmAsmAvmA}mArnA{nAroAsoAvoAwoA~oAapAhpAopArpAypAfqAiqAnqAtqAvqAxqAmrArrAsrA}rA_sAnsArsA|sAetAltAntAotA`uAbuAjuApuAtuAwuA~uAbvAkvAnvAtvA{vAiwAkwAlxAxxA~xAbyAsyA`zAlzAtzAzzA`{Ah{Ai{Aj{At{Ax{A~{A_|A`|Ab|Ad|Ag|Ao|Ar|At|Ay|A{|A_}Ab}Ai}Aj}Ap}Au}Al~Ap~Ay~A`_Ba_Bi_Bj_Bk_Bn_By_Bo`Br`Bz`BcaBhaBoaBuaBwaBkbBobBqbBzbBjcBqcBtcB~cB_dBcdBddBjdBxdBaeBfeBheBzeB`fBdfBifBpfBwfBzfB~fBcgBghBmhBnhBthBvhBciBjiBmiBniBqiBtiBuiBviBwiBziBajBjkBnkBvkBwkBdlBhlBilBslBtlB}lB~lBfmBjmBkmBmmBnmBumBvmBxmBdnBpnBeoBkoBsoB{oB|oB`pBcpBmpB|pBtqBvqBbsBjsBysBftBgtBauBguBhuBkuBkvBxvBgwBnwBrwBywB`xBaxBfxBkxBvxB~xB`yBiyBtyB|yBbzBvzBe{Bk{B}{Bh|Bg}Bm}Bu}Bc~Bk~Bp~Bs~Bw~Bf_Ch_Cb`CaaCoaCubCybC}bCbcCfcChcCpcC`dCndCqdCieCoeCwfCogCshC}hChjCqjCogAqgArgAbhAdhAehAfhAihAjhAkhAmhAnhAohAphAqhArhAthAvhAwhAxhA{hA|hA}hA~hA`iAbiAdiAgiAkiApiAqiAriAuiAwiAxiAyiAziA{iA|iA}iAbjAcjAdjAgjAijAjjAkjAljAmjAnjAojApjAqjArjAsjAtjAyjAzjA|jA}jA~jA`kAekAfkAjkAkkAlkAokAqkArkAwkAxkAykA}kA_lA`lAblAclAdlAhlAmlAnlArlAslAxlA_mAamAdmAjmApmAxmAymAzmA{mA_nA`nAanAdnAjnAlnAmnApnAunAvnAwnAxnAynA}nA~nAaoAboAdoAfoAgoAjoAmoAooApoAtoAyoAzoA|oAdpAipAjpAlpAspAtpAvpAwpA{pA~pA`qAaqAbqAdqAgqAhqAjqAlqApqAqqAwqAyqA}qA_rAhrAkrAorAprAqrAtrAvrAwrA{rA|rA~rA`sAbsAfsAgsAisAjsAlsApsAqsAxsAzsA{sA}sA~sAatAdtAmtAqtArtAxtA_uAauAguAhuAiuAkuAluAmuAyuAzuA}uA_vAavAcvAdvAevAgvAmvAuvAwvAxvAyvA|vA`wAbwAcwAdwAewAfwAgwAhwAjwAlwAnwAowApwAuwAvwAwwAxwAywAzwA|wA}wA`xAaxAdxAexAfxAixAoxA|xA}xAdyAeyAgyAoyAqyAtyAuyAxyAyyAzyA}yA~yAazAfzAjzAkzAmzAnzAozAqzArzAszAuzAwzA~zAb{Ac{Ae{Al{Ap{Ar{As{Au{Av{Ay{Az{Aa|Ac|Ai|Al|Am|Av|A}|A`}Ae}Af}Ah}Ak}Am}Ar}As}Ax}A{}A_~Ad~Af~Ah~An~Ao~Ar~As~Au~Av~Az~A{~A}~Ab_Bd_Bf_Bh_Bl_Bo_Bp_Bv_Bb`Bc`Bd`Bg`Bi`Bk`Bl`Bm`Bq`Bt`Bu`By`B|`B~`BgaBjaBkaBlaBmaBnaBsaBvaByaBzaB{aB}aB_bBabBbbBdbBebBfbBrbBtbB~bBbcBhcBicBmcBrcBscBvcBxcBycBzcB|cB`dBfdBhdBldBndBpdBtdBydB{dB|dB`eBceBdeBeeBgeBieBkeBleBreBseBueBveByeB{eB}eBcfBefBkfBlfBofBqfBrfBsfBtfB}fBbgBdgBegBfgBhgBjgBlgBugBvgBxgBygB|gB}gB~gB`hBdhBihBphBrhBshBzhB|hB}hBaiBbiBdiBpiBxiB{iB`jBcjBfjBkjBljBnjBpjBqjBrjBsjBtjBvjBwjByjBzjB|jB~jBakBdkBfkBlkBmkBokBskBukBzkB{kB~kB`lBclBelBjlBllBmlBvlBxlBylB{lBamBcmBdmBhmBimBqmBrmBtmBzmB}mB_nBanBenBlnBmnBqnBtnBvnBynB{nBboBdoBgoBioBmoBroBuoBvoBzoBbpBdpBppBrpBzpB}pB~pBaqBdqBfqBiqBkqBlqBnqBoqBpqBsqBuqByqB}qB~qB_rB`rBarBbrBcrBerBgrBirBlrBtrBvrBwrByrBzrB{rB}rB~rB`sBasBdsBksBlsBosBtsBvsBwsBzsB~sB_tB`tBetBitBltBntBptBrtBstButBwtBxtB{tB}tB_uBeuBluBnuBouBquBruBxuByuBcvBevBfvBgvBivBovBpvBqvBrvBvvBwvByvBzvB{vB|vB}vB~vBawBcwBdwBfwBiwBlwBmwBowBpwBqwB~wB_xBbxBdxBgxBhxBlxBoxBxxB{xB}xBcyBdyBeyBfyBgyBlyBnyBpyBqyBryBsyBvyBzyB}yB~yB`zBazBczBdzBgzBkzBnzBpzBtzBuzBwzByzB{zB~zB`{Ba{Bb{Bg{Bi{Bm{Bq{Br{Bt{Bv{B~{B`|Bk|Bm|Bn|Bo|Bp|Br|Bs|Bu|Bv|Bw|B||B~|Bd}Bi}Bk}Bo}Bp}Bq}Br}Bv}By}Bz}B|}B`~Ba~Bh~Bj~Br~Bu~By~B`_Cd_Ce_Cj_Cq_Cs_Cu_Cw_C~_C_`C``Ce`Cf`Cg`Cl`Cm`Cp`Cs`Cu`Cv`Cw`C{`CbaCcaCdaCfaCgaCiaCpaCraC_bCabCdbChbCkbCnbCvbCxbC{bC_cCmcCncCocCrcCtcCxcCzcC}cC~cCbdCcdCfdCmdCodCpdCtdCvdCxdCydC}dC~dC_eCgeCjeCneCqeCseCteCueCxeCyeCdfCefCjfCkfCufCxfC_gCcgCjgCsgCwgCygCzgC{gC|gC}gCbhCnhCohCqhCyhC_iC`iCbiCtiCwiCyiCajCfjCkjCljCpjCtjC}jCckClkCqkCwkCykC~kCalCdlChlCrlCslCulCxlC|lC`mCemCpmCsmCzmC`nCcnCfnC`oCdoCioCnoCuoCpgAsgAtgAugAvgAwgAxgAygAzgA{gA|gA}gA~gA_hAchAhhAzhAoiAviA`jAajAfjAhjAwjAxjA_kAbkAckAdkAikAmkAnkApkAukAzkA|kA~kAllAolAplAvlAwlA~lAbmAcmAimAkmAlmAnmAomAwmA~mAinAknAonAqnAsnAtnAznA|nAeoAioAnoAqoAxoA{oA}oA_pAkpAnpAqpAzpAcqArqAsqAuqA|qAcrAjrAlrAnrAurAxrAzrAcsAdsAesAssAtsAysAgtAstAttA~tAcuAnuAuuAvuA|uAfvAivAsvAvvAzvA}vA~vA_wAawAmwAqwArwAtwA{wA_xAcxAgxAjxAmxApxA`yAfyAhyAjyAlyAmyAnyApyAryAvyAwyAizApzAxzAyzA{zA|zA}zA_{Ad{Af{Am{Ao{Aq{Aw{A{{Af|Ah|Aj|Ap|Au|Az|Ad}Ag}Al}An}Ao}Aq}At}Av}Ay}Az}A|}Aa~Ag~Ai~Aj~Ak~Am~Aq~At~Aw~A~~A__Bc_Be_Bg_Br_Bs_Bz_B{_B|_B}_B~_B_`B``Ba`Be`Bh`Bj`Bn`Bs`Bx`B}`B_aB`aBaaBbaBdaBfaBiaBpaBqaBtaBxaB|aB~aB`bBcbBgbBhbBjbBlbBmbBnbBpbBubBvbBwbB{bB|bB}bB`cBacBccBdcBgcBkcBlcBncBocBpcBucBwcB{cBgdBmdBodBqdBrdBsdBudBvdBwdBzdB}dB_eBbeBjeBpeBteBweBxeB|eB~eB_fBbfBffBhfBjfBmfBufBxfB{fB`gBagBigBkgBmgBngBogBpgBtgBwgB{gB_hBahBchBehBfhBhhBjhBlhBwhByhB{hBeiBfiBgiBhiBiiBkiBriBsiByiB|iB~iBbjBdjBejBgjBhjBjjBmjBojBbkBckBgkBhkBikBpkBrkBtkBxkBykB|kB}kB_lBalBblBflBglBnlBolBplBrlBwlBzlB|lB_mBbmBemBgmBlmBomBpmBsmBwmBymB{mB|mB~mB`nBbnBfnBhnBinBjnBknBnnBonBrnBsnBunBwnBxnBznB|nB}nB_oB`oBaoBcoBfoBhoBjoBooBpoBqoBtoBwoBxoByoB}oB~oB_pBapBepBgpBipBkpBnpBopBspBupBvpBypB{pB_qB`qBbqBeqBgqBhqBjqBxqBzqB{qBdrBfrBhrBkrBnrBprBsrBurBxrB|rB_sBcsBesBfsBgsBisBmsBnsBqsBrsBssBusBxsB|sB}sBatBctBdtBjtBktBmtBotBqtBttBytBztB|tB~tB`uBbuBduBfuBiuBjuBmuBpuBsuBtuBuuBwuBzuB{uB|uB}uB~uB_vB`vBavBbvBdvBhvBjvBlvBsvBtvBuvB_wB`wBbwBewBhwBjwBkwBswBuwBvwBwwBxwBzwB{wBcxBexBixBjxBmxBnxBpxBqxBsxBtxBuxBwxByxBzxB|xBayBbyBhyBjyBmyBoyBuyBwyBxyByyB{yB_zBezBfzBhzBizBjzBmzBozBqzBrzBszBxzBzzB|zB}zB_{Bc{Bd{Bf{Bh{Bj{Bl{Bn{Bo{Bp{Bs{Bu{Bw{Bx{By{Bz{B{{B|{Ba|Bb|Bc|Bd|Be|Bg|Bi|Bj|Bl|Bq|Bt|Bx|By|Bz|B{|B}|B_}B`}Ba}Bb}Bc}Be}Bf}Bh}Bj}Bl}Bn}Bs}Bt}Bw}Bx}B{}B~}B_~Bb~Be~Bf~Bg~Bi~Bl~Bm~Bn~Bo~Bq~Bt~Bv~Bx~B{~B|~B}~B~~B__Ca_Cb_Cc_Cg_Ci_Ck_Cl_Cm_Cn_Co_Cp_Cr_Ct_Cv_Cy_Cz_C{_C|_C}_Ca`Cc`Cd`Ch`Ci`Cj`Ck`Cn`Co`Cq`Cr`Ct`Cx`Cy`Cz`C}`C~`C_aC`aCeaChaCjaCkaClaCmaCnaCqaCsaCtaCuaCvaCwaCxaCyaCzaC{aC|aC}aC~aC`bCbbCcbCfbCgbCibCjbClbCmbCobCpbCqbCrbCsbCtbCwbCzbC|bC~bC`cCacCccCdcCecCgcCicCjcCkcClcCqcCscCucCvcCwcCycC{cC|cC_dCadCddCedCgdChdCidCjdCkdCldCrdCsdCudCwdCzdC{dC|dC`eCaeCbeCceCdeCeeCfeCkeCleCmeCpeCreCveCweCzeC{eC|eC}eC_fC`fCafCbfCcfCffCgfChfCifClfCmfCnfCofCpfCqfCrfCsfCtfCvfCyfCzfC{fC|fC}fC~fC`gCagCbgCdgCegCfgCggChgCigCkgClgCmgCngCpgCqgCrgCtgCugCvgCxgC~gC_hC`hCahCchCdhCehCfhCghChhCihCjhCkhClhCmhCphCrhCthCuhCvhCwhCxhCzhC{hC|hC~hCciCdiCeiCfiCgiChiCiiCjiCkiCliCmiCniCoiCpiCqiCriCsiCuiCviCxiCziC{iC|iC}iC~iC_jC`jCbjCcjCdjCejCgjCijCjjCmjCnjCojCrjCsjCujCvjCwjCxjCyjCzjC{jC|jC~jC_kC`kCakCbkCdkCekCfkCgkChkCikCjkCkkCmkCnkCokCpkCrkCskCtkCukCvkCxkCzkC{kC|kC}kC_lC`lCblCclCelCflCglCilCjlCklCllCmlCnlColCplCqlCtlCvlCwlCylCzlC{lC}lC~lC_mCamCbmCcmCdmCfmChmCimCjmCkmClmCmmCnmComCqmCrmCtmCumCvmCwmCxmCymC{mC|mC}mC~mC_nCanCbnCdnCenCgnChnCinCjnCknClnCmnCnnConCpnCqnCrnCsnCtnCunCvnCwnCxnCynCznC{nC|nC}nC~nC_oCaoCboCcoCeoCfoCgoChoCjoCkoCloCmoCooCpoCqoCroCsoCtoCvoCwoCxoCyoCzoC{oC|oCswA???????gAqH?????cD??fA?rH???]???lD?????gA?pH?vH??rD?mA??Z?`IqH?Z???g@???mD???lDgA}TE?A?~S??lDaE?~P?nRgA??vH?rH]???CA?????fAC?A????v@??AhJB?]?CC?JoHBC???IsJII???uBxEyEuBI?@@H@G@Au@h@???A?J?BCB??B???i@??sW??B|ICAC?BBB?A??]AB?B?????AwBCAqBCwBA?ACB?BA??BC?C?IB??C??]B??B?JCdEoAAB?h@?dECC?Bg@a@?C?vI???BxBpJmAA?ABA??B?C?y@A?F??A[??BCeAAa@RBgDDsB?????B?bK?BAh@fAbFu@??AFvD?D????D??CL?C?`IoBD??uIsBAFBD?????D?BoEB??CBBABArDAC?B?ABAA??DADBCB?A?EEEB?iDbFDIi@?DADCoA?C?E|BBC??ACc@EDD????oABD?BA}BxA`@??t@DBoAB?B|Hi@S??DB|Y@@@@@@@@G@@@@j@@@@@@cL@G@?@@@@d@k@j@@?G@G@@@?@@@@@j@@@@@HrL@y@?E_FCz@BBZV?C??A?CBC??A?F?oAu@???CyDh@{B~@AEJ??gBAAu@?B?B`@O??Ax[a@CvFzA??AJBACC??C?CLAqDCFB??cDBdE~@JA?????Ab@AADBOC?B??AwB?yAy[??CCA?B??~DfVACA?BB????Ab@?mE?c@???BAAkJ???CApAA??mC??g@?eU?zBLAuFBh@EC??CBCVC?wKF[@@@@?@@@@?@@@@@@@@?G@@@@@W@@@?@@@@@@@@@@@@@@@@@@@@@@AiH`B?yAKBAeA^BCCoL??b@C?A??CC?BcG?J?oC?sBC?vLABDwK?AAJ?mB?ACBA??BCy@??B?BtAC}BBAy@CfCE?CJ??ABCAe@B?gByY??QSiLl]B?gDB?CC?B?AC???A??C?sDA?xABALiC?BAk@?BCBLkG@@@HfGG@@@@@@@@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@j@@@@xE????C?S??????CtCA?A?E?DB??ACCsC?BeN?}B?tCJ~@AfDb@A???tM?BAr@a@K????BA?A?lGvKb@?CA??Ac@]C?AAxLO??BFAi@eFAAAi@?B?Bv@???i@??lMAB?@@@@@@W@@@H@@@G@@@GH@W@@@@@@HH@@@@???B??wC?xCmN??wCO?yCxCcBa`@?sC?e`@?k`@Xf@X?f@Cf@XbAt^?X???k@l@k@?B?CA?BCCb@FAiH?aF?kC?mL?s^lG??{MKDD`QISOE?AnJ?AD?EjCA?BB?Ac@LDCCDd_@ABIy@??D???CtAt@AAR?yLbBDBBBDCz]ByKCvA?CB?DB??BaEBpAA??w`@_NLC??BE`KZ?ABCB?eKCACEbBvAEApADBCBBsErE@@?@@@@@@@@H@@@@@@@@@PCmJK?Ak_@A?sCgV??jN`MAF?B??BA?AFB?C??R?AAuFBB?ABIE?????B_F?b@ACA_AiUI??B?zCAv@A????U_LAC?F???A|Bc@??BDb[iE??B?xDLBsA?A?mA?zBBCA?B`@C??rAE?@@@@W@@d@d@@j@@G@@@@@@@@@@@@BBBB{Bp\?eB???BA{F?CBFEBD?wJlNCChEA??uCCCwGCAJC??cGFAIKA?E?N?CL?qG????{NB??P|AeNJB??db@?Apa@uFI?B?CmABCA??cCNu`@SA???O{M?L?OC?kGE?????bFkc@eL|a@B?Af_@?@@@@d@@H?@@j@@?@W@@@W@?vAAA???A???aMbMCpN?~FlEvLA?CK?AFl@?zB?oM?aFA?kJlOxM??PAF?C?CCBxD?AwBAAfKlNC?CCC`@CCCIpJ?Kh@?CSBBK`BAzA??FA?OCB?CA?BsBc@AzM?_ABB?KjVAeB??rOBCAAQ_AER???BAb@?qC??yA?vXBARB{GAAF?F?l@AC???kGPcH?fD{B?CR?sC?fM?DD??AtAKrFcA?CCD?DABDSC?CmMFcLADhFDC?jGElO?DDAAAA}a@{NEuOCPCD?BwAFCbB~@?BiGB[|LA??|ABjFK|AC|A??qOvNB?DBFe@{d@CB???sD?u@DBEC?C?AA??c@BDl@BZaHBxAw]?Bd^`F?DBnHAsOACC?B@HH@@@G@G@?@@@@@@@@@@@@@@@W@@@@WfG@@@@@@@@W@?@@?qDtC?sb@?CBv@{APA?sO?ABaV?b_@?B???EKCcE??zB?bNC?A?CBE?Aud@zAACAq@tABkN?`KLC?uXR?B?C???AeBa@Ig^BD?FPIAAaE{CoYvJ??gf@Fe@CiLIBhM?BAADra@?AeB?KCBhEC???ACABAAC?cHEDSe@id@AvAiYBq@DBzCCuOAO?tLA??tE~IBCCAA?hABbB?CmAA@@@@@@@@@@@@@@@@@G@@@cO@@@@@@@xEyE@uB@Al@AACgNi@?AAA??mF??~@OpNPyD??`A?BeHZjCfa@ld@??vGrF?P??zArD?y@?A?AwAub@?LCe@F}M`c@sD?pc@BEABe@?AEB?{^BlMBhGt@gg@C???BCBAg@?BjGJB?A?BBCBCBhN?zf@B}OAA??BC~C?AAyFCA????A?Cm@cO@W@@@@@@H@@@@@@@@@@@H@@@@fG@@@?@@@?C??L?td@_A?oe@jNB?A?APCdG}K}KBACBfH`A?C?hYA??ZS?BC?yF?C{G`A?eHe@tO?BeZB?B?vJ?BC`FLjF|b@?xG{f@nMAcA?AtE?J?AKDEA?`GAnYCE_PvMwGwf@?dN?pf@vBBBAA?eBAzABpBAKCeL@@@@@@@@@@@@@mO??ng@??aAwCnNFmN?dAwCdAdAaA~g@?q@?jPdA?yCnNdAyCdAk@YBYY?bAXYhNXm`@dB?YdBbAf@X?bh@XbAdBbAf@XYf@DYdB?k@?BDBCCCcG_Y?yDFC?jG?AjCB?v@Brf@mO?ZA`A_Z{GD?DfKeACBfH?BEe@BEA}R?s@?CECB???CpOBAB??CwG}MB?PcAICFlP??ed@zG{CAoG??gA???B?BL~NyA{A|BD?UDC?AD~CBZ???C??sc@?DFAgB?zGFDk@?AaHADC?cAAzCD???gOB?yOABG@@@@@@@@@@@H@@@@G@@@@@@?A?JoC{g@ve@h@CEKECFmg@bMuGA~CBy]Bkh@BhGABCCABl@Ctg@B?kE}L?tK???Ck^qb@?gPog@yOgOB?CzGNKc@{UcHvACa@?FNBtc@?t@wJ?AfHJtC?_NBhh@?BBrOAOCpb@?jf@?lP?A??CvO?aMBObC?]A???_AA??FBic@cD~h@??AeKBBLC?Q?C{@cAgPvg@~\ApY?CDqO_i@?NDm[?BB?DiNA?DJCth@C~NrFABC??AP?CoCNl@AB?AC_KBcA{h@cJ?|XDBuh@m@oCx\?FD?B~AB?df@BDxN?@H@@@G@@@@@@@@@@@@@@@@@@@@@@@@@@@@?dP?yEuBC?C?AdMF?CSlG?yKBhCuT}h@_AFtABEyFoh@B~CCpLC?OB?A?Aai@A?aBCB?ACCDAz@SCee@A?C?PC?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@?d@?e@?f@?g@?h@?i@?j@pPUqPWsPY?k@?l@?m@?n@?o@?p@?q@|Pe@}Pg@?r@?s@?t@?u@?v@?w@?x@?y@?z@?{@?|@?}@?~@?_A?`A?aAaDbA?cA?dA?eA?fA?gA?hA?iA?jA?kAaDVrPXjHlA?mA?nA?oA?pA?qATWaQk@?rA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~AxQXjHk@yQsA{QuA}QwA_RyAaR{AcR}AdD|@jQ~@lQ`AeDYbQrA?_B?`B?aB?bB?cBo@lAuQnAwQpA?dBuHmAvQoAsHqAmQcAnQeApQgArQiAtQkAdDeB?fB?gB?hB{Pd@kHf@`DiBTjB?kB?lB?mB?nB?oB?pB?qB?rB?sBbDq@mHtB?uB?vBfAw@iQy@TwB?xB?yBiR}@kQ_ApHaATzBzPc@zHuB?{Bo@k@cQm@lHo@yHd@uRg@nHs@?|B?}BpRdAoQfAqQhAsQjAiAl@dQn@?~B?_CaSe@gQr@fB`CoRnAmRqA}HeAqRhA~HkATaC?bC?cC_DdC?eC_Sd@hDr@fB|B?fCiArAzQtA|QvA~QxA`RzAbR|AdR~Ap@gC?hC?iC?jC_If@`Dr@jDfC?kC?lC?mC?nC~R~@jRaAfIsAeRvAhSyAgR|AbIbC?oC?pCbDqCoStAgSwAtHrC?sC?tC?uC?vCxHwC?xCcSm@lH~BdSyC?zCmSg@jAt@n@v@oHx@gBz@hIuAfRxAiS{AhR~AiIn@eQp@fQd@eIs@?`C|SvApSzAjS}AiB~BxSzChBr@nDkCoD{C?|CkA_AlAcCfSeCdIe@?tBhA}CeSfAbSiAlAoCrS~Cq@b@tRe@iDs@g@fC?_D?`D^aD?bDp@fBwHhBoItBhAvBfDx@RcD?dD?eD?fD?gDnIhDhTc@mHf@mDs@rIgBsRc@?iDbT_C?yCySp@_Te@tD|BkDkCoDmC?jD?kD}HlD?mD?nDNc@lTg@jAoDsIyCoTq@tIr@lI`AlApDjIs@uD}B?qDlArDfTgArRjA?sDaIoAsHtD?uD?vD?wD?xD?yD`TwAtHzAaT~ATzDwHc@wTs@EaAkA{D?|D|Dd@jB|B?}D`EgBoIf@fI_B?~D~Td@oB_Eo@`E?aE?bE?cE?dE?eE?fEzThA~HgE?hE_ExA}S|AfUyAqS}AbEzAlAiE`Ue@{DjExTp@zDtBhA{BgU{A{HkE?lE?mEmThB_Ug@jA`CkU|AiInE}D|BlUc@nA|BkD_D^nC~Iq@nAoE_@pE?qE?rEwIpAnU}AMqAkAsE?tE?uE?vE?wE?xE?yEeEfCnSlCpD`D?aDkBzEdUiApUd@oBfCgEiDyUjAr@e@{DfCt@kA_@~D}If@lB|B_J`DvDbD?zEsUtEtUvEaJ{ErBf@dJfCgEmCqTkD?|E?}E?~E?_Fo@`F?aF?bF?cF?dF?eF?fFrBtBcEv@{Sy@vTzChBh@wIb@mUr@nD}BhUgBhJs@hQu@iEg@jA|BpTlCpDnCpA~AgIhCkSjCbD~C?qCUr@jD}Dp@gFmI^?dCcIp@jUuB|Rv@qUd@jB`CMtDxIvDyIxD~DhF?iFcJgB`Vp@lJ{BjTy@nVc@fEfCpBc@uE_D^`D`@bD?jF?kFp@lF?mFo@ZtP\vP^wP`@yPb@iTuB|Hv@|UuEuUwEvUyEqBnFmPBnPD?oF?pF?qF?rF?sF?tF?uF?vF?wF?xFuVCoPoFwVqFyVsF{VuFrJyF?zF~VDvVpFxVrFzVtF|VvF}VxF?{FtBoF_WrFcWuFrJwFgWpFbWsFaWvFeW{Fx@qF`WtFdWwFsJ{FwErFhWvFkWnCnWsFjWwFmWnCoWtFlWxFfWnCtJuFiWxFpWvFzEwFj@xFG{FHnCw@s@uD_D?nFV|BkD}BoVd@jBt@zSw@gDz@nB|D_@|FvBe@tD`CrEe@{D}DuH}F?~F?_GyHiDVt@n@nCpV[uP]_D`GdIaGaDbG?cG?dG?eG?fG?gG?hG?iG?jGiBp@zDf@jEkCcTjFQfCkEjDrT|EmE~EdVc@uEkCmBnCyTcBbJe@MkG|Ef@lB`CzIaEaUcEcUeE?lGmJuD{TwD|TyD~E\qV_@xPa@dTf@|WlCpDjD~W}Eu@_FoUp@lJmG?nGvWcGwWeGxJoG?pGtW~FuWp@{Wg@iJfCsEq@nAt@n@qGqEdCcIb@eV|BpEmC}U|E`F_FMdBlXd@s@rGw@sG?tG_EuG?vGnJd@s@kCnXeC\kCjJiClSp@}Jr@fBoDvBwGr@wGV`C`Xg@wA_DvEaDkBjF}Ef@lBoDuAf@hXmCbIxG?yGkX_G?zG?{G}ItBhAmGzWq@mXu@tEz@oXe@iD|GaKb@xAfCQjEnIpCjIt@}EtBwXg@yBr@nD_DNd@yJd@s@}Bt@gExXg@fFr@fBt@{@s@\_DdKbD{@}Gr@aGtVvEaJxEwUp@bKs@{Ar@o@~G?_H?`H?aH?bHhKzGyXgBjKkCmB`DsAzE_@cH?dHnKs@MeHkVwDdXhFrK{GzUg@wA}BVoD?fH|JdG?gHkKp@pK|B~JnC|@|BhFq@fE}DjJhH?iH_ItByA}CiKtB?jHzJvDyIkH?lH?mH\nH?oH?pH?qHkYiHhBR`CfCgE{CtKuBiVw@sXlCiBrH?sHuId@oB}DqXe@qAkCz@}GuAtBoEtHgYgBxAjEiKf@gKnCqYp@xYg@|BqDaC}BzXd@qWu@xKf@}@|B_JnFmKaGQ}D{Yg@cK`DoK`DrAjFzJuHiAvH?wH?xH?yH?zH?{H?|H?}HdF~H?_I?`IbJaG?aIiAbI?cIRkBvRmBwRoBxHqBzRsBhBs@aKp@_CfCkEnCtXjCeE}DiFr@jYd@|@`CbY_HcYdItYsHmKe@uYlCeDeI?fI?gI?hI?iI?jI?kI`YwE?lIlYwD?kHuKmHtBmI?nI?oI?pI?qI?rI?sI?tIpBuIuAjH|EtBsTmDtTvIfZs@{E`DrAzE?wI?xI?yI?zI?~CaI{I?|I?}I}Dt@rWx@zKq@zHvB|Ke@kFmCyZd@eIsG?~IqZnD?vInEaF~UcF?_JM`JeCaJxDbJ|Ze@hLf@bCmCwYc@oJnFp@cJ?dJaC_D{Kr@jDjEMeJ?fJ?gJ}Zg@_[r@lK`DvDzEaLxEaYq@tIReAhJfCs@{EiJiFjJ?iBcFbEbUdE{IfEbLnIlZpInZrIpZtIgZe@qA_DkLf@jE_DgFkJeX]_D_@fXb@`Lf@gK`D{@oD~Kq@_XlCxUaD~Zd@s@_DoFnCmFuBoFjDiX~EqKs@rZ`D`@lJ?mJMnJh[g@zEyFHoJ?pJ?qJ?rJ?sJ?tJ?uJ?vJn[pJo[rJp[wJ?xJHyJbLzJ?{J?|J?}J?~JgC|BfL_KaCkCaZlB?`K?aKhZzC}D`C_Lp@pK`Cu[lC~BbK?cKbXfE?dK?eK?fK\}BkAgKhC|B|JhKvZ|IwZp@dC_DzZf@lLnFQiDsIp@dC}BeCiK?jK?kK?lK?mKNkDlE}E?nKnLe@qA}BrKoKkTd@~EpK?qKqIfD?rK~[}IqB_DuJsK[uBsYx@uLmC_K}ERtK?uK?vK?wK~AfCgT`D^xK?yK?zK?{KcCfC{L`DqKsG?|K?}K_@~KiBo@qLr@kIlC?{C}AkDz@u@pX_L?`L?aL?bLwFcLqIdL?eL{KjJiCjEiCfC]qDf[^rVa@gXg@`JfL?gL?hL~Y`IjLcEaXfE}@t@xZy@e[g@[mG_EiL?jLpF`D?kL}[lL?mL?nLiAoL?pL?qL_@rLdL|BpEjF`[yEqB}BqFs@uDkC~@qDxKtBn\p@Q_EkC{B_B_DvEsL`JqE?tL{FdE{InGlFxD{\r@}@`CaB}Dd]s@_]lCmLbDa@kFcFuL?vL?wL?xL?yL?zLlFkHuK{LgCt@?|LwL|ElC}B{ARb\jKc\lK?}L|F`D?xK`BzK?~LhKp@}J_MgM}EkCvBfA`Mf\p@dC_Ec]yD?aM?bM?cMxB|K?dMfCsGnEeM?fM[_M~Ls@rBuBpAgMy\u@?hMdDiM?jM?kM?lM?mM?nMaGq@uE}BnCv@v@z@z[cK{[dKjCfKaBfCvKjFpIgBnTd@rLoMd@zFd@pM?qMzEpMVoE?rMzF_@g[c@sFxK?sMhLtBURtLq@sFmCu]d@k[`D^bDqChBjK}B~]`@sVc@sF{C`LtB_MtMfJuMgJvMqFwMiGc@}FoEgGh@~BeGxJxM?yMlFzMmViFe^d@rXlC{F{M?|M?}M`Mp@_^d@qFsGmC_MmI~MeGkCM_NpF~E`ZcIbG|B_G`Na\q@oJ`DpL_FsLmBbZpByRrB{Rp@zDaNtMq@`^`DsAjF}F|B|@oEhC`C}\mL?bN?cN?dN?eNdGfN?gN?hNqMuBqJw@`\g@`C}BiC}D|Mr@uAiN?jNv]w@zFdChVq@{X|L?kNtBlN?mNs[}J?nNp]jMq]oN?pNe\gB{]e@xLqDm@qNkLtBoEw@rC}DgCoDb]eEx]eKoF`DfLbFfJdFgJfF?rNz^hBuCaDkBiDpMsN|@t@wEtN?uN?vNeG_DdKzExBtGvYmGcFwNbExN?yN?zN?{N?|Nq^bNr^dN}A|C|@}Na]q@x^kNmM~NeFkDvFnKxFkC_FkFlI_O?`O~AjEbG`CzLjDf^fGxWhG?aO?bO{Ah@}A`DsAkFtF{BRcO?dO\nFeDeOeG}B__@bDhGS?hJqEfOyBjJQgO?hOi]q@nA`CoMuBh\y@rCfC[iO}AnCgMnKyMfCsEjOh^e@g]vL?kOrIjOoLkDvF~ElC_DuJ~E~Ms@g@}BpIhB~Fv@bC{Ca@|Cy^kMr]lOwDmOvMd@sMmCi\~EnFvIm@aMnMcMkCmG?}Cz@nOx@oO?pOw_@pOx@qO?rO?sO?tOx_@rOy_@tO?uO?vO?wOcBsOz_@uO}_@wOxCtO|_@vOcBxO{_@yO_`@uOaAzOaAuO``@vOcBaIx@{O?|O?}O?~O?_Pm^nBxRpBn^sBg\`Db`@|Od`@~Oi`@}Oj`@~Of`@`P?aPf@_P?`PX`PzMgNbAaPf@zFY}C?bP?cPdBdPx@ePc`@fP?gP?hPn`@|O?fPo`@hPq`@fPr`@aIbVc@fEjEpMe@qA_E}]rMp@iP?jP?kPfYuDcXlPu_@bM?mPl^lC~BnP?oPvCcNfNaDkBkFr\`Ls\bL`]uBj_@i@d\f@lL`D\pPxF_D^kDqG_FpBqP?rP}^lG|IdKp^d@hDh@_Qj@}Y_I?sPc_@yN`a@e@d[`DrG|B~^c@wMnCuClJnG_DgFjFlCkC?tPs_@e@sNnCgNjFw^eCeE_EwFqKxGfCoNf@qNnF~KuP_GrEhCt@?vPg`@oBcZrBo^q@`SvBpC|BsG`MnFcBuGvDlVyDk]bM}Ft@n@|LtGiDVnOp_@|E_@`BkRbBsKwPj[d@a^kDlExPea@f@i[aDpFnFd@dPxF}BtFmGyGkCmBjDjLyP?zP?{P?|P?}P?~P?_Q?`Q?aQvCbQ?cQ?dQeFc@sL`Kv[cBt`@d@s@lCy`@dN?eQE`OdFfQyG}Bz@vPxBgQdGlG_a@eKhIhQ?iQb^a@u\r@o\mCia@g@wAkCua@kDqGjQqa@e@qAnHfN|CaBkQyG_DgFlQga@p@dCkC`CkQza@e@x`@mCq@mQla@pBh`@p@_C}B~AgOj]v@|DiDrNf@jE}B}@oDeMlH?nQj\uK?oQ?pQ?qQ?rQuMe@eTuBqJ`MdL`CvGbD?lQnb@g@gC`Cab@r@yNnCfFjJe_@d@{BqDoKnF?sK}NtBcEsQt\eDrb@r@yN`DiMxKkM~L_b@b@dYlC{J|EaOs@|^uB?mGrBtQ|C|B~J`Dkb@qBdZp@_C}D{CvK?uQca@`D|]qMxa@d@sa@g@bb@lC|MReAvQw[p@ib@lC{JkDwLwQ?xQgLfD?yQ_Os@e]mC^|Ca_@`DrAkFnG}B}Ge@dOr@wb@aDbc@`D`@|CgIzQ?{Q?|QUh@xb@c@wM`DjMyK|L~LnB}Q?~Q?_RjXq@{`@g@qDu@?qGQmJbCjDyb@rBma@d@sM{CdM`R~A}DbOfC}WkD|EiNr@tQrMcF_VaR?bRw@t@vCcRrEsN{CoQ?dR?eR?fRr@gRdc@f@|`@kDThRr_@lMs]nM?iRqN`Dtb@e@sN`D`@jRec@s@vIqDzF`G`b@s@xc@mMt]fK}c@nMyc@fK}b@q@uAaNkK~CTkRvb@uBlc@d@t_@nChOr@cVqDhc@d@?lRvCmRh_@`On_@d@hDRVnRsGw@eb@f@jc@~Qq_@`D}CoDq[qJ?oRGnCHoM`_@uN?pRaNnNNnFrC|Gaa@zNrCjEzc@`DsAlQcd@g@iJjEUjJoc@sBiZfIjZqR?rR|FkDjd@p@aGmQ\rGdOjJeOyQTsRk\oQuc@eRvc@tR?uR?vRiEwRfOaDhEwIsZyIuZ~Cad@s@ac@`D}Ct@n@}GzL`DxMkFhd@r@~Xu@?}G_B}Bha@eDoG_D}`@|EmEjQ~GkC{c@f@rGt@z\z@zN`DnCqGsKdHnO`C~G}BQxR~G_DvExKuNu@zd@nCgLdLcM`DrAlQ?kJqCmQod@uKl\yRda@lCeObJqM{B~c@d@bHkDxNeNjO`CMzRg_@lC?lJNwQwc@g@}@oEgGR}EtQpGtBrG`CfC|GzKuPm_@qDzI{R?|Rnd@q@rUnGyJaGo_@{Bba@d@`AqHm@hF?}Rde@e@{ZjDce@d@jBoEgG~R`Gu@xG}Dja@~E|DaGhb@q@c^jFwOf@`DR~BgH?_SNqP~`@fE|[eKc[oImZqIoZsIvBaGpGf@mDsGae@r@kI|Che@g@jAoE[jHke@g@|\jLbd@e@fb@oHnGkCoDxKkM{K|GlQ`e@mCnCnGdHeKfe@e@tDt@a[iBpe@f@dJjEbGt@?`Soa@aBlRcB|GjF{@aSwN}EuL{CuCbDi^|M?bS?cSzCqDya@aK|c@b@}d@v@}C`C_BkCcb@|EkOnG}Nf@rd@u@fM|CtJdSd@tInBeS~e@g@aFp@_C~AxOr@m]fS?gS?hS?iS?jS?kS?lS?mS?nS?oS?pS?gMxd@g@mc@v@eC`H?dIlC_EMqS`O~E`EuIhORzNnCaCoHrNtBzOr@lK~ENrSeMsSfd@aDqd@xItZtSxOh@uN}GtFvBta@lCf]jFvOuSmd@|EoOs@l[sLaf@r@|GwIkOiRaGuP|C`CvG|C{b@kDnO|BpE{C_e@mCmGxMkd@gI{OmC}C|B_BnH{e@w@nC}GUqCpOlCne@r@wd@`DMvS?wS`PfC{LkDmGgGyWaO?xSi_@kDq\|Esd@aD`f@s@g@jE_@ySm@zSse@f@lBvPsf@g@cMnF|O|Bme@s@?oEQ_D_f@q@nAoDiG{ScNu@fOxK`BnGoNtB~O}Dlf@s@`HvNxf@wFyf@xFxe@~E_BtQn]hEye@|S}BfH\qDbPr@fc@bDbPRT}SaOsGwe@bBdHdK_PqRqc@jN|FnCfFR{a@qD`PjE_H_R_d@vBv^x@zb@wKqf@|Bge@d@zYv@va@cQwa@~Ste@g@|f@s@{EnFj^|K?_MiMaDpCt@vNkNl_@dOaPwSbg@e@`A}C|Ct@}AkL}OfKUiDef@s@_g@eK~MsGmGoG?_TdN|EgH|BeJ`DjMsLbO}D`O_F?`T~OfCuGuH{OaTVbTiNhO|KlRwEcT?dT?eT?fT?gTx@hTqe@kJdHiT`C}Dfg@u@~d@oQpd@fR?tR?jT?kTze@c@pC}Nyd@lTwFmTnBnT|@oDr[{JaNoThF~CqE`G`g@rRbErCsStCuSvCwSpT?qTtf@fC`Ec@eHjFlg@kCeYaD[{BePfC{@sGmC}KiOrTmb@w@gH`C|e@lC_c@|Ecf@p@_\`DzORjO|B?jEaPsTxItTna@aMaBjErYvBw@}GcPt@n@kNw@aSiFh@ePuTbBqD_HvTuf@|BeJkDz`@vBwg@mC`HpRiPwT?xTiP|Jt[yTl`@cPaAtOhMkK?zT?{TaAsO~_@vOjPtO_h@uOyCwO`h@vOxCuOah@wOoOsGmCdMcBtOtB|T?}T?~T?_U?`U?aU?bU?cU?dU?eU?fU?gUYqHUhUYiDs`@gPp`@aIch@hPdh@aIyg@q@pC`CU_MaHqD~LsG|NiU~a@fEsGtH}g@v@`NmNlb@jU~EkU?lUv\gLw\_IMmUhg@f@qLR}GaG{HxBdg@_Mvf@d@|O`C}GgR_GnUnf@kC}e@}E?jQcc@qD}L|KyBh@gc@oU?pUkf@mCv`@R_HqUif@s@?oDmf@`Dgd@kJfP|B|AqDmFjH}XhErg@sCtSuCvSpB?rU?sUpg@d@kHtBgh@g@tGjFqC~Cfh@lUwOtBkNtUpGaNq@rSnEuUcC}Dug@x@zg@uD?vUnLaGbNfHcCkQiOpQ?wUyMgOtNfCm\aDtOmJdd@`DwDxUqg@yUbHnCka@u@rh@}Beh@dKnKsGbf@zUlh@fC`GbTuM{UgHt@?|Uof@hGeg@bDvh@|CbH`D|NnQsh@aDjh@lCxg@}Exh@{CtN}Dph@tTmYlH?iU?}Uih@e@gb@`DjF|CwNlTo]|Lnh@cBwh@xKyh@wD?~U?_V}@fChHxD~DaMbe@{Bue@u@nc@nCM`VaLlI|g@fCff@aVhf@lTnFbVkPcVfP`ChP_D|d@yKag@y@u^mGv_@~Lrc@_JcP|Bkg@aDdFdVcNnGrMeV`d@e@kFxK`BpHw@|G~FsQmh@e@kFlJhHfV~f@cB_MgVyBRcg@r@}f@lQ`NhVkAiV?jV?kVie@_S|h@p@~b@mCjb@f@ob@qDkPhL\lChHkHkZlV?mVig@~L|CoDdP{F?yJ?oMbi@nC`HwFci@xFqh@wUh]ShPkCsg@bDwDdDyLyQ?nV_OsG`i@f@ei@g@oGkCdi@jFjg@fCre@jDm@oVzh@f@le@dMeCpVtG|Cfi@g@cKiJje@rPvd@fD?qV</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??B?????B??D??B?????E??F??C?????E??G??C?????E??H??C?????E??I??C?????E??J??C?????E??K??C?????L??M??B?????L??N??C?????L??O??C?????L??P??C?????E??Q??C?????E??R??C?????E??S??C?????E??T??C?????E??U??C?????V??W??B?????V??X??B?????Y??Z??pS?WC?[??\??@U?wL?]??^??PJ?sC?]??_??@A@sK?]??`??PD??H?a??b??PG?GC?c??b??@A????d??e??`???J?d??f??`N?GG?g??h??`@?_fAg??h??PI?_hAi??j??@D?Co?g??k??P??cZCl??k??@??oA?E??m??C?????E??n??C?????E??o??C?????E??p??C?????E??q??C?????E??r??C?????V??s??B?????V??t??B?????V??u??B?????c??b??pB????]??v??pI?wM?g??w??PG?wy@g??x??`W?WJAi??y??PL?{W?E??z??C?????E??{??C?????E??|??C?????L??}??C?????E??~??C?????E???@?C?????E??@@?C?????V??A@?B?????V??B@?B?????V??C@?B?????V??D@?B?????Y??Z??@M?KC?E@?F@?@A?cE?G@?F@?P@?GH?G@?H@?`I?CG?I@?J@?pW?gF?K@?L@?@?????M@?N@?B?????]??^??@F?WC?[??O@?@A??G?P@?O@?`D?CF?Q@?O@?@Z?CY?R@?O@?@A?KO?R@?O@?@U?_Q?R@?S@?@`?gS?T@?O@?@@?{A?T@?U@?@?????M@?O@?B?????c??b??@B????V@?W@?@L?sE?X@?Y@?PG?GD?Z@?[@?pE?[A?\@?[@?@C?KS@\@?]@?P\?Se?]??v??@W?GN?]??^@?pA?gO?[??_@?@B?WH?[??_@?PG?OI?`@?_@?pE?WQ?P@?_@?`D?[D?Q@?_@?pH?O`?R@?_@?@A?SB?R@?_@?@a?CE?R@?a@?@`?OG?T@?_@?@@?wB?b@?c@?@?????M@?_@?B?????]??^@?`??cO?d@?e@?`P?GJ?f@?g@?P@?gD?f@?g@?@C?{D?A??h@?B?????\@?]@?pV?Ke?E@?F@?@N?KF?E@?i@?pE?{G?E??j@?C?????E??k@?C?????E??l@?C?????]??_??Pf?cJ?]??m@?`L?sL?n@?O@?@A?SG?n@?O@?`C?gG?n@?o@?PC?wJ?p@?q@?pA?sb?r@?q@?PA??q?r@?s@?PC?Cs?r@?t@?p??{b?r@?u@?pB?Ga?E??v@?C?????E??w@?C?????E??x@?C?????]??_??Px?GK?]??y@?pL?_G?A??z@?B?????]??_??@g?cJ?E??{@?C?????L??|@?C?????E??}@?C?????i??y??PT?OX?~@??A?P@?OKIM@?@A?B?????]??_??pr??K?d??AA?pH?gN?d??BA?@L?CT?i??j??@C?Co?CA?DA?PI?wmBE??EA?C?????E@?i@?pB?{G?FA?GA?@@?CU?HA?GA?@??wI?IA?GA?@??[|?E??JA?C?????E??KA?C?????E??LA?C?????MA?NA?B?????d??BA?pG??T?g??OA?@@?g]@E??PA?C?????R@?_@?pY?oD?QA?[@?@X?C~?QA?RA?`[?wC@SA?q@?@B?SH?SA?TA?@G?[I?r@?s@?PA??s?r@?t@?`C?Sc?UA??A?@@?oG?UA?VA?p@?gC?E??WA?C?????E??XA?C?????E??YA?C?????E??ZA?C?????E??[A?C?????E??\A?C?????E??]A?C?????E??^A?C?????]??m@?AT?wL?d??k??aK?SD?g??_A?q??gSAg??_A?QB?SVAi??_A?AG?SL?g??OA?P??g]@`A?aA?B?????E??bA?C?????E??cA?C?????Q@?O@?PA?CX?dA?eA?@@?GS?fA?eA?P??_H?L??gA?C?????d??BA?@F??T?E??hA?C?????d??BA?@B?{S?iA?jA?B?????\@?]@?@e?_e?\@?kA?p@?cW?lA?mA?QA?_??lA?mA?a??C@?nA?oA?AG?cI?nA?pA?aE?cT?]??_??@x?GK?I@?J@?pM?KF?I@?qA?A??GH?M@?rA?B?????d@?e@?PV?OJ?E??sA?C?????c??b??AB????V@?W@?Q@?WE?tA?uA?AC?S??vA?wA?Q@?Ka?xA?yA?QE?wF?zA?k??AC?WL?{A?|A?B?????iA?}A?B?????iA?~A?B?????d??BA?@I??T?L???B?C?????]??y@?P??kF?@B?AB?p??Gp?@B?AB?@u?wh?g??x??P??_IAE??BB?C?????d@?e@?`V?OJ?f@?g@?a??oE?n@?CB?qM?wA?I@?J@?pr?kG?I@?DB?`d?OM?G@?EB?PY?KR?HA?FB?@A?sL?GB?[@?PA?Ge?GB?HB?@e??g?GB?IB?@??su@E??JB?C?????GB?HB?AD?Kf?E??KB?C?????E??LB?C?????E??MB?C?????E??NB?C?????c??b??qB????]??v??qI?wM?g??w??QG?wy@g??x??aW?WJAi??y??QT?OX?~@??A?Q@?OKIUA??A?A@?oG?E@?i@?`L?CH?nA?OB?AJ?KW?nA?PB?AC?KX?E??QB?C?????E??RB?C?????E@?i@?@A?sG?A??SB?B?????E??TB?C?????E??UB?C?????E??VB?C?????E??WB?C?????E??XB?C?????E??YB?C?????E??ZB?C?????E??[B?C?????E??\B?C?????E??]B?C?????E??^B?C?????E??_B?C?????E??`B?C?????E??aB?C?????d@?e@?pH?sI?V@?W@?P@?WE?tA?uA?P??S??g??bB?P??kbBi??j??p@?Co?E??cB?C?????]??^??AF?WC?[??O@?AA??G?P@?O@?aD?CF?Q@?O@?AZ?CY?R@?O@?AA?KO?R@?O@?qP?SQ?dB?eB?qB?[M?fB?gB?a@?KI?fB?hB?Q??wN?\@?]@?P|??g?E??iB?C?????E??jB?C?????E??kB?C?????R@?O@?AU?_Q?R@?S@?Qd?sS?MA?lB?B?????E??mB?C?????E??nB?C?????E??oB?C?????Q@?_@?@i?Ga?dA?pB?@??w]?E??qB?C?????d??AA?qH?gN?d??BA?AL?CT?g??rB?pA?ShBi??rB?P??cd?E??sB?C?????MA?tB?B?????c??b??AA????d??e??a???J?d??f??AF??G?g??uB?aA?CLAg??CB?a@?[[@d@?e@?`N?CJ?f@?k??`@?GA?\@?]@?@E@Wg?MA?vB?B?????Q@?O@?QC?OX?HA?GA?@@?wI?GB?wB?@??_w?E??xB?C?????nA?oA?ak?CK?yB?zB?aA?cE?{B?|B?AS?g}?E??}B?C?????E??~B?C?????E???C?C?????B??@C?B?????i??y??pN??X?UA?AC?@@?_H?V??BC?B?????lA?mA?a@?_??]??v??pD?gM?CC?DC?@@?SL?EC?FC?`??SE?EC?FB?PD?[D?GC?HC?`@?SJ?{B?IC?pK?oK?JC?KC?PF?CN?A??LC?B?????d??BA?qG??T?g??OA?AB?k]@i??OA?QD?GB?MA?MC?B?????]??v??P[?SN?NC?OC?`@?on?g??uB?qJ?cLAa??b??`D?wB?PC?QC?a??CB?GB?gB?a??oa?GB?RC?qD?_b?GB?SC?QA?GT?g??TC?qE?WQAi??TC?QE?SK?GB?HB?qH@Wh?E??UC?C?????E??VC?C?????E??WC?C?????E??XC?C?????E??YC?C?????E??ZC?C?????E??[C?C?????E??\C?C?????E??]C?C?????A??^C?B?????E??_C?C?????E??`C?C?????E??aC?C?????E??bC?C?????Z@?[@?pG?_A?cC?dC?P??wF?eC?fC?pK?W@?E??gC?C?????i??y??QC?gW?\@?]@?pe?_e?d??f??aC?{F?i??_A?A@?kK?E@?i@?pI??H?hC?iC?A??KC?\@?]@?PM@cg?{B?jC?aK?OC?kC?lC?AJ?OJ?V??mC?B?????E??nC?C?????E??oC?C?????E??pC?C?????E??qC?C?????E??rC?C?????\@?]@?pZ?Se?E??sC?C?????E??tC?C?????E??uC?C?????E??vC?C?????E??wC?C?????E??xC?C?????E??yC?C?????E??zC?C?????E??{C?C?????E??|C?C?????E??}C?C?????E??~C?C?????E???D?C?????E??@D?C?????E??AD?C?????B??BD?B?????g??w??aF?wy@n@?O@?PA?cG?n@?CD?@W?OJ?Q@?O@?QA?CX?dA?eA?A@?GS?{A?DD?B?????M@?ED?B?????M@?FD?B?????I@?J@?@??oE?P@?O@?qC?CF?d??f??aN?GG?g??h??a@?_fAg??h??QI?_hAi??j??AC?Co?CA?DA?QI?wmBE??GD?C?????i??rB?p@?kd?d??f??PP?KG?HD?ID?`A?oC?i??_A?qD?CL?E??JD?C?????]??m@?aL?sL?n@?O@?AA?SG?n@?O@?QA?cG?n@?CD?AW?OJ?E??KD?C?????E??LD?C?????E??MD?C?????B??ND?B?????E??OD?C?????E??PD?C?????d@?e@?@D?kI?dA?pB?P@?w]?QD?RD?a??{}?fA?SD?AA?wI?TD?UD?Q??OD?HD?ID?p??kC?g??_A?Q??SVAg??VD?aA?[[Cf@?g@?aD?sE?n@?_@?QB?kC?n@?_@?QF?kD?Q@?_@?pf??a?WD?XD?@??oB?E??YD?C?????QA?ZD?AA?_X?[D?k??AB?wC?QA?k??QH?CQ?]??v??PF?oM?d??AA?P??[N?g??CB?A@?[[@d@?e@?@??cI?E??\D?C?????n@?CB?AM?wA?tA?uA?AA?S??g??]D?qH?K}B^D?_D?aA?kG?`D?k??A@?[d?vA?k??A@??D?aD?k??AC?_J?{B?|B?aA?W}?E??bD?C?????CA?DA?aM?{mBB??cD?B?????E??dD?C?????V??eD?B?????nA?OB?Q???W?nA?fD?a??CT?nA?gD?a@?CV?E??hD?C?????]??v??AW?GN?]??^@?aA?gO?iA?iD?B?????MA?jD?B?????E@?F@?P??_E?E@?kD?A@?wF?lD?L@?AK?[W?lD?mD?aD?SQ?{B?nD?QJ?SB?kC?oD?qF?oI?E??pD?C?????E??qD?C?????E??rD?C?????E??sD?C?????Y??Z??p^?wC?d??AA?`E?cN?i??y??AS?OX?UA??A?QD?wG?E??tD?C?????R@?O@?qY?kQ?[D?[@?Q??GN?nA?oA?AI?gI?xA?yA?AD?wF?uD?vD?a@????wD?xD?A?????g??h??@??GhA\@?]@?@n?Gf?n@?CB?qA?wA?E??yD?C?????QA?k??AA??Q?zD?k??QJ?WN?QA?{D?a??kO?QA?{D?A??o]@fA?eA?Q??_H?|D?}D?qB?GM?TD?~D?a??gC?E???E?C?????E??@E?C?????E??AE?C?????E??BE?C?????E??CE?C?????M@?DE?B?????lD?mD?qA?OQ?{B?jC?qJ?OC?nA?OB?AD??W?UA?VA?q@?gC?E??EE?C?????E??FE?C?????E??GE?C?????E??HE?C?????tA?uA?qA?S??R@?_@?`g?_E?dB?IE?`I?_Q?JE?KE?@N?_J?Y??Z??PN?KC?LE?ME?Q??oH?E??NE?C?????E??OE?C?????K@?L@?A?????iA?PE?B?????fB?gB?AC?SI?QE?RE?aC?KZ?]??m@?aH?oL?n@?uB?aA?{N?a??b??@??oB?i??j??q@?Co?L??SE?C?????L??TE?C?????E??UE?C?????E??VE?C?????^D?_D?a@?kG?{B?nD?a@?OB?d??k??aH?KD?E??WE?C?????E??XE?C?????E??YE?C?????E??ZE?C?????E??[E?C?????E??\E?C?????E??]E?C?????E??^E?C?????E??_E?C?????E??`E?C?????E??aE?C?????E??bE?C?????E??cE?C?????E??dE?C?????E??eE?C?????E??fE?C?????E??gE?C?????E??hE?C?????E??iE?C?????E??jE?C?????B??kE?B?????M@?lE?B?????E??mE?C?????E??nE?C?????E??oE?C?????E??pE?C?????E??qE?C?????E@?i@?pF?{G?rE?sE?Q??Od@tE?uE?AN??c@nA?oA?QA?WI?nA?gD?aB?CV?Q@?O@?QE?[X?Q@?vE?Q??_U?E??wE?C?????E??xE?C?????E??yE?C?????i??OA?Q??{A?E??zE?C?????E??{E?C?????E??|E?C?????f@?k??a@?GA?E??}E?C?????vA?wA?AA?Ka?aD?~E?AU?gM?zA??F?q??OK?zA??F?Q@?WM?@F?gB?AA????xA?AF?a@?wF?BF?k??AB?GF?CF?k??Q???O?l??k??A??oA?zD?k??qH?SN?QA?DF?a??kO?QA?DF?a??c^@QA?{D?a??o]@d??BA?q@?{S?E??EF?C?????[??_@?`H?SI?`@?FF?@??CQ?E??GF?C?????M@?HF?B?????E??IF?C?????E??JF?C?????{B?|B?qQ?g}?n@?O@?aC?gG?n@?o@?aE??K?KF?LF?aA????MF?NF?Q??G`?V??OF?B?????E??PF?C?????n@?CD?a@?GI?V??QF?B?????E??RF?C?????E??SF?C?????i??_A?Q??kK?FA?GA?A@?CU?HA?GA?A??wI?IA?GA?A??[|?I@?qA?aO?gH?GB?TF?QA?_F@GB?HB?qM?Sf?E??UF?C?????~@??A?Q??OKIVF?WF?q??_C?zD?k??AF?KN?n@?o@?QC?wJ?p@?q@?qA?sb?r@?q@?QA??q?E??XF?C?????]??_??@??kH?E??YF?C?????E??ZF?C?????]??_??`p?oJ?E??[F?C?????zD?k??AC?CN?E??\F?C?????B??]F?B?????E??^F?C?????GB?RC?qN?gb?g??_F?AJ?Wq@]??_??@o?oJ?r@?s@?QA??s?r@?t@?q??{b?r@?u@?qB?Ga?V??`F?B?????E??aF?C?????n@?CD?q??CI?\@?]@?@??Sd?V@?W@?aO?{E?d@?k??qD?[D?nA?PB?Q@?KX?E??bF?C?????cF?dF?Q??kQ?E??eF?C?????E??fF?C?????wD?xD?qC????@F?k??qA????MA?gF?B?????I@?qA?QK?[H?]??^@?qA?gO?[??_@?AB?WH?[??_@?QG?OI?`@?_@?qE?WQ?P@?_@?aD?[D?Q@?_@?qH?O`?R@?_@?AA?SB?R@?_@?Aa?CE?R@?a@?A`?OG?T@?_@?A@?wB?b@?c@?A?????\@?]@?`g?oe?E??hF?C?????yB?zB?Q??_E?E??iF?C?????nA?PB?Q??KX?\@?]@?`q@Gi?\@?jF?p[?{k?QE?RE?aE?OZ?d@?e@?`F?kI?nA?OB?AF??W?E??kF?C?????A??lF?B?????]??_??po?oJ?zD?DF?aB??V?R@?S@?ae?wS?Y??Z??`O?KC?E??mF?C?????E??nF?C?????E??oF?C?????E??pF?C?????E??qF?C?????E??rF?C?????E??sF?C?????M@?tF?B?????{A?uF?B?????r@?t@?qB?Kc?r@?vF?a@?{a?E??wF?C?????HD?ID?@??kC?I@?qA?AG?WH?M@?xF?B?????r@?t@?pB?Kc?r@?vF?aA?{a?n@?o@?QF??K?\@?jF?`W?sk?lA?mA?PA?_??E??yF?B?????GB?HB?q|?wg?B??zF?B?????M@?{F?B?????B??|F?B?????i??j??AD?Co?g??k??a@?gZCE??}F?C?????E??~F?C?????E???G?C?????E??@G?C?????E??AG?C?????E??BG?C?????E??CG?C?????E??DG?C?????E??EG?C?????E??FG?C?????E??GG?C?????E??HG?C?????L??IG?C?????{B?|B?q??S}?L??JG?C?????d??f??`C?{F?g??_A?P??SVA\@?]@?`R@og?n@?CB?aB?{A?HA?GA?A@?wI?GB?wB?AD?kw?GB?HB?q@?Gf?r@?s@?p??{r?r@?KG?@??{[?^D?_D?A??gG?]??v??aG?sM?lA?mA?@??_??KF?LF?AD????d??k??qO?[D?LG?OC?QC?oV?g??uB?qP?kLAE??MG?C?????E??NG?C?????OG?PG?A@?g~@nA?oA?aD?_I?QG?RG?q??{f@\@?]@?Pe@oh?SG?TG?Q??{K?A??UG?B?????n@?_@?aE?kD?d??BA?AF??T?g??x??qE?sIAnA?oA?Q??SI?d??AA?pB?cN?E??VG?C?????I@?J@?pN?OF?G@?WG?AM?cO?LG?OC?qD?sV?XG?YG?QH????ZG?[G?aB????i??\G?A@?WB?nA?OB?qB??W?d??f??Q??sF?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2400015461;
    let startMs = 1664313736531;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","libsystem_pthread.dylib","thread_start","_pthread_start","libjvm.dylib","thread_native_entry","Thread::call_run","JavaThread::thread_main_inner","attach_listener_thread_entry","load_agent","JvmtiExport::load_agent_library","libasyncProfiler.so","Agent_OnAttach","Profiler::runInternal","Profiler::start","Profiler::startTimer","jvmti_RunAgentThread","JvmtiEnv::RunAgentThread","Threads::add","ThreadsSMRSupport::add_thread","ThreadsSMRSupport::free_list","libsystem_malloc.dylib","free_tiny","tiny_free_no_lock","one.nio.server.SelectorThread","run","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","handleParsedRequest","one.nio.http.HttpServer","handleRequest","RequestHandler1_handlePutRequest","one.nio.http.Request","getRequiredParameter","getParameter","java.lang.String","substring","java.lang.StringLatin1","newString","<init>","java.lang.Object","OptoRuntime::new_array_nozero_C","CollectedHeap::array_allocate","MemAllocator::allocate","MemAllocator::Allocation::notify_allocation_jvmti_sampler","JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector","JvmtiObjectAllocEventCollector::generate_call_for_allocated","free","szone_size","tiny_size","sendResponse","equalsIgnoreCase","regionMatches","regionMatchesCI","OptoRuntime::new_instance_C","InstanceKlass::allocate_instance","JvmtiExport::post_sampled_object_alloc","ObjectSampler::recordAllocation","jvmti_GetClassSignature","JvmtiEnv::GetClassSignature","os::malloc","_malloc_zone_malloc","szone_malloc_should_clear","tiny_malloc_should_clear","tiny_malloc_from_free_list","one.nio.net.JavaSelector","select","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","sun.nio.ch.KQueue","poll","libsystem_kernel.dylib","kevent","read","one.nio.net.JavaSocket","sun.nio.ch.SocketChannelImpl","sun.nio.ch.IOUtil","readIntoNativeBuffer","sun.nio.ch.SocketDispatcher","read0","ok.dht.test.gerasimov.ServiceImpl","handlePutRequest","ok.dht.test.gerasimov.lsm.artyomdrozdov.MemorySegmentDao","upsert","ok.dht.test.gerasimov.lsm.artyomdrozdov.Memory","put","java.util.concurrent.ConcurrentSkipListMap","doPut","writeResponse","write","one.nio.net.Session$ArrayQueueItem","writeFromNativeBuffer","sun.nio.ch.FileDispatcherImpl","write0","one.nio.http.Response","toBytes","one.nio.util.ByteArrayBuilder","append","jbyte_disjoint_arraycopy","iteratorFor","OptoRuntime::new_array_C","InstanceKlass::allocate_objArray","OopStorage::Block::release_entries","parseRequest","one.nio.util.Utf8","toAsciiString","sun.misc.Unsafe","copyMemory","jdk.internal.misc.Unsafe","copyMemoryChecks","checkPrimitivePointer","checkPointer","ThreadHeapSampler::check_for_sampling","JvmtiObjectAllocEventCollector::record_allocation","AllocateHeap","startParsingRequestBody","_new_array_nozero_Java","ResourceObj::operator new","Profiler::recordSample","Method::jmethod_id","java.lang.Character","toLowerCase","thread_self_trap","getHeader","trim","java.util.Arrays","copyOfRange","JvmtiEnvBase::get_stack_trace","sun.nio.ch.Util$2","iterator","java.util.HashSet","java.util.HashMap$KeySet","vframe::java_sender","compiledVFrame::sender","vframe::sender","libsystem_platform.dylib","_platform_memmove$VARIANT$Haswell","charAt","G1BarrierSet::enqueue","java.nio.ByteBuffer","putBuffer","jdk.internal.misc.ScopedMemoryAccess","copyMemoryInternal","java.lang.CharacterDataLatin1","getProperties","ScopeDesc::sender","resource_allocate_bytes","Mutex::lock_without_safepoint_check","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<598116ull, G1BarrierSet>, ","JavaThread::last_java_vframe","vframe::new_vframe","compiledVFrame::compiledVFrame","CompiledMethod::scope_desc_at","indexOf","libdyld.dylib","tlv_get_addr","frame::real_sender","frame::sender","java.util.concurrent.locks.ReentrantLock","lock","java.util.concurrent.locks.ReentrantLock$Sync","Dictionary::lookup","InstanceKlass::get_jmethod_id","libnio.dylib","JNI_OnLoad","cpr","ok.dht.test.gerasimov.lsm.artyomdrozdov.MemorySegmentComparator","compare","jdk.internal.foreign.AbstractMemorySegmentImpl","mismatch","checkAccess","processUpdateQueue","_kernelrpc_mach_port_deallocate_trap","compiledVFrame::method","ok.dht.test.gerasimov.ValidationService","checkId","java.util.stream.IntPipeline","noneMatch","java.util.stream.MatchOps","makeInt","java.util.stream.MatchOps$MatchOp","libsystem_c.dylib","clock_gettime","Java_sun_nio_ch_SocketDispatcher_read0","fdval","CallTraceStorage::put","java.lang.Integer","parseInt","jvmti_Deallocate","length","processEvents","processReadyEvents","add","java.util.HashMap","putVal","newNode","ScopeDesc::ScopeDesc","frame::sender_raw","frame::sender_for_compiled_frame","CodeCache::find_blob","CodeHeap::find_blob_unsafe","checkBounds","checkBoundsSmall","ScopeDesc::decode_body","nmethod::metadata_at","_new_array_Java","JavaThread::pd_last_frame","GangWorker::run","GangWorker::loop","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsTask::scan_roots","G1RemSet::scan_heap_roots","G1ScanHRForRegionClosure::do_heap_region","G1ScanHRForRegionClosure::scan_heap_roots","G1ScanHRForRegionClosure::scan_memregion","G1ParScanThreadState::trim_queue_to_threshold","void G1ParScanThreadState::do_oop_evac<narrowOop>","HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<true, G1ScanCardClosure>","G1BlockOffsetTablePart::forward_to_block_containing_addr_slow","G1ParScanThreadState::do_copy_to_survivor_space","isBlank","ObjArrayAllocator::initialize","sun.nio.ch.Util","getTemporaryDirectBuffer","java.lang.ThreadLocal","get","getMap","os::javaTimeMillis","OopStorage::allocate","PerfByteArray::~PerfByteArray","_platform_strcpy","javaVFrame::is_java_frame","JvmtiObjectAllocEventMark::JvmtiObjectAllocEventMark","JNIHandleBlock::allocate_block","unlock","MemAllocator::finish","indexOfNonWhitespace","HandleMark::~HandleMark","_platform_strlen","startsWith","_platform_strncmp","keySet","JvmtiExport::record_sampled_internal_object_allocation","jdk.incubator.foreign.MemoryAccess","getByteAtOffset","java.lang.invoke.VarHandleGuards","guard_LJ_I","Chunk::next_chop","Chunk::operator delete","ThreadCritical::~ThreadCritical","pthread_mutex_unlock","toUpperCase","szone_malloc","one.nio.server.Server","incRequestsProcessed","java.util.concurrent.atomic.LongAdder","increment","java.util.concurrent.atomic.Striped64","casBase","guard_LJJ_Z","java.lang.invoke.VarHandleLongs$FieldInstanceReadWrite","weakCompareAndSetRelease","jlong_disjoint_arraycopy","_platform_bzero$VARIANT$Haswell","java.util.LinkedList","pollFirst","one.nio.http.PathMapper","find","getNode","hash","hashCode","ConcurrentGCThread::run","G1ConcurrentRefineThread::run_service","G1ConcurrentRefine::do_refinement_step","G1DirtyCardQueueSet::refine_completed_buffer_concurrently","G1DirtyCardQueueSet::refine_buffer","G1RemSet::refine_card_concurrently","HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<false, G1ConcurrentRefineOopClosure>","HeapRegion::is_obj_dead_with_size","oopFactory::new_typeArray","unsafe_arraycopy","ScopeDesc::decode_object_values","DebugInfoReadStream::read_object_value","ObjectValue::read_object","ScopeValue::read_from","ok.dht.test.gerasimov.lsm.artyomdrozdov.Storage","getSizeOnDisk","ok.dht.test.gerasimov.lsm.artyomdrozdov.StorageUtils","getSize","JNIHandles::make_local","java.nio.channels.spi.AbstractSelectionKey","isValid","guard_LLL_Z","java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite","compareAndSet","tiny_free_list_add_ptr","CodeBlob::is_compiled","OopStorage::release","PcDescCache::find_pc_desc","vframe::vframe","RegisterMap::RegisterMap","G1ParScanThreadState::allocate_copy_slow","G1PLABAllocator::allocate_direct_or_new_plab","G1Allocator::old_attempt_allocation","G1AllocRegion::attempt_allocation_locked","G1AllocRegion::new_alloc_region_and_allocate","G1CollectedHeap::new_gc_alloc_region","G1CollectedHeap::new_region","MasterFreeRegionListChecker::check_mt_safety","G1BlockOffsetTablePart::alloc_block_work","G1BlockOffsetTablePart::set_remainder_to_point_to_start_incl","void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>","G1ServiceThread::run_service","G1ServiceThread::sleep_before_next_cycle","Monitor::wait_without_safepoint_check","os::PlatformMonitor::wait","pthread_dependency_wait_np.cold.3","isAsciiString","gettimeofday","__commpage_gettimeofday_internal","mach_absolute_time","OopMapSet::update_register_map","one.nio.util.URLEncoder","decode","CodeBlob::is_zombie","Arena::grow","ChunkPool::allocate","ThreadCritical::ThreadCritical","pthread_self","JvmtiClassEventMark::JvmtiClassEventMark","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<2646116ull, G1BarrierSet>, ","java.util.concurrent.locks.AbstractQueuedSynchronizer","release","tryRelease","java.util.concurrent.locks.AbstractOwnableSynchronizer","getExclusiveOwnerThread","isLatin1","sun.nio.ch.IOStatus","normalize","frame::is_interpreted_frame","wrap","java.nio.HeapByteBuffer","Chunk::operator new","chars","java.util.stream.StreamSupport","intStream","java.util.stream.IntPipeline$Head","java.util.stream.AbstractPipeline","InstanceKlass::signature_name","pthread_mutex_lock","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ull, G1BarrierSet>, ","default_zone_malloc","isSmall","isSet","JNIHandleBlock::allocate_handle","Java_sun_nio_ch_FileDispatcherImpl_write0","_os_semaphore_wait.cold.1","registerPendingSessions","java.util.concurrent.ConcurrentLinkedQueue","updateHead","guard_LL_V","setRelease","void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>","void OopOopIterateDispatch<G1ScanCardClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","void G1ScanCardClosure::do_oop_work<narrowOop>","JvmtiEnv::Deallocate","JvmtiJavaThreadEventTransition::JvmtiJavaThreadEventTransition","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","newInvokeSpecial","JavaThread::is_Java_thread","java.nio.Buffer","position","java.util.concurrent.locks.ReentrantLock$NonfairSync","initialTryLock","setExclusiveOwnerThread","JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector","JvmtiEventCollector::setup_jvmti_thread_state","Symbol::as_C_string","WatcherThread::run","WatcherThread::sleep","__psynch_cvwait","ObjAllocator::initialize","G1EvacuateRegionsBaseTask::evacuate_live_objects","G1ParEvacuateFollowersClosure::do_void","G1ParScanThreadState::steal_and_trim_queue","offerFirstTemporaryDirectBuffer","sun.nio.ch.Util$BufferCache","offerFirst","one.nio.net.JavaSelector$1","hasNext","PreserveExceptionMark::PreserveExceptionMark","ImmutableOopMapSet::find_map_at_offset","Java_sun_nio_ch_KQueue_poll","java.lang.ThreadLocal$ThreadLocalMap","getEntry","FlightRecorder::recordEvent","Recording::recordAllocationInNewTLAB","GrowableArrayCHeapAllocator::allocate","ClassLoaderData::holder_phantom","PreserveExceptionMark::~PreserveExceptionMark","G1CMRootRegionScanTask::work","G1ConcurrentMark::scan_root_region","G1CMConcurrentMarkingTask::work","G1CMTask::do_marking_step","G1CMTask::drain_local_queue","void G1CMTask::process_grey_task_entry<true>","void OopOopIterateDispatch<G1CMOopClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","G1CMTask::make_reference_grey","G1ConcurrentMark::mark_in_next_bitmap","G1CMBitMap::iterate","ClassLoaderData::oops_do","G1CMTask::drain_global_stack","G1RebuildRemSetTask::work","HeapRegionManager::par_iterate","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::do_heap_region","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::rebuild_rem_set_in_region","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::scan_for_references","void OopOopIterateDispatch<G1RebuildRemSetClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","OtherRegionsTable::add_reference","_pthread_mutex_firstfit_lock_slow","__psynch_mutexwait","HeapRegion::block_size","G1ClearBitMapTask::work","G1ClearBitMapTask::G1ClearBitmapHRClosure::do_heap_region","MarkBitMap::do_clear","BitMap::clear_range","java.util.HashMap$KeyIterator","next","java.util.HashMap$HashIterator","nextNode","beginRead","compiledVFrame::bci","TypeArrayKlass::allocate_common","Klass::check_array_allocation_length","ScopeDesc::is_top","G1CardTable::is_in_young","JvmtiEnvBase::phase","CodeBlob::is_deoptimization_stub","evaluate","evaluateSequential","java.util.stream.MatchOps$$Lambda$78.0x0000000800cafbf0","lambda$makeInt$1","java.util.stream.MatchOps$2MatchSink","java.util.stream.MatchOps$BooleanTerminalSink","limit","JavaFrameAnchor::make_walkable","remaining","nmethod::is_zombie","mach_port_deallocate","PcDescContainer::find_pc_desc_internal","CardTableBarrierSet::on_slowpath_allocation_exit","java.lang.invoke.LambdaForm$MH.0x0000000800ccc400","invokeExact_MT","java.lang.invoke.Invokers","checkExactType","malloc","HandleMark::initialize","tiny_free_list_remove_ptr","StackWatermarkSet::on_iteration","VMError::is_error_reported","putIfAbsent","nmethod::metadata_addr_at","java.lang.CharacterData","of","MemAllocator::allocate_inside_tlab_slow","os::javaTimeNanos","nmethod::scopes_pcs_end","ThreadLocalAllocBuffer::set_sample_end","Thread::is_Named_thread","pthread_mutex_trylock","TaskTerminator::offer_termination","equals","default_zone_free_definite_size","Arena::set_size_in_bytes","os::free","java.nio.channels.spi.AbstractSelectableChannel","isBlocking","Klass::signature_name","JNIHandleBlock::release_block","_platform_memset$VARIANT$Haswell","oopFactory::new_typeArray_nozero","GrowableArrayWithAllocator<ScopeValue*, GrowableArray<ScopeValue*> >::grow","addIndices","InstanceKlass::array_klass","jint_disjoint_arraycopy","CodeBlob::is_optimized_entry_blob","ThreadShadow::clear_pending_exception","G1RemSet::scan_collection_set_regions","G1CollectionSet::iterate_incremental_part_from","G1CollectionSet::iterate_part_from","G1ScanCollectionSetRegionClosure::do_heap_region","G1CodeRootSet::nmethods_do","semaphore_wait_trap","advance_directory.cold.1","checkPrimitiveArray","CompiledMethod::is_compiled","__gettimeofday","jni_GetEnv","_pthread_mutex_firstfit_unlock_slow","__psynch_mutexdrop","_pthread_cond_wait","VMThread::run","VMThread::inner_execute","VMThread::evaluate_operation","VM_Operation::evaluate","VM_G1Concurrent::doit","G1ConcurrentMark::remark","G1CollectedHeap::resize_heap_if_necessary","G1CollectedHeap::expand","HeapRegionManager::expand_by","HeapRegionManager::expand","HeapRegionManager::commit_regions","CardTable::clear","ObjectSampler::SampledObjectAlloc","Buffer::putVar64","checkSize","java.util.ArrayDeque","ThreadLocalAllocBuffer::set_back_allocation_end","oopDesc::metadata_field","java.lang.invoke.VarHandle","checkExactAccessMode","java.lang.Math","min","java.util.Objects","requireNonNull","jbyte_arraycopy","PeriodicTask::real_time_tick","processDeregisterQueue","java.lang.invoke.LambdaForm$MH.0x0000000800cce400","invoke","java.lang.invoke.LambdaForm$DMH.0x0000000800ccd800","invokeStatic","canEncode",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
