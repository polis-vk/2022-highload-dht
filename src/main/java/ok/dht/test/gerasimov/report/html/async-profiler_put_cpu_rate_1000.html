<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BJuZANUyDvEsJiNtR{XtYa}AJYJ`RYKHSISIRH?AH@HHOP?GYIGQ@IH?HIO@GH?H@OQGH@HH?A???PH@IG?HOAHPH@G?@GAH?@HHH?A@GG@PG@G@H@OGI@@HHQ@HH??IO?GGHGHPPGGG?OH@HGP@QAHOGJRPAPGIHAH@@HHO@OH@RHH?H@H?@HGGO@@?GP@PPHH?AOG?HGGHHGI@Q??@GH@Q@P?@HGHH?IGI?HG@HGGI?NSR`GOGIGPOHGHAIA?@GIAHQGGG@O?OP?PHHI@POHIGQH@A@@HHIG@HHAHAP@?IHGAGHI?PGGO?IIHP?AHHOGPOA@GG@HOHGGAH@HH@I@APGGPHOHH@?A?H@GG@HH?GHHHHPG@P?HHG?@H??HH?PGH@PGHIHH@@?HGG@@G@Q@?IOPG??@@HIGQHPOGH?@HOHGHP@@H@H?@GOIA?G@HI?PGAHO@?@P@PAP?IHG?IH?GSTHHAOHG@I?G?PH@?GGH?Q?P@@AG@@?AGOHHAGH?HHAGPAH?P@HHGHHHHG@@HPI@GIHGIPG@HG?@GG?@??IOPDO@HHPAAIG@HGHGAO?HHO@AOH@@@@GPHO@A@HGGOGA@OG@PG?@G@AH@OOHOGI@OH@P?OI?H??HH@OAI?O@P@HG?P@GAHG@??H??HQ@@OHOHAAH???IHGH@@HGIAHIHGI??HPG@OGHHG@O?@?G?HH?@AG@?HGHIGGHHHHHHHGA@@H@G@HH?G?@OP@@HAHHGGKYx@@??PHGA@GI?@@GGH?HH?PPOH@HAIHGOAI?GHHHI@I?@?AHG@?AOH@HI@AG?@OHHPO?PPIIHH@@@HA@OAGHHHIHP?QAIG@@GOH@OGQ?HIG@A@APGGPGGIOP@I@HA@SXIHHI@HAH@?PH@@HAAPHHGH@G@O@??GG@OH@?AH?H@H?PG@A?AHH?GHGH?IO@@GPOGIGH@PA@HH?OII?HHO@OPOG?I?@@HG@?@@GHHP@O@?IIPG@G@HGG?@HGGHH@HI@IHH@APH@OIHAAGHI@H@Aa?@@GIG?GPP?OH@H@GAOHGPG@H@?HAA@A?I@?@HHGAG@HGHPIG@GP?HGHA?HHHHQAGHGP?AP@?@PI???@?OGAHH?HGH?AHHG?GP@GGIHHOG@GQHOPIGI?IHAAPA?P?HHGHHAO?O@GGHHO@O?G@GGHiAPOHGIPIQHAGAHA?I@H@H??AGGOOGHGG?@AAIH@G?O?GG?G?@HOGA?@HIII@@P@?HGHG@G@@?HA?@O@HHGO@?POPA@A@GOG?@?HGOI@AOH?O@?H@HGOPGA?@PHPPHHIG@?IG?@OI?G?HGHIGHO?I@HGP@G?@@G@?GGH@HPGAAHAHI@PIOH?H@G?G@IIGGHH?HI@G@HHGP?@PGG?HHHIGIGIAO?HG?HP@@?P?OOHHPH?@@@@GHIH@HH@HHH@G?@P?OHAH??@GIH?HGOIGQHIHAI@G?HGAHOHGHHO@HAPHO@?PHHGIGAPIH?OHPG@OHHH@AGHOH?@GG?H@?O?PO@H@GA@HH@?QGPA?@GP@OH????GupAupAndB``BkeBfiBzeBprBytBebBnxAfpBunBlyA}_BecB_fBisAwcBnyAzsAm_BvbB~bBwdBsfBvyBquAexAw|Aj}AehBusBvsAu{Az|Ao~Ay_Bb`BkaBedBcfBjgBpjBuqBz{BaeCysAwtAixAdyAq~AeaBddBgfBeiBioBopBzpB`uBzvB|xB`zBnaCwbCmkCpmChrA~rAwvAjwAsyAzzAi{Ae}A{}Ai~Ad_Bo`Bq`B_bBdcBxdB_jB`lBsmBwmBjnBcpBctBpuBfwBmwB}yBvzBh|Bv|Ba_CbaCibCpbC`hCeqAwsAjtAktAvuA|vAyxAiyAqyA}zAe{Ar{As{A_|Ad}Ar}Ao_Bw`ByaB`bBcbB{bBgcB~cB_eBseBbfBrfB{fBagBdgBdhBihBzhBciBjiBkiBliBtnBtoB`pBdqBeqBorBmsB{tB~tBavBcvBivB}vBqyBryB{zB~zBd{Bp{Bd}Bc_Cu_Cs`ClbCfcCceCieCnfC|fCnsAqsAxsAduAjuApuA|uA}uAkvAzvAjxAlxAmxAwxAxxAoyAfzAg{At{As}A}}Aa~As~A__B`_Ba_Bf_Br_B~_B_`Bk`Bv`BgaBiaBpaB~aBhbBtbB}bB`cBpcBzcB{cBpdBfeBjeBxeByeBafBdfBlfB}fBbgBlgBmgB|gBahBbhBjhBkhB`iBbiBojBpkB~kBolBgmBkmBzmBcnBxnBznB|nB}nBcoBgoByoBepBlpBwpBzqBhrBnrBvsBztBouBxuBbvBnvBtvBxvBewBgwBrwBlxBsxBvxBwxBxxB`yBcyBwyB|yBmzBn{Bt{By{Bf|Bi|Bq|By|Bz|By}B{}B`~Bh~B{`CdaCzaCjbCtbC_cCidCwdCdeC`fCjfCyfCihCvhCwiC`jCcjCkjCzjCglColCplCwmChnCinCqnCrnCunCaoCepClpCfqCiqCoqCzrCjsCvsC~sCrtCzvCexC|zCbqAkqAlqA}qA`rAdrA`sAesArsAtsAusA`tArtAauAbuAluAouA`vAfvAivAmvAovA~vAcwAgwAfxAhxAkxAsxAayAfyAhyApyAryAzyAezAmzAtzA{zAf{Ah{Aq{Av{A|{Af|Aj|Al|Ap|Ax|Ay|A`}Ap}At}Av}Aw~A~~Ak_Bs_Bt_Bx_Bc`Bt`B{`B}`BwaBxaBzaBdbBqbBubBxbBybB_cBbcBlcB`dBfdBmdBodBudB~dBneBpeBifBkfBpfBtfByfB~fBogBwgBzgB}gB~gBchBfhBhhBuhB{hB|hB}hBtiBuiB~iB{jB}jBakBjkBskBwkBalBdlBglBilBplBqlBbmBqmBumBvmBxmBpnBwnBaoBdoBeoBkoB}oBjpBkpBqpBxpB{pB`qBaqBbqBcqB{qBkrBlrBvrBzrB}rBhsBpsBssBxsButB}tBguBiuBkuBmuBnuBuuBvuByuB{uB}uB~uBfvBhvBrvBvvB|vBbwBjwBzwB}wB~wBaxBixBjxBnxBrxBtxB{xB~xBfyBgyBhyBmyByyBczBgzBtzBuzB_{Ba{Bl{Bq{B}{B~{B_|Ba|Bn|Bp|Br|B||B~|B`}Bq}Bu}B~}Bg~Bi~Bm~Bq~Bx~Bz~B}~Bi_Cl_Ct_Cv_C``Ca`Cd`Ci`Cn`Cw`Cz`CcaChaC{aC|aC~aCabCcbCgbCqbC}bCrcCscCwcCzcC`dCsdC_eCfeCqeCreCteC_fCqfCtfCcgCggCrgCtgC~gCxhCdiCgiC{iC~iCgjCijCpjC{jCdlCelCjlCllCzlC`mC~mCanCmnCwnC|nC~nCjoCkoCroCuoCyoCbpCnpCtpCrqCzqC_rCirCkrC{rC|rC`sCfsCxsCysCdtCktCwtCztCavCqvCvvC`wCowC|xCcyCiyCjzC{}Cj~Cf_DvpAxpAypAzpA}pA_qA`qAaqAdqAgqAhqAiqAjqAnqApqAqqArqAsqAuqAxqAzqA{qA~qA_rAarAbrAcrAerArrAtrAurAwrAbsAcsAdsAksAmsAosApsAssA{sA~sAatAbtActAdtAetAftAgtAhtAitAmtAotAstA`uAeuAhuAiuAmuAnuAruAtuAxuAyuAzuA{uAbvAcvAevAgvAhvAjvAlvAnvApvAyvA{vA}vA_wAawAdwAewAowAswAwwA}wA`xAbxAcxAgxAqxAtxAuxAvxA{xA}xAcyAgyAjyAkyAmyAtyAxyA}yA_zA`zAazAbzAczAdzAhzAjzAkzApzArzAvzAwzAxzAyzAb{Ac{Ad{Ak{Am{An{Ao{Ap{Az{A~{Aa|Ac|Ad|Ai|Am|An|Ao|Aq|As|At|Au|Av|A||A}|A~|A_}Aa}Ab}Ac}Af}Ag}Ai}Al}An}Ao}Au}Ax}Ay}Az}A|}Ac~Ae~Ak~Ap~At~Av~Ax~Az~A{~A}~Ab_Bc_Bh_Bj_Bl_Bq_Bu_Bw_B{_Ba`Be`Bf`Bh`Bj`Bm`Br`Bu`By`B|`B~`B`aBcaBdaBfaBmaBnaBqaBsaBtaBuaBvaB|aB}aBfbBjbBkbBlbBmbBnbBsbBwbBzbB|bBacBccBfcBhcBjcBmcBocBrcBscBvcBycB|cBadBbdBidBqdBrdBsdBtdBvdBydBzdB|dB}dB`eBaeBceBeeBheBieBleBteBveBweB`fBefBffBofBqfBufBwfBxfBzfB|fB`gBcgBegBhgBkgBxgB_hBghBlhBmhBnhBphBqhBshBvhBxhByhB~hB_iBaiBgiBiiBmiBoiBpiBqiBriBsiBwiB|iB`jBbjBgjBijBmjBwjB_kBbkBdkBekBfkBgkBhkBlkBmkBnkBrkBukBxkBykBzkB|kBclBflBjlBnlBtlBzlBdmBemBlmBnmBomBpmBrmBtmBymB|mB~mB`nBbnBdnBenBgnBhnBinBknBlnBnnBqnBsnBvnB~nB_oBhoBjoBmoBnoBooBsoBuoBwoBxoBzoB_pBbpBgpBmpBppBrpBupBvpBypB~pBgqBhqBiqBjqBlqBmqBnqBoqBpqBqqBrqBsqBtqBwqBxqByqB}qB~qB_rB`rBbrBcrBerBfrBirBmrBqrBsrBtrBwrByrB{rB|rB~rB_sBasBcsBesBjsBksBlsBnsBosBqsBrsBtsBysB{sB}sB_tBatBdtBetBftBgtBjtBktBltBmtBntBotBqtBstBvtBwtB|tB_uBauBbuBcuBduBfuBjuBluBquBsuBwuB_vBdvBevBgvBjvBkvBmvBpvBwvB{vB_wBiwBlwBowBswBvwBywBdxBexBfxBhxBoxBqxByxB}xB_yBayBdyBiyBlyBpyBtyBzyBazBdzBfzBjzBkzBpzBqzBszBxzByzBzzB|zB}zBc{Be{Bg{Bi{Bj{Bk{Bs{Bv{Bx{B{{B|{Bd|Bj|Bl|Bo|Bu|B{|Be}Bi}Bk}Bl}Bm}Bn}Bp}Br}Bs}B|}B}}B_~Ba~Bd~Bk~Bo~Br~Bu~Bv~Bw~B~~B__Cb_Cf_Co_Cq_Cs_Cz_C}_Cc`Cf`Cl`Co`Cp`Ct`Cv`Cy`C}`C~`C_aCgaCjaClaCoaCqaCraCtaCvaCwaC}aC_bC`bCbbCdbCebCfbCkbCnbCrbC~bCccCecChcCicCpcCqcCycC|cC~cCadCcdCddCedChdCldCqdCxdCydC{dC|dC}dC~dC`eCeeCheCjeCkeCleCmeCneCoeCpeCweCyeC}eCbfCcfCdfCffCgfCofCsfCwfC{fC`gCdgCegCjgClgCngCogCugCwgCygCzgC|gC}gCbhCdhCehCghCkhClhCthCaiCiiCmiCuiCyiC|iC}iCajCdjCjjCljCnjCqjCsjCtjCxjCyjCjkCkkClkCpkCskCukCykC{kC}kC_lCblCmlCvlCwlCxlCamCcmCdmCemCfmCgmClmCmmCqmCsmCymCzmCgnCjnClnCnnCpnCsnCtnC{nC}nCdoCeoCgoCmoCvoC}oCapCcpCdpCgpChpCipCjpCopCqpCvpCxpCzpC|pC~pC_qCqqCvqCwqC{qC`rCdrCerCorCsrCwrCxrC_sCosCqsCtsCusCzsCbtCgtChtCjtCotCxtC_uCauCcuCeuCfuCluCmuCpuCquCsuCtuCwuC{uC|uC}uC_vC`vCbvCdvChvCjvCnvCsvCtvCwvCbwCcwClwCpwCvwCywC{wC|wC`xCdxCgxChxCoxCrxCsxCuxCzxCvyC{yCbzCizCmzCpzCszCuzCvzCzzCf{Cp{Cr{Cx{C{{C|{C}{Ca|Ce|Ci|Ck|Co|Cy|Cj}C}}C_~Cd~Cf~Cg~Ck~Cu_D|_D}_Da`Dl`DdaDwpA{pA|pA~pAcqAfqAmqAoqAtqAvqAwqAyqA|qAfrAgrAirAjrAkrAlrAmrAnrAorAprAqrAsrAvrAxrAyrAzrA{rA|rA}rA_sAasAfsAgsAhsAjsAlsA|sA}sA_tAltAntAptAqtAttAutAvtAxtAytAztA{tA|tA}tA~tA_uAcuAfuAguAkuAsuAuuAwuA~uA_vAavAdvAqvArvAsvAtvAuvAvvAxvA`wAbwAfwAhwAiwAkwAlwAmwAnwApwAqwArwAtwAuwAvwAxwAywAzwA{wA|wA~wA_xAaxAdxAoxApxArxAzxA|xA~xA_yA`yAbyAeyAuyAvyAwyAyyA{yA|yA~yAgzAizAlzAnzAozAqzAszAuzA|zA~zA_{A`{Aa{Aj{Al{Aw{Ax{Ay{A{{A}{A`|Ab|Ae|Ag|Ah|Ak|Ar|A{|Ah}Ak}Am}Aq}Aw}A~}A_~A`~Ab~Ad~Af~Ag~Ah~Aj~Al~Am~An~Ar~Au~Ay~A|~Ae_Bg_Bi_Bn_Bp_Bv_Bz_B|_Bd`Bg`Bi`Bl`Bn`Bp`Bs`Bx`Bz`B_aBaaBbaBhaBjaBlaBoaBraB{aBabBbbBgbBibBobBpbBrbBicBkcBncBqcBtcBucBxcB}cB_dBcdBgdBhdBjdBkdBldB{dBbeBdeBgeBmeBoeBqeBreBueB{eB|eB}eB~eBhfBjfBmfBnfBvfB_gBfgBggBigBngBpgBqgBrgBsgBtgBugBvgBygB{gB`hBohBrhBthBwhBdiBhiBniBviBxiByiBziB{iB}iBajBcjBdjBejBfjBhjBjjBkjBljBnjBqjBrjBsjBtjBujBvjBxjByjBzjB|jB~jB`kBckBikBkkBokBqkBtkBvkB{kB}kB_lBblBelBhlBklBllBmlBrlBslBulBvlBwlBxlBylB{lB|lB}lB~lB_mB`mBamBcmBfmBhmBimBjmBmmB{mB}mB_nBanBfnBmnBonBrnBynB{nB`oBboBfoBloBpoBqoBroBvoB{oB|oB~oBapBdpBhpBipBnpBspBtpB|pB}pB_qBfqBkqBvqB|qBarBdrBgrBjrBrrBurBxrB`sBbsBdsBfsBgsBisBwsBzsB|sB~sB`tBbtBhtBitBptBrtBttBxtBeuBhuBruBtuBzuB|uB`vBlvBovBqvBsvBuvByvB~vB`wBawBcwBdwBhwBkwBnwBpwBqwBtwBuwBwwBxwB{wB|wB_xB`xBbxBcxBgxBkxBmxBpxBuxBzxBbyBeyBjyBkyBnyBoyBsyBuyBxyB{yB~yB_zBbzBezBhzBizBlzBnzBozBrzBwzB`{Bb{Bf{Bh{Bm{Bo{Br{Bu{Bw{B`|Bb|Bc|Be|Bg|Bk|Bm|Bs|Bt|Bw|Bx|B}|B_}Ba}Bb}Bc}Bf}Bg}Bh}Bj}Bo}Bt}Bv}Bw}Bx}Bz}Bb~Bc~Be~Bf~Bj~Bl~Bn~Bp~Bs~Bt~By~B{~B|~B`_Cd_Ce_Cg_Ch_Cj_Ck_Cm_Cn_Cp_Cr_Cw_Cx_Cy_C{_C|_C~_C_`Cb`Ce`Cg`Ch`Cj`Ck`Cm`Cq`Cr`Cu`Cx`C|`C`aCaaCeaCfaCiaCkaCmaCpaCsaCuaCxaCyaChbCmbCobCsbCubCvbCxbCybCzbC{bC|bC`cCacCbcCdcCgcCjcCkcClcCmcCncCocCtcCucCvcCxcC{cC}cC_dCbdCfdCgdCjdCkdCmdCndCodCpdCrdCtdCudCvdCzdCbeCgeCseCueCveCxeCzeC{eC|eC~eCafCefChfCifCkfClfCmfCpfCrfCufCvfCxfCzfC}fC~fC_gCagCbgCfgChgCigCkgCmgCpgCqgCsgCvgCxgC{gC_hCahCchCfhChhCjhCmhCnhCohCphCqhCrhCshCuhCwhCyhCzhC{hC|hC}hC~hC_iC`iCbiCciCeiCfiChiCjiCkiCliCniCoiCpiCqiCriCsiCtiCviCxiCziC_jCbjCejCfjChjCmjCojCrjCujCvjCwjC|jC}jC~jC_kC`kCakCbkCckCdkCekCfkCgkChkCikCnkCokCqkCrkCtkCvkCwkCxkCzkC|kC~kC`lCalCclCflChlCilCklCnlCqlCrlCslCtlCulCylC{lC|lC}lC~lC_mCbmChmCimCjmCkmCnmComCrmCtmCumCvmCxmC{mC|mC}mC_nC`nCbnCcnCdnCenCfnCknConCvnCxnCynCznC_oC`oCboCcoCfoChoCioCloCnoCooCpoCqoCsoCtoCwoCxoCzoC{oC|oC~oC_pC`pCfpCkpCmpCppCrpCspCupCwpCypC{pC}pC`qCaqCbqCcqCdqCeqCgqChqCjqCkqClqCmqCnqCpqCsqCtqCuqCxqCyqC|qC}qC~qCarCbrCcrCfrCgrChrCjrClrCmrCnrCprCqrCrrCtrCurCvrCyrC}rC~rCasCbsCcsCdsCesCgsChsCisCksClsCmsCnsCpsCrsCssCwsC{sC|sC}sC_tC`tCatCctCetCftCitCltCmtCntCptCqtCstCttCutCvtCytC{tC|tC}tC~tC`uCbuCduCguChuCiuCjuCkuCnuCouCruCuuCvuCxuCyuCzuC~uCcvCevCfvCgvCivCkvClvCmvCovCpvCrvCuvCxvCyvC{vC|vC}vC~vC_wCawCdwCewCfwCgwChwCiwCjwCkwCmwCnwCqwCrwCswCtwCuwCwwCxwCzwC}wC~wC_xCaxCbxCcxCfxCixCjxCkxClxCmxCnxCpxCqxCtxCvxCwxCxxCyxC{xC}xC~xC_yC`yCayCbyCdyCeyCfyCgyChyCjyCkyClyCmyCnyCoyCpyCqyCryCsyCtyCuyCwyCxyCyyCzyC|yC}yC~yC_zC`zCazCczCdzCezCfzCgzChzCkzClzCnzCozCqzCrzCtzCwzCxzCyzC{zC}zC~zC_{C`{Ca{Cb{Cc{Cd{Ce{Cg{Ch{Ci{Cj{Ck{Cl{Cm{Cn{Co{Cq{Cs{Ct{Cu{Cv{Cw{Cy{Cz{C~{C_|C`|Cb|Cc|Cd|Cf|Cg|Ch|Cj|Cl|Cm|Cn|Cp|Cq|Cr|Cs|Ct|Cu|Cv|Cw|Cx|Cz|C{|C||C}|C~|C_}C`}Ca}Cb}Cc}Cd}Ce}Cf}Cg}Ch}Ci}Ck}Cl}Cm}Cn}Co}Cp}Cq}Cr}Cs}Ct}Cu}Cv}Cw}Cx}Cy}Cz}C|}C~}C`~Ca~Cb~Cc~Ce~Ch~Ci~Cl~Cm~Cn~Co~Cp~Cq~Cr~Cs~Ct~Cu~Cv~Cw~Cx~Cy~Cz~C{~C|~C}~C~~C__D`_Da_Db_Dc_Dd_De_Dg_Dh_Di_Dj_Dk_Dl_Dm_Dn_Do_Dp_Dq_Dr_Ds_Dt_Dv_Dw_Dx_Dy_Dz_D{_D~_D_`D``Db`Dc`Dd`De`Df`Dg`Dh`Di`Dj`Dk`Dm`Dn`Do`Dp`Dq`Dr`Ds`Dt`Du`Dv`Dw`Dx`Dy`Dz`D{`D|`D}`D~`D_aD`aDaaDbaDcaDeaDfaDgaDhaDiaDjaDkaDlaDmaDnaDoaDpaDqaDraDsaDtaDuaDvaDwaDxaDyaDzaD{aD|aD}aD~aD_bD`bDabDbbDcbDdbDebDfbDgbDhbDibDjbD`mA??????????????????????qI??mT?qI???????????????|U??fI???????K???wD?YfB????fB?????????[?mD??K??a@nW??[?fIm@????{Jd@??mD?R?fB????????AwD??r@sJvBrBAG?{J?Ym@?A?mD?nX?A?fB???????r@???wD@AhDeK@?A?????mAAzY?mA@H?d@??@?A?yKDoAB??d@T??B@????M?@hKABD??m@D???MBBlW?B?lJ?|E??M@fZxY@~JARY??????RRDB?B?K????jVf@vB?hV??BABdF???ABTG@VB?}E?B??ArD?@@@??W?????iE??@??@B?aFG?Af@?\@B??B?G????@?@B???B@?A|Es@rW?`F?B?g@?Z?~L?B@A??ABB???@A??`KmLCgCCH|EBuA?AC@BC??AChA?@?DgCoFH?HwFH?H?xFwFH?EEEoCEEE?{^??hLsM???@bAA@?Hd@??qEh@??w@?~EApCIC_MV??@????aCA@mBBD?C?AC??GtF?@@?CtA??J?BaC@?@???nAA?|B?C?B??A?B?D??N@?~ECZ?r@@?@??AA@@iC???Bq`@A?@BB?A}F?s@kN`[ALAGC???@CB?d]A??B???J??C|L??FC??CCCm@KrC?CDcN?BxAC~EiF^?w@A@~F@gC@BCg@AYmA????mEmNs`@nK?????e`@~LA?Bm@U@??VAC@?tE@?BA???gCuIF?LoA?@FFDBIo@?@@@?@Y@nAgA?@B?f@B}LAB?@?B?V?nAzA@??B??AsJ?JpE?iCCA@bC?@yDzEA?F??BK?g@?AmC???A?fG?A@@?AIAB{CvB@@I@fM?oF?IA?A?_a@C?@@?@ATBBI?BF?l\uGB??d@?@?|@mE?f_@A``@{@??b^??iO?HK?A@??BI?D??@}BpAHBB?nEEEEEEEE?EEEEB?dU??C??IsGT???@yE?@Bu@A|@zB@??@???F??D@??BBzCzEsFR?gZ@??YA?yE?BF@Bd@A?FB???BBB??@?uK?Wi@??iBA?Ab@_Be@??B??A@jCiO?wM?uD@?}Ma]?@yGaM??lc@??W?K?A?Z[}FgLD?@v`@BfC???`HpM????A??eC??BX??@C?DLND?A?@{A?dF?JA?{@?y`@?FD@??B@`F?aH???pEcPH?`E?g@???tGGVkB?GALBzO`JAIra@?yZAb@pEB|AB?@z\??}F???~NnA|d@@Asd@bBA_OF?@bE???A?@A@mF?iBAIqElFh]FAA@?D^cF?A??F?_FBD}c@?@A|@??A?fHBAq]??I?B?AAK???eC@?BBB?B?aC?_M?????A?F????vC??@|GgM?_De@AD~FB?JaH??`B?????B@?AB?}A@?@@?DB@@@JZ??xEBG?@B{C?`EfM|MzC??aBl@K?dNBg@B??B?A?i@?@tA@??cHA@`OnABub@k@CB@L@fd@?pKz]@@@@uL?`HrM`HExFwFH?_A_A_A?|f@???|N@|N?cD@TpC????bB@jHA??Arb@???zO^iCA?AB??rOA??`PA??@IBre@@DB?rC???A?BAr@?A@?@BC?@F?G?LBAcLAcd@?CB?B_d@C@?Bf@@?uGCCBCA??D|@tAC@}D?nEA}D??bB?k@Ksb@?V?@c`@??cb@DCjg@CAC???tGD?Jxc@?jP?i@`AvPC?Anb@C?XDA??@cDoAf@??iEr@`AC@tAB}L?~P?B???BGCJp`@?}@tC??jD@FCv@HAxAA?rA@??Ki@A?A}CpAA?B@ChOC~Be@qQEEEEEEEE_A_ApMxF_A??B@lGaFBJ?AcHA?@A?@G@??r@@?@`BB??J??gH_H?B@W@?}`@?@lHBBH@??A?T?D@?t@?CHyB@A??G??pGjCpG?@@?@?BBuBab@@wCA?B?@~AF?@tF_DAv@@~A?uN?@df@?MkM??@@A?}A@L?`BDcD}ABB?xP?BC@?u@B??_R@???BoQcHpP@XcG`i@?W???A?qf@DBgHF?A?_DC?eLBs@?k@@A?@@jC`C@??CmJ?F?vOzD?tF~\B`ACpHAl@??bH???fH{KBB?@??@?Y???Cye@A???@RyO?Nl@CxHB@AEEE?EEEEs@Bgd@oAkH?HeL?W?`RwOAAAA}DAJH?FhKA?@@H@}b@@?FQ??G{@@B}QA{M@BAAwC?ni@C?A?AAA?i@jC@BoO?iB@?k@_R@?AK}i@?yQmABG@?rCDoFAF??G?nRqc@xD?FBQ?n`@??DwHAAA?gRZ?tE|P]A@AC@w@gM@??wC???cC??vOJoA`AB?@@g@\eBmEBD?~P?d@B~@yg@B?L?b`@rA?@?AAmB?jQb@A?cFB?@L???hR?BD???BA{H?vg@hG????@yNATBcR@@G?ei@?}EAAii@^@AA???~Q}B???ee@Ak@sHIePByFEoCEyFsi@EEA?A_[??BXrRDAAgR?xA??aIAxHMwC??AI|B???yQA@@?kPlK@?R?{C@vJ?@cL{AABjPAA?D@ki@?Bl@?A@??~b@?G@?iB??xP{MmA?cPmMD?fH@?xA~F?}ALaI?k@?Bf@GsHB??B?????`B~i@?AD?Ai@@??_BABAdD@K?A?@`j@jA@eb@tEqLbI??oe@??BB?BAwLAJ|g@BlQbBA~O@IsHiLABR{H?qi@AA@?@?hj@?vBXtMWaF@?oH?ArABB@a@A?Md[pC`AdCJrH\kRB?aO?uKfNA?eHaIk_@A??????yH?@kNrAA@@A`f@@Xi@dG?AxAoHB?mC?pCph@bc@jk@ADW@@_G~Q@LB?iFACA`B?mNtG?}a@?B@?`@?zFACrR?BACCGsN?bC@@?lH@g@?@@Q?_Gu@?_DBA?RTCC?_G@C?Q?~a@xOAcC?BF@?A|@bN?yBABpk@?tOA@??xHD@??@@~A@uh@{@Veh@gPbCk@?vJBBvi@?@A@@vRpHX`AFjAuRiF?B?C??DBAnF?CBV?@BCf@BbB{A?@_i@B?u@`P@nR^??B@A^mBV~Ayj@u`@I@BlHC?@B?lj@?C^?u@oRJDqk@~A?CrAByG???bC|CB}C???{@@@AAld@?@wj@?B?B?BA??AA?@uk@ID?u@D?A?cFCeCBC^?gj@yKaa@?BqAATC@??BA??Lxg@?@????yH{HC?WyCpN_K?aH{B?@C?{KuR@?M?@vRCXCyi@{@zC~c@C@kRB?@sk@fi@C?B`QA??fNBCA??A?B?C?D?E?F?GxRByRD{RH?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_@?`@|RCzRE?H~RJeIa@?b@?c@?d@?e@?f@?a@hIc@oSe@pSa@hIg@`Sh@kSD}RI?i@?j@?k@?l@?m@?n@?o@?p@?q@?r@?s@?t@?u@tSr@uSt@?v@vSu@wSw@?x@?y@gIVeSz@aAElSI_SK?{@?|@?}@?~@?_A?`AbAW?aA?bA?cA?dA?eA?fA?gA?hA?iA?jA?kA?lA?mA?nA?oA?pA?qAOXfSZ?rA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~A?_B`TYgSrAaTtApI`BkIHmSKySaB?bB?cB?dB?eB?fBgBZhSgB?hB?iB?jB?kB?lB?mBjSnB?oBhDiA_TkAoIpB?qBlTIxS{@?rBzS}@?sBOaA{StB?uBnThAmIjAnIlA_@nAiDpAoTJeIvB?wB?xBn@rAkTuAbTwAdTyAfT{AhT}AjT_BtTK?vBuTyBn@[iSzB?{B?|B?}BnDa@rSd@iIf@sSb@nSd@}Ta@wIe@~Tc@jIf@qSb@xIe@`Ud@iIa@oD~B?_C?`C?aC?bCkDbA?tBtIoBrIjAnIcC?dC|Tb@zIf@bUe@fUf@aUc@jIa@oDf@gUd@_Ub@{If@hUe@?~B?eCnD{@?aBdAfC?gC?hC?iC?jCjUjC?kCvI\?zBzT|B?lC?mC?nC?oC?pC?qC?rCdAsC?tC?uCdA|@lIsBdAaBdArBpTvCOwC?xC~ShAsTkAoImAeBoA?yC?zC?{C?|CpU|@lI}CgB~C?_D?`D?aD?bDcUhA_JlA?cDnDvB?dD?eD?fDjBgD?hD?iD?jDwUhD?kD?lDjBwB?mDcAnDgDgApDkAo@nAiDyCrDoD?pDp@xBZxCqUiAsIlAlDoA?qD?rDeAsD?tDp@kDxUuDp@vD?wDp@yB?xD?yDbAzD?{D?|D?}D?~D?_E?`E?aE?bE?cEgJdEdBOaSQcSSp@eE?fEjBgE?hE?iE?jE?kE?lEbJmEvIgB?nE?oE?pE?qEyUhAtDmAqDqD?rE?sEoUbB?tE?uE?vEQgAdJlAlByCrD{C?wE?xE?yE?zE?{En@|E?}E?~E?_FaJaDtUuBrTiAeJmAkJrDeA`F?aFhBsA?bF?cF?dF?eF?fFcAcA|SeA}SgApVmApBgF_V{D`V}DbV_EdVaEhJhFyV|DaV~DcV`EeVbEOiFgDjF?kFcAlFuVbD~IgAqBnAoJtApIvAcTxAeTzAgT|AiT~AoVhAfAnA?mFOnF?oF?pF?qF?rF?sF?tF?uF?vF?wFuUiAoBnA?xFfVPbSRdST[iAhAmF`WuAvTxAbW{AyT~AcJeAvDyF?zF?{F?|F?}FkUzB?~F?_G?`GrBjAuImAqDpArV}EsV_FaJaG?bGzJ{B{TcGjBdDvUdG?eGxWfG?gG?hG\jAiAiGnU}@qTjGiJkG?lGrJeAvDjAiAnA?mG?nGoWvAaWyAxT|AdW_B{WwAwTzAcW}A{D~EtV`DsUbDuWkAkBoA`JzCsDrD?`F?oGjAkAo@pG?qG?rGqJsG?tG|JlAqVzC?oD|D|B?uGmWQgVTtBRb@gAqBpGaEvG_X_F~VuBnJjAiAcDdBwG?xG?yG?zGfXSbEhAuJoALTcA{G?|Gc@}G?~G?_H?`HtIaHqJ}DzV`E|VcE}WxApW|A{DbH?cHcEiA?yFsBdH}V`D`XxCzWkA~DqDeArDaXaF?eHeEyA|W}ASlClUfH?gH?hH?iHjJnEkVpE?jHgDfAbKlAlBpAlAjAq@oA_EoGrXzA~W~AkAlAlBkHpXaDvVoB~JqG?lHhBmH?nH?oH?pH?qH?rH?sHdXmA?tH{XnH|XuH?vHeKuBhXkAo@tHgKoH}XqH_YsHfKnAYqASwHhE{AqW_BmX~D?xH?yH?zH?{H?|H?}H?~H?_IkE_E{VbEpJ`IxBoAfJrE?aIwBbIlEqDfE`F`@cIwBuBjElAQjFe@mAcXtGUiGbY|AkAvG?dI?eIUnAyBoBtJoAa@oFeWfI?gI?hIc@iIvXgApDjIlY}AxXkAkBmFiK`EwBuH`YsHrByFsBkIoJbF?lInViAoBtHrY~AsYaEhJcEa@mI?nIcAtBfKtHmKuBjElH?oISpIPcF?qI?rI?sIkEtI?uI?vIoElAqE_BpKuBkYmAqDyCnBwExDyEgAsExJgAzByCnB|CwYbEsKoBwBpH~XrHPlIvYjAiAtHcKmC?fHdKhH?wI?xIbAyI\zIgX`D?aG_WhAdEyC{UpDpAcEyYoBrIyFhB{I?|IaK}I?~I?_J\yFsE`J?aJ?bJhZiAhAoA_E{CScJkExHcYzHeY|HgY~HMoAbZeAwXmA{YzCsD|CpJdAqYhAfAcD?dJ?eJaZqH|JlHs@fJkAlHjZhAfApG_KdINyC|YxEmJzEmBaI|BgJhBhJ?iJ?jJ?kJ?lJ?mJrKmApBxE_CsEuXoElVqEcZkA~DpAQxE_CnJLoJsZiJtZkJ|KpJ?qJ?rJxEeAxVhAfAtH?sJ?tJn@uJ?vJ?wJ?xJ?yJ?zJ?{J?|Jh@fAwEnAiK}JaK~GkX`HlEpA|DxC}ZoAsEaDzXhAiZzCeXpDnE~JUpG`CnAzKzC`E`F`@pDNqDeA|CdL{CP_KtKhAP`K?aK?bK?cKPdKSeKsXgHtXwI`LfK?gKxKrHaYoBNpAxKuBrEnAg[sHlEyCnBrD?hK`ZhAdEpAiLuBjEvG`CtHjX|GyEoI?fJaLgAzBpAk[iAuEpAn@iK?jK?kK?lK?mK?nK?oK?pKgBqK?rK?sK?tK?uK?vK?wKtYvHh[hAdEqDlKaFeUc@yIf@}Ia@|If@}If@w[b@zIa@|Ia@oDa@x[b@{Ia@wIxKwWyK`L_HlXuBhLoAvE|CgJxDiJhEiVkEmUtC?zK?{K?|K{[}Kp@~K?_LO`L?aL~KbL?cL?dL?eLnYhAtBfL?gL?hL?iL?jL?kL?lLxBmFoYpFfWrFhWtFiWvFkWuBrEmLn[jKo[lKq[nKs[pK?nLz[`HkKrE}KuBeFyCsEaGmZjAq@yCzJ~FsW`Gi[zC`FhKSoLfFkKp[mKr[pK}KpEmVeAbLyChCjA`KdJ?pLgKqLgFzIdBrL?sLfCoB_ZzCsDwE}YzEv[d@iUc@yIa@y[c@p\b@xItL?uL?vL?wLq\xL?yL?zL?{L?|L?}LyW~LpLqFgWsFwJuFjWwFgFoG?_MbJ`M?aM~UwDuLkAdBbM?cM?dM?eM?fM?gM?hM}BzF?kIyJiM?jM?kM?lMOmMsLnM?oM?pM?qM?rM?sM?tM?uM?vMbFrDuBcIgLoBzBqD{BwMnZgAhF{CyDaFKxMqKdFwVyMk\_GtWuBeFpAu[sHgF{C}UzMeCqAbF|CrLoBc]|CsA{FyJ}Fa[iAsIvGmYeIoKeA|ZiAoBcDt@hKg]uBnJyFmF|F?iMyXbD~IjFb]hAoElHUcDt@|FoLiAiCqAi\xCm\zCn@{M?|M?}M?~M?_Nv@dJ}[gL~[iL`\kLb\uBh\zCkZaJlZxCbKjIbMxCvD`Ng\uBp]|M?aN?bNe]eF?cNMxFMmFtLqExZlA_@mL_LgAqBtHrFiAuEqDfEsD?zM?dN?eNr]hL_\jL?fNcMjA`MoBhYuBsF{CeMhAdCrDjFlA_@gNcEhNu]bJj\kAqXrDuAeH~]iAuFyFsB{F?iN?jNdMgAvFoBdJvGaAkN?lN?mN?nN?oN?pN?qN?rN?sN?tN?uNc^lNd^nNf^pNh^rNj^tNl^|Cj@mNe^oNg^qNi^sNk^uNnMnNm^qNq^tNs^oNp^rNo^uNu^pNn^sNr^|Cw^qNt^uNx^rNv^|CoMsNy^tNyFuNoC|Cj@vN?wN?xN?yN?zNz^wNqMxN|^{Nj@|N?}N?~N?_O?`ObMuB~^}N__@_Ob_@~N`_@`OyLrFc\uFs\uBeFqDqAeH~ZbDxBmG?aOi]hAtDpBjDjIf]`GkKrDmKbOlA`No\hA_F{ClJxEzEaIl_@iAeJpB?cOpFfAwEcDd_@sFr\vFe\oBhFsDc@xGiXdOo_@tFd\wFe@pBa_@oBzFjAgEyCr_@uFe_@oBpDvGa@eO?fO?gO?hO?iO?jO?kO?lO?mOtMuBhMwExLsEv]oBqBiGx@sDUtHt_@kAa^hAlLrEx@rDuBeH?nOiMmAuDpLn\uBsFoGf[gKrBzFlMjAgEqDfEoO]xFs_@hAmIyFuY|FaMjMh`@iAy]rDxMaIkLrKt[pOd`@oBhD`N|]kA_`@hAfAiG?~J`]hAuJxF_NlA_@cDt@pL?qOtBrO?sOg`@kA\tOlF`F`@uOyM`FsClAlDxFnCuBbNmAvWqASvO?wO?xOPyOpFzO`^hAtD{O{]iLs]lLqKqI?|O{FlAsA}OkD~O?_PeNmApB|CaNiA]oAjKsE}]hA|MzFzD`P~KaP?bP?cPhNmAy@nAzUzC?sDw@dN?dPwAePz@iGlC}M?fPv_@vFp_@hA_JlHsAdH|BfHeZwI?gPNkH?hP?iP?jPe[mCdZgHfLxImLaLbGnAcGoDcKkPgNjLa\lLxBpAzAlP?mPpLfIpY_Il[fJvCyCrZyEgA{Ew`@iA|FgFy@cDm]iMNnPkC|F}MkMbGcDj`@sK?pOnNoAo`@aFqCiA|FrD[oPuCcDx@|CbFwEz`@wFtCoGgGqDeAxEfChAyMsDoNkLt]oBpNzCuCnAlAyFiGjAq@pAnCpPiNjAzMrDxLnJUxFr`@wOka@xO{`@gH?qPlNfHdKrPgGpAf`@uBrEtHvNuBi_@uBjAjIxNoAw_@fO?sP?tPmGpAgGyCrFhN?uPtLjHoZiAuEyC_^xCo]sDx`@dPiGyFmCiM{BnIlCvP?wP?xPma@oB~MjA[hNnKdInFjAgEpA~NkAuFzIuFjAzNrD_]yPz@nAva@kAvCqDga@yEk`@hAdFqAm[hA_FoGca@iM|LkMx]eAwEtHv@eJyLzP?{Pta@kA~DyCtB|P?}Pia@kAhGzI|AlAlBqDqAyP{E~PdLoDxJjFoa@eAj]jAq@mFt`@iAuM_Q`NiAua@eIoGlA}J{Cea@xEO`QvKaQ?bQ?cQbb@fAbLpAya@lA}JoDvCpAna@zCwKdQ?eQ?fQ?gQlMyF}NgAtJmFbGtHsLlKf\oKjLhQfOyE~YaIlNgJa@iQqFiM|CmAn]gA\jQ?kQcCqG?vGxCrP?lQ?mQc@nQxChHfFoQ?pQiMcDlOvG_b@lAcOrEuCtHjFlHjOmK{EyEgAqQ?rQza@rDkMnOoXcHkCsQpb@nKqLnL?hQ?tQyAoAjK{Eg_@iAhAmG{NoB{AgOz_@iOxCuQfb@gAzKhKkOvQlGoBpOwQ?xQjGrDyCoA_EoDZaHyb@hAa`@aIOyQ?zQ?{Q?|Q`CcDlCaNw]}Q?~Q?_RQbGsG{Czb@iAda@`F`@yPoC`R?aRwNoDdb@jAqOxE_CaImOlQoNfNrGmApBrDxa@bR?cR?dR?eRdCrEc@fR?gRtNpO?hRvNaHha@lLj_@|Cn_@gAyAmFqGjA_OqAyOhRib@hAvM|CwAiRv@jRbAkR?lR?mReEnR?oRgNpRwGqD{OiA|FxEdc@uBwGpAb@kFfFqR?rRPsRvGnA?tRPuR`a@gItNvR~CtHx@`Fq_@yG?wReG`N~CnAqOrDrCnOeGjAsa@hAl`@~JzGyCqNzE`DoAqFjMxNmFkAcCmGyCqNoOnGxRSyR~OqAja@kAiEoI?zR|a@gAec@hApZ|Ftc@hAh_@qBwGyCbP{EdOmAaA{R?|R?}R?~R?_S?`S?aS?bS?cS?dS?eShOzFzD|Fmb@mAuDdJ{LjMtAlMiNyFmC|FxOsE|b@bN?}Q?fS?gSzAhS`MhA}@nAiDqDzCzE|OrDxMnJic@oBhFoDbO}P`c@kAjM|C~CiGkPlA?pB?iS_HmA[jS?kS?lS?mS?nS?oS?pSj@qSj@rS?sS?tSnMuS?vS?wShd@vSid@xSbDyS?zSlPpSbD{Sjd@zSlP|S?}S?~Sh@aHoEvG~@nA~GrD?gFM_MsCdI{D_T?`TsAkIgPkMl]fJ{GqDqAcI?yP?zI`OiApa@zCbX_Mkb@hAuM_Iuc@iAhAxFcCaThCyF?jIz@pGaErGObTx_@gO?wQ?cT?dTpc@zC`d@aIyNzFrFaTvFeTmPnGdPiAaOiAqd@{Cb@fTqPjAu_@zC_BgTsc@zC|GlAeOrDuBpD?hT{GpAzAiT{GyCzd@kAmc@jT}OjAaBoAnFyF{BkT?lT?mT?nTuOjAzNxEaPiAtd@jAq@xFgc@lR?oT?pT?qT?rT?sT?tT}NaHuCiGxb@hA?oPpGpDnGmT?uT`e@kAxd@jAoc@kAo@iGae@zF?dHm`@sOyCmF~@cDt@vTlCwT_NcC_PoAfJrD|AxTvPkAjMxEsGoDoOoKjLyT}CiH?zTne@kIpPlM`G{Ted@hAsPmA|AvGsCrG}@tHbHjAiApGqZeIse@iAk]dJjNbP?|TiYuBhM|C]}TlAjQ|AcCuPjA{d@oDN~TiP}Qbd@gSvF_UfDnA?}TqF}Ft\cMu\eMw\gMx\tQle@kAjc@`U?aU|PoBvAbUa@cU?dU}CwI?eUpAhF?fUke@lA~d@`F`@gUaBmFh@hUwPmR?iU?jU?kU?lU?mU?nUpFeTrLeT~e@aUwAiS|`@hPxEfAnOrDl@hKwAqBgOoU}GdH_QpUjJqU?rU?sU?tUqCuU_BvU?wUaBmGje@iAoBiGcDqAqb@zE?qQgHiUef@kU?xUcByUwPoT?zU?{U?|U?}U?~U?_V?hF}e@lA_@tHud@zFePiM{PjAzM`V_e@zC~_@oBvb@hAzGqDmF`Pjb@zE_f@hAvMrDtCaFxGjAge@yEgAnJof@iAue@pLvc@zClb@pQ}AqAyGlQ?vUvAaV?bV}PoArf@vU~CcDba@jMkHpD?xMeNpB?iRpf@kAnf@iAfc@kAfPnAnP|CkGzMaAcV?dV?eV?fV?gV?hV?iV?jV?kV?lV?mVj@nVbDsNyf@tNzf@uN{f@|CqMyN?{N?oV?pV}^yNc_@_OsMqV}f@`O?qV~f@qV|c@uPj@rVrMsV?tV?uV_g@}N?sV`g@uVag@sVbg@uPjHsE_HpBxe@kAo@cDjF{Olf@kAkBxFUvVbf@mAeBmFmHlAcOrDyDoGbQqQpOhO{_@jO?wV?xVjH{EzPnLxf@jAnOxErd@iA|CyVvd@fOy_@wQ?zVpHiO|_@kO}_@mOhQoAtPlA_@iGte@kAaCqAfe@kA`b@zCwLxE_C{EyA_BjO{VlFhKwf@lAdg@rD}E|Vc@}Vy@tHeDqDqApDnHlAsCvG}G{FnHrGqg@mA?pGlQmA~BoDze@fSqG`NeGyFhPiMhCjQdPyVod@rDuAcIpd@bRcc@~Ve@cDcMyFoQjMMmGXqAgg@jAq@mGeD~TaG_P?_W?`WvKaWcQoDcQ{CrP{FdDyC{AsP?bWhg@mAh@gAiH{F{LkMeQjAeg@kA_PmF{e@dMv\fMzLhMzPpK?cWgQpAwc@|RiQlAeO|C{g@kAjQdJvLzImPoArQnA~G`VyPlA?dW`DeWwAcOiQvG~g@mAcEfW}@pGme@lAuGjM{a@jMe@dW|@qAkGtDcBeUhHoG_h@lAqHpG`QgWrJaHrGpBwN{CzQwEOhWrQtHzFjQgQyCj[`FvQoAtQiW?jWig@lA_@kW`h@mAbDwSjh@sNhElW?mW?nWnLcL|[oW?pW?qW?rW?sW?tW?uW?vW?wW?xWdDqD|GlHs@zR}B{F{O`NaNsQob@oIsQlAmQgOwb@yWtb@|Gfa@_MiGjQ?zWrHaOaBxFzHmAkJrErNdJvLqOfQsDw@iPy@iGxQmA~B{Cgb@eQhb@{WuH|CvGtH|OrEqa@zFy\|FsNlMjf@pThe@rTkQcDcB|Wqh@rDsOzQ{b@}WyAxFqHjI}@cDcNqOgObQ?~W?_X?`XeDyCbPsE?nJyCgNuHrDla@gHfLgPzHaXfg@yEtQeM|e@aT|HnAcG{Cm_@yE`DbXpAcXhf@wUug@kAlg@{CjGsEyBzOvf@hKsQzIkf@mA~BhKrKpBjDeP}HoAvErDl@xMnNmFdGjPnd@|FZrEtHpDdCsEqGyF`RdJrg@nAdQrDuApDQrEwQtHsh@nAbR|CoHrQcBxIng@mAsg@pDsOdX?eXwK~I?fXnc@`F{FlHhRaF?cI~@tHMmLwOpDqHnAnPxEeMzIfGpLkg@lAog@`FuPyFkCqOkFoM{\qM|\sM}\uMiRoApe@rD|HiG}h@gXnQpAb[aKc[cKdQ`V}GkIfDiGqQ_W?hXwHyTdGdPeRnAoPiXce@mT?jXaP`N_BkXmi@lTde@nTpQrDl@zInCeAzGpAiRxF`InAbRrDoMlX?mX?nXmHlHaAoX?pXkd@oSmd@dIpi@qAmf@hAlLrDzh@`F]mFwd@{CcRzEtKhNyHmAeBmGkCqX~`@_NkQnAuOyFtg@kMpg@rDrUrXad@~QaD|CdHnTy@jRfGdJoP`Tbe@lTlR|CaDyEz@tH|i@oA`G|OyPcC{i@nAmR|FlAyV}d@oDeQyF~@jRbHyFtPlHaDrDoGvG[`NxCsXvAtXuHwEaGuXoLoPhH`FkOzWaQyFsBjIkDvX]mGjRyChHsDgf@dNtHhKvHtPdHuTzZjJuZlJ?pJ{ZrJNqAgIwXif@jUff@xX?yX?zXaQjAwa@`Fcj@dIhQxFyh@zCgi@mAfPoAwHcWfj@kJ|KmJ?{XrHnGkHeHqC`N`IcDuf@kMjGrEsf@bVjj@kAoj@lAlDmFdRlAcf@aFfOzEmQsP?|Xqj@mAth@|Cwi@iAyd@|Crc@dCdH}XmHcCmO~X_I`Fcg@aI}P}TjRpAcIkWkj@{Czi@sEfQ{CnHyVsR|C_IxEbO_Y?`Y?aY|QbYxGjQz@vTcJaHvGcD?cY_j@mToRzFeEdY?eYzg@zC{QnAri@`F`@eHbEhNah@kMlRwEdRvGsPpBeHcYdDrErNcYpRnGvAcNti@oIuQqDai@oAm@qAeDpA|HtHqRyFi`@iMrj@nAvAfYwg@gYaf@fUjAlHwh@rDiPhY?iYnCwXvHjYfDcDnj@lMli@oArOpD{FcCsKaH_I|CxGyFsAjIch@kYiHkIfCzOsRwEM_B`NjQpj@mAwZyE?lYvQmF|j@pLsj@}X|CiGoi@`FjYyP?bRQhAaRcQci@fX{PyFhP}Ftj@oAcIvVkLmYhh@yCgh@aFaj@yCbk@eHnLnYdIyCvh@qTnGwPih@wO?oYdj@zFbIpAlOlHhc@oRck@zCuQpAmj@lJvZ|GzApYwe@vQtOdJdNzIbh@mA{h@zEmGqDmMzFb@jF`ItHPqY?rYhNpBSsYxi@aFqRjAmRpL~j@aFdi@yP_k@cR?eTUaXgBjNpRaOtHzI?tYrG{OrPdHxj@oAfDtHvj@rDcBgP~MyF}HxFxQpB|QdL?oWlh@qWmh@sWnh@uWoh@wWaLrEy@pGaElHbj@`F_QuY_c@|Ch@vY~h@iM{ClMzj@`FlGwYdOpBhk@|Fij@xY|h@fMzLtQfh@zCbIoAhi@sDw@eNeRtHzQ|CtCeHtRpAok@qDdd@sE~HyCnByY]pAkGdNc@zYdMkFkF{YhCtO{j@iYfR{ENrEzHcDhE|YdY{HfY}HwJ}Y?~Y?_Zac@yEtRyCek@{FNdWwQnAlk@_Mfk@oGaG`ZaRaZdIpAjNbZ?cZ{NaH`k@yCbQrQ}@oA{EdZ?~P}j@xE{QtHwRxFdh@xEcInA~GrEnQyCak@zCmg@yEve@bQ?eZ}HmL_LkFx@xE|DjFtk@yEoKwYtf@wU}OjQnk@{CuAzIvHfZxh@{Q?}WkAgZeHdJ?`Puj@qBwMgWkh@mW?hZ`DxF`GiZui@eIdk@rTie@tTbi@mFx@yEPjZrh@pLpQxEwRoAvEwExDkZgk@pJoGlHh@wYdIqDfRsEaDsDqCjQ]mLqe@pDhGpDuNdJ}QzIkFlZji@mZPnZ?oZmk@gM?aTej@zCrk@zE~@pGvk@aIik@qBz@cDt@eJiHdHkc@|GqPyF~HqDkk@jMyAmGv@vT~HpA}g@}Ryc@_Szc@aS{c@cSkIF?pZ?qZ?rZ?sZ?tZ?uZ</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??B?????B??D??B?????E??F??C?????E??G??C?????E??H??C?????E??I??C?????J??K??B?????E??L??C?????E??M??C?????E??N??C?????E??O??C?????E??P??C?????E??Q??C?????R??S??@M?KC?T??U??@A?cE?V??U??P@?GH?V??W??`I?CG?X??Y??pW?gF?Z??[??@?????J??\??B?????R??S??pS?WC?]??^??@U?wL?_??`??PJ?sC?_??a??@A@sK?_??b??PD??H?c??d??PG?GC?e??d??@B????f??g??@L?sE?h??i??@??wE?j??k??@?????l??m??eF?[A?E??n??C?????E??o??C?????E??p??C?????E??q??C?????E??r??C?????E??s??C?????E??t??C?????E??u??C?????E??v??C?????E??w??C?????E??x??C?????E??y??C?????E??z??C?????E??{??C?????E??|??C?????E??}??C?????E??~??C?????E???@?C?????E??@@?C?????E??A@?C?????E??B@?C?????E??C@?C?????E??D@?C?????E??E@?C?????E??F@?C?????E??G@?C?????A??H@?B?????E??I@?C?????E??J@?C?????E??K@?C?????E??L@?C?????E??M@?C?????E??N@?C?????_??a??pr??K?O@?P@?pH?gN?O@?Q@?pG??T?R@?S@?P??g]@E??T@?C?????E??U@?C?????E??V@?C?????E??W@?C?????E??X@?C?????E??Y@?C?????E??Z@?C?????E??[@?C?????\@?]@?C?????\@?^@?C?????E??_@?C?????E??`@?C?????E??a@?C?????e??d??pB????_??b@?@W?GN?_??c@?pA?gO?]??d@?@B?WH?]??d@?PG?OI?e@?d@?pE?WQ?f@?d@?`D?[D?g@?d@?pH?O`?h@?d@?@A?SB?h@?d@?@a?CE?h@?i@?@`?OG?j@?d@?@@?wB?k@?l@?@?????J??d@?B?????]??d@?E??{H?E??m@?C?????E??n@?C?????E??o@?C?????E??p@?C?????E??q@?C?????E??r@?C?????f??g??P@?WE?s@?t@?@C?S??u@?v@?P@?Ka?h??i??@D?wF?w@?x@?`@????y@?z@?P?????{@?k??@B?__?E??|@?C?????E??}@?C?????E??~@?C?????E???A?C?????E??@A?C?????E??AA?C?????O@?Q@?@F??T?E??BA?C?????E??CA?C?????E??DA?C?????E??EA?C?????E??FA?C?????GA?HA?PG?GD?l??m??pE?[A?IA?m??@C?KS@IA?JA?e]?Se?E??KA?C?????E??LA?C?????E??MA?C?????E??NA?C?????E??OA?C?????E??PA?C?????E??QA?C?????E??RA?C?????E??SA?C?????E??TA?C?????E??UA?C?????E??VA?C?????E??WA?C?????E??XA?C?????IA?JA?@e?_e?IA?YA?p@?cW?ZA?[A?PA?_??ZA?[A?`J?o@?\A?]A?`A?cE?^A?_A?@S?g}?`A?aA?PB????E??bA?C?????E??cA?C?????E??dA?C?????E??eA?C?????_??a??@g?cJ?E??fA?C?????E??gA?C?????E??hA?C?????E??iA?C?????jA?kA?B?????E??lA?C?????c??d??pB?wB?O@?mA?@C?SF?R@?nA?PI?_hAoA?pA?@C?Co?qA?rA?PI?wmBE??sA?C?????E??tA?C?????E??uA?C?????E??vA?C?????E??wA?C?????E??xA?C?????E??yA?C?????E??zA?C?????E??{A?C?????E??|A?C?????E??}A?C?????O@?Q@?@I??T?E??~A?C?????E???B?C?????E??@B?C?????E??AB?C?????E??BB?C?????E??CB?C?????E??DB?C?????E??EB?C?????E??FB?C?????E??GB?C?????R??S??_P?OC?_??`??@F?WC?]??HB?@A??G?f@?HB?`D?CF?g@?HB?@Z?CY?h@?HB?@A?KO?h@?HB?@U?_Q?h@?IB?@`?gS?j@?HB?@@?{A?j@?JB?@?????J??HB?B?????E??KB?C?????E??LB?C?????E??MB?C?????E??NB?C?????E??OB?C?????E??PB?C?????E??QB?C?????E??RB?C?????E??SB?C?????E??TB?C?????s@?t@?P??S??R@?UB?P??kbBR@?VB?pA?ShBoA?VB?P??cd?E??WB?C?????E??XB?C?????E??YB?C?????E??ZB?C?????R??S??ON?KC?E??[B?C?????E??\B?C?????E??]B?C?????E??^B?C?????E??_B?C?????e??d??@A????O@?`B?`???J?O@?aB?`N?GG?R@?nA?`@?_fAE??bB?C?????E??cB?C?????_??c@?`??cO?dB?eB?`V?OJ?fB?gB?aD?sE?hB?d@?QB?kC?hB?d@?aE?kD?E??iB?C?????jB?kB?B?????_??a??@x?GK?E??lB?C?????E??mB?C?????O@?Q@?@L?CT?J??nB?B?????_??a??Pf?cJ?_??oB?`L?sL?hB?HB?@A?SG?hB?HB?`C?gG?hB?pB?PC?wJ?qB?rB?pA?sb?j??rB?PA??q?j??sB?PC?Cs?j??tB?p??{b?j??uB?pB?Ga?\@?vB?C?????E??wB?C?????E??xB?C?????E??yB?C?????E??zB?C?????{B?|B?B?????l??m??pG?_A?}B?~B?P??wF??C?@C?pK?W@?oA?pA?p@?Co?E??AC?C?????IA?JA?UU?Ke?E??BC?C?????E??CC?C?????E??DC?C?????E??EC?C?????E??FC?C?????\@?GC?C?????E??HC?C?????E??IC?C?????E??JC?C?????\@?KC?C?????\@?LC?C?????E??MC?C?????E??NC?C?????E??OC?C?????E??PC?C?????g@?HB?PA?CX?QC?RC?@@?GS?IA?JA?pe?_e?{B?SC?B?????T??U??@N?KF?T??TC?pF?{G?UC?VC?Q??Od@WC?XC?a@?ob@O@?Q@?@B?{S?A??YC?B?????T??TC?pB?{G?ZC?[C?@@?CU?\C?[C?@@?wI?]C?^C?@??_w?E??_C?C?????O@?aB?`C?{F?R@?`C?P??SVAE??aC?C?????E??bC?C?????ZA?[A?QA?_??ZA?[A?a??C@?cC?dC?ak?CK?\A?]A?Q??_E?oA?VB?p@?kd?E??eC?C?????{B?fC?B?????_??b@?pI?wM?R@?gC?PG?wy@R@?hC?`W?WJAoA?iC?PT?OX?jC?kC?P@?OKIlC?kC?@@?oG?lC?mC?p@?gC?J??nC?B?????oA?iC?pN??X?lC?oC?@@?_H?IA?JA?pZ?Se?h@?HB?pY?kQ?pC?m??`@?KN?qC?m??@X?C~?qC?rC?`[?wC@sC?rB?@B?SH?sC?tC?@G?[I?j??rB?PF?Wq?A??uC?B?????R@?S@?@@?g]@E??vC?C?????oA?iC?PL?{W?E??wC?C?????{B?xC?B?????{B?yC?B?????hB?HB?PA?cG?hB?zC?@W?OJ?A??{C?B?????T??TC?pE?{G?E??|C?C?????E??}C?C?????dB?eB?PV?OJ?_??oB?AT?wL?O@?~C?aH?KD?{B??D?B?????IA?JA?pV?Ke?fB?gB?a??oE?hB?@D?q??sA?R@?@D?Q??[[@h@?HB?P\?wQ?AD?BD?PG?[Q?CD?DD?A??GI?\A?]A?aA?cE?^A?_A?qQ?g}?_??`??eL?{C?ED?FD?B?????_??b@?PF?oM?O@?P@?P??[N?ZC?[C?A@?CU?\C?[C?A@?wI?]C?^C?Q??_w?oA?pA?@D?Co?R@?~C?P??cZCGD?~C?@??oA?IA?JA?P\?Se?E??HD?C?????E??ID?C?????{B?JD?B?????ZA?[A?a@?_??_??b@?pD?gM?KD?LD?@@?SL?MD?ND?`??SE?MD?OD?PD?[D?PD?QD?`@?SJ?^A?RD?@K?oK?E??SD?C?????jB?TD?B?????^A?RD?pK?oK?UD?VD?PF?CN?A??WD?B?????R??S??PN?KC?XD?YD?Q??oH?e??d??qB????_??b@?qD?gM?KD?LD?A@?SL?MD?ND?a??SE?MD?OD?QD?[D?PD?QD?a@?SJ?^A?RD?qK?oK?UD?VD?QF?CN?h@?IB?eh??T?jA?ZD?B?????dB?eB?@??cI?dB?eB?`P?GJ?fB?gB?Q@?gD?fB?gB?a??wD?fB?[D?qA?wI?dB?eB?@U?OJ?IA?JA?@E@Wg?\C?[C?@??wI?\D?[C?@??[|?E??]D?C?????e??d??AB????f??g??Q@?WE?s@?t@?AC?S??u@?v@?Q@?Ka?h??i??QE?wF?^D?~C?AC?WL?E??_D?C?????`D?aD?B?????c??d??`D?wB?bD?cD?a??CB?]C?DD?a??oa?]C?dD?qD?_b?]C?eD?QA?GT?R@?fD?qE?WQAoA?fD?A??KK?E??gD?C?????E??hD?C?????E??iD?C?????E??jD?C?????E??kD?C?????E??lD?C?????E??mD?C?????E??nD?C?????_??a??po?oJ?O@?oD?aK?gP?_??b@?AW?GN?_??c@?qA?gO?]??d@?AB?WH?]??d@?AR?sI?X??Y??pr?kG?X??pD?`d?OM?V??qD?PY?KR?\C?OD?@A?sL?]C?m??PA?Ge?]C?rD?@e??g?]C?sD?@??su@E??tD?B?????`D?uD?B?????IA?JA?`g?oe?E??vD?C?????R@?hC?P??_IAT??U??EA?cE?V??U??Q@?GH?E??wD?C?????E??xD?C?????E??yD?C?????E??zD?C?????E??{D?C?????E??|D?C?????E??}D?C?????E??~D?C?????E???E?C?????E??@E?C?????E??AE?C?????E??BE?C?????E??CE?C?????E??DE?C?????T??U??P??_E?T??EE?A@?wF?FE?[??AK?[W?FE?GE?aD?SQ?^A?HE?QJ?SB?IE?JE?qF?oI?E??KE?C?????{B?LE?B?????{B?ME?B?????{B?NE?B?????{B?OE?B?????_??a??@??kH?u@?v@?AA?Ka?PE?QE?AU?gM?^D?RE?q??OK?^D?RE?Q@?WM?SE?DD?AA????h??TE?a@?wF?UE?~C?AB?GF?VE?~C?Q???O?GD?~C?A??oA?O@?~C?qO?[D?E??WE?C?????hB?d@?aq?gD?E??XE?C?????e??d??AA????O@?`B?a???J?O@?aB?AF??G?R@?YE?aA?CLAR@?@D?a@?[[@E??ZE?C?????O@?aB?aN?GG?R@?nA?a@?_fAhB?d@?qI?oD?E??[E?C?????B??\E?B?????]C?rD?qH@Wh?\@?]E?C?????E??^E?C?????A??_E?B?????c??d??@??oB?E??`E?C?????E??aE?C?????E??bE?C?????E??cE?C?????E??dE?C?????E??eE?C?????E??fE?C?????E??gE?C?????E??hE?C?????E??iE?C?????E??jE?C?????E??kE?C?????E??lE?C?????E??mE?C?????E??nE?C?????E??oE?C?????E??pE?C?????E??qE?C?????E??rE?C?????E??sE?C?????E??tE?C?????E??uE?C?????\@?vE?C?????wE?RC?P??_H?E??xE?C?????WC?XC?qT?Cc@_??oB?aL?sL?hB?HB?AA?SG?hB?HB?aC?gG?hB?pB?QC?wJ?qB?rB?qA?sb?j??rB?QA??q?j??sB?QC?Cs?j??tB?qB?Kc?j??yE?Q??wa?E??zE?C?????E??{E?C?????]C?dD?qN?gb?E??|E?C?????X??Y??pN?OF?V??}E?aJ?[O?E??~E?C?????E???F?C?????IA?JA?PM@cg?^A?@F?aK?OC?IE?AF?AJ?OJ?dB?eB?`F?kI?E??BF?C?????E??CF?C?????hB?@D?qA?wA?E??DF?C?????O@?P@?qH?gN?O@?Q@?qG??T?{B?EF?B?????_??b@?qI?wM?R@?gC?QG?wy@R@?hC?Q??_IAB??FF?B?????E??GF?C?????R@?YE?qL?gLA^A?_A?AS?g}?E??HF?C?????E??IF?C?????B??JF?B?????IA?YA?@??cW?R@?YE?a@?CLAR@?@D?A@?[[@E??KF?C?????E??LF?C?????QC?MF?@??w]?cC?dC?QA?WI?cC?dC?AG?cI?hB?HB?QA?cG?hB?zC?AW?OJ?jA?NF?B?????O@?aB?aC?{F?R@?`C?Q??SVAR@?OF?q??[[CE??PF?C?????hB?pB?P??sJ?A??QF?B?????X??Y??pM?KF?X??RF?A??GH?E??SF?C?????A??TF?B?????_??a??PC@{I?O@?P@?`E?cN?R@?hC?aW?WJAoA?iC?qE?kW?\C?[C?A??wI?\D?[C?AA?[|?UC?~C?q@?Gd@WC?~C?AQ?Cb@J??UF?B?????_??oB?QQ?wL?E??VF?C?????E??WF?C?????cC?XF?aE?cT?cC?YF?AH??W?T??TC?@??sG?s@?t@?Q??S??R@?UB?Q@?kbBE??ZF?C?????E??[F?C?????jA?\F?B?????J??]F?B?????cC?dC?AI?gI?E??^F?C?????hB?pB?aE??K?_F?`F?AD????_??a??Px?GK?_??aF?P??kF?bF?cF?p??Gp?bF?cF?Pl?gh?R@?nA?QI?_hAoA?pA?AD?Co?R@?~C?a@?gZCE??dF?C?????E??eF?C?????E??fF?C?????E??gF?C?????E??hF?C?????E??iF?C?????T??TC?pI??H?jF?kF?A??KC?R@?lF?AJ?Wq@E??mF?C?????E??nF?C?????_??`??AF?WC?]??HB?AA??G?f@?HB?qC?CF?g@?d@?`W?o`?g@?oF?@??w^?]C?m??@??Ge?s@?t@?AA?S??R@?pF?q@?O}BdB?eB?pS?KJ?R??S??@J?CC?dB?eB?`T?OJ?]C?dD?QT?sb?WC?XC?Q??kb@R@?`C?A??SVAIA?JA?P|??g?{B?qF?B?????E??rF?C?????E??sF?C?????E??tF?C?????E??uF?C?????E??vF?C?????E??wF?C?????E??xF?C?????E??yF?C?????E??zF?C?????E??{F?C?????E??|F?C?????oA?pA?AC?Co?qA?rA?aM?{mBR@?YE?qJ?cLAE??}F?C?????E??~F?C?????E???G?C?????E??@G?C?????E??AG?C?????E??BG?C?????E??CG?C?????J??DG?B?????J??EG?B?????E??FG?C?????E??GG?C?????J??HG?B?????E??IG?C?????E??JG?C?????E??KG?C?????E??LG?C?????E??MG?C?????E??NG?C?????E??OG?B?????B??PG?B?????B??QG?B?????J??RG?B?????O@?aB?PP?KG?SG?TG?@??kC?E??UG?C?????_??a??@o?oJ?_F?`F?aA????VG?WG?Q??G`?E??XG?C?????E??YG?C?????cC?YF?AB??W?E??ZG?C?????R@?YE?qP?kLAWC?XC?AV?Cc@O@?~C?aK?SD?R@?`C?q??gSAR@?`C?QB?SVAoA?`C?AG?SL?f@?HB?aD?CF?g@?HB?QA?CX?QC?RC?A@?GS?wE?RC?Q??_H?[G?\G?qB?GM?]G?^G?a??gC?oA?`C?A@?kK?jA?_G?B?????O@?aB?Q??sF?E??`G?C?????J??aG?B?????bG?cG?Q??{K?hB?@D?aB?{A?R@?hC?qE?sIAJ??dG?B?????E??eG?C?????E??fG?C?????R@?pF?qH?K}BgG?hG?a@?kG?hB?d@?aL?sD?_??oB?aH?oL?hB?YE?Q@?wN?^A?_A?aA?W}?jB?iG?B?????E??jG?C?????E??kG?C?????qC?lG?AA?_X?pC?~C?AB?wC?qC?~C?AA??Q?mG?~C?QJ?WN?qC?nG?a??kO?qC?nG?a??o]@R@?hC?aT?SJAhB?YE?aA?{N?s@?t@?@A?S??R@?pF?pH?K}BgG?hG?@??gG?A??oG?B?????E??pG?C?????cC?YF?Q???W?cC?qG?a??CT?mG?~C?AF?KN?^A?_A?q??S}?g@?HB?AZ?CY?h@?HB?AA?KO?h@?HB?AU?_Q?h@?IB?A`?gS?j@?HB?A@?{A?j@?JB?A?????E??rG?C?????hB?d@?AN?sD?qB?sG?q@?sM?E??tG?C?????E??uG?C?????E??vG?C?????E??wG?C?????E??xG?C?????E??yG?C?????E??zG?C?????E??{G?C?????E??|G?C?????E??}G?C?????J??~G?B?????E???H?C?????E??@H?C?????E??AH?C?????E??BH?C?????E??CH?C?????E??DH?C?????E??EH?C?????E??FH?C?????E??GH?C?????j??sB?QA??s?j??tB?q??{b?E??HH?C?????_F?`F?aB????h??i??Q??wE?XD?YD?Q@?oH?T??TC?`L?CH?E??IH?C?????R@?S@?AB?k]@oA?S@?a@?{A?O@?P@?PA?_N?hB?zC?q??CI?`D?JH?B?????E??KH?C?????E??LH?C?????E??MH?C?????E??NH?C?????_??a??pj?kJ?FE?GE?qA?OQ?^A?@F?qJ?OC?E??OH?C?????h@?d@?`g?_E?AD?BD?`I?_Q?PH?QH?@N?_J?]??d@?QG?OI?e@?d@?qE?WQ?f@?d@?aD?[D?g@?d@?qH?O`?h@?d@?AA?SB?h@?d@?Aa?CE?h@?i@?A`?OG?j@?d@?A@?wB?k@?l@?A?????jB?RH?B?????j??rB?AC?Gq?E??SH?C?????WC?~C?qO?Cb@^A?_A?q@?W}?bF?cF?@??Sf?oA?iC?qN??X?lC?oC?A@?_H?lC?mC?q@?gC?\@?TH?C?????E??UH?C?????jB?VH?B?????_??aF?pL?_G?A??WH?B?????]C?^C?AD?kw?cC?XH?a@?CV?oA?S@?QD?GB?SG?TG?p??kC?oA?`C?aA?wK?cC?YF?A???W?E??YH?C?????E??ZH?C?????E??[H?C?????E??\H?C?????E??]H?C?????jA?^H?B?????O@?mA?AC?SF?cC?dC?aD?_I?hB?d@?as?cE?O@?Q@?aA?{S?O@?P@?AB?_N?]??^??@??GL?mG?~C?qH?SN?qC?_H?a??kO?qC?_H?a??c^@R??S??pZ?oC?hB?zC?a@?GI?oA?`C?Q??kK?cC?XF?a??WT?X??RF?aO?gH?]C?`H?QA?_F@]C?rD?qM?Sf?]??d@?Q??WH?E??aH?C?????g@?d@?pf??a?bH?cH?@??oB?hB?d@?QF?kD?oA?S@?QE?GB?R@?nA?AA?KhAR@?dH?a@?k^ChB?zC?qY?SJ?E??eH?C?????E??fH?C?????bD?cD?aA?GB?_??c@?aA?gO?IE?AF?aC?OJ?R@?YE?qO?kLAdB?eB?pW?OJ?fB?gB?a??[F?IA?JA?P^?Se?R??S??p^?wC?hB?YE?QB?{N?E??gH?C?????E??hH?C?????qC?~C?QH?CQ?E??iH?C?????T??TC?@A?sG?PE?QE?AS?gM?h@?d@?pY?oD?j??sB?PA??s?j??tB?pB?Kc?j??yE?aA?{a?O@?Q@?qF??T?oA?iC?qQ?GX?R@?gC?aF?wy@R@?@D?A??[[@E??jH?C?????oA?iC?qG?kW?hB?zC?qA?GI?\@?kH?C?????PH?QH?@??GJ?hB?@D?aF??B?dB?eB?pG?gI?E??lH?C?????PE?QE?QT?gM?oA?S@?aE?GB?dB?eB?`N?CJ?fB?~C?a@?GA?E??mH?C?????E??nH?C?????E??oH?C?????\@?pH?C?????\@?qH?C?????</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2399957543;
    let startMs = 1664313555417;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","libsystem_pthread.dylib","thread_start","_pthread_start","libjvm.dylib","thread_native_entry","Thread::call_run","JavaThread::thread_main_inner","attach_listener_thread_entry","libsystem_kernel.dylib","close","CompileBroker::compiler_thread_loop","CompileBroker::invoke_compiler_on_method","C2Compiler::compile_method","Compile::Compile","Compile::Init","Node::Node","one.nio.server.SelectorThread","run","one.nio.net.JavaSelector","select","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","sun.nio.ch.KQueue","poll","kevent","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","handleParsedRequest","one.nio.http.HttpServer","handleRequest","RequestHandler1_handlePutRequest","ok.dht.test.gerasimov.ServiceImpl","handlePutRequest","java.util.stream.MatchOps","makeInt","jdk.internal.misc.Unsafe","allocateInstance","ok.dht.test.gerasimov.lsm.artyomdrozdov.Memory","put","Runtime1::is_instance_of","ParseGenerator::generate","Parse::Parse","Parse::do_all_blocks","Parse::do_one_block","Parse::do_call","PredictedCallGenerator::generate","Parse::merge_common","Node::Init","Compiler::compile_method","Compilation::Compilation","Compilation::compile_method","Compilation::compile_java_method","Compilation::build_hir","IR::IR","IRScope::IRScope","GraphBuilder::GraphBuilder","GraphBuilder::iterate_all_blocks","GraphBuilder::iterate_bytecodes_for_block","GraphBuilder::invoke","GraphBuilder::try_inline","GraphBuilder::try_inline_full","GraphBuilder::try_method_handle_inline","GraphBuilder::check_cast","ciBytecodeStream::get_klass","ciEnv::get_klass_by_index_impl","I2C/C2I adapters","Compile::Optimize","PhaseIdealLoop::optimize","PhaseIdealLoop::build_and_optimize","PhaseIdealLoop::build_loop_late","PhaseIdealLoop::build_loop_late_post_work","PhaseIdealLoop::compute_lca_of_uses","one.nio.http.Request","getHeader","trim","java.lang.String","charAt","OptoRuntime::new_array_C","InstanceKlass::allocate_objArray","CollectedHeap::array_allocate","MemAllocator::allocate","MemAllocator::Allocation::notify_allocation_jvmti_sampler","JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector","JvmtiObjectAllocEventCollector::generate_call_for_allocated","JvmtiExport::post_sampled_object_alloc","libasyncProfiler.so","ObjectSampler::recordAllocation","Profiler::recordSample","JvmtiEnvBase::get_stack_trace","Method::jmethod_id","InstanceKlass::get_jmethod_id","sendResponse","writeResponse","write","one.nio.net.Session$ArrayQueueItem","one.nio.net.JavaSocket","sun.nio.ch.SocketChannelImpl","sun.nio.ch.IOUtil","writeFromNativeBuffer","sun.nio.ch.SocketDispatcher","sun.nio.ch.FileDispatcherImpl","write0","PhaseIterGVN::optimize","PhaseIterGVN::transform_old","PhaseIterGVN::subsume_node","PhaseIterGVN::remove_globally_dead_node","Node::replace_edge","Node::set_req_X","ok.dht.test.gerasimov.ValidationService","checkId","java.util.stream.IntPipeline","noneMatch","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","Unsafe_AllocateInstance","InstanceKlass::allocate_instance","JvmtiObjectAllocEventMark::JvmtiObjectAllocEventMark","JvmtiClassEventMark::JvmtiClassEventMark","Compile::optimize_loops","PhaseIdealLoop::Dominators","OptoRuntime::new_instance_C","Compile::Code_Gen","PhaseChaitin::Register_Allocate","PhaseChaitin::Split","PhaseChaitin::build_ifg_physical","ok.dht.test.gerasimov.lsm.artyomdrozdov.MemorySegmentDao","upsert","java.util.concurrent.ConcurrentSkipListMap","doPut","Compile::call_generator","InlineTree::ok_to_inline","InlineTree::try_to_inline","InlineTree::should_not_inline","Method::has_unloaded_classes_in_signature","OopStorage::release","OopStorage::Block::release_entries","ciMethod::get_method_at_bci","ConnectionGraph::do_analysis","ConnectionGraph::compute_escape","ConnectionGraph::split_unique_types","ConnectionGraph::find_inst_mem","ConnectionGraph::split_memory_phi","ConnectionGraph::create_split_phi","cpr","ok.dht.test.gerasimov.lsm.artyomdrozdov.MemorySegmentComparator","compare","jdk.incubator.foreign.MemoryAccess","getByteAtOffset","java.lang.invoke.VarHandleGuards","guard_LJ_I","java.lang.invoke.LambdaForm$MH.0x0000000800cce400","invoke","PhaseMacroExpand::eliminate_macro_nodes","PhaseMacroExpand::eliminate_allocate_node","PhaseMacroExpand::process_users_of_allocation","PhaseIdealLoop::build_loop_early","OptoRuntime::new_array_nozero_C","vframe::java_sender","compiledVFrame::sender","vframe::sender","libsystem_platform.dylib","_platform_memmove$VARIANT$Haswell","Node::pinned","getPath","substring","java.lang.StringLatin1","newString","java.util.Arrays","copyOfRange","jvmti_GetClassSignature","Matcher::match","Matcher::xform","Arena::contains","PhaseCFG::do_global_code_motion","PhaseCFG::global_code_motion","PhaseCFG::schedule_late","PhaseCFG::insert_anti_dependences","PhaseLive::compute","PhaseLive::add_liveout","PhaseAggressiveCoalesce::insert_copies","ScopeDesc::sender","ScopeDesc::decode_body","JavaThread::last_java_vframe","vframe::new_vframe","Arena::grow","Chunk::operator new","IndexSetIterator::advance_and_next","PhaseChaitin::Simplify","PhaseIFG::remove_node","PhaseChaitin::add_input_to_liveout","read","readIntoNativeBuffer","read0","PhaseChaitin::interfere_with_live","PhaseChaitin::post_allocate_copy_removal","PhaseChaitin::elide_copy","PhaseOutput::Output","PhaseOutput::fill_buffer","NonSafepointEmitter::observe_instruction","NonSafepointEmitter::emit_non_safepoint","DebugInformationRecorder::describe_scope","DIR_Chunk* GrowableArrayWithAllocator<DIR_Chunk*, GrowableArray<DIR_Chunk*> >::insert_sorted<&","ProjNode::pinned","isBlank","indexOfNonWhitespace","JavaThread::pd_last_frame","CodeCache::find_blob","PhiNode::Ideal","PhiNode::wait_for_region_igvn","frame::real_sender","frame::sender","frame::sender_raw","frame::sender_for_compiled_frame","CodeBlob::is_zombie","getRequiredParameter","getParameter","compiledVFrame::compiledVFrame","CompiledMethod::scope_desc_at","one.nio.http.Response","toBytes","one.nio.util.ByteArrayBuilder","append","one.nio.util.Utf8","frame::is_interpreted_frame","libnio.dylib","Java_sun_nio_ch_SocketDispatcher_read0","TypeArrayKlass::allocate_common","Klass::check_array_allocation_length","_kernelrpc_mach_port_deallocate_trap","parseRequest","toAsciiString","sun.misc.Unsafe","copyMemory","copyMemoryChecks","checkPrimitivePointer","checkPointer","CallTraceStorage::put","ThreadHeapSampler::check_for_sampling","JvmtiObjectAllocEventCollector::record_allocation","ResourceObj::operator new","os::malloc","libsystem_malloc.dylib","default_zone_malloc","ok.dht.test.gerasimov.lsm.artyomdrozdov.Storage","getSizeOnDisk","ok.dht.test.gerasimov.lsm.artyomdrozdov.StorageUtils","getSize","oopFactory::new_typeArray_nozero","Matcher::match_tree","Matcher::Label_Root","AddPNode::bottom_type","TypeAryPtr::add_offset","TypeAryPtr::make","Dictionary::lookup","NTarjan::DFS","PhaseOutput::BuildOopMaps","OopFlow::compute_reach","FlightRecorder::recordEvent","Recording::recordAllocationInNewTLAB","vframe::vframe","jvmti_Deallocate","JvmtiEnv::Deallocate","os::free","java.util.concurrent.locks.ReentrantLock","lock","free","iteratorFor","java.util.HashMap$KeyIterator","next","java.util.HashMap$HashIterator","nextNode","jbyte_disjoint_arraycopy","sun.nio.ch.Util$2","iterator","java.util.HashSet","java.util.HashMap","keySet","SharedRuntime::on_slowpath_allocation_exit","indexOf","OopStorage::allocate","PcDescContainer::find_pc_desc_internal","jdk.internal.foreign.AbstractMemorySegmentImpl","mismatch","Chunk::next_chop","free_tiny","equalsIgnoreCase","regionMatches","regionMatchesCI","java.lang.Character","toLowerCase","java.lang.CharacterDataLatin1","getProperties","thread_self_trap","toUpperCase","java.nio.HeapByteBuffer","java.nio.ByteBuffer","putBuffer","jdk.internal.misc.ScopedMemoryAccess","copyMemoryInternal","unsafe_arraycopy","CodeHeap::find_blob_unsafe","ScopeDesc::ScopeDesc","szone_size","tiny_size","isAsciiString","jbyte_arraycopy","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ull, G1BarrierSet>, ","AllocateHeap","<init>","tiny_free_no_lock","length","sun.nio.ch.Util","offerFirstTemporaryDirectBuffer","java.lang.ThreadLocal","get","libdyld.dylib","tlv_get_addr","java.lang.Object","JvmtiEnv::GetClassSignature","Klass::signature_name","tiny_free_list_add_ptr","one.nio.server.Server","incRequestsProcessed","java.util.concurrent.atomic.LongAdder","increment","add","java.util.concurrent.atomic.Striped64","casBase","guard_LJJ_Z","nmethod::is_zombie","Java_sun_nio_ch_KQueue_poll","java.lang.invoke.VarHandleLongs$FieldInstanceReadWrite","weakCompareAndSetRelease","jlong_disjoint_arraycopy","one.nio.net.JavaSelector$1","hasNext","_platform_strncmp","ensureCapacity","java.util.HashMap$KeySet","resource_allocate_bytes","java.util.stream.MatchOps$MatchOp","os::javaTimeMillis","libsystem_c.dylib","clock_gettime","one.nio.http.PathMapper","find","getNode","hash","hashCode","GraphKit::round_double_arguments","ConNode::Opcode","PhaseMacroExpand::scalar_replacement","ciField::compute_type","ciEnv::get_klass_by_name_impl","ttyLocker::release_tty_if_locked","PhaseChaitin::gather_lrg_masks","decodeHeapOop_not_nullNode::oper_input_base","addHeader","processEvents","processReadyEvents","putVal","newNode","jni_GetEnv","gettimeofday","InstanceKlass::signature_name","Parse::do_field_access","Parse::do_get_xxx","PhaseGVN::transform_no_reclaim","TypeInstPtr::add_offset","TypeInstPtr::make","TypeOopPtr::TypeOopPtr","ciInstanceKlass::get_field_by_offset","ciInstanceKlass::compute_nonstatic_fields","ciInstanceKlass::compute_nonstatic_fields_impl","ciField::ciField","PhaseIdealLoop::build_loop_tree","RegisterMap::RegisterMap","PhaseIFG::init","IndexSet::initialize","registerPendingSessions","java.util.concurrent.ConcurrentLinkedQueue","updateHead","guard_LL_V","java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite","setRelease","os::javaTimeNanos","_malloc_zone_malloc","szone_malloc_should_clear","tiny_malloc_should_clear","tiny_malloc_from_free_list","java.util.stream.AbstractPipeline","evaluate","evaluateSequential","java.util.stream.MatchOps$$Lambda$78.0x0000000800cafbf0","lambda$makeInt$1","java.util.stream.MatchOps$2MatchSink","java.util.stream.MatchOps$BooleanTerminalSink","nmethod::metadata_at","ChunkPool::allocate","startsWith","ThreadLocalAllocBuffer::set_sample_end","ThreadCritical::ThreadCritical","pthread_self","Profiler::getNativeTrace","ObjArrayAllocator::initialize","unknown_Java","GangWorker::run","GangWorker::loop","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsTask::scan_roots","G1RemSet::scan_heap_roots","G1ScanHRForRegionClosure::do_heap_region","G1ScanHRForRegionClosure::scan_heap_roots","G1ScanHRForRegionClosure::scan_memregion","G1ParScanThreadState::trim_queue_to_threshold","void G1ParScanThreadState::do_oop_evac<narrowOop>","G1ParScanThreadState::do_copy_to_survivor_space","G1CMConcurrentMarkingTask::work","G1CMTask::do_marking_step","G1CMTask::drain_local_queue","void G1CMTask::process_grey_task_entry<true>","ClassLoaderData::oops_do","void OopOopIterateDispatch<G1CMOopClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","G1RebuildRemSetTask::work","HeapRegionManager::par_iterate","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::do_heap_region","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::rebuild_rem_set_in_region","G1RebuildRemSetTask::G1RebuildRemSetHeapRegionClosure::scan_for_references","Buffer::putVar64","java.util.concurrent.locks.ReentrantLock$Sync","JNIHandleBlock::allocate_handle","checkPrimitiveArray","PcDescCache::find_pc_desc","CompiledMethod::is_compiled","Symbol::as_C_string","processDeregisterQueue","JavaThread::is_Java_thread","nmethod::scopes_pcs_begin","guard_LLL_Z","compareAndSet","G1CardTable::is_in_young","JvmtiJavaThreadEventTransition::JvmtiJavaThreadEventTransition","Mutex::lock_without_safepoint_check","malloc","pthread_mutex_lock","JavaFrameAnchor::make_walkable","Chunk::operator delete","ThreadCritical::~ThreadCritical","pthread_mutex_unlock","methodHandle::~methodHandle","MemAllocator::allocate_inside_tlab_slow","unlock","_platform_bzero$VARIANT$Haswell","isLatin1","ScopeDesc::decode_object_values","_new_array_Java","processUpdateQueue","VMError::is_error_reported","jint_disjoint_arraycopy","__commpage_gettimeofday_internal","JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector","JvmtiSampledObjectAllocEventCollector::is_sampled_object_alloc_event","checkAccess","checkBounds","OopMapSet::update_register_map","ImmutableOopMapSet::find_map_at_offset","_os_semaphore_wait.cold.1","mach_absolute_time","JvmtiEventCollector::is_dynamic_code_event","java.lang.invoke.LambdaForm$MH.0x0000000800ccc400","invokeExact_MT","startParsingRequestBody","java.lang.Integer","parseInt","void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>","void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>","DebugInfoReadStream::read_object_value","ObjectValue::read_object","ScopeValue::read_from","nmethod::oop_addr_at","java.nio.channels.spi.AbstractSelectionKey","isValid","equals","JNIHandles::make_local","ThreadShadow::clear_pending_exception","endWrite","chars","tiny_free_list_remove_ptr","ConcurrentGCThread::run","G1ConcurrentRefineThread::run_service","G1ConcurrentRefine::do_refinement_step","G1DirtyCardQueueSet::refine_completed_buffer_concurrently","G1DirtyCardQueueSet::refine_buffer","G1RemSet::refine_card_concurrently","HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<false, G1ConcurrentRefineOopClosure>","void OopOopIterateDispatch<G1ConcurrentRefineOopClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","OtherRegionsTable::add_reference","SparsePRT::add_card","RSHashTable::entry_for_region_ind_create","JavaThread::threadObj","G1CollectedHeap::mem_allocate","G1CollectedHeap::attempt_allocation_slow","VMThread::execute","VMThread::wait_until_executed","Monitor::wait","os::PlatformMonitor::wait","__psynch_cvwait","semaphore_wait_trap","ParallelSPCleanupTask::work","OopStorage::trigger_cleanup_if_needed","__psynch_cvbroad","G1EvacuateRegionsBaseTask::evacuate_live_objects","G1ParEvacuateFollowersClosure::do_void","G1ParScanThreadState::steal_and_trim_queue","GenericTaskQueueSet<OverflowTaskQueue<ScannerTask, ","TaskTerminator::offer_termination","Monitor::wait_without_safepoint_check","SpinPause","_pthread_cond_wait","_pthread_mutex_firstfit_lock_slow","__psynch_mutexwait","one.nio.util.URLEncoder","decode","PerfByteArray::~PerfByteArray","java.lang.invoke.Invokers","checkExactType","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<598116ull, G1BarrierSet>, ","oopFactory::new_typeArray","nmethod::metadata_addr_at","java.util.concurrent.locks.ReentrantLock$NonfairSync","initialTryLock","java.util.concurrent.locks.AbstractOwnableSynchronizer","setExclusiveOwnerThread","_platform_strlen","G1BarrierSet::enqueue","__commpage_gettimeofday","java.util.Objects","requireNonNull","mach_port_deallocate","javaVFrame::is_java_frame","ClassLoaderData::holder_phantom","java.util.stream.StreamSupport","intStream","fdval","nmethod::scopes_pcs_end","oopFactory::new_objArray","wrap","java.nio.Buffer","position","_new_instance_Java","MemAllocator::Allocation::notify_allocation","isSmall","frame::is_runtime_frame","putByte","VMThread::run","VMThread::inner_execute","VMThread::evaluate_operation","VM_Operation::evaluate","VM_G1CollectForAllocation::doit","G1CollectedHeap::do_collection_pause_at_safepoint","G1CollectedHeap::do_collection_pause_at_safepoint_helper","G1CollectedHeap::gc_prologue","G1DirtyCardQueueSet::concatenate_logs","Threads::threads_do","semaphore_signal_trap","G1PrepareEvacuationTask::work","G1CMTask::make_reference_grey","G1ConcurrentMark::mark_in_next_bitmap","void OopOopIterateDispatch<G1RebuildRemSetClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","G1ClearBitMapTask::work","G1ClearBitMapTask::G1ClearBitmapHRClosure::do_heap_region","MarkBitMap::do_clear","BitMap::clear_range","PreserveExceptionMark::PreserveExceptionMark","HandleMark::initialize","CompressedReadStream::read_signed_int","advance_directory.cold.1","HandleMark::~HandleMark","compiledVFrame::method","MemAllocator::finish","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<2646116ull, G1BarrierSet>, ","JvmtiEnv::GetStackTrace","sun.nio.ch.Util$BufferCache","offerFirst","Java_sun_nio_ch_FileDispatcherImpl_write0","JvmtiEventCollector::setup_jvmti_thread_state","std::__1::vector<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample> > >::vector<std::__1::__map_iterator<std::__1::__tree_iterator<std::__1::__value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample>, std::__1::__tree_node<std::__1::__value_type<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, MethodSample>, void*>*, long> > >","compiledVFrame::bci","convertReturnVal","_new_array_nozero_Java","isSet","HeapWordImpl** HeapRegion::oops_on_memregion_seq_iterate_careful<true, G1ScanCardClosure>","void OopOopIterateDispatch<G1ScanCardClosure>::Table::oop_oop_iterate<InstanceKlass, narrowOop>","void G1ScanCardClosure::do_oop_work<narrowOop>","WatcherThread::run","WatcherThread::sleep","_platform_strcpy","limit","putIfAbsent","JvmtiEnvBase::phase","sun.nio.ch.IOStatus","normalize","checkBoundsBeginEnd","JNIHandleBlock::allocate_block","CodeBlob::is_deoptimization_stub","InstanceKlass::array_klass","CardTableBarrierSet::on_slowpath_allocation_exit","frame::entry_frame_is_first","StackWatermarkSet::on_iteration","ObjectSampler::SampledObjectAlloc","CodeBlob::is_optimized_entry_blob","load_agent","JvmtiExport::load_agent_library","os::dll_load","Profiler::dlopen_hook","Symbols::parseLibraries",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
