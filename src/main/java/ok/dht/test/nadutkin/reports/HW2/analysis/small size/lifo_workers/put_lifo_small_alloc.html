<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BEdLAx@bAtBeFf~@?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????CPGlLNJaxbhayihayxp{O?Ax?EVNG?h`[Ipp`hIxZEI`hBMMIpJpW``\UGI`h?MLTOcO?LQp`[WDSTIKKLMHhpKRhY[RULKTLNJUIp`VKJa`KMHpa`TKJhhpLaAhaiPaqhSLLSLMNJhxphxphpp]MNJhahp`[KTKR`]Rxh`y`Rhih[QhxpSUxPxyxaxxpC[LTMNNNNMLK\Hz]JbTTUKKSQxihpaxx`pb``i`aiKSYi`ai^MTNMLNUxVNUNMVLS[NUNMVNNMYqahr`y`zp`ypiaaxya`yaypii`yxixypqa^Zxqaiai]^NKUNSxNTTVVMVUK^TUNYqqiqaxz`yiyxqiaaybaiyxiiiiqypiqiypbpqqaiiqbxiypyayxiqqxqfHsLN]M[UT\L``zprpjxyqyyqqyyiibiqqqqiqqyazpraibyypjpjajbixrxjpz`zayqbibxbabtNM\]S[T\S]S^ST^VS^S]]UMS[\T^N\T\S]VS\VVT]VS[[S^V^TT^K`qbajxcNT^T\V[T\T^VVS\px{LN\[S`ajqjyzazqbqjyqraycNS\ShajqqzqbqbbqbyrybybyqyyybybisNL^SU]N^L]S^T[\T\S^ThsJsHdNK[[Uhizxzizybrijayybibqyqbqyrijajqrzijabqyqbibibjjqjyyqijybq[ULSUTVT`qyqrqbqbrp|N]N`Eh`zabyxx\VSS]VTVU`sL]VS]US\[T[US\S\VTU\S]T]VS[[T[S^hbbqqbyqjiqzqribaqyybbyyjqqyqqyquKpShkIkMN^V\\S^S]]T\^U[U\]V[T`pzmL[[]UU]T^T[]^UT[[^UVT[[^T]S\[TaqjjybyrbbqjyribjyzyyuH{Kh[`risMxcN[T`yyjqrbjrxzbjjx{NM\[^^N\`arlU^[T[`ijbizbrybzazqkK\VT[`byyqj{V\VV]T\[][xChLhcKKh`cK`hkKT`yikKS`dS\`iyryzbqzirjqzxzrpcKU^\T^VT`prtVS`qjjykNL]\T`qyrikMUS]S`icLT[`xcLamN`DhN`{H{LL`bxtGdNM]\Mh`cL[Sh\`jxlNacK`xzxz`jxkKNYkKL`pz`jqjqyybzazprqjlTT^M^K``cMUS[S]U\N\T[^V^Lh{GtIsKhV`^bqykKL``{N]M``zrqcLK`bjjqzizjqrazbjvTN\\[]V[\\[U[^U\S`ajbqjyrjajjbjpvS\U^S]T\\Th{HdJsN`[`xsN\L`azrxrbrkNakKS`qyjxlML^VT]V^TV\V^S\^N]\V]U]\qrxrrakLU^\S`yyrizqrjirqzbykNN]pNbKh{HlIkKhV`hcK`hdMN[`pzbjjxrijbjrxk^T][U^T^S^VT\\]VUV]U[^V[U[]U^S]]qzjybqrjqjyjjyyqrjuG{L`hkLN`racKL`uUM`pcK`xkML`bqcLV[]V^S]\U`ajbijyraj|VL]U]L[^VT]^M]T^V[T\]U^V^L[]T^KhhcMibbilKK`|HsGd_@ti@rh@pk@fg@bn@{j@qk@|h@d_@_j@xm@vm@{m@ej@ui@aj@ao@ip@vo@un@rk@}n@ym@mp@xe@~c@ue@kk@xn@ap@dp@nn@bf@lk@`j@mx@zy@yu@x_@zx@bw@ay@xp@lt@sp@{y@b{@_b@ts@~x@l}@{p@|p@zz@cw@wz@ul@`y@py@|y@r{@y{@|d@gs@~l@bq@zt@~u@aw@xz@ok@`l@ny@oz@m|@pb@~b@gc@wc@vh@|q@r|@xb@}c@fd@kf@ng@sj@km@jq@kr@pr@mt@dz@{z@_|@`~@i_@pa@ua@sb@fc@ic@qc@oe@{e@af@kh@ii@mk@el@jl@tl@cm@rn@io@gr@us@kv@{v@by@lz@j_@l_@p_@_`@ga@ja@qa@`b@mb@|b@bc@rc@uc@ld@wd@~e@cf@hf@~f@`g@cg@qg@bh@hh@jh@qh@li@}i@vj@zj@}j@jk@vk@wk@cl@wm@en@on@sn@yo@eq@kq@ar@dr@}r@js@ls@qs@{s@`t@qt@tt@vt@wt@eu@lu@uu@zu@jv@qv@}v@dw@lw@tw@yw@cx@hy@jy@ty@az@n{@q{@`|@{}@e_@g_@h_@n_@o_@r_@s_@t_@u_@v_@y_@{_@}_@~_@g`@i`@x`@z`@ha@ia@ma@na@oa@sa@ta@wa@xa@za@|a@}a@~a@bb@cb@db@eb@fb@hb@ib@jb@kb@lb@nb@ob@qb@tb@vb@wb@yb@{b@}b@`c@ac@dc@ec@kc@lc@mc@oc@pc@tc@vc@yc@zc@{c@_d@ad@cd@dd@ed@gd@id@jd@md@od@pd@rd@sd@td@ud@vd@yd@zd@{d@}d@~d@_e@`e@ae@ce@de@fe@ge@he@ie@je@ke@me@ne@pe@qe@se@te@ve@we@ye@}e@_f@`f@ef@ff@gf@if@jf@lf@nf@of@qf@rf@uf@vf@xf@zf@|f@}f@_g@bg@dg@eg@gg@hg@jg@lg@mg@og@pg@sg@tg@ug@wg@xg@yg@zg@{g@|g@~g@_h@`h@dh@eh@fh@ih@lh@nh@oh@sh@uh@wh@yh@{h@}h@~h@_i@`i@ai@bi@ci@fi@ji@ni@oi@pi@qi@ri@si@vi@wi@xi@zi@{i@|i@~i@bj@dj@fj@gj@hj@ij@kj@lj@nj@oj@pj@qj@rj@tj@xj@yj@|j@~j@`k@ak@bk@dk@ek@gk@hk@sk@uk@xk@yk@zk@{k@|k@~k@_l@al@dl@gl@hl@sl@wl@xl@yl@zl@{l@|l@}l@_m@`m@am@bm@dm@fm@gm@hm@im@jm@lm@nm@pm@rm@sm@tm@zm@|m@~m@_n@an@cn@dn@fn@gn@hn@jn@kn@ln@qn@vn@yn@zn@{n@|n@~n@`o@ko@lo@no@oo@po@ro@so@uo@wo@xo@zo@{o@|o@}o@~o@`p@bp@cp@ep@fp@gp@hp@jp@lp@np@op@pp@qp@rp@tp@up@vp@wp@yp@zp@}p@`q@dq@fq@gq@hq@iq@nq@pq@rq@sq@vq@xq@yq@zq@{q@~q@_r@`r@br@er@fr@hr@ir@lr@mr@nr@rr@vr@wr@yr@zr@{r@|r@_s@`s@bs@ds@es@fs@hs@is@ks@ns@os@ss@ws@ys@zs@|s@}s@~s@_t@bt@ct@dt@et@ft@gt@it@jt@nt@ot@pt@st@ut@yt@|t@}t@~t@`u@au@bu@cu@du@fu@gu@iu@ju@nu@pu@ru@tu@vu@wu@|u@}u@_v@bv@dv@ev@fv@gv@hv@mv@ov@pv@rv@tv@uv@vv@wv@xv@yv@zv@_w@`w@ew@fw@hw@iw@jw@kw@mw@nw@ow@qw@sw@vw@ww@xw@{w@}w@~w@`x@ax@bx@ex@gx@hx@jx@lx@nx@ox@px@rx@tx@ux@wx@xx@yx@{x@|x@_y@ey@fy@gy@iy@ly@my@oy@qy@sy@uy@xy@yy@}y@~y@`z@ez@gz@hz@iz@jz@kz@mz@nz@pz@sz@vz@yz@|z@~z@c{@d{@f{@g{@h{@i{@j{@k{@p{@s{@t{@v{@x{@z{@|{@}{@~{@a|@d|@e|@f|@h|@j|@l|@n|@o|@p|@q|@w|@x|@z|@{|@||@}|@~|@`}@a}@m}@o}@t}@w}@x}@z}@a~@b~@j~@w~@y~@z~@{~@|~@a_Ah_Af_@k_@m_@q_@w_@z_@|_@``@a`@b`@c`@d`@e`@f`@h`@j`@k`@l`@m`@n`@o`@p`@q`@r`@s`@t`@u`@v`@w`@y`@{`@|`@}`@~`@_a@`a@aa@ba@ca@da@ea@fa@ka@la@ra@va@ya@{a@ab@gb@rb@ub@zb@_c@cc@hc@jc@nc@sc@xc@|c@`d@bd@hd@kd@nd@qd@xd@be@ee@le@re@ze@|e@df@mf@pf@sf@tf@wf@yf@{f@ag@ig@kg@rg@vg@}g@ah@ch@gh@mh@ph@th@xh@zh@di@ei@gi@hi@ki@mi@yi@cj@jj@mj@uj@wj@_k@ck@fk@ik@nk@tk@}k@bl@fl@il@kl@ll@ml@nl@ol@pl@ql@rl@vl@em@mm@om@qm@um@}m@`n@in@mn@pn@tn@wn@_o@bo@co@do@eo@fo@go@ho@jo@mo@qo@to@_p@kp@~p@_q@aq@cq@lq@mq@oq@qq@tq@uq@wq@}q@cr@jr@or@qr@sr@tr@ur@xr@~r@as@cs@ms@ps@rs@vs@xs@at@ht@kt@rt@xt@{t@_u@hu@ku@mu@ou@qu@su@xu@{u@`v@av@cv@iv@lv@nv@sv@|v@~v@gw@pw@rw@uw@zw@|w@_x@dx@fx@ix@kx@qx@sx@vx@}x@cy@dy@ky@ry@vy@wy@_z@bz@cz@fz@qz@rz@tz@uz@}z@_{@`{@a{@e{@l{@m{@o{@u{@w{@{{@b|@c|@g|@i|@k|@s|@t|@u|@v|@y|@_}@b}@c}@d}@e}@f}@g}@h}@i}@j}@k}@n}@p}@q}@r}@s}@u}@v}@y}@|}@}}@~}@_~@c~@d~@e~@f~@g~@h~@i~@k~@l~@m~@n~@o~@p~@q~@r~@s~@t~@u~@v~@x~@}~@~~@__A`_Ab_Ac_Ad_Ae_Af_Ag_AmpNG`BG`BGgEGGe@GGGGe@GGGjAe@GGGcBGdBn@Gn@GGGjAqAn@Ge@rAqAGfByFe@e@e@GsAn@e@{EGGGGGn@GGe@GlGGGjHGe@qAWWGfBGYGGGBrA}@mCGGBsAGe@Ge@GGGuAjBiI_@GF@Y@@FaBtIn@XcBGG`GsApC}@e@lHdBrCWGFGdBjIG?aBGGGNFe@|EGBjAe@G?Ge@GGGGXDFDDDBa@DBDDDDcBjBBLGDvCsAn@B?FBXXn@YGGYMGnAGXGLWXG?BH@Ge@n@S?jBmCAqAAMuAYMe@B@n@GN}@GuAGNWe@LGG@GGG_ApB@?GG?G?GE?Nn@S{CM_@ZALYwAGGBE@ZMeAHFYGLeAE?fA@@wAH?B|CAfAfAeAfAAG`@?Ge@HB{CwAGL?KGN`@S|JeAAKG?vCHF@wAUM`@eAN`@DfAeAG|CAfAG_A_AGBGGYAGa@ALtCLCJA@CGBEHa@GJ?KAWGIANkC[MEE?EKSE@?n@XGFCJLAGBF@W`@ALDDDSDa@DDXDXpCGXDBFDBXF[DXBUFX`BBJSLDTW[GALAH@?EOCxK??ZAHEAIRAI`@G?WAM}CpBpBGA[F@AO`@xLGEB@TDF@AQCR_@Q?K@`@Y^MNJFNDBE@^CRJDWAITAIEQHB[WJS@MSQCuA?JLa@Ae@RtAOFRNM[N@YZID@CFF@C^[Q??IKSBW}@DLT`@LQTQ?_ABGbM}CxMYNLEC^L?NHEBIY^X@B@?LSQtCGE@?\?RLQA\UIYLB@ADNIJBECMIAAB@I?XO`@SBEQ?\ALUGLICHEBWMGI@[^DUE?DFTZCAECLHA`@?@LMEY^I?`@CUB]Oa@EBI_@A?AMa@_@TWe@ND]FF?vADDDDDXDDXABEBDXOFX?BOU_@H?HTTAYN^MB@?GDKS@]Q]MEBO[N_@TWZ[SODAM]OA?URE?DFITRCJBW^^A[HNT^?O?B@PEIA\?_@MXTHS?NACFNTN`@BPDBIHPECYCL?JXGI??UWH^NL`@KKHFUCBMI\FTLTERFL\AASPMLEXQCPM??IMCD[]YWJNHED@^A^YE?RB?[YF@?TUB@\]LSB]QK@?A@EA^?@AMIC?A]_@K^BZTYOWa@QYEsLQ?U?[EC@@TA\XIKB@NDFHF_@@MAN`@DLO@BGC[L`@?IERXBA_@N[@FXHE?Q_@Q??X@OOFI^B@^FWCJAM_@A\VACECYO?HEB?ICR`@WFTZEMSDB`@DW?J@VAL\VZJFCLV`@Y]?CYRBH@\YIB[@FXDDDDCDDXXDDDXOOEXBXFDB_@TDFUYEYWYZTIZYD?B@OJVUD?WUHAVH^AYT\[mMB@PQMB@SVIAa@@ILBTCR@ZVxC\AAHO`@CRPJNI?JH?KPQX[AJNA[NMCOFQ?Q^@MAZJ\Ba@A@?[[FPQ^AHKIPDFWB^O@KDWvAK^TXDUHVAF@YD@MDFZPL[?JY?ZTRHEHITDFUTP?SHESNX@MIAZABB@HF@FJSQ_@N?LkKFIS?Gk@IRPOI]B??nA[KWAE^PZDFOBVZIMA?BIUUCOGILOFCTCICQ?O[Z@ZAID?RRDF?LQMMTXtADPMIV?FVHPR?EI]?KILWPMIBJKQMZAHBN@B?JAY_@^@CQH?CTYW?IAHMLA@[EKS@?@@AF@@MF_@A\XIH@MLHDUPO_@]]\?TNA_@KBQ@?HC^?M?OGHMTWA`@BQCD@?AER@Q[WHIO[T]WS?FZAPC@ANPDYL@A\L?V@RY@CQN@]A`@I_@_@@[OQJ@R[DCRNY?HEICH@_@IX]DDXDDI]BDDDGDDOEODEADBOBBG?CAXYTAL^DSBFUHWQBS@KRVNQAITSIZCA@CD@CTa@BHEVB]AY_@WL@NDS?F@?EWOBWPD]YUKEAZA^\Ma@@TZ?EF?N@B@B@K`@]?AMZRAB[PCR?Fa@S@LY^UCD_@MVD][IGDH@FUAACFk@DFFK?`@BW^ACYZE@FL_@HAC@AIk@S@@PWX@CLWP^POMPID?MS@AM@RCU?AjN]X[L?DB@?FAWB?A^CZT\qBEHCJ?UYAV?D@ONWC\CLACIO?JS]HBBUa@QANLUEIZA?WE[CEPQFCIMS]Y@Y?JLPL\DQ@BKFINM]UPZOJB\?CLPSBE@H_@IMFEC?`@CXMBDCF@QN]LBESCNPIDBP@AYE?a@W_@AUABCAG_AAKS?IXV?HLN]?BBP@KWCCI_@IBOVHVKTNNNM`@UB@NCEOCQSBBZT?LIUOBUNIHZKSPK\Q@_@]i@UI_@FNT^@?E]\D@???KK_@WE?^F?L@SNLELSNL?OUZRK_@?SB@FZNVIIN@H@MTJ@?_@@V?DRINMAB@JWAX^@MPRCVP]]\HFECC@L`@@@?UX??A@IWT?@AAPMIRQIJ@BDQAIEU@MINI?@@_@EDXDDDLDDHDDXDEFEFDX@OOXX[Ys@MIk@^YL_@QKNQ@FE?J@@EP@HIAL\ZA_@CSQEBCJ`@a@@HNOFTT[]BFF@SWDCBFLQ?J@]a@AXZ@PDORWQXOQEC\[]IBS?PDJBBLUS@FXYEQ`@EYLYZR?[?@_@E?K@?EYIWYVHDHDAS`@FH@A?ETI\UOQBQFCWBM?VXFZH]MWKFON?SVBQY_@]A@PZ\YW_@@SDOS]??NAWFBKJ?^_@IQ_@?[D_@KYZENBD@YOOBFBXD?JNOX_@O^^?WRVa@Z@QJV@TI]D`@_AC[FZ@H@ND^@@BHCRJ[?_@]J^KOWTIFDCSLTREBHAI@@?DI@]M?HKS@NJ]@IFPSUXWJ[O@@?QIBB\@i@UJJC^CLIUF@[HHMY?C?JPKDM?A\CV?G[PLT?ANB?@X?BE[\MHSLVHAAZPCI]V@BJB@ADXAE?^YJHC]X@WJBC@V`@ICEMIZJA?UISCPH?BTW@mNCJ_@PIWEXO?KVYEI?@B\A@KDBXAQ^Y@FTIFPCNLPZHDFIB@??LCLDCTF@ADAVE`@OZLHKGBMHI@TWD@MFRWU@?Y@C@XRa@YWAIOBWCF`@ECT`@HXP?NK[SJ[\U@HEC@Q?LWBITW\Qa@AP?@ANWFD@?W?DF[?S`@N@RCPLRMQ\R?DB@IJIC[VIMAOCL@UCVFB@SZ@MY@?^?IVT@BJB_@E_@O\D?qBBTC\@H`@E]D_@DDDDDDDD]DDSXF@BXXBYB?KY\ZIM]HVO@?PDV??UP@@?ZZINQTZ?UK@@FOK?CMANIZqBPLVBKAOBFFBEC?@W\IANM\XP@BE?@@HPUB?ZDFCYZANWDF?@K?`@??OMXAA?s@IDAJGK?MI?@V?KQ\YA^IAQOB?[A?KOIES@@I^EF@LOZDEQDATNI@TR@^D]A@??vADXSEUA\Y[`@UOBPMICM@UBPBLB@?XL`@OLRKQ?_@?`@KDSUDTHQLAW?_@IECR@@\B@HCXKIAM?B[K^FAJBDD_@SBPBAANI?BZSTCMBNL???RLQHTB@_@@?IA??K_@L_@APCY@?a@FI`@`@YEJB@?FMA_@AKU?K@@A^ATUU@JMNNIZP?F@@[KANXVVFYEABWASDJ?TE]OkC]HDR\ORY^B@DYB^OOTRKSAV]S@ABGGTCP^E^XCECASQKBJN@[R@Mk@`@I@I^V@K?HEV_@@HYJUZUELCNHT@O@WF@ECNUQMT^YWAQEJHA?FNQ?BO]R@_@YBWAXVAJH?ERYIE@?FnAIE[RBM`@V?VAH?J]\KRFE]BECLARREHBLEL\\H@R?F[P\IZH?BIB@VA_@]WPQ?F^BL@?IYA@?@^?MPKTSWH?B?@LN?Y?A_@OV[?KT?RQYCB[CSL`@@@]KE?]`@XINRRVa@FK?KMAi@?JAARBT@JEECVL??KP]^WKCINE?H?HI_@ACEJB?AQ\C]KBKG}@}@DZ@BYBELMRBi@?STTFD@AZOFMV`@K@JXYTJTV@CALB@EPGX]EHTSNQYE@DHIi@?K~@C]XDF@ADDFDFFDAXDDDXXX[DXBEQ[[YWLAYBK@?\KSJBBDDH?YW^\INBA?B?VKCUEOJL[EH?[ZTZAFLBHDJBVVF@LYVT]?IJ`@KS@VFEU]A?UOQTMO\^QAPCPEHP@RTZDE@`@ZEi@@LC\EZQ?D?A?WSR@Ea@TWAi@E?_@OV?VHIMJKHV_@AZ@?@I~@[JK]HVRWA?D@T\FPWZ?JUIP?LUYBUDA\JNV?RQYIJE?NK`@OQ@K@MSIYDEBYBHIs@IG_AADa@F]ADO?AW@?a@@B?MQ?YIBNLBD@@IELVLQ?B?EZIEASZUOa@SUFNMJDBFMATLFULUFFCYF@UWT@@?X?Ak@IYAP?UY\?H@EJ@DREWLJ[`@ZCBIIHYUEC?KMHLC?EJEMXMI]O?Wa@BVCY_@X@SMDHA@EMT\IBD?UUOYVJYBY@?_@ALEB@UPP@E\PQA?NAEI?Ai@QDRHQ@^O?OA?OYZF@@?_@INHKB@_@[N@FEr@I@JXOC?MKCXKJCTDARBMFHWAFAPPA^UUQEXO@LUW[AVEAP?[CHQ??PWCKDWNYA]HJR`@?NH@BCKOTK[@A@LDyABGAGCKfD]HEJOMLa@@QJL?F_@`@[YPDV@@BXIJCBNB@?AU?NXZ@BOQ]AUPF@ROELKONA\JAE@W[\DUQ@@AEICHFZEBIWMDJJ?JQEZDa@MKPW@@?NB\?[CHI@IHMJCLD?RZH@RHBNM?BKI_@?YZBAV?D?FN?UFI@CB?WLZNQ?D?DCL?@]DZ_@DXK?UN\]DF@CNB@RF?LNJa@?UCF^LXJBIFKFIL?KCBCJST@CY@AIABC@TA\QKQVA_@CQA@CE?INAUWDCUMSNK?BSSBR@YZLA??[?FLWAD@OFK?BDAIZAA?AYDFY?XDDDXDDFBDDDDFFBXXXXs@oBGGGe@`HZLJ\ZY`@F@BFHEC@HKBHJTIL_@\IPY?K?OJFCR@BEJBAYMXM_@^OUB?ESQB@@?EJ\]Y^\]K?DK?DO@@@?AOIZALD?IXI@PFF@OVV?Ak@RQAWMYLQEPE@JADHECVFIL?RMZT?Va@F@MVE?BD^?IF@HCAnAILHFWF@@J?CHZFA?C]?JTILHCR^HFN[JBM?HD@X@MWACDQAHRW@NDFABF[DLPB?MHFEP`@@YJT?MDEWJUWKBJECYCJB]?IAF?TDEPD[?@[VE?Y?AYZE?VXCEM?k@SJSa@XAO@UBA@CHEAA?CE\QTWHEDFN^HC?FEtADSQ@YZQGOQK?We@G`@GGGF@XCAIEDCBA`@E]PED@J`@IDDFHMW?Z?B@`@BQ@?HWQ?O_@N@B_@L_@?JBIH@Ki@@?JPRXQMBC\A?B@WB`@F?D@R_@@^[HFLBAQQr@DABEPBQ_@FAINFQ@BE\[VKJBROCAZ^M?_@FCH?CTA^SIU?SPO^AYvAYCNDPQBNRVY?JUPPAM?AMJZNAQ@BC`@SR@NA?DEKLMU[KXU?@CYEFDCADUBACRAN@NFNHFBN@?@]@?KC\AAANQOJIB@VSTP?UJSZLDVZ]BMF@SWBRSF_@VRA@NTQYADCFF]KDFKH?NXFM\@[F@@TUPKNHV??Ij@WQLH[?\WSRJF@ISE?IHCZ?JSAGUB[aPNGmDjAJTQUB@QHW^K@UMPK`@YXQWH?DV[DJI`@BDNJOLCITB@@EQR@\TUXTD?P?_@M@HCJCAL@j@N@L?JC]AFDF@K?LJ?PAAA@CP]QGCB?CN?C@?MKa@D^LAXJECEEUIEVMDCQBF@r@ACTAH?[@WAU@??CU@OLEMX@TYEEZYr@SCSQ?V?A?@H_@MVEKSTWFKYKK^??K@F@NLCIFOLB@a@A@JIKEJ]BDDDD]DDDDDLDDD_@XXXXA_@`@XPHT?E@W?FBj@DRHEV@JAAAMT??KOBIK@BCE@BUi@DIYL^ZAUR?QJB@@BK?OCMMAAZVHH?NOHFIVQRKPCD^]HW\A??HCSRDI@@V\F^?Es@GGGdDMk@xA?GGk@BEUAEF@@COEMLEO@I@NIDCFRMKX?HCF\N^A@]`@JJ??BT\?VB?@??AMFA`@WAH?NO?DEPCF?CWA[AHBL_@SLERBUSBH@FSLHXZPRL?XEAHUBPQFJ@WQ^IEJW[EQ?I?QJ@]?]H[JDCBAN??AP[UQEJP^EARKFEHYtA?K@YN?@@VG^LPH?QMP]HDQNEIHEF@?Y`@J@BTKL`@ABL@?ODCLFD[M??AE@X?T`@U?K@BEQ?[@^CRM^APCa@_@]HB?LRJBQDL]CP\CTD@?JNFIBSBFABHMNALR@KBRZAVXB@KCN@IEP\HJEIMj@?XK?C?FRAH[EW@QEARNJI?KVBXER?_@KY_@B@BIO]dDqD}@VxAGiDKGGUCVLWCRTDB?[IKO_@ZB@HWFF[ETOF??B@N^@AUSX?@NJBQICKVNVFXX@MI@KVABCE^CP@RBMKACANV?[HF@DOLU?CKIBCZIk@TEFr@?EBWTBF@QFZBAHD?I_@B?HRR?LTFK^FBI`@KSTA@BFO@OM?YKMEEH[a@DIA`@LYCKBH?`@PD[HSQVAJJYYSMKKJFBHQTZJCCZUCDWAI?HMHER?YKTIC]R??I@IHM?KEAJPH?IPNX@@??[Ba@LUPRI??@??N`@QLD?BT@^KISCa@C`@B`@AFT@?OP@J^XBU^VSR?ARAKNEWRRV?FCXKXVEQQ[KW`@I[JJPEPAO?NAHKEWB?X@_@NVBVH?JAe@NExARGGGd@oBcQJe@EQ@LW@H^LQ]QD?F\?FYR?CCIY@K\EXZCC@OZa@EYZ@HH@D[YSN??CK^?JVBTMSKQ[AW@\BSLMOEHOI?V@[?UMOWMJO?JbA]HDQQEXKSBLUH`@M\?MZ?PBDDSFFFDDDDXDXFXXXX@[_@AWLAEYa@JCEQ@UFSHAAIBK@WMW`@WFFVHSPBFLO?RV?^XXTNBLNRH@[Q@HD?PDCCRZ\L[FX[UOUDEBBBOBEJ_@A]M_@MXFO?S@KBH@JPODS^\\^T?ANBRD?VCS@Q?V\FK_@NLTOFF@TFFC?@F@E?_@i@[\W@KOKYH@D@QTPa@NTZAr@?BAF@?Z?FB@DQ@Aa@DLXA[B@O@\U?EBVSSL[PRDAXASQ@N`@BC?U?C@Cs@?IGqPcAdPg@g@Ge@G`RJGG?\]^IMBk@[R?@BCJKF]F@IQNVIY^ARVFKCB@BJUUIIBXSB\@`@W^HJKU?QKD?H`@YD@YLSYJBD`@JURQKKT?ADF@]VMME?LEFB?UCOYDLJM^CSI@?RYJPF@^I@B_@B@@AYQ?ASO[JCDBXN?@?OBOLARPRZ@HNCHZYHKBEOK?TAKHXHI?HE@Z?TVON@~@W?JCCj@@OYKBT?N?RCIZUUBP@@ZE\@PZa@Ij@B?Y?ADCKBERSLJH]LHCMUOS[[?MRJ?\PR_@XEEUN@@S?_@AFYZC?YD?HMR?^BB@@DAB_@r@?@H[D@CCN@[KQCKH]VZ_@]AQ@^RA@JYUDBKDB?H^@_@V]^F@@WEIPH?VA?TDF?FXSNBFX]EKu@}@qDg@j@g@g@e@u@u@u@sD}@GRa@?WFP@QMI?SQQ@@LNE]U@FZUOU@]TH?DTJFNB@\N@@?HRULA?MD@RLSKAU[CFF@BXH?]_@RLD@@W`@BR[Q??BFC@M`@INi@PJJTJQYQDBL@??D?IID[OOIFMa@@IQQP\S[CSDRQ^VC[[S?C`@ECEHTHIXFH?WETZUAHBD[PFEFEKESIAFLLBIBPPDAEC@?]ZPOJFAWAODA`@RDMU@LOFIOBCKAOJB`@ACRTICCJ?NEUV[UOICABWUON`@@@UJC[VVB]R@a@ZXKO@\C`@BAF]JFDB@AEHi@FKOA`@ESUOHZL?KHAA~@H@PE@XLS?RC@MT?J^RHWSPLJIFUEC`@PUQXL?BEJYBE?^EMHIU[DE\PD^DD@`@BiDGb@d@Ad@Bb@sD{NGGCtDGIDXDDDXFDADDXFF]DDX@F@_@WMX@CB[CBDP@P\^OU^E[VDT]ZRD@MBVCWL@TBC?J@XS_@]^Y?B@LAE@UJE?HHEC^TR[ZLJJBAHNCQKF?BUCLM@YI_@MRRIBF@EDFEC@LRRETM`@LCR?UACBF?EJ?ZLCJB@PILDY[a@H?FE@?BHIZ@D?EITAQ?YPCBBF?@^XUCVAS?LMJ??BWDKSE?XBNHk@RB^FANABEZHV?CTJa@XW[DAW@H?ICC@CXY@FAC@Lj@W@H?RRF]FKT@JKAUKHINAV?K@LFDPIVYHFj@?@LAAUDFW@J@SCQN?RE\RB@NWLNJKODDA@?L?@\FBEQ[i@II@`@@@FKN@UWCZHE?VA?XAOBEFI]_@BHAOC?FZ@s@MZF@d@{Ob@GfDf@GGnPb@GGb@x@_@b@SK@RA@LE`@HJFCJFA?A?`@BBFCRZIX?@COUIH?IB`@Q^?@RMEYAE@?KYF@C?JWF[Q?WDAKNWKJ_@VBR?R@BIF_@@KWT@T^A??ECEECCNKIYCRL@^JYK?AQ?PDC@@TASH[IJCYIXBSBDBBROAA?U@A[C@`@ZCDQVH`@SCDLJP_@U]BFC_@DFDA?MDCAKSEQIT@QQXKHIJBI?MJBKMHCHAa@a@QVA^@F@ZKT@a@QJ]QQIEPFLMC@K@LAD?V`@BEBF\BERTAAJ?\VI@CRKM?HBF@?KI_@Y@??PLNVH_@MFF?@DUE\CWB@MHAA]HO[J?@UPPbAXB@?ENL?M?YHSPRJ??DN[@VABT@?AMa@SFO??i@@IH@EAHAQxA?n@G^GfBGd@x@b@x@h@b@x@b@GGYoBHE?RLDKF?WPAE?T?K?`@S]BC_@L@CHE?A@F`@F?Q`@FLJBHZLOKJLHRM@?J?ASMCPNSBND@CHKL[B[E?T@SQJXPOCTEROAIHE~@DQA\?]JVCJA@COW?I`@?VV`@KL`@PAORUC?S\@LB_@@F@@_@LDW@Q?UOQ@UNTLBRO?QIT_@AHDPEJ?T?YN[HK@\PC^IWE?JVH]CEUT?DY@OECIQPNTJa@@r@JC_@PX@SAQ@\U@IXJBEUPMXIKOUB`@PDI@E@Z~@BRWACDDFDXXDDFDDADXXDXT[NVT\_@RF@Q@ECA?I@QVKLD??JA[\?J@D]a@ML?HBT@SPYPIAMNLF@?R@IR?H??ELDEIAWALEHBCFHF\PKFSOFVLYL\O_@@FFCP?ENRA?s@e@g@x@g@QGGc@G@c@g@u@jAb@f@p@b@p@b@p@h@b@Gh@Go@CT\L]EBO@QU_@OFERAH@CI_@ACJ`@@D@@NDU@NQa@PHCW_@TK@EO@_@LDEJ`@OMa@KSR`@_@IF@TVBVCD@Z]a@U@?KC`@TA^?CU@HEF@AT@CF?BXDMY@CBUABV@A^VFHE?YVOWMBA?HH??^TIRCSC@Y?PAAAN??SBKL^C?OKKMAKOTZA?H@UDA]TC?WBEET\KUL]Y?C@@VAP^JO?@MAIYOVJZV@BKCWVANKUH^JAA@QH?Ea@JHAM?Ra@i@A@AODCAREQCB\PL[^@?E[FBIAIBEI_@?F@BH]V^^DJCVBV[Z?_@BJJB@INB[C?XNHD@^`@VAZ?EOFPKJLA?_@?\A??@j@@W@BVUCDFWC]DN?A\DBC]`@?SVBSL@ALROKTMSFU?Gu@f@p@b@p@b@p@b@p@Gh@GyAo@|Qx@u@G^d@b@d@b@d@b@e@?U?PJ?B@AINOJ\YV?KBMIV?@Da@U]?I][Y?ZDFC?LX@JSUDKSL@MX]CJ@?@A][@D?E?@N\|MJ]PRU_@\?RB_@@K@@BDFALYSMFBCN@OIYDEU?BO`@N]DS?PTCUMC_@UFPUQEUOX^NC`@@CEI@H\LCBCOB@@WNTBRANP?ZEOWH?KPDDRBIAPLOMRLDE@[WORCVO?ZETB_@LZ?_@CH@A?HBED\CRNYF@LEZ?STYF@@KBH\PBA`@JO_@TN@HTKr@JCEBS[@KAF]?STEO\O[@CBV?L@?`@KLHNIV[\PPRPTU@BACCVWRLUD^?BW?CBZAO]?J_@HO?W@DRB_@BYD?Q[JYJBABBEFLH]\J]PEJJH_@CFT?@@?@`@WHE]H_@HQS]Y?HETG@@b@d@b@tDh@GPo@Gg@c@pPf@p@h@b@Gh@v@Lo@GGS\_@PBL@KPMDMHH@F?FSANJSCTI@?\\CQEO?BELEQTB@\MJ?LNM@PCH[@?NUF?KSV[@AANHREV?L_@ELQERCJDMNJXYN@JUEQAMS@@?KUD@TWI^CFa@OJNLECWVOCFSIK[XDDD]DDDDDAYDDXDDZ[XB@I\DE?a@BDUCMXYEOEA?C@LMM_@UASPQRF?VPP[_@DCKP[MTCMCRJ?SCUADVZ@??L^AYNZFMEJCPQ??J_@RCS@S[ITTED???EQLSXVP?a@FBAWY[EEJDZ\FDZAKD??QRHLMY@PU?LOnAFMDOH?U@@@LTAM?IHO^W?FCJKRDUJCVAW\A?@X?@KL@OK?B?FVCk@I_@AKLJ\AEKB?K?DB@DUE_@_@YY?CMV^??RS@KBa@@?Fs@GAGl@Mc@rCf@Gh@t@v@m@g@x@c@g@Ln@vRt@v@m@dAIc@l@f@aBTMK?QHER?FFFE?FMALT`@LP`@FCRIEFFKBD?VTXNAI^?CQCVW@?@SKDCFZW[NADEF`@VU?SUE?HEOW]`@AIMNHRC?J?UJC?PBH[XMMM\UODD?F?U?VQBNENINZ\`@K@PVQO?C?JCAXB?Z\ABLO?BJQJJQKLF^HVFWMIACLF?@UCFIFM]HPNB~@^PXSAD?J@COC]`@AC?K@AHFFALF@KSHMCA\ALF@?Ba@SAANJOF@UE_@CTA@E@?RVOYNIHB\JDH?WTN@UL@HF?YINJIT?SPC?LPJ\@B@?CXIH^@KD@@N]?JDT`@Q@UISXr@FKOKJTBC@FZZBKOYI?LDIF@@BFIJSFYAJ@?UI]FJIOK?FJ@ZU^LROUR\IAF]?P@O@J_@yAHGh@t@v@m@dAk@c@l@c@hAGh@t@v@m@dAu@f@Gd@b@p@b@yA}AGG\J@P@BWAQAV?K@V@DILSLPVTDE?CIO@WP@SF?X_@HE_@ZJJW@XK?BAPKROJKIMASPNKBQ?FMH@^KFE@BIYI\P`@?NK?MJB@IC@JHPUXHAYFL?PUNOF?@NFRUB`@BS[N[ABEMHB@@V^COJ@@ACMLA\EHD@HS@B_@B?EBMVNF@]Tj@VHC?F[APB@BDDNVHM]A@EL@_@RF`@CTSF?P??JS`@\AYBM?CQBWa@RQDKHFD^XNABL`@JIHRBPBFB@?SJ^AN[ITKABSKJUVBEO@SCP_@]IW_@JB\O?@NBSOH@D?OA\YAAI??DE]UCJB@P?@D?ITYXKAV^?J^~@HEF@BC@SZ[MAXXSIUFJPUCREC@BFFIWL_@WQ?Z@VHAB@??E?BPI_@NT_@gO{@d@b@p@b@GGrAm@dABGf@Gf@Gv@m@dAc@l@c@aEb@?D|@THHT]D_@DDDDDDDDDXDX?J[XXI\]@@DQQ@WH@V???NL?i@CA]CBNAHE@P@?P`@^PVA?IUWCHB?a@M?@?QL\PIYHENEC^IQVHSCICa@C`@I?RQ^]J\UIB?HD?E?ACCTACUAE\XHUWDHZEUCVF`@MHL?AVW@BM_@_@KB?O?VHCY?MRO`@T@CCWYYCURFK~@E]M]A?X@?EH`@@IRIi@EJSB^@LBGCU@DAJBOY?S_@EECQLM]LWS?FM?@KP@LD_@CA@BWM^@F@YNA?EWO\CBQ@EHk@[`@YPW?KNMB@BK]Y???@OIACCYFJY]j@ECR\?UJDDO[A^AJCLK\NDC@ZDB@BCH?I`@FLOIUF@WNHQBPOJBUCITN`@?MBKA[AERVHJB@VKHZ^SIQ@_@MIMCFDMOFDVJJ_@[As@ZWVGz@c@z@Ec@z@c@z@c@z@c@~AGp@b@d@b@f@b@p@b@d@b@f@d@b@f@d@h@b@b@PI_@KIK?KDB?@RS`@N\BEa@S@[TEAOQJSR?EALY@IKBAK`@[@@OPVZRJBD@[B_@XBOB@JYYBRY@VC??ZRBZ^@X@BC`@?ISITVQVa@@ONQXADPD@NJO@L?V?^@JB@WAO]QD]EKA?VH@a@C\B\Ki@BMSHT@BSDEB?@WAN@EUC\CCWWCO?DZ@@@KHAMSAOFOLO?Uk@B@?E_@@BBYJ[CLB?AJ@NMCB@FXHB@CF]OCZACNW?K^MQ?RFK@VBTQ@?LAV_@CA\??SU??KBE@[RAQAJIDAN\J?OK@?OEKL?AMCZAB_@B[EHKCCQ?HKWBFMRIIUAYWEN@a@SD?SEME?WTB\ZCIFr@UJBBE?OPEX?PWCIIa@YKBXT@Q?B@@LP?@j@I@IA?\G~KH]FJGm@Gx@g@c@g@~AcSf@C?b@Ld@b@f@d@|A\h@Rv@gAm@oDc@~A?GCHJbA?[NH@?`@H?EY?FO`@URS_@I?WIOK\PF@APa@SQAUEDI]@D`@FF@C^KF]J^?EVVIKSME@IIH@TCPTYZ@QRHRCIQC_@YI\?F_@DJ]FP?@OISQSNRZIk@KCYW@CH?HEK@PFAKT[A\ICHMVOSSK?P@`@LE]UNYL^RSKHFCV??HRMSI@?L^AIY?K?PEKB@R[TN@]EJA]FAI@Q@S??R?Uj@HNH@@_@LMIB^?M?QSOB@T\@[BKRL[HNH@]T?HVH@T?NEQCVFDDDDDDDDD]MXDDWXXAX@Ar@NHCj@FNJa@ADa@CUCSA@?L`@T[?VUSVVPUKRM[MHT`@PIA_@QO@BKa@@F?@BA?T`@@K\\ALK?OPQJ?ZOBBAIXWT@HXBEJL?OENO@Q?PA]A?@Bs@oD\XYh@b@o@c@C~So@UBc@b@p@Ae@c@z@DPb@f@h@cAF@f@pAn@g@d@cTNCg@Ud@n@pAh@b@o@c@AIMxCBCIV`@]EUC@KNSS?@BA\?DD\B_@WPS`@?FDR@??NZI`@@??TMIDEH@`@QQ?BBK^`@O@FLALNAE@KUQ?RO\DWARBF@^XW\S@CB?E@?CKYN?DRTYHYXQ_@a@I?@H?HATB@E?BNNP^QRUKIBHD]E^BO@HZN@TCa@PE]FJFWDENBRCZAIC[DOOVACC?YEPSBA[?NWWQU?@CSKIO@BOD?IZ@AM]`@J\?J@@@X?BPBSEMX@SZKA^E?F@Y?HJCW?OV[EKY[KNLAQI@B@J@SRi@IFM???@AA?\IUOSFHE??ITMHDJ[E?XU]N?VDDVBW?TI^?EQKF`@?W^?PDHV?PNA\UOPV?@A^R]LV@?QJJTTTNS@B?OACAXLEF@O@BAS`@CBFC@D\F@MXIGG`EgAc@g@d@Gg@b@f@h@cAd@q@g@d@xBq@g@d@q@g@d@q@pAh@b@o@c@GHJJ@Mr@V[IM?EPC?JNTBLAUOCJBA@?CKFHSIAIL`@?ZUTJ?Oj@??DHFFOFA_@XCENYHEOVF^JBHFBVWXA]YS@Z\V?FBBTOR?@U@ANHZ@QL]UVHJFHLH@KRWXQOBNAYO[HEU@RTE???UIZCUi@IH@^@PB?MH@CCBAAECA[WECFZBECWH@FSA]\ZJH@IK?TE@FF?@A@F?T\XRCTHFHUBj@OVSMPE^a@LYNWJVF@HWKBBDVH`@BJYMZARRBOOFAB?KH_@ECICWLi@bACEBBPAHJ?FTXYKNPUNN?H@@@AETCa@?BA?LAFE[^ABUJ?MOB`@?@@TPIDMVC_@@FEC]@WB@X?@FY?^B\P[UJQP@_@IJFASBBi@?JR@_@A@EF@NW?AJIBDUSJ@YPM\TXe@BhAh@cAf@pAh@b@o@c@b@p@e@c@z@Qb@Mf@h@cAf@pAq@Jg@d@q@g@d@xBq@g@d@Fq@g@GE?LHEEABX@TCBAXK]T?OKBK?P`@D^?]Y@H?ZBN]?CQ?J@KDABMELIEB]QDRBPCKZJ^@PX@NA@@^F\KPJPQKN[@KE\NV@ACBM?@HIT?EFMOVWT@DAFDDDFDDDDDDX]ECXXXX[@MW]VC@Q?DHE??J?AZQ_@P^TWKHYJRAVJ?@?PCTIP^JCi@QJKHUKa@@IQFMNDW\E?BOQAARJ]CF?DPVHNAALP?E?A`@VJJE@SBCEZILMUO@BOVFNHAC?CC_@KENANXBQBTCE\@CVUB@MEHAT]EKJWDF?VC^FQVV_@C?LIL`@BBAQLVO@M@??@JXJDZLEZJJ`@ECPBVF^@D\FKMWEC^RAQNKKDRS\JB@IBF`@JBWAMCECEEHVAHS\Z?CDFKKSATLVUSBETZ`@I@FJs@@H~Dc@u@hAd@b@d@b@t@Wh@o@Gl@c@g@{@d@b@d@b@d@b@d@h@iAm@_Bl@zS}DGCIHLY@??HBB`@]@WEP?@AMIYFKMD@Ra@RWTCVFLBJ?_@I\UCWECJPVEIDZBKa@HLANLWEEWBOBDJAAQV?JBJ_@AMM?BA@?V??@IC?BDHY]TM[IJNCE?KBFWUJBHV?]j@IIHN@RJB@SP?XCBEJMIZE_@??MJI?UKHR[UOER@WIH?Ti@S[ECSJVAH@EQE\A@N@AI?Z?FS?MEJOKFERALA@]DN@F@?BICa@??CKIAD@LM?AT@@A@H@EJ@Q?a@`@PT[_@F^EDXORFSPWECR]?BM_@@?ZZI@CUOD@OYCR@FL@X]CTIUHZCRU?VEMCEJ[K^M@?LN[H?J@?a@RWE@CZBVMLPI\FUWF@J@DBLHH_@EBNIB@]k@XCEVJRRRAHOE^CRA?L`@I?ABHREQ?EG?Cu@hAd@b@d@b@d@b@t@h@o@L_Bl@c@g@{@d@Jb@d@b@d@b@d@h@iAm@_Bl@c@g@B\IKSNZAEIa@KQDEFHFET?W@AH_@IE??KCKX?HR@`@a@LVNB@`@LB]VO@AE@?@H?TKTD?WNF@j@KPKR_@H?BC?\DWFKLMTBTEOJDFi@?VE?ADDNEBAMPQWDPH@DH@_@QEO^FWCF^AIVN@QF@E@AU[XF@N@PBM@LC^E@?OJHCA]FBRIR@]T?ZB\CQ@UD`@\F@@AEHAFIV[NHKUOQFCSZ@SYZUF@_@bAN@AOBOBRHHLRBOMP?^ZAE?ACPRR@F?IBUYJHAPI_@TFEAJ?SQ?LBZF@E?RILANH@[?EF?DDMEF@??H\^NI[S?MPFV@[@?BJ`@DBONMHW@CZFD@@[CJUC\CPEA?YALO?L]CBS?JULTN?R?FLLU_@SXN]FDDDDDDDCDDXXPDXXX@Ls@Gk@b@f@|@y@c@NFf@@@|@F@Rb@O?Ba@XX@q@Ql@f@Bk@|@y@c@b@d@h@t@m@c@l@{@b@Gq@l@{@b@q@l@{@^NLYWPETRMQE?H@?SFCEA?LM`@?a@JECMS\BFVQF?WJHIYMJIFQKCSCFA@`@@]CACULMYVFB??DJB?O?NXIJ?@ZAAHCQ^S@O@DAVHE^VTDFIABF@EEAB`@DC`@C[S]?CPWYIBAHFEBKUQ`@H[MAV@@C^EL`@SVOa@BRRAS`@AS@@HHNAPCIE^QQ?JU_@TMIKBZCKLk@@PSBEHLBEk@@AQHIBUBWNYPCF?KCMUATJDBJZQE[AH]S?QHESS^MHQUIOQJIIj@NJEYCFK\PLRJBUAC?QA[PE@C^URFTVXOCOLFSZAWL@@BRJBMBA@HNA@JXSETABP@CN@?EJZFAIPTDRKMITDUCEJQC@\H`@MXIQEKA[KPEH?V@CZEFLWCNRF?WnTGY@SBHmDGc@f@|@y@c@f@h@t@m@Tc@l@f@Y|@Cy@c@b@d@Kh@t@m@c@l@{@b@}Ac@f@|@?y@c@f@r@?\LFR^?SMFHFCQ_@@?KNDWWD?^FRITNE@@DE@JXOTYAIJi@U[PH[DFBDEH`@CR`@SWA@E\ICB`@WEFDEHCKF\I^FOVSID`@a@N@JF?PF@B@T`@AQUS\@LOI_@HJBKJHSAM_@KJ?EKZ?A@LHOO@?VA@?MI]J@CCZ_@JYZ@ES?@??YLTBBJ?B_@D]J[BHBKB@VA^_@@LEa@SOIIH_@]CFOOBCZTSD\PECKWFWW?KKPKFa@I]Yj@D\KRMJCWAE@B@HP@H^CTA]J@?KAJI@?E?BCPE^Z[MRLR@QIWADCU?C@?SH@YO`@LQSBAVIZa@RCH?PJJTAZ?^?[?DTT@F@O@@RC@a@WNFNJKa@A?ATBQ@Q@BJa@_@ZQNXBU[UAAPOF@FUSDJQJN\XONEA\CArAGHCBFd@h@t@m@c@l@{@b@o@g@f@aE|Am@c@l@{@h@y@c@f@|@y@hAt@m@c@l@{@b@q@l@a@B@PA\@IYNJCV\ZVF@?D?UDPDSAWABAZT?DMB@J@HJKRVBNLH`@AOM@^DPP?DV@DKSk@D_@?XZA?`@JT@PFHS@E?WMB`@UAMNJ?NJCR@@DKDS@A`@SYXANEVIEWJFHEFPQ^LBE]IMBB`@@]DFBREKFDEX@WTSI\?WFAVHa@?HDK?@PYXQAMUMDIK?KH@FVDQDAT\@[?KAKNJZ?U@K@BBT^?F\]]FB]EADD]DDDDDFKDXDFXXXX[BLLB?K@EFOHD??Ma@N_@@\[H\LMQE?@CEEOBHW?AJA[CWLFC?ORER?CHZQTQ[AHMDCV^ON??XKV@??OCKYQNQIRZ`@E?M?R@UHC@Q^^D@`@XCRAPX?DDRC?H@TMIEZRA?_@MIDCE@CKU@@PMETBYBQKOWs@XyR}A`@Cy@m@o@gA?m@o@gA?m@@So@gAy@m@CHo@gAGjTe@q@iAv@h@|@|ARALMA?@I@?LX?@I?UKDSQEI`@LBPTRIQYM@@QFDDECIYADMCULYa@Y@MSSQK?D?B^FUIBHC\YCJMQKAPHES[KM?PDF@JM\IHBKL?HEH@IBZ?a@DFL[VMIH?FMP?CT@NRHF@S@K_@[APJEYV?VVNC_@DBV?DAM@`@XCHDXCUAQ\SDSQJEMHT`@PJJ@?L]_@?FIOR@ASQ[IML@@J??IKV`@HCCB@[I?YID@DSECWAW@BA@ECXZAJ[JSPOOH@THEZS?IS\QZMD@@??R?[AQK?AYC?THMEZFPD@RPLCABO?UNAJFAO\CAH@OHQ]L?BNUHK_@TDH]KX?JE??H]^DD@HAYUOF^CATK?BVA?ZPERWH@j@QSASAMUJH?HR]\CH@BYW@??VMZXtT?QB}DGq@iAv@q@`@iAv@FkUq@iAxBv@h@|@|A@t@p@t@b@G`E\p@d@f@hAS@QFYRPFII?NHECCIHW\E@FBbAUORETL@JPDZEL[WYIRSKFJHP_@AEQRBDAHAIQRWK@ESQC?NADJO^I@I?J?AUOOBRFNXY?@CCMA?D@J@@TSDECH[L_@UCTC`@SKDFFEU]@CCFAT\KKDZHAHCHF?OLB??E?E]^A`@H@IUKE@SE?[BEB??NIW`@?K\@MHB?BH^ODCCA\U@M`@CCA]??CUOVX@EUP?PINAE^A@TE?FFC?YH?OYE?C[]NMVA@POFECDEY@CHTCBNYWB@@WPA@BTEEHFE[TFZ@[AC?\CTJK_@]OBDFQCA@B`@I@PD@`@TH?Z@VU?CKIQH@Yi@FEZA@UDLj@KJCQOFN@ELTVCPINOPHWS@HEDFWFTF@MAASj@?E?j@@?@TEHFCW@BM~D[b@f@Zf@u@~Ac@g@g@z@l@g@z@l@c@z@l@x@cAFdAGc@l@x@cA\dAoU_B}ALy@DFCW@SSJFJPa@RMATBF\N@HO?FLKPJ@LH@PIAPPR\D`@JB?PA?B?BZFF@j@\AFA?HLSKF\@EEKKX\@F@MH]DDDDDXDDDFDDDbAXXXTY[JJ_@BDMLF?]@VK@DHJMLGAGBGCGDGEcEBdEDyBCeEEzBDfEEzBFGGGHGIGJGKGLGMGN{BGhEIjEKlEOGPGQGRGSGTGUGVGWGXGYmEHiEJkELGOoEQ|BZG[G\G]G^G_@G`@Ga@Gb@Gc@Gd@Ge@Gf@Gg@Gh@Gi@Gj@Gk@Gl@Gm@Gn@Go@Gp@Gq@Gr@Gs@Gt@Gu@Gv@Gw@Gx@Gy@Gz@G{@G|@G}@G~@qEInELG_AG`A_CJrEMGaAGbAGcAGdAGeAGfAGgA}BhAGiA}EcA~EjAGkAGlAGmAGnA~BoAGpAGqAGrAGsAGtAGuAGvAGwAGxAGyA_CzAG{AaFiA`C|AG}AG~AG_BG`BfFpAgFrAiFtAkFvAlFxA`CdAGjAbFlAdFnAbBKGaBGbBGcBGdBcCLzE`AkAjAuFmAeFNnF{ArFqAhFsAjFuAaCwAmFyAlAeBGfBwFcBzFu@GhAlAgBGhBGiBeChAeBjBGkBGlBaGiAbBmBGnBGoBGpBGqBGrBGsBqF`B{FrAsFuA}FxAoF}ApF_BGtBhGsA|FvAtFyAdCuBGvBGwBGxBGyBGzBmA{BcGnBdGpBeGrBgG_BeCv@vENkGtAbCwAeBkAcFmAmGvBnGxBpGzBmA|BG}BuEw@uGw@vGuAiGyAjG~AkA~ByG_CG`CGaCGbCGcCmAdCGeCGfClA_ArGlBxGlAvFN~GNeBgCGhC~By@GiCGjCiHmAG_CcHaCgBcChH`AlAOGkCGlCGmCGnCGoCGpCGqCGrCgCsCGtCGuCtHtCuHN_HvAkAvCGwCGxCGyCGzCiB{CiCkCoHmCqHoCG|CG}CG~CG_DbHlA_ImAmH`CdHbCeHiAhCnAaH_BbI`BwHwAfHeCgHNmA`DGaDGbDGcDqGNcCaB~FdBgCoBGdDGeDbGkBbBfDGgDGhDGiD}Bv@lC_CnHbChBjDGkDhIbBxFdBnCpBsGsBxHwCGlDGmDGnDGoDGpDGqDlCnA|G}B_GiAkAeA_FgAoIw@hBz@wE|@yE~@kIlB{HlCpHnCjCpCsHrCeIaDfIcDzIfA`Fu@dCfBaIN|I{@xE}@aJbBpI`C`IcC`JgAlIgDmIiD{INhJhDnIu@}GNmAhBuIqBfGsBoClDvInDxIpDqCv@lJw@hBiCdJcBbJ|@yINoJdBsIcBnCdDyBrDGsDGtDGuDGvDGwDpJ}@wJ~@nJjCqJdBkAxDGyDlAMrJeDcIxAdIfC{JNjJrBtG`BvHuCsCmDwIoDGzDG{DG|DG}DG~DG_EeJaCiBiAsC`EGaEGbEGcEGdEzJyAiJiDhKu@iCPpERGeEGfEuCaEfKcE}JsBhC_CqIcCwChAiKQ|BgEGhEoKiAyJaA}ImC|HpCmJN~JNkHhCrIkD_JbDgIzBqChAgJu@eKbCmK_BqKcDtKzBzCcCoCxCyHzCgB{CwCv@uKNzGwBoGyBkBiByKw@{BiEGjEGkEGlEGmEmBnEGoEsEg@tEpEGqEGrEGsEGtEGuEGvEfCiAnBwEGxEGyEGzEG{EG|EG}EG~EG_FG`Fw@xE_LzEaL|EcL~EeL`Fw@aFgL{EbL}EdL_FfLyE`L{EkL~EvKiAlKbEgKdEnK`CfJiAwKyCzHbCG{CyChAuCbFGcFuLcFrKiAsK`BtLiAxJyDvLNsJsDtJuDvJwD_KnDkJqDpLcEzCiAmLzEhL}ElL`F{L{EoL_FjLyEnL|EiL_F}L|E`M`FfCdF{KNyLoD`K{DbK}DdK_EwLtDuJvDzLdEqLaCgBiAkBiAlBnCjC|C}H~CdMbCkBNzKxB{GN~CpDjMqDGeFGfFGgFGhFGiFGjFGkFpKRjKfErLzCmBjE|KlEGlFaM}E_MzE|L~EnM~EoM{E~L`F_DuDhMiAiMyBsMzBeMoCrHqCyCv@pM_FwM`FqM|EyM}ErMvDtMN`D|CgM_DzMwDvMw@_DmFaK|DcK~D}MNlMkE}KlFkMbCbN{CaNlErBgE~M{DcM~DrBeEgNfE`DpC{M}C~H_DhNqCkNrCeN|D`N_EdNhEcNlFlBnFGoFfM}C~CzD_N}DmBpFGqFGrFGsFGtFGuFGvFGwFGxF`AqFpNsFGyFw@zFaDyFoN{DfN_EvN|DbDrFaD{FG|FG}FbC~FG_GG`GwN}DlN}DxNsFG{FGaGGbGGcGGdGGeGGfGGgG|N~DiN~C`AhGGiGGjGGkGGlGoAmGGnGlBoGGpGoA{F~NbG`OdGGqGGrGcJ~@zAaG_OcGcDsGGtGGuGGvGGwGbDxGGyGGzGG{GG|GG}GG~GG_HlOuGnOwGbO_EoAtFrN`HGaHoAyF`AbHGcHGdHjObGiOeGGeHGfHGgHxO`FvOuFG`HeDyGpO{GGhHGiHGjHzAkHGlHGmHzOcGcDeGhDnHGoHGpHsBiGeOqHGrHzA|FyNuAhOpGnNoF~IqCcO_DbPdGGsGtOvGoOw@{AeGhDsHGtHePjGGqHgPN{AqGGuHGvHkDeHGwHGxH}N~Dw@yHGzHG{HG|HjDeHG}HG~HG_I_PlHaAnHcPpHlDqHhP}FwGxAjPoCuMrCw@`IGaIGbIGcItBvFtNxFaAdIGeIkDfG{AfIGgIyPmH|OzGqOhH~OjHiPqCrP_EsPzHtP|HjDfGaAhIGiIGjI{AsGlPwGbQgI|PuAaC~FzN`GrD{G}OiHrDkIGlIGmIGnIGoIuB|GrOpIGqIGrIGsIGtIGuIGvIGwIGxIGyInBzIdOjGoPrH_QwF`QeIaQgGjQxFuBhH{PrHtB{IG|IG}IG~IaAwHzPoHhQtGmOvGmPNwDuGuOw@fQiIgQeIaRvGoQ}GGpIpQrIrQtItQvIvQxIG_JxDpIdRsIsQuIuQwIvB`JcRwGbRjIjRw@kQvAG~FxD~GsOtG_RwGgRqIqQsIhRvIyD`JvDiHqRjHzD~FrR_GzAaJGbJoAcJGdJGeJlQlImQnIeDfJGgJaAfHsR`GtB`HzQ|I{Q~ItRbJaAsH~QpHyQNuNsFqNuFsNwF`AhJGiJGjJGkJGlJnDrGGmJGnJGoJfOnGzDwAxQxFoRrIeRuIiRxIG`JeSsIpRwIvByIgDiGfPrHlRN}RtHkReIdSxAwRmInQoIsBcHyOlGw@pJGqJxRgJ`ArJGsJGtJGuJGvJGwJGxJGyJlSdH|R}IjSyAmR_HiQw@pD|CwB{FGkH`PmHkSnIsSlG}QxHnDuHwSoItS~IgStIfRwIvB_JpDpC}PaI~PcI{RaH|D|@uBzJG{JG|JG}JwD~JuRdJ{S}@w@_KG`KGaK~RiJ`SkJaSiA`TeJxSvHlDkGySuIfS`JeTvIyDyIwBmGdTlGmSsJnSuJpSwJrSyJsBbK_TiAaT~@|S{J}S}JdQrChSjGwQN|DmJbSoJuDiGiSNbT`KGcKGdKkTlBaA}HxP_IoTnJsT~HuToJvSaGkOdGaOeHwP~HlT|J_EeKGfK{DgKGhKGiKGjK_EjJ{DlJ}TkJ~TlJrBkKnBlK_SzCiBmKw@nKGoKGpKGqKGrKGsK_UiAhTtJoSvJqSxJvDtKGuKGvKGwKeQ{HuPdGkPtGnRw@xTfKyThK{TjK`UuJiTxJuStGcUNgDcHvT_IfTwIfUxIgUyIw@xKGyKGzKG{KwBtFwOaHbEvJaUyJpTjGqTcKrTvEmTqH`A|KG}KG~KG_LuDbKgTnG`A`LdUkJGgKzTiK|TNhUwJiUgKjUjKbU|HvP}HbEaLmUhKeUNnUiKlUxJwT}Jw@bLGcLzRgH?dL</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??pB??O?H??A??A?????G??C??pH?_O?I??J??@@?k`?K??C??@B????L??M??p??gB?N??O??PG?GC?P??O??@B????Q??R??pA?WD?Q??S??PG?oC?T??A??A?????Q??S??pK?sC?U??S??PG?KD?V??R??pE?cJ?W??R??@C?KS@W??X??@V@sg?Y??Z??p??{W?[??\??pU?OU?]??^??`??oL?]??_??pL?sN?[??\??pA?OT?[??A??A?????W??X??@E@Wg?W??`??p@?cW?a??b??PA?_??a??b??`??C@?c??d??`k?CK?e??f??`@?{B?g??h??@C?GJ?g??h??`M?OL?i??j??`C?GE?g??k??`@?WV?l??k??p??o[@m??k??PD@W]?Y??n??`J?{O?Y??o??`@?cP?p??q??@A?kR?r??s??pN@WG?t??u??@F????v??w??@D????x??y??pO?ST?z??{??P??OM?z??|??pY?kR?z??}??@O@wU?~???@?`[?Ob?~??@@?`T?[d?A@?B@?pH@CP?A@?C@?@A?gJ?A@?D@?`F?CJ?E@?F@?PI?_hAG@?H@?@C?Co?I@?J@?PI?wmBK@?C??@M?KC?L@?M@?@N?KF?L@?N@?pB?{G?O@?P@?@@?CU?Q@?P@?p@?wI?R@?P@?@??[|?S@?A??A?????Q??S??`L?wC?T@?A??A?????U@?A??A?????K@?C??pS?WC?V@?W@?@U?wL?X@?Y@?PJ?sC?X@?Z@?pr??K?[@?\@?pH?gN?[@?]@?@L?CT?G@?H@?p@?Co?E@?A??A?????X@?Z@?Pf?cJ?X@?^@?`L?sL?_@?`@?@A?SG?_@?`@?`C?gG?_@?a@?P??sJ?L@?M@?@A?cE?b@?M@?P@?GH?b@?c@?`I?CG?d@?e@?pr?kG?d@?f@?`d?OM?b@?g@?PY?KR?Q@?h@?@A?sL?i@?R??PA?Ge?i@?j@?@M?Sf?i@?k@?@??su@l@?A??A?????N??O??pB?wB?[@?m@?@C?SF?X@?Y@?@F?WC?V@?`@?@A??G?n@?`@?pC?CF?o@?p@?@??_X?q@?A??A?????Q??R??`@?WD?r@?s@?P??kd?t@?u@?`B?SE?t@?A??A?????Q??S??@F?kC?Q??v@?@@?SB?Q??S??`N?wC?T@?w@?PF?_D?x@?A??A?????X@?^@?@T?wL?[@?w@?@O?[D?y@?A??A?????P??O??pB????X@?z@?@W?GN?X@?{@?pA?gO?V@?|@?@B?WH?V@?|@?PG?OI?}@?|@?pE?WQ?n@?|@?pC?[D?A??~@?B?????Q??v@?P??SB??A?@A?@@?SL?E@?@A?PD?gn@E@?AA?`A?cr?E@?BA?@E?CN@I@?CA?P??C\BT@?w@?pA?WD?T@?w@?`J?_D?x@?DA?@C?S[?X@?Z@?@o?oJ?_@?a@?`E??K?EA?u??@D????FA?GA?@A????HA?IA?@B?__?JA?IA?@?????T@?w@?PG?_D?x@?w@?p??gE?KA?w@?@B?_D?X@?^@?pM?wL?[@?A??A?????L@?N@?@S?[H?LA?A??A?????U??S??`B?CD?MA?NA?P@?Gm?OA?PA?`??G?@QA?RA?`^?[]?SA?TA?`G?oI?SA?UA?`D?[K?VA?WA?PT?G^?XA?A??A?????X@?{@?`??cO?T@?YA?`N?CJ?ZA?w@?`@?GA?X@?Z@?@A@sK?X@?[A?PD??H?L??O??p@?_B?t??\A?p@????v??GA?P?????]A?A??A?????SA?UA?P??KK?^A?_A?P??{P?^A?_A?@??GQ?`A?A??A?????T@?w@?pI?_D?x@?aA?`??sN?KA?aA?`B?sr?KA?bA?@G?OM?V@?|@?P??WH?}@?A??A?????P??O??@A????[@?cA?`???J?[@?dA?`N?GG?E@?F@?`@?_fAL@?N@?@A?sG?eA?A??A?????L??O??@B?_B?fA?gA?PD?kF?E??hA?PN?sS@iA?jA?`??g??kA?lA?@B??T?mA?A??A?????E??F??`E?GE@E??nA?pc?WA@iA?oA?P??w@?kA?pA?`D?S]?qA?rA?`B?gc@sA?A??A?????X@?Z@?Px?GK?X@?tA?pL?_G?kA?lA?pE?GT?uA?NA?@@?GS?vA?NA?PA?cH?OA?wA?pB?gy?OA?wA?`u?[j?xA?A??A?????fA?gA?pB?gF?fA?yA?`@?GE?G??w@?p@?_H?zA?{A?@B?KY?I??A??A?????W??X??`R@og?|A?A??A?????W??X??Pe@oh?}A?A??A?????~A?J??@@????U???B?pC?OF?V??@B?@@?GJ?W??@B?@B?{e@AB?A??A?????U???B?`D?OF?BB?CB?pB?_B?r??s??Pf?WE?t??u??`E????DB?EB?PD????v??w??`C????FB?GB?@v?WU?FB?HB?`l@[b?IB?A??A?????BB?CB?@I?gB?BB?CB?`s?OE?BB?JB?pH?kF?KB?LB?p??GB?KB?LB?p??sC?c??LB?PA?cE?c??MB?pA?KF?KB?NB?p@?GB?KB?NB?@??SC?KB?A??A?????BB?CB?@y?SE?fA?yA?@??GE?G??A??A?????OB?A??A?????PB?C??PC?O@?B??C??pA?Cs?QB?C??PM?wG?RB?SB?@B?SG?TB?UB?@@?GJ?VB?C??P???Q?WB?XB?@@?gH?YB?A??A?????kA?pA?`@?C]?QA?RA?Pj?w]?QA?ZB?`q?Ka?U???B?PF?SF?BB?[B?@S?[A?BB?\B?@B?KG?r@?]B?@C?gp?KB?^B?`Z?cF?_B?`B?@G??A@_B?`B?Po@?F@aB?bB?@??WF?cB?A??A?????KB?^B?@b?{F?BB?CB?p`?WD?KB?^B?@W?_F?dB?eB?`D?KU?fB?gB?@F?_^Di@?j@?@D?Kf?i@?hB?P`?wj?iB?A??A?????dB?eB?pF?SU?dB?eB?`B?gQ?jB?kB?PD?KJ?lB?kB?P@?GH?lB?kB?p_?WG?_B?eB?@??gH?_B?A??A?????BB?[B?@P?SA?mB?nB?pB?K_?oB?nB?`??kA?oB?nB?pG?{V?oB?A??A?????KB?^B?Ph?CG?pB?A??A?????QA?RA?pe?c]?SA?WA?PC?wL?lB?kB?P??OF?qB?rB?PA?[C?lB?kB?@[?WG?oB?DA?@C?Sn?sB?DA?@A?{B?E@?w@?`@?cU@E@?w@?pP?C`?BB?\B?P??CG?tB?uB?@A?OYAtB?vB?p@?kr@jB?vB?PM?OH?wB?vB?`F?[B?xB?yB?p??{E?xB?yB?PA?_E?oB?zB?P??WH?_B?`B?`FAgF@{B?A??A?????BB?[B?pA?g@?mB?nB?@B?K_?|B?m@?@X?[P?_B?eB?@B?gH?_B?w@?P_?CH?}B?A??A?????wB?vB?pB?OB?~B?TA?@??OC?~B?A??A?????dB?eB?@C?GU?Q@?w@?P@?kE?i@?A??A?????_B?w@?`A?cD??C?w@?pA?[A?@C?A??A?????oB?nB?pF?wV?oB?nB?PP?CV?_B?w@?P@?cD??C?A??A?????qB?rB?@??WC?qB?A??A?????_B?w@?PN?OG?aB?A??A?????BB?CB?PG?WC?tB?AC?P@?Gh?tB?BC?p@?oV?jB?BC?@D?_L?_B?w@?Pa?CH?CC?DC?`B?oL?TB?A??A?????BB?CB?PH?_C?EC?FC?P??_M?GC?HC?@??KF?IC?A??A?????_B?w@?PC?oD?JC?A??A?????lB?kB?@Y?SG?lB?eB?@l@GQ?_B?w@?P??sF?dB?w@?P??GI?KC?w@?P@?_D?jB?vB?pK?OH?LC?MC?`E?sB?jB?MC?`D?gF?NC?OC?@??[X?wB?A??A?????xB?yB?pF?gE?xB?PC?`L?oD?QC?w@?@@?wB?RC?w@?`??GD?SC?w@?`??cB?TC?w@?`??KC?UC?w@?@E?{O?UC?VC?@C?wp?UC?VC?@?????@C?A??B?????BB?CB?@D?cB?_B?`B?@V?OB@_B?WC?@A?[I?KC?XC?@A?gH?YC?A??A?????IB?A??B?????ZC?A??A?????dB?eB?@B?GU?Q@?A??A?????KB?^B?PV?_F?KB?[C?pB?CH?\C?A??A?????tB?uB?P@?OYA]C?A??A?????BB?[B?pN?SA?t??\A?P@????^C?s??pP????v??w??PB????_C?H@?`@?KW?Q@?P@?@@?wI?i@?`C?PA?gw?R@?A??A?????BB?CB?`F?WC?aC?A??A?????BB?[B?pS?[A?bC?h@?@D?K\?bC?h@?p@?W[?bC?cC?p@?ON?bC?cC?PH?sM?I@?CA?`@?cXBI@?CA?p@?_ZBZC?A??B?????wB?vB?@D?SB?~B?dC?P??kN?eC?p@?@??GP?eC?A??A?????sB?DA?@??{B?BB?CB?`??KC?oB?fC?P??kA?oB?fC?@R?{O?mB?nB?PA?K_?oB?fC?P??{N?oB?gC?PS?GK?^C?s??pF????hC?s??pD????_C?iC?p@?k\?_C?jC?pC?w]?JA?kC?pK?{T@JA?lC?@A?WU@W??X??@z@Si?BB?CB?PG?gB?mC?A??A?????BB?CB?PT@CF?tB?nC?PC?_X@jB?nC?PA?gO?oC?nC?PC?KX?pC?qC?@??OE?pC?A??A?????~B?TA?`B?WC?rC?sC?`A?SP?rC?tC?@?????xB?A??A?????BB?CB?@d??E?uC?P@?@@????YB?P@?`A?{KAvC?A??A?????BB?[B?@J??A?EC?wC?`@?WO?GC?xC?@??kF?yC?A??A?????BB?[B?pC?k@?bC?cC?@L?{M?BB?CB?PC?KC?mB?zC?@B?wb?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2591930475;
    let startMs = 1664998438742;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","java.lang.Thread","run","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.lang.Class[]","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.nadutkin.impl.HighLoadHttpServer$$Lambda$70.0x0000000800cca6a0","ok.dht.test.nadutkin.impl.HighLoadHttpServer","lambda$handleRequest$0","one.nio.http.HttpServer","handleRequest","RequestHandler1_put","ok.dht.test.nadutkin.impl.ServiceImpl","put","upsert","byte[]","ok.dht.test.nadutkin.database.impl.MemorySegmentDao","ok.dht.test.nadutkin.impl.UtilsClass$Memory","java.util.concurrent.ConcurrentSkipListMap","doPut","java.lang.invoke.MethodHandleNatives","findMethodHandleType","java.lang.invoke.MethodType","makeImpl","java.lang.invoke.MethodTypeForm","findForm","canonicalize","cpr","ok.dht.test.nadutkin.database.impl.MemorySegmentComparator","compare","jdk.internal.foreign.AbstractMemorySegmentImpl","mismatch","jdk.incubator.foreign.MemoryAccess","<clinit>","jdk.incubator.foreign.MemoryHandles","varHandle","jdk.internal.foreign.Utils","fixUpVarHandle","filterCoordinates","java.lang.invoke.MethodHandleImpl$1","java.lang.invoke.VarHandles","linkCallSite","linkCallSiteImpl","java.lang.invoke.CallSite","makeSite","java.lang.invoke.BootstrapMethodInvoker","invoke","java.lang.invoke.Invokers$Holder","invokeExact_MT","java.lang.invoke.DirectMethodHandle$Holder","invokeStatic","java.lang.invoke.LambdaMetafactory","metafactory","java.lang.invoke.InnerClassLambdaMetafactory","buildCallSite","spinInnerClass","generateInnerClass","java.lang.invoke.InnerClassLambdaMetafactory$ForwardingMethodGenerator","generate","convertArgumentTypes","java.lang.invoke.TypeConvertingMethodAdapter","convertType","cast","descriptorToName","java.lang.String","substring","java.lang.StringLatin1","newString","java.util.Arrays","copyOfRange","one.nio.server.SelectorThread","one.nio.net.JavaSelector","select","iteratorFor","sun.nio.ch.Util$2","iterator","java.util.HashSet","java.util.HashMap$KeySet","java.util.HashMap$KeyIterator","one.nio.http.Response","ok.dht.test.nadutkin.database.BaseEntry","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","one.nio.http.Request","getHeader","trim","parseRequest","one.nio.util.Utf8","read","toAsciiString","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","processEvents","processReadyEvents","add","java.util.HashMap","putVal","newNode","java.util.HashMap$Node","getPath","one.nio.net.JavaSocket","java.nio.ByteBuffer","wrap","java.nio.HeapByteBuffer","jdk.incubator.foreign.MemorySegment","ofArray","jdk.internal.foreign.HeapMemorySegmentImpl$OfByte","fromArray","getKey","<init>","java.lang.StringBuilder","java.lang.String[]","sendResponse","writeResponse","write","one.nio.net.Session$ArrayQueueItem","no_Java_frame","ok.dht.test.nadutkin.impl.UtilsClass","getBytes","encode","encodeUTF8","copyOf","toString","java.lang.invoke.LambdaForm$MH.0x0000000800ccd800","java.lang.invoke.LambdaForm$DMH.0x0000000800cd7800","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","jdk.internal.misc.Unsafe","java.lang.AbstractStringBuilder","one.nio.net.JavaSelector$1","java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock","lock","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquireShared","java.util.concurrent.locks.ReentrantReadWriteLock$Sync","tryAcquireShared","java.lang.ThreadLocal","get","setInitialValue","java.lang.ThreadLocal$ThreadLocalMap","set","java.lang.ThreadLocal$ThreadLocalMap$Entry","toBytes","one.nio.util.ByteArrayBuilder","handleParsedRequest","linkToTargetMethod","ok.dht.test.nadutkin.impl.HighLoadHttpServer$$Lambda$70+0x0000000800cca6a0","java.util.concurrent.locks.ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter","initialValue","java.util.concurrent.locks.ReentrantReadWriteLock$Sync$HoldCounter","append","ensureCapacityInternal","getRequiredParameter","getParameter","one.nio.net.Session[]","java.util.concurrent.AbstractExecutorService","submit","execute","ok.dht.test.nadutkin.impl.BlockingStack","offer","java.util.concurrent.LinkedBlockingDeque","offerFirst","java.util.concurrent.LinkedBlockingDeque$Node","getTask","take","takeFirst","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","startParsingRequestBody","java.util.concurrent.locks.ReentrantLock","java.util.concurrent.locks.ReentrantLock$Sync","acquire","java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode","newTaskFor","java.util.concurrent.Executors","callable","java.util.concurrent.ConcurrentSkipListMap$Node","java.util.concurrent.ConcurrentSkipListMap$Index","ok.dht.test.nadutkin.database.impl.MemorySegmentDao$$Lambda$83.0x0000000800ccb9c8","lambda$flushInBg$1","values","java.lang.Class","ok.dht.test.nadutkin.database.impl.StorageMethods","save","java.lang.invoke.DelegatingMethodHandle$Holder","delegate","java.lang.invoke.StringConcatFactory","makeConcatWithConstants","generateMHInlineCopy","int[]","writeRecord","jdk.internal.foreign.MappedMemorySegmentImpl","asSlice","asSliceNoCheck","dup","java.lang.ClassCastException","ok.dht.test.nadutkin.impl.Constants$1","jdk.internal.ref.CleanerImpl","jdk.internal.ref.PhantomCleanable","clean","jdk.internal.ref.CleanerImpl$PhantomCleanableRef","performCleanup","jdk.internal.foreign.ResourceScopeImpl$ResourceList","jdk.internal.foreign.SharedScope$SharedResourceList","cleanup","java.util.concurrent.ConcurrentSkipListMap$Values","fullTryAcquireShared","load","mapForRead","mapFile","makeMappedSegment","sun.nio.ch.FileChannelImpl","mapInternal","sun.nio.ch.FileDispatcherImpl","duplicateForMapping","java.io.FileDescriptor","java.nio.channels.FileChannel","open","java.util.Collections","addAll","resize","java.util.HashMap$Node[]","sun.nio.fs.UnixFileSystemProvider","newFileChannel","sun.nio.fs.UnixChannelFactory","java.nio.file.Path","resolve","sun.nio.fs.UnixPath","jdk.internal.foreign.MappedMemorySegmentImpl$1","sun.nio.fs.UnixChannelFactory$Flags","toFlags","sun.nio.fs.Util","java.nio.file.Files","size","readAttributes","sun.nio.fs.UnixFileAttributeViews$Basic","sun.nio.fs.UnixException","rethrowAsIOException","getPathForExceptionMessage","sun.nio.ch.FileChannelImpl$DefaultUnmapper","sun.nio.fs.UnixFileSystem","sun.nio.ch.FileChannelImpl$Closer","sun.nio.fs.UnixFileAttributes","sun.nio.ch.NativeThreadSet","long[]","createFile","newByteChannel","java.lang.ref.Cleaner","register","jdk.incubator.foreign.ResourceScope","newConfinedScope","jdk.internal.foreign.ResourceScopeImpl","createConfined","jdk.internal.foreign.ConfinedScope","java.lang.Object","java.nio.channels.spi.AbstractInterruptibleChannel","sun.nio.fs.BsdFileSystemProvider","getFileAttributeView","sun.nio.fs.UnixFileAttributeViews","createBasicView","translateToIOException","java.nio.file.NoSuchFileException","java.nio.file.FileSystemException","java.io.IOException","java.lang.Exception","java.lang.Throwable","fillInStackTrace","beginBlocking","begin","java.nio.channels.spi.AbstractInterruptibleChannel$1","java.lang.Object[]","openOptions","java.nio.file.OpenOption[]","java.nio.file.LinkOption[]","java.lang.invoke.LambdaForm$MH.0x0000000800c02400","java.lang.StringConcatHelper","keySet","java.nio.file.attribute.FileAttribute[]","java.util.ArrayList","grow","asBasicFileAttributes","sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes","getFileName","initOffsets","java.lang.invoke.LambdaForm$MH.0x0000000800c11000","newArrayWithSuffix","newArray","allocateUninitializedArray","allocateUninitializedArray0","ok.dht.test.nadutkin.database.impl.StorageMethods$$Lambda$84+0x0000000800cd7c00","move","sun.nio.fs.UnixCopyFile","sun.nio.fs.UnixCopyFile$Flags","fromMoveOptions","sun.nio.fs.UnixNativeDispatcher","stat","stat0","ok.dht.test.nadutkin.database.impl.StorageMethods$$Lambda$84.0x0000000800cd7c00","java.util.concurrent.ConcurrentSkipListMap$ValueIterator","newSharedScope","createShared","jdk.internal.foreign.SharedScope","resolveSibling",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
