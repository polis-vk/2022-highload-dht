<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BGsKAk@~@bB{DcErEby@???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????CPHfHNKN\NKSVMTMSTUa??xWhNSMJOSRIpCJUJBppWDMSJSRaGRLJaQZiGAahRCKqGMLLLJxJ`xap[KLKKJhxh`Q`ppxMISUJMIx````aDNNGVJ[MMH``KTa@p[ZhSNKPihpVLJip[MNLLMKMKLLMNJahhTLSKMLLMMLSHphpqEKKSNNKJah`fGSVRa]VKSVKMLVKNKUKSTMLNTMLMSNLMULMSLNMMQpbaUKSMULLLSRihixMTSMLTKNxLVSNNTRrhpyaxpb]SVMRiy`jpaa`bihixaqaqxhyhij`qxahiq`y`baaq]TTMSTKUSVNaEUSSVSS^MTUNVNUUMUVMST^MVK^MVMLSSUVUL^MSSUUVNTUULUTSS[USTUTVNSVVNK[K`xqivJkHcLLVTU]L^U]N\N]LUUTUUUTT\VSVVTS^M]N^L[UVTS[S\VVNUVUUT^MT\TS[VSUUUUM^NUM[pibiyibiqjibyyyyykJkKM]T^US]UVVUU]UVVTSVTTT^MVUK^U]T\UTS]S^US\VVUT\VTT]US^US^TxChqcKS[U\]S]S]U^M]L\`bqybqbyyyjibara{LU[^VVS^VSVT[^S\`qyyqqybbbbajxcLV[^VUVT[^S]xLhS`cN^`hcL]U]U\V]VTV[^^^UV]V[U]VT[U`qjdKT\^S`irjazyyzxrcL[[^TV]S]S[\[[]UhqbjxsKS]pN`kKM`pzkL`zazybrqjarbjjirdL[^T\]UVU]T\[[[\hbbbjirqjybyyrbjb{L]V]S[^T]T\^U[V[hjzqj}GlK`hkNK`kMM`kN[`xsNL]]S`byjyjbyeL[T^\S`ybzqzyyrimNTT`yyjqkMVU[^T\SxazbiryrjijryraryfM\pM`^`sLM`bisML\]hsNL]]S`qbrizbqjyrtK`yqrbbbycLT\^S`blL]S\\][^[[ShxrjikLhjybjrijbzqjbbrycVV`^`kJ{KL`sKL`azzxfMS\`hkL\U[T`bacMT[[pryjbjrbazjbbisNUpjbjjqbrjqryrrakKUpzazqjjbyjrqjqnN`jlI{KhV`xcK``dK`psNK`fNK`zirycM^L`bybbzuMT\]\^K`bjjbjrqzb}K[T]]\VV[]]U[^T]\prqricM^N]S`|H{HtNhq{JkN^M``{MUT^V`xzjtL`yyjqzqzbicLV\]U`dL]]S`xrbjrjyjbry}MT[\^]U[[^^TU`iryeK`qrqyyjbuG{GlL``sK`kL]T`hsM\KhhcN^N`ir}NN`yijqkL[S`asNTV^`sMVT\]^US\^^VU[]^hqjrjybrrbbqrrjqb}M[^S`bqbuIsKhU`qbkK`{NUU`hzzicMV]^M\\`|NL^]U^M[\][V][\]hybbrijrjjqqcMT^T[pjjbbbqjrqbbrbbqj}MT]]U^pM``sL`]hM`kM`kKU\\T`xrjikLV]]LhsL^^K`jyzazirbicK\hcK]\T\^U^U[^T\[^SpjbjbbyjjbjbrqzqjeNV[[^pM`{KL`^`jakLNxjikMM`rpsMK`jqkML`b]af@`f@fh@`h@|h@kd@|g@dh@b]ck@xg@pg@yh@{h@df@|k@hk@`i@wl@qh@dk@}k@hm@kf@im@ug@sh@gm@ph@{l@gk@tc@bj@ke@gh@mm@ju@yt@bx@{m@~v@y^tn@}t@bs@st@zt@ev@cv@by@s]ar@vt@_w@tq@np@du@tt@ax@ex@sw@nx@vs@cx@hy@h^qi@ri@ts@zw@az@cz@a`@rd@mk@vv@ly@~y@}^b`@h`@ga@ob@~m@no@tz@q_@u_@p`@y`@sc@yg@ai@{i@sm@so@sp@or@}y@k^k_@oa@ab@fc@kc@ie@|e@lg@lh@fi@gi@cj@yj@mn@|n@kp@nr@wr@}s@bv@my@}z@g]h]n]t]i^z^l_@v_@~_@f`@q`@v`@z`@~`@ta@{a@|a@gb@jb@pb@xb@cc@dc@{c@bd@cd@hd@pd@ud@vd@ae@le@pe@{e@}e@vk@ql@rl@tl@jm@en@hn@un@wn@go@to@yo@lp@{p@qq@br@er@tr@yr@ds@is@ms@au@bu@gv@ow@vw@~x@c]e]j]l]m]o]p]q]r]x]a^c^d^e^g^m^p^q^x^|^~^b_@c_@e_@g_@h_@i_@j_@n_@o_@p_@r_@t_@x_@y_@z_@{_@|_@}_@_`@``@d`@e`@g`@j`@k`@m`@n`@o`@s`@t`@u`@x`@{`@}`@_a@`a@aa@ca@da@fa@ia@ka@la@na@qa@ra@ua@va@wa@ya@za@}a@_b@`b@bb@cb@db@eb@hb@lb@mb@nb@rb@sb@tb@ub@vb@zb@{b@|b@~b@`c@bc@ec@hc@ic@jc@lc@nc@oc@pc@qc@uc@wc@xc@yc@zc@|c@}c@_d@`d@ed@fd@gd@id@ld@nd@sd@td@xd@yd@{d@}d@~d@_e@`e@be@de@ee@fe@he@je@me@oe@re@se@ue@ve@we@xe@ye@_f@bf@cf@ef@gf@if@lf@nf@of@qf@rf@tf@vf@xf@yf@|f@~f@_g@`g@ag@bg@dg@fg@jg@kg@ng@og@qg@sg@tg@vg@wg@zg@{g@}g@_h@bh@hh@ih@jh@kh@nh@oh@rh@th@uh@wh@xh@zh@}h@_i@ci@di@ii@ji@ki@li@mi@ni@oi@pi@ti@ui@vi@wi@xi@yi@zi@|i@~i@_j@aj@dj@rj@sj@tj@uj@wj@zj@{j@|j@~j@ak@bk@ek@ik@jk@kk@pk@qk@sk@tk@uk@wk@xk@zk@{k@~k@_l@`l@hl@jl@kl@ll@ml@ol@pl@vl@xl@yl@zl@|l@}l@~l@am@bm@dm@em@fm@lm@nm@pm@qm@rm@tm@um@wm@xm@|m@_n@`n@an@bn@cn@dn@gn@in@jn@kn@ln@on@pn@qn@rn@xn@yn@zn@{n@}n@_o@`o@bo@co@eo@fo@ho@io@jo@ko@mo@po@qo@ro@vo@wo@xo@zo@{o@}o@~o@_p@bp@cp@dp@ep@fp@gp@hp@ip@jp@mp@op@qp@vp@wp@xp@yp@zp@}p@~p@`q@aq@fq@gq@hq@iq@jq@mq@nq@oq@rq@sq@uq@wq@yq@{q@|q@~q@_r@`r@cr@gr@hr@ir@jr@kr@lr@mr@qr@rr@sr@vr@{r@|r@}r@~r@`s@as@cs@fs@gs@hs@ks@ls@os@ps@rs@ss@ws@xs@ys@zs@{s@|s@_t@`t@at@bt@dt@et@ft@gt@ht@jt@lt@mt@nt@pt@ut@wt@{t@~t@`u@eu@fu@hu@ku@lu@nu@pu@qu@ru@tu@uu@vu@zu@{u@|u@}u@~u@_v@av@dv@fv@iv@jv@lv@mv@nv@pv@qv@rv@sv@tv@uv@wv@yv@{v@|v@}v@`w@bw@cw@dw@fw@gw@kw@lw@nw@pw@qw@tw@ww@yw@}w@dx@fx@gx@ix@mx@ox@px@rx@tx@ux@vx@wx@|x@_y@cy@ey@gy@iy@ky@ty@vy@yy@zy@_z@bz@mz@zz@d]f]i]k]u]v]w]y]z]{]|]}]~]_^`^b^f^j^l^n^o^r^s^t^u^v^w^{^__@`_@a_@d_@f_@m_@s_@w_@c`@i`@l`@r`@w`@|`@ba@ea@ha@ja@ma@pa@sa@xa@~a@fb@ib@kb@qb@wb@yb@}b@_c@ac@gc@mc@rc@vc@~c@ad@dd@jd@md@od@qd@wd@zd@|d@ce@ge@ne@qe@te@ze@~e@ff@hf@jf@mf@pf@sf@uf@wf@zf@{f@}f@cg@eg@gg@hg@ig@mg@rg@~g@ah@ch@eh@mh@vh@~h@bi@ei@hi@si@}i@`j@ej@fj@gj@hj@ij@jj@kj@lj@mj@nj@oj@pj@qj@vj@xj@}j@_k@`k@fk@lk@nk@ok@rk@yk@al@bl@cl@dl@el@fl@gl@il@nl@sl@ul@_m@`m@cm@km@om@vm@ym@zm@}m@fn@nn@sn@vn@~n@ao@do@lo@oo@uo@|o@`p@ap@pp@rp@tp@up@|p@_q@bq@cq@dq@eq@kq@lq@pq@vq@xq@zq@}q@dr@fr@pr@ur@xr@zr@_s@es@js@ns@qs@us@~s@ct@it@kt@ot@qt@rt@xt@|t@_u@cu@gu@iu@mu@ou@su@wu@xu@yu@`v@hv@kv@ov@xv@zv@aw@ew@hw@iw@jw@mw@rw@uw@xw@{w@|w@~w@_x@`x@hx@jx@kx@lx@qx@sx@xx@yx@zx@{x@}x@`y@ay@dy@fy@jy@ny@oy@py@qy@ry@sy@uy@wy@xy@{y@|y@`z@dz@ez@fz@gz@hz@iz@jz@kz@lz@nz@oz@pz@qz@rz@sz@uz@vz@wz@xz@yz@{z@|z@~z@_{@`{@a{@b{@c{@d{@syNGyBGq@q@G`AGGh@GGGq@GGh@GGG`AgAq@vAwAGgA`Ah@GgAGGgCq@wAgAGq@mAGuAh@qAh@dFG`Aq@hCmAGh@GGGpEvAGG`AGq@GGhAq@^hCDGqAG^GGvAG`AuAh@cByAvAG`AGiBGGGgBDGGGGGqAhAh@?h@GGpCqAhAGGGh@GyAGh@qAGxIGGuA?h@Gh@@uAGiBG@h@h@GDh@iBGzAGq@IDBGFF`@GFFFGFFFAEGFFFEAEAVV?GVVVh@cBAwCq@GGBmAzAzAGzAlJAGDAEcBq@a@GD?a@JqCBIXGL^BGF@GGGGGaAG|A[GLGR_@LBpHE@a@DME@A?FFA@XMLI^VyAXBE@C?D?@@CMGh@`@LII[B?E@@E@_@D?RBRaAsCGoBC|A@IYGBLG?q@gBXBGFAGGE?F?SIGGEYI[M`@E?KB@C`@CJVRIY@C?O[ED?KOIaAGG@a@q@XPABGFyAOLE?KDVBVB]a@JH@LBHKpC]IYVKGXFGHNa@OFFFGFFFFFVVFFoBFAAT@DVVSFyBY_@VEEAV`@DGJADhL|AGa@_@}C]XIG_@AFAGh@ADSPSfIxJBPAET[BBB?SOYIR?G?JJB?SHVA@IVADoBaA|AGaA`@EH@B@QBHIY\FT@\PHEL@]BADN[TBsCAB]?FCAGYB@FAHRT?@BI^SJ^XBORBBAAD@XE@DB?JEIE@A@@?`@BhB}CCmK\_@BNB\GH?FTMKN?@D?_@@?SY^GH?]IOZ?OZIFCXGA@??O@CLKJAVCGV?Y?KZXSJEBWAT@^VRP?J]TM^AX?KIP?SAV`@JBRB[CE@FDB\\`@WAHWUFMAIOMEa@TyH?LGODE@@O@CYJGFEEFMFFFFFZFFAFAVNETJAAKBYVVI_@[AOIV_@xAOOE@CNUJAEWb@]OJ@T^]GRNMVYZHIBRQVC?JQK@VBIKYAD?BE@B@L?\B\MACb@VQA@A@RLTI\IN@WAB?MDCLKB@?COEMRFBCFEI?_@CQALKYM[JBKA\BAADAJEABR[F^BLNA`@CQFFRPTE]\\IPJ`@@CI]KHELH]_@\DxAACCUDLI\@TIBXFUIQWIWKZRANFM[RTOT?IKBRIMICE@RPC@H?W]U\FPJ\BULB@?Y[DJPAMUO[@BYJA?QMPT`@ESJA@?VX?K^AAB]BMa@ZOCPZBRDSNFA]?[SJDH@LOVGGXLB?UCIkLM?DDR?I\CUDB?SJE^`@D?D]D`@MrABQCUOCERZ@BCh@h@BMJIKN@D[KPIA_@FFFFFEXFFVFVFVAJFFE_@VAAVYE@NOIIRLRZBHTD@F@@M^QKAQAHEL[IIBR?BOT?KKUQ_@JADZ@BH[BWN]@BP@QR[LI[DCDELCJG]ABARM^Ga@JWAZ`@D@@???BA?XBV@U]CJBMWUCWMEa@@YB[HA^MM`@DB?WST@V?K^O[XPC?A@UIO?YIBI^?T@JDLWS@\CKNZ?JDD@IT\IXC\D\Za@^NCBLCZBF?JHA@HVV_@LBC_@FAXFB?@CU@UIJ]B@`@DYi@VLATCF@H@`@\R\MQDXa@T?AZ`@FJPSOBBVOHNDQNYV[DA@GGA?RAB]BYJO^SPUINBHDMCD?@MROQ@JA^]@K`@L@C_@HOA^XDWT`@?SZ^@\ADDH`@ECJZHY?@VORFYWCW[@HRHADLa@S?RhBIMM@HQWAJO?MLM[?SOY[^a@P@T@X@@AV@\?^EB\IF^?qLWAXTYUDFC`@K[NUVFRQ@UHAAX`@M\BUB@ELBM@AJECDA[[YZ?R[EEZ}AFFFEIFFFFFFZFJEATAAV^V^b@ECXdMb@\IYMROANETKDHE@@C?DP^BBILO\Y@@CWNEAFNSRA@BA^[ILMVSDBPWDJCDOLW?BRJU^JW`@XB?O\RAQF[JOUAC@CJUEN`@?JPRLRD[Vf@?KCAI?RBO?_@FTBLSUDLPGNBIYHHAMBXJV@DVFEHF?AOINEOLK@XH]_@NTS^EIWHR@PULBO]ZWABK\Va@?@AIB@??H^[@RD?M_@a@?JH\IOWDN?XL_@B_@SRJPAQAHLVDPUAEOLDRLBa@[ATJS`@I^G?NHBO]CMS?B?K@IMAC?B\XJFKSIM`@H?CRH]?JY_@UKMIT@[]@AN[BLF_@AFK?HDRZ?BMA@DAMI@IAD@EISS@MROICHIFAD\DWOwA^VJB\SFQNa@SER[S?Z\BKMEZlBG?DU?H@PVBa@RXPBYMb@@?@@@KNMAZTI^ABKV?R?@?JLSXBHD??@]LURIQ@NQ@I_@XMPU?S]E@@X_@?LIBLEY?MC?@CTHBIBSNE?DXTORIAJEYJB^X[CBCZPATFPG_@?DIO\A[]ARBQDHPBC@??HOINIYXYUEBA?IYQHHNUAADOMVBZAN@?DO[WWATYZCBCVZVFFFrAa@FFFFFEZFAFFAAAAVATYESf@L[YLBLWL?DA@CCFH@a@@SZZX^Bb@BNE?DT?CE@?T?ZZRZEQ\]`@[GGEhA@JDCJNTWZXYR?BIBWAFJYHHF??MRA]B]BDD??CSA\@]OVEA@`@JIY???ZUDBPAIwCN]LR?TWWPC@_@ADIOAD?QER]ML?KE]MHTBST?EEWUM?^`@BN@ILD[QD?RD@@I?JI]FJM_@QC]HD?^Kq@]a@BCVOAFAXIA?FATI?D\DF_@LCX^HZ@?KN?R@O@XJHD?I?ONO@?CW?]I]OB]Ti@I?H?HT?E@_@VSME]BKEHEDA@_@Y?BKPCLEBDB?XY@?AZXFK@?B?`@T?ALQFUE]?i@X\E@N\AO?BNGGmA?P?B@@HO[SYVLAi@QLBCJB?JCFMHLCH@}ARYA@XYALTF@`@IEK@I^AD?U`@TTFBL[@CHH@JEBLVCUJRBOKA]CQMDBHUIBSHA?UXT`@R@?V?CIOLA@U?QPZEHBAD?RZU_@J`@[B@MO@ECEHEX]?@DGlBJBLTR@AIBA@@CCI]E[E@S?BP?RXA?JZFBA`@CWA[DRCSP_@HDHKOY^N?A@MZ?B?H@?JEI@[?PODCLLPVWIJA@CJAIB?]T@KHDOi@E@B[\TWXHCX@K`@VJa@]@NM^@X@@@Z@?JYTEI^LDCUBPWeDdONSNJRISPYB\^E@ALJF@HE[ADTMRNL\ZFGu@F]FFFAFFVVFAFTAFb@FAAAA?T?MYYBRCR@CH@J?AS?F`@AXDBBO_@@@OJPCS@U@YE@JM`@QVR]XCLE@QDACDJC@L@?\BMO\DP_@UXa@C@HHNUET]B]VVMN@RT@SJS?UK@[`@L^BUVIAv@PGGB?K@TCPSYFIQA@MYLMP@CED?^O@LNCEH@QBFIBC@@CHD^_@OE?BUDM\NQ_@?T?K?BRR^OYA?FQFV@UW@DC@L?JIY]`@IBJCJAA?@Wa@FH?Vf@XNYR]BQWAETANNH@\PBLEBRV?BQA@EQQa@DRRAABV]EBTf@EUCG~AG@M?HC\?YWSJBXD]ASSK?JBNN_@_@WXNB[FQO@DK@JOECB@GIIBH@?MAD?@K?CCIO@[BP]OWIY?JKH@C^ER_@SVIYCP^CVNE_@ACT?XB?IKPIVCa@BC@I?JHDR[YQ]J\II?FJAJPHPT^K@B@YIPO]VQ@@SQK?M`@B?IJMJgCGhDXLODEKTAAERAVL@I\Y?DJO_@VAFC@HVIPa@@RR]D@HCOHDAAWBRF^TIb@COLA@FAHADBSO@RSAILM`@VQNAFA@EOXDMYN@]VT@AEb@EEPI@^UAMT[IAYN?A@F_@FQ_@PMPCYRXPE?VSDS^X?P?`@\OEEC^WPD@LHDb@KPEGGlBDYKPI[]BVDBAK@@?E@IYCE[AC?OZi@Y@HNFEC?UBBZE@I]?JBa@?EFAQEZLBAOZLFMAMLFN@JPDCA?]RXr@TI[TAB[A@@DE`@ER[BCQOBa@C_@PJALHKAKXI@CFRJR@D?@_@[^PABVDCEM`@I@BCT?AY?FFEFEFFLFFVVFVFFV^VIv@wAaAGSYIi@LMB_@TK@KNPET?H?VWW?RB\BRX@?JW@NHES?MJBMJLX_@Y@@TKCDJ@DYXKYTVVAYFRBCTE?CLAFIM^KPK\YIK?@WHOVFDTH@BAKN`@OOTQABH_@KNPKHB?ZCJBH\BBCJ]?HHQE@?_@A`@EHI`@IA@?BK?C?K?ZQB]J]b@YEFGGq@`PDBA@JW?MTQIC]OXFLCBE?@?C?JABb@XQi@@a@ZMLJ?WJP@S[HBOZBAMCT`@}ANBJIA?EH]`@RHASNOOSACCNH]JADTCa@BV_@@ITYXFWM?SCUE]\ICCD[MD@ZRJHRNETA@TBML_@@I?f@E@_@KWRVHCSHAJ]ODLBBUUWOCXWCNAAAXOJJLGqCh@LhAG??FE\TON@KRBP]@ZOSUYOPDEN@`@?JAMT[QFFMVJMABPEBMKA\Ca@`@C`@UH@OP?Y@@[D@?C]SKIVTA^@?BJAa@ZAKR_@Fa@DOEO@CVHKBLJWYDAJR[JQWZS^?SAP\[CQJEJBPLRB@a@T?ZTAT`@K@YLMIOUC?SRAQ[BEH]EPFa@LLO[k@TgBk@h@CHEOHFB@XBVEW@LBa@ATFTA]P@DI@@OMBPLP@OB?]PCWCZ@Q]@CBTa@TIABUDIAS?Zf@MB?A@OJR_@HDDS_@ANXIPTE@Q]rAERIUUHBT?r@COHBFDM@@Q[Q^@@TQX^Ja@AAPOMLCQM`@ZCrANYFPSDB]_@J`@NA]K`@SUi@BIUU@JECBIGG~Ah@gAV?@i@P?RBXE@HQA?NTOHXBCJBHZA\DIKW?KWCNKb@_@T`@]JAKOEI_@?SWH@^OPZUQIT@OPK\NSI?FKLAf@QN@KMHU]?BBUFFY?BHT?@BE?C[BJRCIPB@CLFU@PREV@CVKb@`@F@@LJL@FZu@FVu@FFFFFFFFVUFAAFAVO@O_@YOB[^K?W?PNDC?LHMQi@Hv@gDV{MwOcP[CGI[CQC^@KT@S@@[PTOE\ZLUINFKBXH?@CCWW@^B`@IVI?A?^TTWDECEDCNIVYOYADBDa@H?@QUDUMV_@TS^I_@\D_@KD?H?DJFUSOWB_@M[RC[QTJWEQDCNHBHME[BMZLAJD?HDJCBXE@AXH`@PZOPNFMXFM@a@HC]?OHEBJ??f@AHB@LFDCQBH^SELHDMi@k@sO~PYh@h@GMUJ@FRRUUHKJM?@W?LRABLK?V@XEHM@CJ?DCHC\[ZT@YLBKYRKE?HANPKNIL[DTAIAXUOXAP?@@?E^IXADBCf@CXYKPPS?CKa@YIPJa@O@SBI\?BUFSC?Ba@YZWAFJBQMBFPM\Q@OUEa@?]FD@?OHZ]ADER]RWABHT?K?KH`@ZBLHJ[DIECBHC\OCGDJTGGsBGG]NVUVE@HS]\@IAJ?ELMDRMTSDHDJQBB]IDWB@AIBMXOKa@QKN?DSZf@MFTAK?Y]^BAEH?D?@H^Y?E?CZNEB[]ULNJSDTNTBBD@SEICRI[BS@??Jf@`@E@Y]WOCU?TYB?SNHQNIBCDVBA?SKNJRMCIJC?JPO@`@\@WUDMQCPS^@BRE?@SDMLB??GG[Nk@GGSG@\WJP`@LDFC@YXF[_@SN?UUIH[PBUFPFBA[?\EHIH@X@@[RSPP[RZ^BDDA?TMZE@YJK?AICMRJCUA_@XFHHRF@QJP]ZACLFE`@E`@VAKB?WQ[QMC?K[DA?M?I?LNAE@?MYASMRQ@?C@?L\?HSE\A@ZNBOCK??UM\I@MUL?SW_@RVOPH???[CJGx@d@LGk@gDN[_@NE@QVBDIU?_@]DAWCOATV@RHOD?H_@Cr@A@CL\WBAASBWR][E@@DCLTBUC@@AIOBAF[C_@D?H\HD^MNDCMJ`@WVD?MUBA?P@NB\NEDB@X@JX_@ATFFVFFFFVFFOVVFFY\FEVNFODNRMM\XCO\OETDNAQKADUHJA[\VZ?Ri@IKAAQNK?QN@O^@CZRINRJ@DAH?NUS@CBv@rDGGw@m@q@x@\J_@KLXNa@i@BWQ@WA@S]@C@`@_@\JI@\U@@??AFM??SWPRM]E@YXDZWH@DIW?SKWFTFVYMB@?LBAH?PLC@FPPSI?RYXr@PZ?N?J`@VE@?HEUD]V^RVKCM??AZ@}AFE?KMJAZBMUIJEAFC@VA@WDLr@UQ`@MJIVQ?@B@@@?WAJYKR^AN^R?WSHUI@@JOK^CJRHIA]Cj@~Ah@Ad@Gl@ElO@IT@@CDZ@RHAM\N_@]EHa@@NIU@ANFIVBLA?LV_@SHCTB\UKE?EA^MN]AB@CLa@CAVDK@WPAIIPVPXISQP@CIS?NEWKYDYBO]U[BFAEBND?CHDFULWI[YOEHEUFY@??H?BJU^WERR]E^CC@^WCJEPX@F?FH`@B^]_@HEELAMDH?R_@XHA@U[ODDBNSSUA\Da@Oh@FLSGUeDP~Aq@Yd@CGGs@ZYQ?KSCB[WDHZA?PFYW^BKPAB@@[IHMH@WA?D@AV]ENDVB?ASLZ@?UC@KB?XBIJHa@^?A^XTWHUY?O?@IA?EAKWO_@S_@@TOEDFZRFW]JU@YU?VB?[PNY?AZCXWPTFBDBACCJOZMb@C?WDJXAQMLWHHPB^?r@HADHDOXN@F]IQJLRCYU@@NXU@D@DGhAx@GBk@d@_RUvBOGYAI@]@@BADKWCWBCREURXT@ZIE?AHN@KABB[OCUXOQZODQJgADWAW?B?@V@@XOZLAVF??KAD]BAUDL@UEZX?M\BL?AD?@[ABECUFB?IKA]ME@WQP?J@RBDK`@Q?_@FYABRD@CCFN@RXYABKOS?ZAL`@RIH?FAQA^?J[YPTHOPFr@MNf@@DAEQN_@DXPEAT_@KVJOBw@h@x@n@k@Gd@XGGSHKICSJD?O[FEAIb@@D`@E@QNWTZULYDB@CAELAVAA?@?AB[a@^b@BOFGWJf@OBQX@?H@V@DRYAZ_@TADE@XVE@A@VFFF^FFEVXFFZFFFFEVOAOD?LVYEBTRHD\ECDJD@Y?KUUORMXMCKE?HTBFJAH@DCLLXPT[LHLSPADDTIE@ZEAAXOOEXa@?WAFAAY@?a@V?V_@JAJRSBLIv@P@JTE?@KEl@oNGGl@t@GGzQ\ACB?I_@]@MD?a@NPFE@?YYEBR?a@?XRICQNUPTPAAJ\_@IADJO@hBY?W???KP@?BZ^VBKCILMQ?N@C?U?@WNRTYXDAIXBX]KDDC??F?V@?RLFHPf@YBWBSNJSE?NAa@ILMCPTMXSRQCAJSUP@LMPVE]BY?AV@?@@K?DDDRRENVL_@[OTTKTL@JHHO]AWHMDIi@MPGc@uDc@PGn@g@Gg@DGJCOHFAYPPK\QT@BM_@HJ@CQO??SKVUQBa@\@BVE@@XJTWA\JFJ?KO[OMRA?AKB@SJHERUCa@FOBRMPATKEJI?XCC@??WHIIR^KSHE^LJPQLQHPKEYV?ZYB]Q@@@XBDKNF@DC@\[BCBDFJFB]LA@DSSQF]VXIOP@CFTIL[?CCQJ?IBNCHBUHDL?KHXIOK?EZAIJAc@g@KrDLG}@g@h@g@Gm@EUKDKO?\VZYEIUCa@[@CBEPCJKVWZYNW_@NJa@TIK`@AAHS^AIE\ICT@]WUYIQF?@?QK?IBIK?IA@L?BCSLK@FRFCTROIKJM[AYU?TBDSJDICE[AFBSYr@MQBD?D?INDIFUHR?]KDOJATVFKNPM?M?OPWIDPKEZCTLS@JBPJR@C^?@f@]?P@DLL@?[JIHAPa@Z@E^UH]NGg@Go@Go@y@g@dAm@D\EIPXWUPA@\D^Q??SBJI@K_@D?LECBFXT?LI?N@_@A?BUPB@C?T_@LKXWJTQMFEBHVCFC?M?b@PAAII@KCR?VJSDCHH_@BWAFHI\CWE@`@_@DASKEY`@@?IAWQI?BNY?@DCFBWCV?DBDa@DLYZE`@OJWC@[IP@C??]?Ea@i@?JBCMZ`@S@Hi@BU_@DAHH\BQYUWDY@ERA]HE`@?RGc@Gc@uDJc@j@c@{@G@YAS^JHX_@@QF@[DOFUR?D?XACf@A@IC?OHWAAXNMUAEM^FC@Q@M@KZT??^TVZFFFFFFFLu@EFVUVAFFVABD[RC@WFBNARLC?MDKIEEPTDLVKP\I?_@DB@?F?PCABNC`@^?[MA\?UP`@A@UNAVZ?JO@L_@UIYEDJDSANDKE`@WRQN^Ba@Z^NDWLHQHKLC?AD^@a@IZX?EBCKUPHNOANSBETv@X@Yd@c@e@n@d@jAe@~@d@g@[gOI?FSD?TLMJA@NBC@IDDM]WN??PJIDBNa@@OCSa@O]B_@Z]FAAEIQDP?BAAS@J`@L\[HSPATH`@PABSK?@CD\VMIMWQHPF\FU`@@H?SKK?^MZVa@T?W\FUf@@APFD?Y\SB\OLJB?C?@B]KQTEFQ@\a@^M[UF_@SSXAZTPJ?HUUHYIPXLUCUTYXO??SK@RDZBXFEAIKFWEBJECU?MJAi@BLm@Gd@l@j@n@|C\jAQe@k@GHYHHWLOHADWA@FXDMZ[BC[WNFVAPD]C?KQVFEMXC`@NAXPQAN\SHIf@JFWVFB[FDOEHH?JYHAOM`@SH@BLI?DR@T??BHQ@QZFQMT@[B\W`@?D?VFKWEXOKDAITZD[OPJDCa@O@AUBUHJABI@?F^LKR?QMDN\AD@?BSCIAMK_@ZT?S\E@?F\EPD^W_@ALVPF@@LSCH?KBI??DsBl@e@n@d@Pg@ZGn@vQc@R^Q?JS@@KBNTX?^Fa@CKCVBR@DAXWUPP?KDOa@O?H`@AV_@?JPTr@FDEWR@ZOASJAQ?LRH@f@CK?H@CBAXZ@U?BJQZ@C?BYTHIFQBDRFAL?HQMW?RDBEWIAPP[WQI@UD\CWKNBCIZ`@@HZQ?WESMJEH?CF\\@LBBAWX@@C\FCUCJEPF\L@LX?F`@PYANEa@@BTJ@WIBB\AX@\PsB]e@k@|Cg@?e@Jk@Ad@g@nPG`@?KDNE?NRI@MBXQFFLBP@Ea@ANND\JA_@@B]ERRQNE@?AAH\E@UZMCB?JO\?H@UES[@UCBU@_@]J]TO?UIDQCDSb@@??TYBYIUEA^^@@@@?DBANQ?WI[]?[@BAa@@?DP?BD@JARa@R^T@^SBH?QDOKR@ADAPRK^?QZSRa@CUXTJHYTDOSEB_@AQ@A?IBRCNCELHOEUADMWGUPO\z@o@j@t@d@Hg@m@Bj@y@jAl@hDGCCLa@N?XQ@@Nb@X??B^BQ?B?TQEFFFFFFFZEVTFVFAVCVV]`@IINJNVNFCFAF@EWJVICJ[LVF@@US]ASAAMTELJECR^LLD?D@@?JFNAf@_@HW]?SBMO[SHAECUAWHCIXFSQHBRMLA@DPJAFKOJb@?@YQFXAOMBT@?H@CD?IQYDTPL?B?XJM`@N@EKLSC`@?UPMf@[V?@]DKWKAO?SNPY^Jv@z@w@G?dAc@e@Gd@o@m@n@]ZZ@WQWRJ@?EJEr@NNMa@SNZNBQBKB?EKCFEAb@^@AR?F\?\JSPXK@A@u@OW@EMXOKRNXDEHHB?KJA_@K^DS]OANLD@?@HDBSCOUCSYH_@ZCB?IZ?TUJ?E^VASNBT[?S]YVMY@@T@DJ`@KHNMABLRQPZM?@WCPISNSTIPM?MMKBE`@MECCA@NS@_@@B@HEV_@?IIFDTNC?IRCZK?HNFb@Gc@g@j@k@c@G{@dAjAe@p@GO?B^BP?KE@I]EBWH@??TBMHXA?E?JSb@ZVCL?Q??BVTFi@^QA?AU\EV]UCa@T@BC]AIJTWSS?XBU`@LADERYUJT^X^?CWF@MW?TZAD[PBNDL?H?CEYMYHCOABVWV??WBRFCH?W@LJRNHY?LSITBDAB@AHFPAb@SRC@?L?IOFHNE_@JE@HKO`@DCEI?SOYPW?f@\@DUEBIU^ASX?F@O?d@o@G}@G_Ae@}@c@g@s@{@BWCHZPQ[CD_@MTU`@IJQZS??@LDUQ]PDE\@ZMKb@KBU?@??AERT?EH[\HZ?K\\@P`@?KNKL@PH@AA^B?M@B@@ZCAQKV@EH??LOC_@YVD`@@SRCC]?JJDCUH^YPH]TXC@OPAW[@?S_@Y@A?B@BX?B?KDCJVCAF^\MQHJB[@B??ELZRSDSEBIKKAJYO^[HPIF@?AV?QRRXJWA[DBAISlS@c@e@t@z@l@?j@{@dAjAe@p@d@MK@?BIC@PP`@T[BDV@U@_@DCNXBFDTF@J\X?MWP?B]Y_@@?]C@@?S@MFO[K@O??]X?ZUDC@D@AH]M?D`@KF_@LBBDKC@@J?@B]`@MWH?I?VBb@DJKFPDE?KIRDFYJOQF]LHKKEBCHSFBa@T[ABA@[LB?AFAP[UJKN?MXSS\UHBMK?AEMBHHAKPYBAA@@Q\XQUN?MKOAUSXTYHCD?FFFFFFFEEFZFFc@VVVVVYGl@g@g@s@w@m@o@m@e@w@m@GR]BBQAEDDA?PFJ?A]DLE^VIMZETa@WNCAAEAI@QVDEMO_@AUA@ETXATSOMT@CJNZYBJ`@@`@DDJWCDX_@?F`@CS?V_@J]BWHDHKPHSIBACJPMOIIOBDN?PHJ??\BBEATF@[[XYQADKQWA\A@Ba@E?EFROBLr@F@AW[@DRB?EHTH@b@CXf@V@N?EM?@ID@SDQWr@IYEI[Li@?SS?@Vi@_AAH|@e@e@kAj@~@j@@~@wRj@~@GJTDYJH^V]B^@DCDBDECE?@OZWDM^XAW@[`@ADK?A?PBE\LHEIIEK[?FIC@K?WNYO[ILD?BHANa@^HNEF_@@QCMOA?O]\V?H?QDUKBBWFSX^_@RAD\?UDH?JCW^BT@HM@XPDLKN@?LAJJ^VDTUZHERM@JH@KYTCICUi@ZP?DODON_@UUNSFYQa@r@K_@QETB?KCRAL@APIU?^{@BX}@CGd@d@d@c@Gc@l@o@c@g@s@UK@Ea@[HYX@CCODPER@MK@I@?FP\BQ\JFE@??RXB^[UAC^F?IHOAD@EJ@]?OB\PNK?PVHMU@HPKHP]B[LDH^SE_@JIPQa@PT\@NUV@IHI@i@YPD\ANA@M@HFL`@?IAf@H^KMS@AIZr@??A?@XM@CDXTV@OCS@BQQ??NM_@X?HTZM\KIC?X?KDAZDEC]EDa@B^BXBU?EK@J\H@h@K[XBAg@s@Em@m@s@Ce@kAe@kAGe@BkAeA]LLH?EFOA?J@@FA_@HEFBM`@BBDTJ@BWFJFRE@H@[@BVZ]@K^PATRSHCW?NHIDO`@XVW@M?U[?HSU@?KPYXE?[YM@Aa@?KEBCFADBDHI?@`@VVVH@QHA`@D?TY?Ki@WW?_@BYBQDW@C?LAHCCHYWPZAYX_@BQ?AQMS@?Sa@XC_@@OCKL_@ZKEHMYAAEUCCNY?MJKLMLO@CRQ@QC?T]BCe@HkAp@I@p@{@a@eAn@eAn@k@~@Gt@ZIb@ENDBLQK?NHHOHYA?PLBb@`@ACYQND?DEJVPUIFCB]_@HK?`@Z?HFUPO?CL@PL\I^?HPMMNWWW@]_@B@TH`@AMWADEOWALC@ALBKFBCIE@OK?RQPRSKKDB_@LJEBDQPO_@TBSFAC[E?PZHSZHH]UM?H_@Ji@?_@?TEQVAH@ROWTAYBIDHFF]VCFFVZFFFFEF^VEFEK^?Z[@?[L@H@?RWUHHEI]AJv@c@p@d@_Ae@}@g@j@z@e@ySc@g@n@Z`@BT?CAE?SJ??JIBTZALMKY?HWX@?AEC?FI@XE@RKMBNXHLP??D@?@]?BE@H?_@BC@OPCJHALKAPW\VE@FA^ZB`@`@@H@DDHCDLM`@KBCCKI]^DCBFUCEFHJf@I@CDL@[BR^\??C?QCDI?IRQQYWN?BYZ?DO?Q?FJ@C[Qf@QIHNF`@]OY?TOC^T?DHNIOKR@CAJX_@ZSa@?_@ACX@@HBJL?@HAMd@wBe@MG`@g@n@c@p@y@o@a@t@B^d@@|@Hy@K@@DBL^UEFC?MCBB`@A?D@EJa@u@U_@?S^CPT?BXSHEFOCPB\MU?Q?_@DLDLCa@@?K@La@BBUK@WY@WYAD\Q@HHDX`@X_@KN@?CLA`@?EM@SHK?SRCOYWDa@ZC?VH@D[UE@ELJ\u@?E@RNC@BC?VHFAB@C@AMIYC?@SBXEY@F@PN?F?^YB?K@HKBLAFi@@K?@PT?BNIBDAFNBLDJ\E@Q@c@p@d@_ADk@Lc@p@y@Do@t@Wd@I|@Vy@EKNPLAPC`@KZEFE@`@MVr@ABFDD?RH?`@RMCH?DOF_@E@MQ?KEV_@EH^ETWFXX@CPNVRSC@YI@AMU?NAFLC`@JBUb@PJACBW\CTUDQLUXVxAN?]?AAXE^]CCQEN@NBIPNTB@HNMONKVOCFTCEI[E@C?IAADXBKXMHEAF?ELF[TAJ_@?MT??YOMSDA?TBDTQWZWVATWMBKYCNCEUAIJ@?c@Mj@d@_Ak@c@p@y@o@@t@d@]|@y@W?UHXXSRJA?@A\FQF@BM@D?RSMVW@CUUEW]IHF_@ANJX?]BJOHH@SU[WOWHNYFC@XV@UV_@ADKpRNf@S@FNI@IB?WB?VW?A@NTLCM@?UY?LZ@ZA^NTKa@CHK`@?T?LV?MC^JITMNSJETIHPDJZALSZKRI?@NGH@@C@M@B^AHB`@HDNO@ADFNUALAL_@ZBAHBCAB?CSF@\@Oa@RTG]Ye@d@s@n@EAc@Tp@y@o@t@d@|@y@Bo@@MSLANFTCi@S_@Ua@LI^DTA^I@OD@JFQL_@PAXTZDYKEOKQW?BFEDBUM?AEBA@FDZM[VAH?QYCQHLSCJ@SX@f@B@AD^HABABK@Ua@CDFEi@I?[?CLFJYQB@?HRQHNVUB?EMEOX@CYT@b@?CK@PIZEEFFFFLFFVFFFEVVV@`@IZIBC?WQE?KF?SNCMALUB[VB@FBPWK]RFPU?A@JLHI?MA?^v@?Z?FFAUb@AHCp@e@s@l@Zz@d@n@eAo@l@Pc@c@b@DOVB^N\Da@C@?HMAD@CVTb@EP`@Y?DBNDLa@DEEITJQ^HQ[`@Zu@N?TQUQHV`@EAOZKELJEf@LA?ENJ?@LJBA\HQDb@J?M]BCAQZa@W]?KRNB\TEB??_@WQ?SBE@QMD?MCINIHCAODTJ?KM@KX_@E@BBLAM@OHDDNa@JTIOKUHTVLKFLKRDE?H??KJ_@`@BU@]V@?]^HTAPFW?CP[YHVOEX`@H@dA?n@P\p@|@l@c@fAk@n@m@o@c@c@C@FDT?@SWI^]RSr@a@ZQFJEMKC@?AAJR[BLQ\HRHD?YPWJ^HDL@?@?VX?MO?FP_@EJ?@N?RAAKZNDZUIRR??FH@PKI^DA?[QODBBCBJAD[DC?@IQ?HX?BWHB]_@E??XTa@@?HS?OJYCLCMMAQWCWBAE?DJI?]QER`@BMEDAUL\DKSDLKJNRX?JZLQQ@BQNZ@FCAJ?OV?BPA@B@?ICLDqSNn@p@|@l@c@@@fAk@n@m@o@l@c@?HE]B[TDCKEBW`@SN_@UNCJB@]RACAT?]T?OECCABWDA[MBMHF`@DNIPFDWA@DT\CL]IAC`@CW?JAb@EA@@QIWY`@BBIAEDAIWFKAJSJCZABBBM?WFBA@@@TEWD@ZF\V\YLIFCKBUJ@J@QK?VB?`@?RO?ZSEDA^]JWK@a@\@LEIR?JRPUPNBa@FEDV?Ba@TLXEOAJ]AUZTFAJ?C?^A\]S}@{@j@m@l@c@fAk@Bn@m@o@l@c@@QOFEa@CXNU@QWPILE@OUXRMEHE@VD@C@AP@ICBEIY?DB[?K?KZ@?@@NB?_@[OCVR@RUN?ALUPTWQ?B?^SAMR@^ARDERDK@EKFB@RDCDLVUWU\S[QS?AK@b@\??AI`@?XQW@O@@E??EB\_@AE??\Hb@SEB@PSJAD??IBBNQ^Q[LADDA@SUWWT\\RDS[O@B\CJD@U@PF@DCBZYI@aA^TI?a@s@Se@Us@l@z@d@n@eA?j@l@c@c@Hc@?EAOOUBSWM`@BQWNRTEUFT@Q\MVHID^MERH@DA@FFrA@Aa@IL@OTBBRJSWI@SP?WFK_@_@L_@KZ?^@DMDEWPDJKCBTI]@OSC[SNZCKI?DAK]U@YFFFFFEFFJFFFVVVVVVf@YABYK?QPJWW_@E@HNPV^TBT`@]^??PEAAIBa@AADS@IX@CBVCKQKZa@??OJVVUCVE@UB\\AJ@P@UJBSCBBLUEEv@Cc@x@d@w@k@c@x@c@s@dAo@|@^LV@@?KSA?[@HBU^PQ?`@Z_@OAOO?AK?@QFLBINEWETMXMLPDCQJNDCVAHR?ANS\M]`@LNEK?ZT@a@@FT[N@UIIAZ^MQR??END?@B?@@L]B[?BC?H??@OQ?RKZFQEI?LDAEJAZYD?LVNI?EJPQM\LESJ\B@BC@YNEH?^UAJLO?U?CZRJIPBLDUN[@EU^Y]MPEESZFa@B_@RK@PJ\@@E~@c@j@d@w@k@c@x@dAo@t@g@]C_@?MCW@CQRB?F?TKI@]IO`@B?NI@DDTX?A@QCFYSa@`@ZYIA?JJSa@@QXJDABFENRIZBYP@?HC@EHAYMCV?QOUMBIUTAC?SECFIE@X@PBUH]][NE?AM@HL@??DBJNR@OBLAWHHWAD^DNAODA@B?K`@[YQDJQ@B_@KB\PC?QK?WX`@[@TKHBQ?_@WICC?JEAQNLB\KLEDEOKKJNCEXSHh@x@`@z@m@Ht@g@kAlAe@b@n@l@{@k@BERBHJDRTJJE\CHAADWXR]a@XDD]KC?SFDHABEUIHBZFQW?VY@a@ACAAC@MAu@@JRIEEOB??LKNAD???IK]W_@BIWWAB\Qa@QF??QSM?JIH`@Zu@a@D@RCPA@AU@?LOQKSR[O@CAYXDAFEN@@\R@?@DBXNCLIAI?WTHH@QIUH?KRB\Q@WIW[SKE?U^^Q@?PKKB\S@^XDAQUDHKKBO??E@Vc@j@d@s@n@l@j@wBg@Rt@aBs@Gd@FCXVDAJD?TMOJA\AJQ^DRTBPND?WA@`@\NMUQNH\@W^HB@C@LJ?a@BN@X??BC@B@XXNHE??KTVIHFXF@S?V]@C]PBCEJ?MAZHSEC@Df@WBLDFBNELS?JXJBE?JD?[`@BKNBCBQ?SPIABCKUSH?@^\@ODZUQB@PCB@ICAA?Nr@M@`@MDCS][TCEDOKAA@@YAJ]BEC?BZFAUNIEN?a@QI@^i@vBw@k@c@x@d@g@t@g@e@d@e@lRd@G\KWK\UHC`@A`@HDETKKBIVC?DY`@SJSPR?R@DKSE^ZUFYD@B@QIKBD?B_@X?QFAM_@@?JBMCAJ@E_@?Ba@?UFBILBAM@EA@DCBb@?HEZu@u@F?BFFBF]OFFFFFFAA@EEUC`@AODR@DAQYRNC@AQBRPT?IR@QBJNEDN@AMP[LOEUW\IJUJACPE@YSURXY?ANPTFUBP?@[ZHPODE?^ONS@?R?ADODC@WISBCB^v@P~@j@e@_Ao@c@c@tAk@t@n@Hw@R\IE`@@EK?[N@U]@_@U?]EA_@@CB?EK\T@B?[MBCFDETVLBAD?KLZJUDZ@?_@_@[@?D@[FFAQVRFBPNBN\OD@N@Y_@ZBF@CDY@@ABDMVRC[AW@MEZDCHEE@MCXQODOPQW@IRAI?KEH?YALAB@CRLTFA?KV^?WJ?LAOTSHZ@\WDCDBCANTBLF?CYEFBXJCLUDLAHFRDRM_@JWJQIEwBJd@k@eARp@s@w@lAz@d@d@a@p@SE@OJAUABXBSWKADB?SB?@L@CSRAVYFH^PT@EOCL?JIOHa@AWRIQ?RKSDCJOPISRSCNEYFZYEF@BH@`@MADZDCCSCDL?@ZQRCY]KBQITN@NNABAEOLEZITHMJa@]a@Q?NS?NO@X]UX?EET?CB]?@?HJR[@`@OIFP?KHDP\]N?@@CS`@BXBNEAEKD_@ELCBQN??[BBJMACUN?S\?Db@Kw@g@jAlAfA{@eAp@o@g@g@fA?tADNLLYEF@I?H??]_@CJMA@AIAVBDCFTR@?P\CT`@UH@SRPY^CBAEW?AMA@a@A_@PCLQ]IB@\?S@@@UCJSXDTDRBRI_@RFDKD?EANKPPB@CNBOZQ`@LHBJ?FSSA?@BHBOLQYRL?EECa@H@@PTQVHXE`@]I@BJUASF?@AZBSA?OXBE\BN@D@@FHHXO]@KK_@FBILQET@KC?E`@HEX?EmAE{@p@Re@p@|@s@CtRc@OtAMk@t@s@w@I@DQ?NJBUB?JCL?O?RSY@_@E@HE@HY?L?AA^ABQLRBW@KQJSRUKOUZPZFA`@IME?@A?C?NOD[@FR?MN`@E?ITU@HWA^URUHRWX@BQ?LFJJUFY?DCBF[PIWZa@?TSQ@L@NE@BX\?BJYDWCDPJE[Cf@D@BCF]O]?IH??FAJCUAU^Q\WHXBO[NDRKCC?TAJ[JSJ]?\OZP?f@DHT?JTQz@d@fAt@x@m@s@w@lAz@d@Tp@j@ED`@XBJUb@OXAEWXSQ?DHNA^B[D@BZLJ@HOCL@N?AMCWEb@X?JXMFEFLKDCE]?IW@?BRFD`@\@H@BWQ]VFFFFFFFFF@FCVFVVVVb@ABUBNC?@TODK?@[EC\MKQZX?JV^@ANWDQJWIOY[AEN[MA?BA@C??@IAD[^?KK?B[CU`@B`@D?ASF?ILIY?EAALCQY]?WW@WH?X\RA@@PHZRN?_@`@J@MSADLv@GYAg@~@d@g@j@d@GHj@Cd@Jm@e@sSS[RXJ?IJPQNAQ[I?AAJHOBL\M?E?HWPDO^E@\KKAWu@][OJA?HSNa@@BFB@?QNRB]XDZCT@JF?MT^UH?TMP[IBK[@H@S@WD_@CWHURBTBBM\@HAOS@@@M@SQFBSR@E\R?AN_@CNCQKLP?_@K[WAOSNYF?LLC@HEr@COFEP^WB@`@ATEBRCHJECWVa@U@@\RTXQFNDu@BNNCBIH?DlAvB@j@aBl@e@Pd@xBRj@d@m@Ie@?d@PQKJ`@X@KJNRKM?BA@MQ?JNP^SPIJQFWR[F@?A\LJ@Na@DB?M?AEXKSBP@MUP_@FHDB@FA`@NAVCB?XCSWQNXBQULSa@_@BNTWS?^b@J?KA\IBXE@?HB?@@T]LU\IQADOMQAECUICSWDAMXKPO?ABLUHQK?`@QKPZ?\AOQFMDDIA@FJBES\KPOPB?T]QNBL?PATSOEKDB@?R?ICFFTZc@e@tAc@j@Mk@l@m@}@g@_At@NWA?Z@IQAH[@UXNFEOIVCAWAQB?\S?TIPZQETF`@`@J??@IKIXQEFB?B@N@EOMJ?KKT_@CR?ASB[@DHUDE\ICJKZ?B??NEYUI@SWFDMBF@a@?A[WBPM@Xa@TAJPEQ]DID@QCL^`@PT?XDJFXEMQUVCJECJIOJA\AB?J?SHOIQWWHKUMZIFTAAEYBE[?YEA?EJHWVBKC???BRQBWFOCaBo@Gy@g@j@d@xBj@d@lAe@Ed@?BCMC^KNEEAZ@i@S@X?OJAADR[DTUUWHMIBVDIFE@VKVFABN?JE@?^A^F?BHXD??HCBBNUJ?_@AXADBA@R?EBJIPZU@C@FAU`@THXKXDTB@?DXZ[WFPS@LQZb@F@MEDHVH@^`@WE@PPAD[RQEBNJ?XV^?@IL?TN@CINKPb@XTCCB`@@JSB?@C@@@@YAR\?ECBFYE@DO@FAEEZxA@?LB?Hc@Ae@tAc@j@k@l@Im@@T}@Jg@_At@\XD?A?@KBVP\LHQHHKEFTMBa@DEADVb@QNI`@YD?FFSKYXCAHDF@B?J^f@ZHAQFFFEFFFFFQFVFNVVVVVf@BIQYJUTE?K?@NLCWa@XMUVBIVJOFF?O@HJKP?DKBXHTRb@HJEDDFCI?ES\S\Ma@S@]B^HRWSCX@KDACB[MFJ?@[YA?HHE`@?RXQNMXU?@Q?^[X@QCFBHPNII[Z`@DH@PFI]v@KNKDHFAAL\i@j@s@xBRaBx@e@c@z@F@fAm@g@GUAABR?M??@PQAVu@[_@RZAN?QDSIYU?DA?KAY`@MBU@WC@ULBHJYD@@MFYXA?B\D?@DDZC\HP@AYFA[RM[HCE@QCa@B[QN?I@MWBX^U@?C@EU??CW?\`@LVEb@]DIEEJ?a@JFUAb@@ZB@Hb@SIM@AT?C?@JFCJR\EXL@Q_@AZDFWMC?SQUBX[@HPLSOM?CDWO[CSTQGAGBGCGDGExDByDDzBCGFGGGHGIGJGKGLGMGNzDF{DH{BOGPGQGRGSGTGUGVGWGXGY|BG|DI}DK_EMbEH{BJ~DL`ENeEIcEL}BOGZG[G\G]G^G_@G`@Ga@Gb@Gc@Gd@Ge@Gf@Gg@bBZgEh@Gi@Gj@Gk@Gl@Gm@Gn@Go@bBp@Gq@Gr@Gs@Gt@~Bu@Gv@Gw@Gx@lEl@Gy@Gz@G{@G|@G}@}BJfEMwEKdENG~@G_AG`AGaAGbAGcAGdAGeAGfAGgAGhAGiA_Cm@GjAGkAGlAGmAGnA~B[GoAGpA`C_AyEaA{EcA}EeAaCgA`FiAoA\GqAGrAGsAGtAGuAGvAGwAGxAxELeF`AzEbA|EdA~EfA_FhAeCMbBPaEyAGzAmFaAfFdAfCgAoAh@kEj@sFbAnFeAhFhAqFQGyArFLnAjAaFlAbCnAuFcAgFfAoFiAzFdAtFhA{FeAvFiAdBkAbFmAcFg@}FfA~FlAbC{AG|AG}AG~AG_BiCgAdGhAdB`BGaBGbBdBcBGdBnEq@oEeBGfBGgBGhBvE}@kCr@GeBhGgBjG|@eCiBGjBlCeBkGhBkCkBGlBGmBoAoAoAnBGoBpApBGqBnArB_G{AaG}AeB_B`GmAgGdB`CsBGtBGuBGvBGwBGxBpAyBGzBG{BG|BG}BzGzB{G|B}Gg@qGpAnA~BG_CG`CGaCGbCGcCGdClCs@nAeCGfCGgCfBtBwGvByGxB_H_C`HhCGiCGjCGkCGlCeHfCfHLfGaBwFyAxFMtGlAyFg@sGqBGiBnGg@tCiBtCMmHmArC`CaHbCcHdC_Cy@tE{@cCqAiFsAkFuAGmCGnCGoCGpCcC]hE_@GqCGrCrHrAjFtAdCvAlFxAlHzArGoB|HLqHz@uE|@uCnAoAsCGtCrEw@yCuCGvCGwCGxCGyCkHgCyCtC_Ix@dILoHNvChChHjCjHlCvGj@~Hg@gHuBxGwBdHt@mClBpGg@nAn@mEg@fBzCG{CpFNoGfBiGhBxCiB~G{B|G}BmGjBfB|CG}C{C~CG_DvCaCbHcC}H{@zCiBmC`DGaDlIgBlG}@uC{AuG~AcGNoCnArCbDGcDGdDnCeDnI|BpAfDGgDjEg@nHjBuIhBpAhDGiDvI|AbG~AqI_D_J}AnCNsI|@|I}BoIg@tIjB~I|@eJ}@}Ig@iImBjIo@yIg@`IvCaIxCcI}BfJg@jBiDoC{AwI_BeGiAcJg@bJ}@kI{CeIv@sEx@mIjBkJw@zHsAsHmCuHoCxCMmJg@nJx@pAi@qJj@qEv@jJ|A`JNrJw@aJ~AgJg@gIvBtJx@uJNzIcD{I~AGeDpI}C|BjDGkDGlDGmDGnDjCN{AoDGpDGqDGrDGsDGtDGuDGvDGwDGxDGyDmBpD{JrD}JtD_KvDaKxDbAzD|JsD~JuD`KwDbKyDbAqDgKtDdKwDkBtAdCmCoJpCjBNrIbChJwCbIyCG{DG|DG}DG~DG_EG`EGaEGbEGcEGdEGeEGfEfKrDcKuDiKxD{CiCiHkCjKrDpKvDeKyDsKsDhKvDoKsDuKwDnKxCiJg@jCgEzCMvJwByKxBxKNsJ}AeBNpJNjBg@tKtDkKxDvKtD|KyD{AhEGiEGjEGkEGlEGmEGnEGoEGpEGqEzK~AwJdDeBeDwKyCnBcCfLdCcLN{KuDqKyDgLvDGrEGsEGtEGuEGvEGwEGxEwH^iEyEGzE}KuDiLwDzB{EG|EG}EG~EG_FnL|EoL~ElKuAtHnCvHpCdJg@eL}BrKjCdL~ArLg@lLvDmLxDuLwDvLyDwLxDsLkC~C}EpL_F_DvAyL~E_DmC{L_FtLeDxLlCjL_@xHrC`DqC}LrC~C`FGaFGbFGcFGdFGeFzLwA{AkDyJmDGfFkBgFGhF{HwAbMxA~LaF_McFaMeF`DyEnBiFGjFGkFGlFiAmFGnFGoFGpFGqFGrFGsFGtFGuFiAvFGwFGxFGyFGzFcMlDzJfFgMzEiAiEG{FG|FG}FG~FG_GG`GGaGGbGGcGGdGcD{FdD}FwM_GyMaGzMeGGfGGgGGhGkBiGGjG|LnCfMbF`MdFuMmD|M|FvM~FxM`GqBkGGlGGmGcDjE~KlEGnGGoGGpGGqGiCrGsAsGGtGGuGGvGfDkE_LnGGwGGxGGyGGzGG{GG|GG}GG~GG_HG`HGaHGbHdNcFeNfFbAcHGdHGeHGfHsA}F}M`GqBgHGhHGiHGjHGkHcNoClMnFGlHbDmH_BnHGoHGpH_B~FfNaGGqHGrHGsHGtHGuHpBvHzNdF_BwHGxHfCyHGzHG{HeO_G~MbGGeG_NgGcOoHiOeFjOxH|FiAsA|HG}HpOeAaCyHkO{HmO`GgNlGpBwFrMyFtMg@aOpCrOfAiDlHbONpNlEiNwGqNyGsN{GuN}GwN_HyNaHpB~HG_IG`ItOaGGkGhNmGkDgAsAaI`BqHGbIGcImNtGnNvGmDrHhIxBxOqFGmH`BkGnBdIGeIiMkFkMdFbPyDnDvBuOxFsMzF`BgH}NiH_OkH`BbGjDfIGgIjPwBkPhH~NjH`OjBgPeIhPlFqPjFjMlFpDeGnOhGqO}HfPlGiDoFmMqFnMsFpMuFaPhAlDnGjNpGpDcGoDyFmDbIcAhIGiIGjIkDyH}PiI{PzFqDiHmPjBuBwGyOzGtN|GvN~GxN`HrBkImBlIG~H_P`IoOpH`QjIoDmIoPxBcAfG`NhGaQg@tPmG_BnIGoIzPdGuPpFbDrFoMtFqMg@uBoGkNqG|PcIsDpGkQqFwPtFfDpIGqImQqGqDrIhMjFsPdFtBsIGtInQrFlQuFlDmE`LoEbLqE_QzHbAuIGvIGwIvOzFbQjHpPg@iQgGrQtIdPmHsAxIGyIGzIjQoIyPiAyQkH|QmG~QyIcQxGrNzGdQ}G|O`HrB{IlNhA`RjBiA|IG}IG~IG_JG`JGaJGbJGcJaRzItDyGzO|GeQ_H}OdJqQkFiPeFtBuGwQ{HqRvGuBeJGfJGgJGhJtBiJGjJGkJGlJtDmJGnJlPjHaNjGcAoJGpJGqJGrJcAsJyRpJzRrJ{QhGsQsFxPg@}RtFnDsHfOuHvDuF_Sg@iAtJGuJfR}IgR_JiRaJkRcJ}QNeRg@{RrJ|RqJhQ`I~RtHuRjJvRlJuQnEaLpEiAvJGwJ~O_IpQNdSoExQvIGxJGyJGzJfSpEcAfIcA{JG|JmB}JaDoFvPrFtQg@mRzGbR~GfQaHmS{G{O~GwDdJjSgIcA~JG_K`S~IhR`KGdJbSuH{AaKGbKGcKaSrJoQqIbAdKGeKGfKGgKqBbGjD{JrRfJsRhJnS|GnR`HrBbHcSkJuS}GcRaHGkIeS`IiSqEgSxJhShKkS|JvSlJhOj@eMiKbNwArPkFdRiAbAjKaDkKGlKGmKePNpS_JG`KbAnKdDaIoRlFxSyJGhKvDg@zS`JjRbJwS~GwDbHgQvHtSgJ{NdH|NfH{ShJrSbKoS_KxRwAsDoKGpKGqKGrK?sK</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??pB??O?H??A??A?????G??C??pH?_O?I??J??@@?k`?K??C??@B????L??M??p??gB?N??O??pB?wB?P??Q??@C?SF?R??S??PI?_hAT??U??p@?Co?R??A??A?????N??O??PG?GC?V??O??@A????P??W??`???J?P??X??PP?KG?Y??Z??p??__?[??Z??@H?oJ?\??Z??p??{f?\??]??pZ?ci?\??^??P@?Kn?R??_??`C?WnAT??_??@\?GS?V??O??@B????`??a??pA?WD?`??b??pK?sC?c??b??PG?KD?d??a??pE?cJ?e??a??@C?KS@e??f??@V@sg?g??h??`B?c\?g??i??pH?S]?g??j??`l?gb?g??k??PC?cc?l??m??`??[F?n??m??@B?_D?o??A??A?????`??b??`N?wC?p??m??pA?WD?q??A??A?????r??C??pS?WC?s??t??@U?wL?u??v??PJ?sC?u??w??Px?GK?u??x??pL?_G?V??O??pB????u??y??@W?GN?u??z??pA?gO?s??{??P??WH?|??A??A?????`??a??`@?WD?}??~??P??kd??@?@@?`B?SE??@?A??A?????u??v??@F?WC?s??A@?@A??G?B@?A@?pC?CF?C@?D@?@??_X?E@?A??A?????r??C??@M?KC?F@?G@?@A?cE?H@?G@?P@?GH?H@?I@?`I?CG?J@?K@?pr?kG?J@?L@?`d?OM?H@?M@?PY?KR?N@?O@?@A?sL?P@?a??PA?Ge?P@?Q@?@M?Sf?P@?R@?@??su@S@?A??A?????u??w??Pf?cJ?u??T@?`L?sL?U@?A@?@A?SG?U@?A@?`C?gG?U@?V@?P??sJ?`??b??`L?wC?p??A??A?????c??b??`B?CD?W@?X@?P@?Gm?Y@?Z@?`??G?@[@?\@?`^?[]?]@?^@?`G?oI?]@?_@?`D?[K?`@?a@?PT?G^?b@?A??A?????P??X??`N?GG?R??S??`@?_fAU@?V@?`E??K?c@?d@?@D????e@?f@?@A????g@?h@?@B?__?i@?h@?@?????u??T@?pM?wL?P??A??A?????A??j@?B?????u??T@?@T?wL?P??m??@O?[D?s??{??@B?WH?s??{??PG?OI?|??{??pE?WQ?B@?{??pC?[D?T??U??@C?Co?k@?l@?PI?wmBu??z??`??cO?p??m@?`N?CJ?n@?m??`@?GA?`??b??PG?oC?o@?A??A?????p??m??`J?_D?l??p@?@C?S[?u??w??@o?oJ?F@?G@?@N?KF?F@?q@?pB?{G?r@?s@?@@?CU?N@?s@?p@?wI?t@?s@?@??[|?u@?A??A?????p??m??pI?_D?l??v@?`??sN?n??v@?`B?sr?n??w@?@G?OM?k@?x@?P??C\Bu??w??@A@sK?u??y@?PD??H?L??O??@B?_B?z@?{@?PD?kF?E??|@?PN?sS@}@?~@?`F?cX??A?A??A?????u??w??pr??K?P??@A?pH?gN?P??AA?@L?CT?z@?{@?pB?gF?z@?BA?`@?GE?G??m??p@?_H?CA?DA?@B?KY?I??A??A?????]@?_@?P??KK?EA?FA?P??{P?EA?FA?@??GQ?GA?A??A?????e??f??`R@og?HA?A??A?????`??b??@F?kC?`??IA?@@?SB?`??IA?P??SB?JA?KA?@@?SL?R??KA?PD?gn@R??LA?`A?cr?R??MA?@E?CN@F@?q@?@S?[H?NA?A??A?????F@?q@?@A?sG?OA?A??A?????z@?BA?@??GE?G??A??A?????p??m@?PM?CJ?n@?A??A?????L??O??p@?_B?PA?QA?p@????RA?f@?P?????SA?A??A?????p??m??PG?_D?l??m??p??gE?p??m??PF?_D?l??A??A?????TA?J??@@????c??UA?pC?OF?d??VA?@@?GJ?e??VA?@B?{e@WA?A??A?????c??UA?`D?OF?XA?YA?@I?gB?XA?YA?@y?SE?XA?ZA?pH?kF?[A?\A?p??GB?[A?\A?p??sC?]A?\A?PA?cE?]A?^A?pA?KF?[A?_A?p@?GB?[A?_A?@??SC?[A?A??A?????XA?YA?`s?OE?`A?C??@W??F?aA?bA?P??gH?cA?dA?P??s@?cA?dA?@A?OB?eA?dA?PI?[W?eA?fA?PL?cY?gA?dA?@?????hA?A??A?????`A?C??PY?CF?N??iA?`??w@?N??iA?`@?_B?u??m??@D?[A?jA?A??A?????c??UA?PF?SF?XA?kA?@S?[A?XA?lA?P??CG?mA?nA?@A?OYAmA?oA?p@?kr@pA?oA?pK?OH?qA?rA?`E?sB?pA?rA?`D?gF?sA?tA?@??[X?uA?A??A?????vA?C??PC?O@?B??C??pA?Cs?wA?C??PM?wG?xA?yA?@B?SG?zA?{A?@@?GJ?|A?C??P???Q?}A?~A?@@?gH?e??f??Pe@oh??B?A??A?????E??F??`E?GE@E??@B?pc?WA@}@?AB?pE?KZ?BB?CB?`B?gc@DB?A??A?????}@?AB?PB??Z?EB?FB?@@?OV?GB?FB?pD?CI?Y@?HB?PD?wz?Y@?IB?`u?[j?JB?A??A?????KB?A??A?????[@?\@?Pj?w]?[@?LB?`q?Ka?}@?~@?@K?kX?EB?X@?@@?GS?GB?X@?PA?cH?Y@?IB?pB?gy?XA?kA?pN?SA?PA?QA?P@????MB?NB?pF????OB?NB?pD????RA?PB?PB????QB?RB?p@?k\?QB?SB?pC?w]?i@?TB?pK?{T@i@?UB?@A?WU@XA?kA?@P?SA?VB?WB?pB?K_?XB?WB?`??kA?XB?WB?pF?wV?XB?WB?PP?CV?XA?lA?@B?KG?}??YB?@C?gp?[A?ZB?@W?_F?[B?\B?pF?SU?[B?\B?`B?gQ?pA?]B?PD?KJ?^B?]B?P@?GH?^B?]B?p_?WG?_B?\B?@??gH?_B?A??A?????_B?\B?@B?gH?_B?m??Pa?CH?`B?aB?`B?oL?zA?A??A?????[@?\@?pe?c]?]@?a@?PC?wL?^B?]B?@Y?SG?^B?\B?@l@GQ?bB?A??A?????pA?oA?PM?OH?uA?oA?pB?OB?cB?^@?@??OC?cB?A??A?????P@?Q@?@e??g?[A?ZB?`Z?cF?_B?dB?@G??A@_B?dB?`FAgF@eB?A??A?????uA?oA?`F?[B?fB?gB?p??{E?fB?gB?pF?gE?fB?hB?`L?oD?iB?m??@@?wB?jB?m??`??GD?kB?m??`??cB?lB?m??`??KC?mB?m??@E?{O?mB?nB?@C?wp?mB?nB?@?????oB?A??A?????XA?YA?PH?_C?pB?qB?P??_M?rB?sB?@??KF?tB?A??A?????^B?]B?@[?WG?XB?p@?@C?Sn?uB?p@?@A?{B?R??m??`@?cU@R??m??pP?C`?MB?NB?pP????QB?U??`@?KW?[B?\B?@C?GU?N@?m??P@?kE?P@?A??A?????^B?]B?P??OF?vB?wB?PA?[C?N@?s@?@@?wI?P@?xB?PA?gw?t@?A??A?????VB?WB?PA?K_?[B?\B?`D?KU?yB?zB?@F?_^DP@?Q@?@D?Kf?P@?{B?P`?wj?|B?A??A?????[A?ZB?Ph?CG?}B?A??A?????VB?WB?@B?K_?~B?Q??@X?[P?XB?A??A?????[A?ZB?@b?{F?vB?wB?@??WC?vB?A??A?????}@?~@?`^?[Y?}@??C?`@?{I?_B?m??P@?cD?@C?A??A?????_B?m??`A?cD?@C?m??pA?[A?AC?A??A?????AC?A??B?????XA?YA?@D?cB?XB?WB?pG?{V?[B?\B?@B?GU?N@?A??A?????mA?nA?P@?OYABC?A??A?????uB?p@?@??{B?_B?dB?Po@?F@CC?DC?@??WF?XA?YA?PC?KC?VB?EC?pB?wb?VB?EC?PF?Sa?[A?ZB?PV?_F?[A?FC?pB?CH?GC?A??A?????HC?A??A?????XA?kA?pS?[A?IC?O@?@D?K\?IC?O@?p@?W[?IC?JC?p@?ON?IC?JC?PH?sM?k@?x@?`@?cXBk@?x@?p@?_ZBKC?A??B?????KC?A??A?????uA?oA?@D?SB?cB?LC?P??kN?MC?D@?@??GP?MC?A??A?????_B?dB?@V?OB@_B?NC?@A?[I?OC?PC?@A?gH?QC?A??A?????fB?gB?PA?_E?XB?RC?P??WH?_B?m??P??sF?[B?m??P??GI?OC?m??P@?_D?SC?A??A?????_B?m??PC?oD?XA?kA?PG?{@?IC?A??A?????XA?kA?``?{A?TC?A??A?????VB?EC?PB?Oa?XB?UC?P??kA?XB?UC?pK?GQ?_B?m??PN?OG?CC?A??A?????XA?YA?pB?_B?_B?m??P_?CH?VC?A??A?????IC?JC?@L?{M?c??UA?`K?cF?WC?XC?PD?cF?WC?A??A?????XA?YA?PG?WC?mA?YC?P@?Gh?mA?ZC?p@?oV?pA?ZC?@D?_L?XB?UC?PH??Q?[@?LB?@w?Sa?XA?YA?@B?KC?[C?NB?PD????RA?PB?pA????QB?\C?`U?gY?XA?YA?p`?WD?cB?^@?`B?WC?]C?^C?`A?SP?]C?_C?@?????fB?A??A?????</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2591949291;
    let startMs = 1664992480974;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","java.lang.Thread","run","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.lang.Class[]","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.nadutkin.impl.HighLoadHttpServer$$Lambda$70.0x0000000800cca6c0","ok.dht.test.nadutkin.impl.HighLoadHttpServer","lambda$handleRequest$0","one.nio.http.HttpServer","handleRequest","one.nio.http.Request","getPath","java.lang.String","substring","java.lang.StringLatin1","newString","RequestHandler1_put","getRequiredParameter","getParameter","java.lang.ClassLoader","loadClass","jdk.internal.loader.ClassLoaders$AppClassLoader","jdk.internal.loader.BuiltinClassLoader","loadClassOrNull","findClassOnClassPathOrNull","replace","ok.dht.test.nadutkin.impl.ServiceImpl","put","upsert","ok.dht.test.nadutkin.database.impl.MemorySegmentDao","ok.dht.test.nadutkin.impl.UtilsClass$Memory","java.util.concurrent.ConcurrentSkipListMap","doPut","java.lang.invoke.MethodHandleNatives","linkMethod","linkMethodImpl","varHandleOperationLinkerMethod","getVarHandleGuardMethodName","java.lang.StringBuilder","<init>","java.lang.AbstractStringBuilder","byte[]","one.nio.http.Response","java.lang.String[]","one.nio.server.SelectorThread","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","startParsingRequestBody","sendResponse","writeResponse","write","one.nio.net.Session$ArrayQueueItem","jdk.incubator.foreign.MemorySegment","ofArray","jdk.internal.foreign.HeapMemorySegmentImpl$OfByte","fromArray","read","one.nio.net.JavaSocket","java.nio.ByteBuffer","wrap","java.nio.HeapByteBuffer","one.nio.net.JavaSelector","select","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","processEvents","processReadyEvents","java.util.HashSet","add","java.util.HashMap","putVal","newNode","java.util.HashMap$Node","parseRequest","one.nio.util.Utf8","toAsciiString","java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock","lock","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquireShared","java.util.concurrent.locks.ReentrantReadWriteLock$Sync","tryAcquireShared","java.lang.ThreadLocal","get","setInitialValue","java.lang.ThreadLocal$ThreadLocalMap","set","java.lang.ThreadLocal$ThreadLocalMap$Entry","java.lang.invoke.LambdaForm$MH.0x0000000800ccd000","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800cd7800","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","jdk.internal.misc.Unsafe","no_Java_frame","java.util.Arrays","copyOfRange","toBytes","one.nio.util.ByteArrayBuilder","ok.dht.test.nadutkin.database.BaseEntry","toString","iteratorFor","sun.nio.ch.Util$2","iterator","java.util.HashMap$KeySet","java.util.HashMap$KeyIterator","append","ensureCapacityInternal","copyOf","handleParsedRequest","java.util.concurrent.AbstractExecutorService","submit","execute","java.util.concurrent.LinkedBlockingQueue","offer","java.util.concurrent.LinkedBlockingQueue$Node","getHeader","trim","newTaskFor","java.util.concurrent.Executors","callable","java.util.concurrent.locks.ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter","initialValue","java.util.concurrent.locks.ReentrantReadWriteLock$Sync$HoldCounter","java.util.concurrent.ConcurrentSkipListMap$Node","getKey","ok.dht.test.nadutkin.impl.UtilsClass","getBytes","encode","encodeUTF8","one.nio.net.JavaSelector$1","one.nio.net.Session[]","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","ok.dht.test.nadutkin.impl.HighLoadHttpServer$$Lambda$70+0x0000000800cca6c0","ok.dht.test.nadutkin.database.impl.MemorySegmentDao$$Lambda$82.0x0000000800ccb148","lambda$flushInBg$1","values","java.lang.Class","ok.dht.test.nadutkin.database.impl.StorageMethods","save","writeRecord","jdk.internal.foreign.MappedMemorySegmentImpl","asSlice","jdk.internal.foreign.AbstractMemorySegmentImpl","asSliceNoCheck","dup","one.nio.server.AcceptorThread","one.nio.net.Socket","acceptNonBlocking","one.nio.net.JavaServerSocket","accept","sun.nio.ch.ServerSocketChannelImpl","implAccept","sun.nio.ch.Net","java.net.Inet6Address","createSession","java.lang.ClassCastException","load","mapForRead","java.nio.file.Files","size","readAttributes","sun.nio.fs.UnixFileSystemProvider","sun.nio.fs.BsdFileSystemProvider","getFileAttributeView","sun.nio.fs.UnixFileAttributeViews","createBasicView","sun.nio.fs.UnixFileAttributeViews$Basic","ok.dht.test.nadutkin.impl.Constants$1","jdk.internal.ref.CleanerImpl","jdk.internal.ref.PhantomCleanable","clean","jdk.internal.ref.CleanerImpl$PhantomCleanableRef","performCleanup","jdk.internal.foreign.ResourceScopeImpl$ResourceList","jdk.internal.foreign.SharedScope$SharedResourceList","cleanup","java.util.concurrent.ConcurrentSkipListMap$Index","getTask","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","java.util.concurrent.locks.ReentrantLock","lockInterruptibly","java.util.concurrent.locks.ReentrantLock$Sync","acquireInterruptibly","acquire","java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode","java.util.concurrent.ConcurrentSkipListMap$Values","fullTryAcquireShared","java.lang.invoke.LambdaForm$MH.0x0000000800c02400","invoke","java.lang.invoke.LambdaForm$MH.0x0000000800c11000","invokeStatic","java.lang.StringConcatHelper","newArrayWithSuffix","newArray","allocateUninitializedArray","allocateUninitializedArray0","java.nio.file.Path","resolve","sun.nio.fs.UnixPath","mapFile","makeMappedSegment","java.nio.channels.FileChannel","open","newFileChannel","sun.nio.fs.UnixChannelFactory","sun.nio.ch.FileChannelImpl","java.lang.ref.Cleaner","register","java.io.FileDescriptor","sun.nio.fs.UnixFileAttributes","mapInternal","sun.nio.ch.FileChannelImpl$DefaultUnmapper","sun.nio.fs.UnixException","rethrowAsIOException","translateToIOException","java.nio.file.NoSuchFileException","java.nio.file.FileSystemException","java.io.IOException","java.lang.Exception","java.lang.Throwable","fillInStackTrace","int[]","jdk.incubator.foreign.ResourceScope","newConfinedScope","jdk.internal.foreign.ResourceScopeImpl","createConfined","jdk.internal.foreign.ConfinedScope","sun.nio.fs.Util","sun.nio.fs.UnixChannelFactory$Flags","toFlags","keySet","java.util.Collections","addAll","resize","java.util.HashMap$Node[]","jdk.internal.foreign.MappedMemorySegmentImpl$1","sun.nio.fs.UnixFileSystem","signalNotEmpty","sun.nio.ch.NativeThreadSet","long[]","java.nio.file.LinkOption[]","sun.nio.ch.FileDispatcherImpl","duplicateForMapping","resolveSibling","openOptions","java.nio.file.OpenOption[]","short[]","java.util.ArrayList","grow","java.lang.Object[]","asBasicFileAttributes","sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes","beginBlocking","java.nio.channels.spi.AbstractInterruptibleChannel","begin","java.nio.channels.spi.AbstractInterruptibleChannel$1","getPathForExceptionMessage","java.lang.Object","ok.dht.test.nadutkin.database.impl.Storage","getParent","sun.nio.ch.FileChannelImpl$Closer","ok.dht.test.nadutkin.impl.UtilsClass$State","afterFlush","createFile","newByteChannel","java.lang.invoke.LambdaForm$MH.0x0000000800cc2400","simpleConcat","sun.nio.fs.UnixNativeDispatcher","stat","stat0",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
