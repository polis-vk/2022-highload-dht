<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BDlIAIQ`@qv@??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????KQqyzicUS^VU]TS`jqzbqzxjjiybbarqriryqbyrivN\V^K]T^^M^S^K`iyjyqb~HkLS[S`qbrxzpzrvM[VTU^VU[U[V\U]UU[V^VUVS\]^M[T]]T]TxbyjyyqzxzqybribrayjbyyybazizxzqyzykUVVUpM`bqjyyiijjabbqcKU]^M\TJpb`abrzz{VVV[]^U^^U^]S[\V^UUT^T]T^VS[U^VT]xybbqrqyqqjqrbabqbjyqybmH{IdLUU^M\[]xbrqbqyycNN^K]`^`hrabxjjizjirqcMTU[U^xrijyqbqbybyrizabyqcNK[[^VSTSK`pcK]U[p{NVT]VT[hab{IsKT][T`ajjijrhrqcNUVSS`icS^S\V]T]UT[]OVMUUVTUUS`pryjzqzbjzbb{ST`bybzrjbzbybyqyrijbqbqjmH{HlK^M`TqShabbqjbyybbqbbaqqiyqjqqyqyqyijjabyvK`rbayrrbbbryqqbjyjajrqracNL^VU\S`xlTS]V]S[^T\pN`DhjxsKL``{KT[]T^M[]U[T``tTS[[]^N[T\T]^M[S[VT[]^UTVS[\[\T^UTayrqyqribbxpiqbijirabrqcN\V[][[ThkIdS[`\`[`pzxrzqbqryizibryrpzizqbyyqrsU[S[]T\U^S\[T^T^UV]N]L[T^N\\T^V^L\[qiG[MT[S]VUUSU^L^VT^`qsIdH{L\U\M``sNUVapcNN]T^L^UT[VUS[U[][M\VT\T[]^L[]T\iyqjazqcMUT^N^L^L\S]UVS]S[S\VVUTVUUpzjijqbxfHsIdKN]^M]N]M\M^M]L\U^V[S\]Uaxrxrjqyyjbryqjijbjarbyrabybyryib~K[[\\S^S\\[\VVS]TV]T[VTT[^N\U[xN`uN`cLL``kL[T`]`pzjacKT[^T^N]UVSHSLNTVT[ayqbyrjjiryqbyabiaOpqararirqqrqjikNKiqjbyjayybqbrijbqcKU\xF`LhM`rah`dL\xzpkMK`rpcNN[S`jpjizxryyrirxrxkNM]VVaqjajizyybyrazyqyqjyyqyrajrypa[UMNK]`kL\UVUVMUVSUhJcJkKL\M]M]MUUL]LZz`U`[``zkMp`??`bpyaiyqpbiyapjahqx`jxaypLMMNLVKVMUTNhbyipiZTUKUUK\T\K]SUTTUSVK[VTS\TTT^LVVTTTVNSUxyiatH{H{HdGlHsHdIkNVT[xkJkLK`yqribxjxrU^KVVL]NTL]TUUVUTUUxaqy?`hxbiqiypyhqiqxiyajxbijxbiyhribdN`ibpjhzhcMT[T\TxF`N`xbqyiyajpbqbeK`iyaqqi`YqhjxcKK`prhrxrpjizxrqjyjacVUUTT]S\S]S[[VSSVUVTS\VST\S]S`ibnM]^S[\]US]TSSSTKhETVM[N]N\N]K`pjcKpxbrxricKT^^NNJSM[]U[S`irabbiybzuM^V^US\T]M[U\UUS^S[S[VUVV\T[S^hlMUVVU\S[\UUS[]UUhzhkJkJzxkIsJfM[`HgYg_@xa@kd@if@_^sc@jh@hf@fb@cd@gY{c@me@vf@eg@}c@de@se@gf@sg@rf@xd@sd@dg@`h@gh@wd@eh@_j@~c@_g@fh@jg@}m@ul@bm@_o@ak@wYjn@vi@sj@`m@an@mo@ml@xm@in@kl@wl@hn@nn@dl@vl@mi@vk@fZlo@~p@vq@}o@hm@zq@_q@dr@on@_r@to@o_@`i@uo@kp@eq@rZ`q@c[n^e`@da@}k@xZ|_@|`@gb@}i@ej@pk@lp@dq@`[l[k\`^s^d`@x`@ha@cb@}b@~b@`e@zh@}j@qk@ql@~Y_ZdZgZoZyZ{Z_[k[o[z[~[a\r\s\z\n]t]v]y]}]g^i^l^t^v^__@b_@h_@j_@p_@m`@s`@w`@na@ib@jb@rb@`c@cc@hc@bd@zd@we@`f@ef@of@`g@fg@tg@yg@kh@uh@|h@ci@jj@rj@bk@gk@ik@xl@nm@pn@{n@bo@mp@{p@pYrYtYuYvYxYzY{Y|Y}YaZbZcZeZiZjZkZlZmZnZpZqZsZuZvZwZ|Z}Z~Zb[e[f[g[h[i[j[q[s[t[u[v[x[y[{[|[}[c\d\h\i\j\l\p\q\u\v\w\x\y\{\}\_]`]a]c]d]e]g]h]j]k]l]p]q]r]w]z]|]~]c^d^f^k^p^q^w^y^z^{^|^~^a_@d_@e_@f_@k_@m_@n_@q_@s_@u_@v_@w_@x_@z_@{_@~_@``@b`@c`@g`@h`@i`@j`@k`@l`@o`@p`@q`@r`@u`@v`@y`@z`@{`@}`@~`@_a@`a@aa@ba@ca@fa@ka@la@ma@pa@qa@ra@sa@ua@va@wa@ya@|a@}a@~a@ab@bb@eb@lb@mb@nb@qb@sb@tb@ub@vb@xb@yb@zb@{b@|b@_c@ac@bc@ec@fc@gc@ic@kc@lc@nc@oc@qc@rc@tc@vc@wc@xc@zc@|c@_d@ad@dd@ed@fd@gd@id@jd@ld@md@nd@od@pd@qd@rd@td@vd@yd@{d@|d@~d@_e@ae@ce@ee@fe@he@ie@ke@le@ne@pe@qe@re@te@ue@ve@ye@ze@{e@|e@}e@~e@_f@af@cf@df@ff@jf@lf@mf@nf@pf@sf@tf@wf@yf@zf@{f@}f@~f@bg@hg@ig@kg@mg@ng@og@pg@qg@rg@vg@xg@zg@|g@}g@~g@_h@ah@ch@dh@hh@mh@qh@sh@th@wh@xh@{h@}h@~h@_i@bi@ei@fi@hi@ji@li@ni@oi@pi@ri@si@ti@wi@xi@zi@|i@~i@`j@aj@bj@cj@dj@fj@hj@ij@lj@mj@oj@pj@tj@uj@vj@wj@yj@zj@{j@~j@_k@`k@ck@dk@fk@kk@lk@mk@ok@sk@tk@wk@yk@zk@{k@|k@_l@al@cl@el@fl@gl@il@jl@ll@nl@ol@pl@sl@zl@{l@_m@am@cm@dm@fm@gm@im@jm@lm@mm@om@pm@qm@rm@sm@tm@um@wm@ym@{m@|m@~m@_n@`n@bn@dn@en@fn@gn@kn@mn@rn@sn@tn@un@vn@wn@yn@zn@|n@}n@`o@co@go@io@ko@no@po@qo@ro@so@vo@xo@zo@|o@~o@`p@ap@cp@ep@gp@hp@ip@jp@pp@qp@rp@sp@up@vp@wp@xp@yp@zp@}p@aq@cq@fq@hq@kq@pq@qq@sq@tq@uq@wq@xq@yq@}q@~q@er@mr@nr@qr@rr@sr@xr@{r@~r@`s@hYiYjYkYlYmYnYoYqYsYyY`ZhZtZzZa[d[m[n[p[r[w[_\`\b\e\f\g\m\n\o\t\|\~\b]f]i]m]o]s]u]x]{]a^b^e^h^j^m^o^r^u^x^}^`_@c_@i_@l_@r_@t_@y_@}_@_`@a`@f`@n`@t`@ea@ga@ia@ja@oa@ta@za@{a@_b@`b@db@hb@kb@ob@pb@wb@dc@jc@mc@pc@uc@yc@`d@hd@ud@}d@be@ge@je@oe@xe@bf@kf@qf@uf@xf@|f@ag@cg@gg@lg@ug@wg@{g@bh@ih@lh@nh@oh@ph@rh@vh@yh@ai@di@gi@ii@ki@qi@ui@yi@{i@gj@kj@nj@qj@xj@|j@ek@hk@jk@nk@rk@uk@xk@~k@`l@bl@hl@rl@tl@yl@|l@}l@~l@em@km@vm@zm@cn@ln@qn@xn@~n@ao@do@eo@fo@ho@jo@oo@wo@yo@{o@_p@bp@dp@fp@np@op@tp@|p@bq@gq@iq@jq@lq@mq@nq@oq@rq@{q@|q@`r@ar@br@cr@fr@gr@hr@ir@jr@kr@lr@or@pr@tr@ur@vr@wr@yr@zr@|r@}r@_s@as@bs@cs@ds@es@fs@gs@hs@is@js@ks@ls@ms@ns@evOIIIIIw@IIe@e@e@IIIIIIe@e@w@w@IIIIIhAIIe@e@IIe@II{Bw@e@I|AIzBpBICII{B?Iw@I?IzFuBtFCiFIcAIIIIqAe@bFIIIIIIII`Ie@Ie@IIoAI}FII??e@e@IIGyEIIIcAyI@CIzBiGw@hAe@IwB?N\AwBpBhEpG@zA??I?hAIIAw@e@IIY?C??w@@IGG?HDaCe@w@_JG?zATDYI?IACcBHIDGA?w@I?YIAIDcBUIIAQJG@DIDBOYANI@@KuCIDQGD?BcAPGAJIYS?NGHABIT@K??AIYAGQe@@G@\F\BHDFISOBaCKDzATI@F?I\FUIT@FDJ@TIVVLDJIFBNLCBSFDSGMHLI|A?Pw@CTDMCB@@??A]?DQBIMe@uB@UCcAFKI?QC?]GVBYV??PCD@PB@UDDKvCKBNILBVMR?GVyKT@`KH]?HUCe@R]NA??PMU?F]F@H@UMUQU\YAe@FoAvCFGPFJFR?OQ?\@?NIGUM@@BFAWJG?KCI?O?PDHMPAHhAI@?WLBKFFRICQI@APL?DK@ANAA??GI@FIXBEJWBXe@?IIIdBwLcAIe@qAIe@}LIdBIpH?qAyHIWRFXF@SZGHXRRGpLIPQU?YM@@DNHKUTX^?BBFA?J?F@]SHMC?]]QC^H@YALDLF?D@NQZ?@GKVB]@M_@PB@B?ASPG@QP@EUAQ@SAYJK@?JE?P@BTSUAU]BHAJ]WOLVTFDWH?ARG\CFDYSPK?UC]F?J^HLFVH@L_@EVAX@BC@X@?XGKTYMQG]H?DWXBLXL@@?ONS@FEJAMXM_@B@VHED@BHOBNSLDYe@MIHFQ?@]U@E@SO]AEASH]UYEEEEZEEEEEEPEIVPEA?VPTHOQUJ[EQ?XC?VJDEAMB?K?KE@OBBWQJA]RL\@@\WEC@CDG@[KUFPAAX???G?LMS]O]LB?FAMPPU?TSB?@ZCNRM?TO@QJJ[DFKFGBXATDSU^L@FMRVD@LJYDPB\TQDZGEEEBUDP[OLAOYMFFBR@FHIAT?Aw@}AIIIaIIAIQuIw@eKIg@e@IABeBpC`DcA_IFBBADUIHK?B\C@CWB]TG@M@XEOMO@KHFNW?ARBYFG]D_@ERH@EC?G\NE?AFHtCRN?PFS]BEC??ACC]TCMCX\MSI?UCVUWBCU?GL@AMBB?JXL@@^CBUKMDJ]X?Q?DWPK[RF@?BLT\\OPV?JG@DTAJ@?@EGLZ\SEA?JCCRHW_@I@CCAFBJK@C@HXOQVU@]\H@R?@CBMLJ@FWUH^QY@QZLCDJG@AA?UCC\B?@^VKCGSFO?NAVOVtAAFKB^XE?C@B@CUMEVA^S@Q[KYF?BKLEFBTMsAWXELNF_@\@@MOBRECKHFMD_@BSMR_@NJMH??L?DGL]XL@?S?A@]EPWB_@@QTEDuCCB[FY@F]NBAAGTDE?X?D^EJPEY@QBJH]@GC@SD@XQKPFATHVNE?WUBLE?AT\@{MDFIIIoAIe@IdBe@xNIId@g@Is@ZIAIOo@?ZJB@@?@JO?@@KXKDJJD\^]X??CB@?OOVADK[_@^D[DF^FKBLBU\SJVOGASJ?QJFR@LCW@GJ?YWB@[?KOK_@SIHDRCAD[CBVL[C@CD?_@@FYO@S[NNE?VQATC?K?E[E?ZHQ^@PQO@TNTKMKGRPEZ@CBEE_@??^ULUAPL@GPLRJEGWBECFABRBZWKFNWSKR?[F?VL@^B?P@@YJF@G[RBO?TXJCOCJWABNUR]GOODHCAJT]@LQL^P_@?HBRGA@F^U?_@@@HHU?^Y^GSPGHZRH@HE\RHCCEMJABSDDADMRKA?B@REWMXFUXBUAQBM@BAUSER?@A^[UDCAAD??M@]?@TSP@XA[ELFO@RQXBPTZuACU@CV?LAW?ES@MERQNUDMEFUVLJWKONCJH?NSG@ED}AB?O[nHIa@pCp@o@Il@A|AaB}AId@g@a@@s@t@p@o@kCFH^[Q^BAURZ@UHTHEYBXHO?PXUMB?N[?C@Q?OBLA?_@ALEBSEZEEEEEEEEEVAEVVV\XEY??GOGY?GZ@@LIJWBBA@@CBFQH@NJC@CNZNWD?LJR@T?HS]BXBGAFYPNGGL@R@BQKA@YD?KA[\ZASSFGCBQ?V]@DSDVAMVD@?FQCLBG?F]MCN@WY[QCK??UB?OSAYIC^[_@XXQPHCL??BCAHOJDMFKBPALJ^BRIDBN@FV_O?C@@LU@M@FAHZ@[DFM@QWOARBRLPHDVv@^_@CPQGSDVWKULFCHGATAFMLJTSES[PQ@?AC[QBNR[K?AFKSKEU?[S?^YMM?VY?@H?LBHYDTFYA?JMESAM@QLBD?H@E?tCBAJVAAND?GSR@CFLYAFJ?ABYWDuAN@DGHLL@H@FWSU\IsAOAJt@|@IIIb@Ia@hAPh@I`@b@s@i@`@b@Ds@BM`@cABCUBF@SuAOAB@[SPM?WHSEBUVEH?E\@SPCRNK]FZE?RZCVFTBW@QPEZD@?ODMA?X]PYK@PCKLR_@?K?KHDMGJP_@QRJOU?D?@J?COZK?YN\WLBMK??DWDLID?R?TXLAAQUKNFUGLDP?PQKPQPDD?@G]@?AH?BAFNCHOA@AOZ@@?D?N@CBM@MHHFAKXHZDBLO?_@GZ?ENHMS?GMESKEUN@_@q@@QCO_@KFP@A@RCG[O@KUA^R]?FTAMS@?D@PRGKCAAVBYM@@QNSD?QRA?LI^NK]XTOBHEV?SRDJOEDBANJQ?N?K??SNYSQN@CBVXNBAEUCBD[NTPGL@OPBD?Y@BDJLY?NPI@BBYSC?LK?G??A[C[VSZSD@Q_@UEE?BD?JOWS\f@^AFK\G@OTGS@HFJLWOICl@a@p@o@g@a@IIaBa@r@`AWa@r@`D|Ha@r@`AAPAHBCC?GD@W?BZ?G[MM^_@B]TKB?BS@_@DHGSAMKZWC^KNF?TLGY??GCAP@SQCJXW??HBV@BCSBROHPWQMAA@F@HO@AHT?DQMK_@@@TQX]MTTVQF@BEBOD^JKQWM[KABR?QH@ERALXHL?]_@ZW[CYKHD@EE_@JMLQULA?\AT@XVARLOFGO[KK?TXM[VMTADD@DUB@v@MAOGB??_@A\?XRCGBK?F^]@YLOAAq@Ef@KXSQD@@D@AKLXOADHA^J@AS@RCD@LL?NRD]A_@VZEEEEEEEDEEEQVVVV@\YSHCF@AWPTVFD?BWPSEMVB?HTKK@ACQ@QZeDAWPBKA^?OD??M^?RK@Hv@MSB[Z@[HCQ?BU^?@??\ARQ_@]C]CTCB@RPE?BTFUAJN\LJ@?@TBUOFAH?GAC_@uM]h@d@r@a@u@cBa@j@]r@BIg@vLIg@b@IIIg@Xb@c@ThDg@S?C@FEWYEL??F_@WYCV?CC@E?DYX?@?EVG\EAJCG@HCNHFXALCTFDA\DU^@B@FHPAW?AG?KTZP[GOBUFATUGM?AFOE@ENAf@D[?CDT@Z@NPXDHHO^GJAA?HF@SRSYS?A@ZU@@@]MU?C[]GOREJTN[^JB@?CJU@?DA][UGLPWU@PVKBKUL_@CCU@V@S@YADBL^ONL@@FDCDPMXC[MRHDRAAv@?KU@ORHTA@NM@B@HZGC]M?OKB_@UKE@NGUAKRQOWXYGLLRRA\FC?L\PDDTBJA@?DBGFAMF?BB]WFO]?UCJBHEOLMHVEL[LXC@GL@M?MEQATLMSGF?GNDMUHRAPFKHR@?F_@]@Q_@?KYEYMTTXC??DDXY@@PUN@AM??K@?MLY@^RXQ@RF^_@]DDBHTBC\kCgDe@Nm@r@a@@i@I@c@`@a@d@IIa@i@c@`@a@i@x@o@v@??@@DX]MD@?B^O???KMRM?GH@X[RJHO?B^HGJRQP[??@CQVAGRCFQNQGEXX@ZPFRKASG_@FRCH@MLJ??\?BAFO@G_@@SXBU\R\QU?_@OZDFHODM]EGO@@N@XS@AADDEHCBSWGQZFRNRN@FWMWF?@H??[GFHME\?WD?X[MB?F?@GQP@HOABSAE\PXYSFU?MQRFLCZSDS@AA@A@PCSYAJDBEC?EXAK?AEN\@^??@\B@H@?LTENYNTJNCK@CA@GVDSS?U?PZ@^A@Q?P??AsA@F@tAH@JJBA?N?BDJIHP_@ZFBCDK\Bv@B]?E?KALYNHBGBFTFNDB^@MA?RD_@AY?KH?Q?E?POAAUGRAASCAIQEB??AMF@E@XDTJ@YEM?AHFR?N?VC?tADDYQUC@][?Ra@H^j@d@r@Bt@l@b@r@a@?i@x@Ia@i@x@o@e@FYu@?b@r@`@a@AU?ASCKFJJD\WBREA@JFP@UGSD@FWC\L\E@@JC\Y?NTU@@VB?V@?K@RYACP_@QHBE@@FMDGTWLBNBVXlOZDEEEEEESE?EEDVVVVJDCQOVEQVf@XBFN]UKQANQ???KB@TA]GTTn@[AJK@MU?_@@DGUTEN@A?QAYAJ@BFVC@OEGDDE[KBAPJQCWGHXWQEKD?Q[AJCB]?PCOAF[NOCLBD@DHAGAPAE?@\KVFHFCU@?HHPX]YPR?AX?@?OKB?HFBBN]AAHCQACM?DFHDSH@CAZ]AFN\X@BE?KT@OB@S^?BJW\JV?EKUC@?@OT?MTHMM[AA_@TDUR??@Q@SD_@HALFP[]^CDBSKCFGF?ANS@VAJ?JVGQ?RBD@EDn@n@P^XDBWWDTARHF?OUDC\?OPYR?_@[[?YLAIC???IhD`@c@_Pb@l@l@IIa@@`@|@b@?|@b@l@w@gD@p@k@PZCWTFVFEJGE@GLNFDBPXRAR@RPVU]TUBODXUB^QCJDN@W@??OGL@^PPJAFB?AAQ?XBEDBCTBMPW@DHB[NZ[GTRCKLT@Mq@^?W?U^ZODf@FF@BBRG\CE?^[CBPY_@A?ODHDC@_@G@DW]MA@CARP@@BLLTPHLFD]n@ZUGGW@QCq@AK?E\??SMJq@JGTFBLQVWF?HMNFACQ_@AF@T?OCBGFMPO[R]CFN]PBSSBBCCFAA_@ANGJNGHLY?R?CDD?RCH_@JAFW\@UEMPKH@B?U@KJ^N@M^YGQD^KCD?RB@BUUZ]]AWELKAF?SDHE?SBX_@AW\QNCAFRGFDF@CDDACG^ANZF_@U[DFCRHHDES?DXLAYAH?S@M@J@@R?DGG?\A@n@W[?EB^VAKOKTBUEDLWA[?SRr@b@l@i@w@I`@|@|@Bb@l@Kx@Zi@a@qPI`@[c@b@l@I_Qe@W?HRF?EH_@_@^Y?@VUBJJFE?C@CT@?DYFNWZRCOONJQE@BDG?f@?KKAMNFTAR^?BBRRC[DR@@QAMMHSDZ?_@SODRBOPBFU?PXJ?FABGBYBEL?BBSJF[BJZG[FNLLX@B@@@C[K@[^?DA\M?GQM@@DBS]ODK?^DF[_@AKF?NCX?SH[?GDBZA\?EAOK^\E@@TF??W?F^AEVD??K\\C@GQ@]C?U?QZAXAFDG\HP?CRC?BZ@LCFPXFV?BAAFZ@@QDG_@SHFWWM@D^OH^WMBC@HOQVFUGGJ[?FY_@VS@ZB?@D[?DBCEEEDZEEEEEEEVEV_@VVNA[VERCAOC@DBB@_@KDFYv@G_@FE?UBNTA[B?O@JWB_@RXXSJK?KH@KB]@E?ZVHF[AG@F]C?DD@S@@^JAVZEHJ@BA{@CKQb@@h@c@`@?t@i@l@o@Ar@b@h@t@eBQCi@l@Ld@`@t@eBVi@Xl@m@IZL@AVT@WGDFU?GDDM@JYBRTR[AMTHJU@@_@PFNF@?\R??PWNOBACB@OGG@]C[NAY@OSNWGDSV?GGHSO\XGPKBVNKL@GOQFCNCQW^ESZ?KN]?NTOCHG@MUL@WJ?BS_@@Z@N?KLUFF[KK@AQ]?PNWLB?eADDDEWAESDXH?ZZL@OC_@EHLC@EV_@L@VYBEQXHK?FPQ?HRPAJ?W@[JDWQ@LUQ?S@@M[NBEVVHA@A?@GLSDL@@NRB@\NWXNR^DMS??DQFWHO@@DZ@ZPTAHVUCBR@EBJ?@?YTWW@FBBYY]?QF?AO@@QCJGZR@_@PKHPFGB?MbABDT@\A@WBRA?Af@Q@?@MGLCDB@AZ?KNHXGJAW?OSFR@CAOJ@CMTFA[N?HKBPD?DDZEANSRRS[PYEBL?@M`@t@uOId@|@p@Ii@Dl@fAc@I`@t@d@b@h@r@p@`@t@?RA@?QPB@XZL[AR@FF\QMBRK@LL^MENBC@E?K_@PDV?UQCRJT[P^SK@MDM?]??KF@RE^?WKMOOH?YXAAUCEB@?HXLN@RBK@PVYAWRTE@GSCEH?WBGBQ]]MP\A@CS@EERCNOE@?BWAWNNSE?FC@L?@?NRF@?APAW]XDLB?@KKTAXLHFPDABVABB@BO@QDKGJAH?NGf@@[O@Z@HYHC@QPLf@SCZODPBQ^???M]GLCBXAT?HWCPTD@GM?]RF?FFA\T@@G@CWMB?A@DOAYMLF\B@BFLNNDLP^TO@WNOBVTRBGL?ZJLF]BUUJTTSADGJRC^@YEDC?[Z?UML[@FCAQS^N[UESN?BD@?AYKF@@NAUGMG\GPU??BQMBSWTH@KZAA[]BU@HGDMGYCBBGJWR@Ib@h@c@`@I_@g@l@o@Xr@p@s@j@F`Ad@b@Bt@~@i@l@m@b@h@M@QL@HY@X@?POBJJPLPAU?SKU?FAY@QNJR?BA_@ARRCQ@QBR?RXF[Q_@@EMVAEXZ??OU?TLK\MPO?FJf@AMB?W@QSUOLUTWBEDWP?KVWWCDES??FMVEEEEEEZEEEEEHVVV?VAJAD[ONEU@BBJFKCCQHXN^^ZNQG@BM?@ECAO@C?P?VPMX@UJ?BKKBULHFB\Q_@YAW^A@?LDA?FKBL@@QGA_@BWNUTRS[X@QHKE\TLBX[P?V?KEO?KWLTS[FPDR?NKMASG?B@J@PHOTFOJ[F?Z][HU?@FF?OWO@ONJ@@GFNAPKUQ@BBA@?G@?^WEDA\PU@SHCKKKO?FJWf@@RAWAC\?UK?TBSLODBYMPFNVADT?RC@FB?CTHNYWBW@GJM?L@KOF@?_@?G^X\?WGD\]?{@@D?R?@Ta@fAm@s@S`@b@y@Aa@fAo@j@`@b@s@i@Ib@Us@iAb@IOAMJSF?KSZ_@GHB@?FAO?AJENGf@DGAPDSCOG@ETMEALBEJM@UBAN?B@CQEND?VCBMBOAGXAXH??SC?BQUPNR@MHCVTFVYSSQCS@NOXDBP@[DHGXHNHROF@XTTNHV\HK@@VGDAK?G?FOYPME?MBOOAXBA@FCQB??DPN@ACGGZWB_@J??UD@LPGR\M^CTUME^XOT]KAFBG@@@ARLCJZU??ZBA]E@?@SR]CHBMON@?PFMJWPL@SE?QU@ALZT?v@^@OAVWU?DSDS@GOXE?N@AB[Y^?KF?KCLA?Z@@?A?@QYXR_@BHHBBKACBJGEEEAXMZHSbA?@DU??_@]LERON@WRPO]EDTBLAT_@NASH^C?YBPYTEHOHED[@GX@MU@FJJU_@_@?TIH?@HA`@b@g@t@c@@x@g@`@b@`AI`@b@s@iA`@b@s@iAb@s@EHA\@DMF[]@?SQKCECA??APCGD[^_@?@V@RbACCSATG?JCFY[XTCJER?HKSCUACK_@@?APQP_@CB_@@BUHPECM@QR^CBAOeD@VKHO?RK_@K@NSf@_@CURNRCKNTXTV?RBLBD\AWPEKT@P[?HQVZE??B^K_@^DT?YOEMM?B?A??C@\DB_@HD^JLAFT?ZO?JHK?DF[RFA_@RBCJAQDn@UQU@D@f@FBVE_@MBB?NZSMHDHUH@Gv@@HZA^@E@FJX?URR@?GPNRLCPAA?E@Y[DGTFBFQDBPPQ?NJG@QON]@KBTEHB\??YMWGCXOEA\BE@@GHD?JB?B@WP^RSDAA?UU@@WQGB?MX@V]B@AVTCC?EEDEEEDEEEEVVVLVVV@AMPM_@RTK@DLRU@LTTJ@P]@{@I^Bl@^d@k@`@c@a@Ke@?LOFFj@b@E@k@^BVc@@vARj@x@b@k@Ij@x@b@k@c@`@c@_N`@KPJWN\BKDGBORU\HBGSCAJTFVX_@D@CB??@XLSD?JHWZq@T^@[FS??KEOKQ?ARtA^AJOVWT?UF?@OBR@EGWVS[NT]ALBCHB@CBGCGWZGFNPZFMWOLB?DTDD@RJC\UZDAS^MQTLQ@LCTCJQRJ@ZD[^OV_@R?FHLBBPBUD]USAGN^eAHG?K@ZDT@@B_@UAQMBOPSDPEJCG?CUNW@]@[YDUA@SNKJYU?@GR\LTW@ZZAEEKEM_@H@FOENJ[TFHNA?ZGCRNA]BCFSADFQTAAQCVB?YOALBQD\CLB??@XMUXC?ZKRCYSHUX@FK?JABLSCMFX?\LBRASBBROB?MA?KMC\MBQ?BD@?PORM?\YB\R@FAD@@K?CM[@RLALNPBQ]CZ@F?O`Ab@r@`@a@j@x@r@iAt@aBl@d@o@c@I`@a@z@Kj@Ux@b@Hk@c@YGOQW?]@MSVNM?BHTBFQCMVBB?MP\JHCXG@GE?EEKAS@]BTND][^?Q[OHRBO?J@UFNT\R\@AEXA?KTR?G?U@^BA\O\DBJCJP?KCQOGQN?NVFMJ?@KMNRBUC?S?GAD@J@J?NAO@JJBCBLRBFP^PQDFNV?ZXB]DF??OQ@FAKR?@[A\JQZ[EDUTOQ?W\ADET?YVSAA@B?GLOHK?N@@YOGMSYYYPCBRO@HEC[_@A@DQ?AJ_@_@KOB??K@H?WG_@GK@DMPf@PXNU@QSWLNGSHODCFAO?V]O?NH?T\UNS?FD@^R?APNV??\R?RNM??CKBBJBHWXUFN?A?WFAQCQQCCN@?VN\YEFWYC?ABF?KO@UN?@VXD@PYA?MCTN@GL?PDFEZ\]]FDXZGvNTB`@a@i@m@b@c@`@c@a@z@j@k@c@`@c@`@c@`@c@g@u@b@k@c@S`@c@`@c@}@`@P@TREJ@CCP[XC@VE@@MSADL?EVKDW@L^ECYAYCVCF?CBM?B@FQQP@PX\?KB^?J?@A@HHUHGLM_@ARQE?\M@BSOAOEGBE\MWDUTE?Y@@CVSMFF@RGJMJY?FMKQQQC\?F?_@@B@FA]CP@MSDS?_@SE]FRGC[?ZNAAAQSBGP@KKAKF@GGHVX?AC?MFE?X@R?VG?@?GXAEEEEEEEEEEVGDYVVV?VAZVXOBKUEFOEK?@Y]Q?XGZ^PJ@OLU?BPR@GFNN^JGC?V@OQABO?KR^E?YMJ?K@NNGJFOQD^TSOCAP[PXJU@?C?TJYB@QREDCJXYWBFF@HO@^RZ@@GK@MAP_@YG@DQJ?C@^^@QQCFR^Z[L?B@P?BKHAMS?@L?XW[X@ODEVM{@G@OPW`@c@j@?`@b@s@KOr@RqAt@b@Jl@RgAm@`@p@y@`@m@`@m@`@t@\?@?BAPVN??DVVLLDTG]PPKHBVEYWRFUUJ?CKS[HA[GLTN@A]ZBRB?MHODABZX\@RE\@_@F?ADC@UGBn@ZDADOTPTbAA@QOB[@PB@_@FXWDBBLP?X@G?DUJZ@O[Q@JED?AE_@YGDFDUK_@GH]L[PS?KB@XYGFSDUUACHOPBZZH?DJN@EKFLQTCNBOZXV?UQGCJUTA?FTBA@?_@NBAAE@@ZVS@ODFDZUY?JDBVZCT?_@D@F]L?@ACBBZ[CCDMCL\XBR?NGQRYBGXPUSO@DEW]@TFXEQPCBDUWMD?H@ZNQBPVQX@?BUFOW]TORCUMq@@QAKALLRO@QUZA??S^WDBZHO\@@@@D[Z[?BBBFM[USEM@OC?OOPVPZGbA?J`@m@Ma@k@Si@C`@c@j@t@b@}@a@b@a@b@a@`@?m@`@m@`@m@}@`@Cc@HW@DL@NAPCOVARACK?XE?@XQOLLAM\N?KJQBDQJ@CBAR@DLW_@MEALBRDLQSHPTZTHCFX_@ZNGAQ?GRBEX_@HOVBO?BVWDN?[DBB?^@EFP@CFCAYBPP]C@]DDT?@DCBJFDZ@[]CWFAWK??FG?EMOCJWHOAJ?UWD?KCBSGJVLq@ZCAEGQAAPD@DK@??@AF?AAN?KVTLVG?Q?AHDNGLUHJVNAH@BNU@GQ?CSYG@_@@n@DJJMCGEbAKMC@@A[_@N@DIEDTA@Qn@Q@TFB\UDP@_@@[@B[L@EDPFJDCMDH@AXACAHFJRQ@@J_@G?LRJB_@LACC@M@@GTMEA??DENF[N@A?@FWTHYMSERDHDJ@?N?_@EBAGU?CZM?B??_@C@?ZEW?IC?i@c@y@t@k@i@`@m@`@fAg@c@j@i@[c@j@p@y@`@m@b@SMNOLDGXAQ_@OSBD@@@VA@YHA@OB]OE?CPR_@AKT@NZ^?KbADOF_@JK]@S@ZCQHWXBRMCSS?XZUSHBVEEaAaAaAEEEZEaAEEAE?EECCECA@@P[PCF?U?U?@@BEJ^YOREAYBOPTT?P??R\K@JLZD@NK?BDU@@WMC@]@NZZEC[BRMKRFQNEK?HRNVXJHVB\DACGCASCQDR?DM]@[H_@AQCZARDDRC@LBBM\?n@JG_@\F[XB@BQOGQDFCAE]NG\CBQMBC@QX@?Q?JTF_@NTXTJSJ?LBL@LZRELJ@@XWLQYKVE@XLNDBCOMMXC?CJO\RDHLEAAA@B?MACDEQY_@[AYHS@L?XR?D[B]?KDV@A^@^DDOSABR[EGPCJHBYHAGHYFOEDGBA?D]BBQMC@JV{@b@h@p@a@g@Sy@k@c@wAg@y@d@b@a@vAg@y@d@b@s@@BF?A@][GUA??EPD[L\FDBEBHQAALHFEW@_@FJARN?B]SFFKOQ?E]?ONAPHZBBKMPES?UB@TF[BJA_@Z?NQ_@D]C@BTOR?GGC^DPWHZCNG?SBCHZDBS?DZ?AWECZV@PBCB@_@FL?KFUAXECEJD_@\?BOBBWH?EK@\SAKCAWEMA?G@D_@CU@@@Q\T^@G]?\WFBO?KGLMQON?GZUDY?KJ\YOF?Q@?AHMSDE\]@O?ZW^@H?F?CFK@MHA?JRDG[_@]\D?CLFQJH@TXN@?VEOWZf@R@UGDHOESZT^@HJ@UaAJeA^E^FK@B@DM?NO@W\G@?V]OACHHOHB?OAEP\K?BCW]M?]LLC@OD[ZKLG@YT@ARXWDDHHOOf@GJ@T@_@D@AMKM_@?C?DPT@NJTFGFh@c@`@~@]l@IBc@QgAt@u@d@b@h@wAg@y@d@b@h@j@x@NF[?UNMPS?F@A[DBEUAC?KV@VGE@GFJZOVKLHTRXNXEDQ[LT?FCZMKBGD?NAE?K[\?UT?L@Y^@RBEQ\[HGPDQD@Y?KB@JZDDNFAFUVU?WO?EWFGSZ[QHSMDNLFFBV?KHJQFCKJA@C\[HKOW@G?UKAeA@@O^^LHAYWDEFEL??EJHRYP?\J^SCNE@@QU?HBEPD@_@M\AGn@PFLT@EKU@BNGFOYMVn@Vf@BBQDR@TQCAK?UCE\A\BA@NGC@DQJQ@O?GKM]]N^CW?VBH@CXBRV?@??R_@ZZ@MCBZGB@OJK@STFFAVNAA[RHG@M?UF\D_@?SB@@PJW]BGLB@AGTOGVQC?QFVDVEEEEEVYEEAYEEVE?EA?@M@[\@B?@DDAADB@JBF?XCD{@Ip@_AvAiAo@g@a@h@g@wAc@u@t@h@h@g@gAd@a@h@c@Pu@[LAT]CDBC^H?BOCNHDA_@N\M?HSBK?F?QFUXDFX^^A_@ND@@HFC?@RC[T?KZAC\\M@B@GERDC@CFM@EXNPXDAABTBBPEC?PVERCLYAHNXHOFUQS?C[V?HG?P?[Z?]JQ_@HOSE@RNA@E?JTVGNN?PDHHSH@LMBB?NV@JWCANRS?E?FCVQ?CEJ[@ZEJYF??UK?BJBFRHP^F?_@_@EWQVRFUEM@DSDBPXDUM@n@TJ@E?[B?KB\BR^?@@SD^JW@EDF[?FW?GO_@FKUP@JJ@_@?KETEAT?DNSDGJPZFAASC??H^LRF?^B@SA[F@V_@@ACGACEKSWXSH?GP_@D[QC@@\G[^BF?\?TFC?M]E@EB@QAMF[UXOGB?BWPVL?LJTBA?A_@e@t@h@l@a@c@u@s@p@_Ac@o@g@gAd@d@a@h@g@gAd@Sa@s@p@ALBFFTEA@TVRC@V?A?^QAS@BDLSDXKY?F@UVQY]^AREFS?]O@CW]T?K?VGXE]@U?C?NSDHFNM@OYRZTPMPL?C@EBDRM_@NE@QWGXBMCE@?B@Q@GFNAPT?XARPKFEDRSCF?SXZAZU?[@@ZD@H@GBWFE?@PA_@GWE@MBSSDDS@P??RJ\_@ENWK?AB?KGFBFME@BQn@M_@D_@@JFDOM@@BBQGDFJ[VV@GBZMBRAL?LL@UDBC[]f@CGn@Z??_@AGHQECTLFAXN@QCWME@_@@?@E?OBE?EPJWSPBq@K\?DKSGHEBC@[_@MHY[^JC@YBFLSQSFD]F?M\NS\YTB^FL@@@B@@QTU^PA?_@\WATDJHBQDTCT@f@AW?JZGPWFNL?F?BBLGSc@m@LwAp@_Ai@p@Ah@g@OgAc@u@t@h@h@g@gAd@a@h@g@Nx@a@GNKAATPBYC@@?EEQTWMLOAN^@NHMG@GK@DQKKYBSKPAYWJ?AA@FO?K@DJHFGC?AZMCH\NAHCGKTRHSEF?X\NNG]L?JAE@HKF?@FXVBHAV\@@VMRT?F?HGCFW@OAWFY?K_@@XJE?C?@OSN@Q@M^B@LZZJJGCLKOBF@GHJJKJHE?PP?\OEHGRKF?FA]QPOZXSSJA@CBB@KBFHDJTf@?q@APZEBNf@FTCCDG@L^VEZDYEaAEaAVDFEE?EEC?CEE@??MHVD@JG?P@@L@DD?L[N]ZAW@SBFFLDT_@E@?KCZJD\PPDLGPSQ@DSO@HCJ_@RW^ZAFXEEGSS@KEFDMYMBN]WW?FPD\JPEVVU?HCQEDDS_@LAMME@JYAROL\ZBRDKBKH?{@Zd@b@Fk@p@Ga@~@y@_Ac@p@`@`@}@`@`@`@`@`@`@}@`@`@ZP\JMFK\FGFRLD@]?KWSGPPPJYER@@QHL?CFB]E?[@ZJ[ARA@F?@FSKBA@G?[CAPAXABOE@?OCSC?CTN@[DN]^NEY@BFE@?P?URCZ?CW?AX@MOSQACL?D?GJB?ENDAMAC^?Z?OLC@WL@TBKPF\q@TWBYJFM@DC@BEGFWKP^ZAL]n@QSCO?@G?CB@V?PBXARPEAH@UC?PTSRWQYUDX_@NTAF?KQ?WBEDeAQMABGWZH?_@@HF??@]LHL^O@]D\NAOC@PB@C\HTDWBZF@VOZRCDDP]SRD[BSFXBXS^@V@GDEFAF?[XDF?WKFAXQGEGQ?[@@JZVXBZF@NRPDSKF@HNSOH[HXABF_@O@P@MD@@?JR@@Y?KPN\SEGALf@DmQHm@g@l@b@Do@p@a@~@s@@b@o@fAc@i@j@y@FD_Ab@LZo@}@fAc@w@VHVXBF??NOMQO@?UTX?^HOYDPB^UGAMUF?K@K\HGC_@?XDBUn@VVMBMUQEHA?@@AOJMBH?VW?BA?@ETAQL?ZSADHNDAJFLHY^@@GF?LZR@^HAE\YGQ@^JF?HC@BBC]O_@Z]GLSJKCN@CET@C@SXNWq@^JOQS@AD?KFGUDOO@A_@AV]CBH?UATEF\R@?U?PNPVNGRLLA@EAHCOK?L?MA_@^AODLBKAR@E?EQFGQ\_@PXJYH@GAE??H@G?OS@WAAPPTQL@B?J@R@L?J?EJM^AJDD@O?NCTY@QFQ]OQJ\[?TFV?KSASAQS?BATOVNN]?@?QY[@DCWM[S@@LDMCV?VC?AAR@v@CADBCHK@YRN@^EVTKP?AKCCXFB??BMBPj@_@y@b@fA`@`@vAi@j@Oh@|@c@p@j@y@_Ab@Fo@x@d@~@Ds@TEJBA?CP@K@@PPOPZEB?UEPE_@@EUCX?HNNUMDB_@BRKQL\W??SASE_@NN?PCWG?TTL^AC?LNBG]F@TWTXT^PGGGVARBDLF^TLTDMq@@VB@?Nn@EEZEEEEOEaAE@EEEVVAVVGY\?OLW?GBT@]?QODXWAKAYP@H@QBH?C??A@XASAUPW]@QGBCFTFAU?]@CACCA_@N\QBZ@HC?BO?[HOFM?Aq@XXHE[KUSFDL?UDF@LYPN\Av@ZHB?EB?HFABD@T@\PAZAREFHGBBY@EE?LK@P\WK?CX^?B?TBBAYU?O?NoAVXT@E_@NPPL@?@TBCPBL][DBFCYJVLH@@CRGVNJAO?NA^?RLBZSDGGSDJQXHDA_@WBUM[@QCSHG?UABA?GJAU{@Aa@k@_ADAJ}@p@h@g@`@c@`Aa@k@k@Fj@`@?b@z@l@?`@c@IBHKRGFLPRW?[]M[GUDTBYOCU_@^DH?ADY?H@UY??Y?KUGJB@AWA^TABGFDFQCTF?MAFG^PZALX?GFKBG\??S@YWBHYP[DFHDGB@TSX@D^SHX?WAWZXS@?OYEBSH?KCNE?JA^PEFT?T?ARECHEYOL?J^\MWFXRUHJ?H?AThASFD@WFWXAWLBGLDP?B?CRH^N@HSX_@FJWECKEOQTJHKCJA@P[@?@\H@Q?@@T?W?AN\JCHR@QYCRS@SUSMFLERPWJDXJ@DBGLBBE@Z[F??XNTDB_@]DH@GFHEW^CO@BBZWGLUBG[B]?KBW@Vf@CFAM?DF?u@a@p@@d@i@a@k@j@z@c@`Aa@a@k@j@`@b@|@l@`@PCCG??@A[OPAJYSC?KAMDC@@HO@PV^EFB?RC^AHOCMBMULRMBCA?MKYEULFFJ@TFA@GA@ADNT@ANFCABFB?ELXEOAL@MPS^HHHEM\TVHCHFK@\??JK[F?G?MF?VN?QJFL?ND[FN??QLYTPCGQAVA\LQO]BSAE]K@FQBOPB]K]Q[HGDSCBEPNBEEVMH@SF?EXK@?Y[FCOT^NACM@HFNBDAGLf@Z\VHS?HEJ?MLE[FXA@?T[H@AHLUH?WZKT?PO?A?NQCCNLR?HXFJB^ABUHH@@XA@MHE?]EJ?HF\@GLXKQ\BDRBNN@MOUC\@?BFMLCA@@H?XAADB@KJC@HNQJSF?[ADAF\EM^RQHO?AWCGWL@EKN]?NV\???@?ASCJC@\F?HNARZHF@TGNAJ`@b@Di@`@EMk@j@~@c@h@g@`@b@b@z@c@`Aa@k@iAd@IQC?DPXRJTF^@CDWJ?MLHKKCBEAXEQOSGYD^EEDDEEEEEEEVV_@VVGVJ?\]XH@BKEDBq@O?@?BMM^FQ^Y^@bABBGGTAAHSF[^CLPAM@OSP?@@HGJE?OSLDA_@NM?KSABGFC^GLE??GMMMAA@CF@HQW@BRDZXHY?BNY?HQ??E\LBRCQYKXFO@[n@A@MF?BHOLLE?NC@^T\\P@GCE?OM?EUO?JEWXDBBAPOLBM@KTF^TF[?EEA@q@X{@|@a@u@c@a@d@r@g@@b@c@a@Tk@`@z@m@|@b@c@a@^XZF?JO?RA?QU^F?T[VCH]Q@_@ASR?CW?FGBO^[B@CJAq@\BSA\GGUHBE@GAPFCD@W@PLNAW@EQC@AMCG@BOXf@]AC?ZAUBQUEAZA@GCFVCCMGAN[^@GE?DF\SGGPF\q@MKB\M]KHDBSN@GCT?VVN?GA\??KNBB@???SWCPJ@MOU?HSH\BAJSQCKAB@?XAKHFK^K@FY@[FDJJE?FNAKDCJDBHADC[O@EA]TR@TJKH@M\KF@S?PEN\^LL@U?YDPK?@?RR@LWY]P_@RDCCJGEFTJJW@?BNUNA^BBBUB?JH?@RDEWZL_@A]W@DAUGPCE?COG@CNACAA@OB[^A@CEQ?Qo@`@i@Nb@`@}@d@Br@Tg@b@c@}@a@\j@b@c@a@j@~@u@?k@YMN?FD]ZLD@D??JJD@ASMOXH@LALJD@BD]@VB@NBJ?RXGTCXSUP@DBAMP@EP?LNKDLAXDBCVF?VRAO@TJE\f@COG_@[FO[Q@?SAYD?@_@MLEA?B@CHVF?_@VBKGC?[DAAQPGB?ND_@CJFR??DDM?]]SE@QCPVEAGALD@SYL@JLP?HH@KW\@M_@C?R@FGEPNBCGeAT?DBAW@VBSQ?TEAE?UK]WCUACX[EHRC@CDFPGSP@]?@A^HAMPBFG@?A?@@EX@MRG_@?WAGFC?B@?P?W?KFLMVUCEVeA@HCCNCCNJ@JEB@N]D?ZD?H@QW?@JS@XCGO[DC@_@AHT_Rd@c@A~@d@`@Bz@Dm@`@Kz@m@a@j@Db@c@a@j@~@u@k@SY[CVGEBMv@JQv@SKHCDXFHGHXG]L?M]YBG?Y?BLA?DASYIYBOMHHQO@ABL@XFYT@?NHE^WG?KBSOJ@SPTXBAJq@CH^BSC?BEVABJYBBZE@f@H?KMFGL\SGFNPFL\BBWRC?D?\DNHYOGXME?F\A?FK?FCMK]EVEVYDPEVEETEEEZEEXCCNQ?VJ@M?FH@LTZ??@QAASAAOD@RW@CB]C]CWQMEMHECAEN@MSK?QFT@PCZNKB?EC?AP?M?G@F?@JMMCA?LFPPOS\YBUB@RMDRGJAQKOJ@WYBY?B@UCDSZBRYWDEYWD\BY?CKE@H?LPLJEMDXNBMKXUDRT?UK@\AWAFDY{@Y_Ab@h@c@c@X`@`@z@FLs@i@i@o@Zh@_Ad@d@d@a@a@Ra@BRBTEEFAJ??JAJ[\DCR@C?BB@A@ENV@QVAL\RMSD??OKSBA??v@UYA\JAD?LHBGQGQSX\AWSCN^Y?VES@RCGHH@NBAOBKPJA\PBEBL?@BU^KsAPFE[PBKMGB[QU?FGF@WQAHD@[YU?A?X?RC?CHWAU?N??_@RJRCBA@?F?@?YZG?\D?KYML@R@PJCA@FENFZ?FOEMB?^TSY?A\]@@CPQOGBAHE]CBMFXGL]D@]V@GDBDDf@RLECXMOBMCBUXJB\GDWGHRQNWENDQTKRJ[BA?SCDE[K^E?@]DE?L@A@JAD@@]FWBGLQ??YCB_@W?X?SGD@?J\L?G?C[@]m@g@l@m@Bb@b@r@[c@a@Wa@a@F}@a@a@a@a@a@a@b@b@b@CTA?TN[U?U??Q\CUWf@SL\XABOWRQ@?SLXJG?NF@^EO@MUMG?THCFEWM[?@DKN?TTPFBR[HRLSNVJU@FURAL@_@HHAYQ@QBP@XHBB@CGWADB@RAAU?DC\JMCBC@??^DQT]PZHQC_@FTCM@CF@?Z?CB]KN^UAE@q@FDRC@E@NE_@CB@M\U@G@A_@BUOSL@XHX@GBS]A@J@A@BA@QDCBBDELM_@A_@DRCNNGRDHQFQ@?[HOv@GAAM@ABDS?@TFLHUE_@KMDAZWHPOBCLNUD?BU?@L\WP]YDNETZTS?CBEOKKMS\R[TJGKLZELVGCSDBNWA@WPQ@SBJBELJV@Q?@DA[]@JU`@`@a@?z@s@`Ax@k@c@o@h@h@a@a@a@a@a@@b@b@b@IJ?@KEQM??ANBGK^P??DWSHE@SNRCAF_@J\EDA@?F?VFHT@?RJAGFMNNF?PL_@DBRQ^BS@]FMWCUJ?@X?HVGLUT@VAE@PJFGGXN?N@FSR?US^P@@G_@JFKMC\?I?E@G@OS\_@U]V@HEYMADR@ED@?B^J?]_@VH@WNEQKK?EVEEEVEEDEGVBVEZEVEELJVY?OdRBDCCM?L?ALHCVDJPPGX_@C?EP?RV?EH@EBM?A?PG_@QERX@L?@C?WF_@L_@KF_@EFf@G?VLB?E[BBUMYD^TFuAGN@OB?BBR_@?C^[FB[CBCn@AF?RGR@?GJW^CZPAF?QYMUQDBBBK@SAU_@_@XEFJJL{@A@@z@`@r@HEo@Ry@CDj@Ra@a@\c@d@b@j@a@c@d@c@o@y@~@A@ENXBKVZTRCGELCCq@?]DT[P@O@@[VO?T?UU]GN@GEDAZHM@NALBUCDHCFVTXFA@NTFL^?@X?@TDEZK?GLAn@^C?TZKACHSOQ?CN@@F]JJCGDLP?]DFEL]QBQMXSJBPOPG??J?_@KX???RC?]VZ_@GSLFTEJNJNBFOKDBKE@\\QECHNW@VG?q@BU?RSSVABE?HW@[[U?BGAC?CBF@B^V@C^JW??T@RDSR]CTWRQ_@R?GXYFAHHF@R@ZFF?FPSD[?AAYOTR?CGF??ZB?J?CP@ZZ[MSTE?DCEYEG?KN?H@]AJW?@@H@CLAEGFE^DDBAJP_@X^G@DHALHDOtQ`@|@b@x@c@o@y@}@`@h@u@d@i@`@h@u@Dk@x@z@\KG@[A_@MQLLD@M?CU?OTZEFDJ]]?JJESN@DBTKM]X[E@C@YGG]^FAJOHHH?JCPC@FRX@n@QC[A^DDHS@A@GA@@@GXND?XW_@EON@?K@\@@BHZZZAQGVASK\TLQKU@GJ?@MVD]RONUDBLQNDSB\KCFWMCHLCAAYB@DCKT^DDBAE\?KYME?FRJC[@GHNOL?P?DYMTWSR_@?@LPGE_@DHOOPVRMCATQ?@ZSHPRGLN?KAOv@@LNKROAADCDNK?_@ARTA?WGLETDJBUOAFADC_@_@B[?HOU@D@M?CNBNC?HVVEP?X?GQW@@ODABFMB@^LN@JKDBBX?OCAS?AUONX_@QwOFa@Rp@k@Yb@_Ai@`@`@h@u@d@i@`@h@u@k@Ex@Dz@`@@PFCZU?ABPMD?Q@YJC@Q@ARHOT[RAYKBGEDCJAT@WSHBYTG]FDPE?B?AN\@QKXC@BELM@YCTJWCUJATV?HROFSDPQ[?@YEFaAZ^HOBECODAESWHJHM^KFPZQ@RP@GBSAM_@Hf@H?ZFHOBGORVO@Q_@[?WNJBE?AHKTCHJGBXZNBPZEF?D@ZUDEVDEEEEEEEEVFVVVV?AMM]TRQR_@BUQSHD@RRVP]ZM]^QH?D@@@RLCCC]_@YNAEJB\TDL@GADQBLTSZANOL][^B?QNL?CF@G@VPZ^XSTPYOT???H@?CBOJWVMCH@M@PJC@Uf@TR@LDZ\\J@C@XJDLH?TUA@v@NSL{@[`@d@a@k@u@`@_@m@Fi@Kc@j@s@r@g@c@j@y@`@m@QSn@\D@VQBRYHFD@XXA[CCBIIAIBICIDIEIFIGIHIIIJIKILIMINIOIPIQIRISITIUIVIWIXIYIZI[I\I]I^I_@I`@Ia@Ib@Ic@Id@Ie@If@Ig@Ih@Ii@Ij@Ik@kBa@yDc@{De@}Dg@lBi@`Ek@kDJlDLmDNIl@Im@In@Io@kBp@Iq@Ir@mBKIs@It@Iu@Iv@Iw@Ix@Iy@Iz@jA{@I|@nBOpDRqDTsDVhB}@I~@jB_AI`AqBSrDUtDWiBaAIbAIcAIdAIeAsEToEWiBfAIgAIhAIiAsBUtEXIfAtBjAIkAIlAImAInAjAs@iEu@IoAIpAIqAIrAIsA~Et@jEoAItAIuAyA|@nBl@fEn@oB_@zEVhBXIaArBvAIwAIxAjAyAIzAcFMnDOjALdFm@gEo@jA{AI|AI}AjB^yA~AI_BfFWuEbAvEdAxEPmFMlFPkFNeEm@nF_@oF|ApF]xD_@aEb@zDd@|Df@~Dh@_Ej@rF_BxBXgFbAIvAhFxA{AaArBcAwEeA{FbAsFeA{AfAtB`BIaBuFNoDP~BgAIbBIcByAdBIeBIfBkAjA{ElA}EnAxB}@pE]yBl@eFo@_CO_Cl@bG_@_GeBkAbB~F_@dGm@vBu@kEw@mEy@vF}AqF_@eGfBcCoAaFuAhG]{AYuD[wD]I_ArEPbCcB}BcA|FPvBgBIhBIiBoBjB}BvAdCpA_FrAmGdAqGwAsBkBIlBImBInBIoBIpBIqBIrBIsBpAtBIuBIvBIwBIxBIyBIzBI{BI|BI}BI~BI_CI`CIaClAuByGwB{GyB}G{BgCbCIcCIdCIeCIfCIgChCvBzGxB|GzB~G|BIbC~AhCIiChHwBcHzBkHbCmHiCmAxBjH{BiCjCIkC_ByBdH|BlHcCIlCyBOdCtAmAmCInCIoCIpCIqCIrCcGPqHzBoHcCIsCItCIuCzH{BiCcCIvCIwCIxCuHnCIyCIzCtHuA}H|BjCsC{HuCrAbC~AvC~HxC`ByClA{CI|CI}CI~CI_DI`DIaDIbDlAcDIdDIeDIfDIgDIhDIiDIjDlAkDIlDImDInDIoDhCpDIqDIrDIsDItDxGsB_BuDIvDIwD_BxDIyD|Bi@cCv@lEx@nEz@kA`BsHPxIw@gGz@jFzAsGeAnGhBoGo@IjBfCPkAhAtGxAfC_@xAzDI{DeC_A{Ix@|IPaGm@`G~@eC^wFc@bEf@wIj@bJ`A}IPcJn@fGn@qCy@xAq@~IiB`CkA|EmAaJ{DfJd@xFg@dEj@`JiAeJ_@jJo@dJ]lG`AxA|DI}DI~DI_EI`E~BaEoJnArC^lJr@wJlAjGZvD\qE`AzJ[kG^mJo@yJmAhJPpJe@cEh@yFk@tJ}DuJ_E~JnAiJo@aK~DvJ`EkAbEIcEIdEIeEIfEIgEIhEIiEIjEIkEsClEImEInEIoEIpEdK_EkJz@pK`ErJ_@qBqEIrEIsEItEIuEIvEmKmEnKoE}JjBrC_ArGqA`FsAcK_@qKrErKtEtKvEvK`A|J\{JPnJlA|KmAzIaBuKnEoKpE_Kf@gJk@xJ_@}KnA{K]sJPbCwExC^`L_@`CxEIyEIzEI{EI|EI}EwKrAxC_AfLsAxKsEsKuE~Kg@qJk@yCtEhLh@aLyEbL{EdL}EgL`AzCi@iLuE_LfBjLzEcL|EeLPmLj@nLvElLPzKPoL{EkLPqLk@pAlBuG~EI_FI`FIaFIbFvIyD|BcFIdFIeFrAfFIgFbK`ErAhFIiFIjFxLiF|CgFrA}B_H_CaHaClCcCeHeCgHgCzL~B`H`CbH`AdAdCfHfCdAkFIlF~C_C|L`A_MeC`MlF`BmFInFmAoFIpFlCjCdAlC`BoCwHqCbIzCrL|EsCcEfKeEhKgEIqFIrFIsFiM}EmMPyCtFIuFIvFIwFIxFIyFpAzFI{FI|FI}FcI|CI~FmC_GoCqDqIsDsIrBtLg@lBcFuLeFyLjFaM`C~LPdAvChIdDiIfDkIhDmIjDbBlDnC`GIaGtIvD~CbG}C~DfMkC`NmDoIoDmAcGIdGaD`GwMrDrItDyMh@IcFzMaC|MwCjMdEgKfEiKqFlMsFiNeEkMhEkKjEwCeGIfGlNfGqCgGoMvFqMxFfBfEjNrFwCoE{CmBIhGIiGIjGIkGgC}B{L`CeNdGaDnDpIPmAlGImGInGcDi@bN_@gN`AhNxCcMnFuNoDwNmGbDsDxMsB|CoGIpG|NPfNaGaNwDoNgEjKiElKkEdDqFnAnBvGpBwGrBdAhCeMpFgBtDzNPbBqG}MeDjIgDlIiDbOrB~NpGdAsCdDhEkNkEmNuFpMwFrMyFiOvFnNyFhOiEmOjEfBrGIsGsM{FtM}F`OrFaOiC_D}CdI_DeIaDgIPfOsBdAtGIuGyNj@{NjFgBvGIwGIxGIyGtNaCoOsGrOsFnOkEqNpE}CzGI{GI|GxOk@gMgCdOfD~MiDcDcFgOtCkOwFqO|FcN_EbD}GI~GI_HI`HIaH`PdFoCbHIcHhPeFfDgDeOjDiPcHnAdHiHyBrHbC~AsCeP~GfP`HsO~CmC`DfIbDaPuCdP`EgBeHIfHIgHIhH}OrFbPxFsPyFrPsFnMuFjOxFoPfHpPhHmP_DtObDtPvFcP}FvP`DnPP~O{G_D~FvM_@lP_HgPaHzP_DI_G{P`H|P_G}PaHuPgHyP|G~P_@yOwGzOyG|O`AbBiHIjHaQjHiDkHIlHImHInHIoHIpHIqHIrHIsHItHxPaDvOuGcQaG}NnGlAuHIiHbQaGcOfB`QhHdQlHeQnHgQpHiQrHjDvH{CwHnImDdNPhMpCxHrCwPwFnAxHIyHIzHI{HkQbDuQPjPhDqQxFvQiDxQjDnA~EsL|HnCnDbMfCwQyFkPwBImCvHmFdMjFzQgCrQyHsQ{HlQlDyQoDpQiHiDxG{O~BIbGzC}HnQmHfQoHhQqHjQsHI~H|Qj@pA_II`IIaIfDbIfBcIIdIpNsFaReIpOrF}QnHoQqH~QtH`Rk@bRsG{QzHnAhGrNjGsN|BjCtGmBfIIgIIhIIiIIjIIkIcRrHjD~H?lI
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????B??C??@W??F?D??E??P??gH?F??G??P??s@?F??G??@A?OB?H??G??PI?[W?H??I??PL?cY?J??G??@?????K??A??A?????L??C??pS?WC?M??N??@U?wL?O??P??PJ?sC?O??Q??@o?oJ?R??S??@A?SG?R??S??`C?gG?R??T??P??sJ?U??A??A?????V??C??pA?Cs?W??C??P@?kf?X??Y??@V??F@Z??C??pH?_O?[??\??@@?k`?]??C??@B????^??_??p??GC?`??a??PG?GC?b??a??@A????c??d??`???J?c??e??`N?GG?f??g??`@?_fAf??g??PI?_hAh??i??p@?Co?f??A??A?????L??C??@M?KC?j??k??@A?cE?l??k??P@?GH?l??m??`I?CG?n??o??pr?kG?n??p??`d?OM?l??q??PY?KR?r??s??@A?sL?t??u??PA?Ge?t??v??@M?Sf?t??w??@??su@x??A??A?????R??T??`E??K?y??z??@D????{??|??@A????}??~??@B?__?j??k??@N?KF?j???@?@S?[H?@@?A??A?????O??Q??@A@sK?O??A@?PD??H?^??a??@B??C?B@?C@?PD?kF?X??D@?PN?sS@E@?F@?`??g??G@?H@?@B??T?I@?A??A?????O??Q??Pf?cJ?O??J@?`L?sL?`??a??pB?wB?c??K@?@C?SF?h??i??@C?Co?L@?M@?PI?wmBb??a??pB????O??N@?@W?GN?O??O@?`??cO?P@?Q@?`N?CJ?R@?S@?`@?GA?b??a??@B????T@?u??pA?_D?T@?U@?`L??D?P@?A??A?????T@?U@?@F?sC?T@?V@?@@?[B?W@?X@?P??kd?Y@?Z@?`B?SE?Y@?A??A?????B@?C@?pB?gF?B@?[@?`@?GE?Z??S@?p@?_H?\@?]@?@B?KY?[??A??A?????B@?[@?@??GE?Z??A??A?????O??O@?pA?gO?M??^@?P??WH?_@?A??A?????O??Q??Px?GK?O??`@?pL?_G?O??Q??pr??K?c??a@?pH?gN?c??b@?@L?CT?O??J@?pM?wL?c??A??A?????T@?U@?PG?wC?c@?A??A?????T@?U@?`N??D?P@?S@?PF?_D?O??J@?@T?wL?c??S@?@O?[D?d@?A??A?????^??a??p@??C?e@?f@?p@????g@?|??P?????h@?A??A?????i@?\??@@????j@?k@?`D?GF?l@?m@?@I?_B?l@?m@?@E?KC?n@?o@?P@?[I@p@?o@?p??wE?q@?r@?`B?[M?s@?t@?@??OC?s@?A??A?????j@?k@?PF?KF?l@?u@?@S?SA?l@?v@?@B?CG?W@?w@?@C?gp?x@?y@?@W?_F?z@?{@?pF?SU?z@?{@?`B?gQ?q@?|@?PD?KJ?}@?|@?P@?GH?}@?|@?@[?WG?~@??A?@C?Sn?@A??A?@A?{B?f??S@?`@?cU@f??S@?pP?C`?}@?|@?p_?WG?AA?{@?@B?gH?AA?S@?P??sF?z@?S@?P??GI?BA?S@?P@?_D?CA?A??A?????AA?S@?P@?cD?DA?A??A?????AA?{@?@??gH?AA?A??A?????AA?S@?PC?oD?x@?y@?`Z?cF?AA?EA?@G??A@AA?EA?@V?OB@AA?FA?@A?[I?BA?GA?@A?gH?HA?A??A?????AA?S@?`A?cD?DA?S@?pA?[A?IA?A??A?????AA?S@?Pa?CH?JA?KA?`B?oL?LA?A??A?????AA?EA?`FAgF@MA?A??A?????l@?u@?pN?KA?e@?f@?P@????NA?OA?pF????PA?OA?pD????g@?QA?PB????RA?SA?p@?k\?RA?TA?pC?w]?UA?VA?pK?{T@l@?u@?pS?SA?WA?s??@D?K\?WA?s??p@?W[?WA?XA?p@?ON?WA?XA?PH?sM?L@?YA?`@?cXBL@?YA?p@?_ZBZA?A??B?????l@?u@?@P?KA?[A?\A?pB?K_?~@?\A?`??kA?~@?\A?pF?wV?~@?\A?PP?CV?l@?v@?P??{F?n@?]A?@A?OYAn@?^A?p@?kr@q@?^A?PM?OH?_A?^A?pB?OB?z@?{@?@C?GU?r??S@?P@?kE?t??A??A?????z@?{@?`D?KU?`A?aA?@F?_^Dj???@?@A?sG?bA?A??A?????j???@?pB?{G?cA?dA?@@?CU?r??dA?p@?wI?eA?dA?@??[|?fA?A??A?????T@?u??`@?_D?T@?U@?pK?{C?j@?U@?`B?{C?gA?hA?P@?Gm?iA?jA?`??G?@kA?lA?`^?[]?mA?t@?`G?oI?mA?nA?P??KK?oA?pA?P??{P?oA?pA?@??GQ?qA?A??A?????j@?U@?PG?CD?rA?u??pE?[J?sA?u??@C?KS@sA?tA?`R@og?uA?A??A?????X??Y??`E?GE@X??vA?pc?WA@E@?wA?P??w@?G@?xA?`D?S]?yA?zA?`B?gc@{A?A??A?????P@?S@?pA?WD?T@?V@?P??[B?|A?}A?@@?KL?f??}A?PD?gn@f??~A?`A?cr?f???B?@E?CN@L@?YA?P??C\Bl@?m@?PC?CC?[A?@B?pB?wb?[A?@B?PB?Oa?~@?AB?P??kA?~@?AB?PH??Q?t??v??@D?Kf?t??BB?P`?wj?CB?A??A?????}@?|@?P??OF?DB?EB?PA?[C?}@?|@?@Y?SG?}@?{@?@l@GQ?FB?A??A?????AA?S@?PN?OG?GB?A??A?????AA?EA?Po@?F@GB?HB?@??WF?x@?y@?@b?{F?x@?A??A?????mA?nA?`D?[K?IB?JB?PT?G^?KB?A??A?????G@?xA?`@?C]?LB?hA?@@?GS?MB?hA?PA?cH?iA?NB?pB?gy?iA?NB?`u?[j?OB?A??A?????j@?k@?pC?GF?rA?PB?@@??J?sA?PB?@B?{e@QB?A??A?????NA?OA?pP????RA?i??`@?KW?~@?\A?pG?{V?~@?A??A?????@A??A?@??{B?x@?y@?Ph?CG?RB?A??A?????sA?tA?Pe@oh?SB?A??A?????G@?H@?pE?GT?l@?m@?PG?OC?n@?TB?P@?Gh?n@?UB?p@?oV?q@?UB?@D?_L?x@?y@?PV?_F?x@?VB?pB?CH?WB?A??A?????DB?EB?@??WC?DB?A??A?????[A?\A?PA?K_?kA?lA?pe?c]?mA?JB?PC?wL?AA?S@?P_?CH?XB?A??A?????_A?^A?`F?[B?YB?ZB?p??{E?YB?ZB?PA?_E?~@?[B?P??WH?r??dA?@@?wI?t??\B?PA?gw?eA?A??A?????q@?^A?pK?OH?]B?^B?`E?sB?q@?^B?`D?gF?_B?`B?@??[X?_A?A??A?????n@?]A?P@?OYAaB?A??A?????l@?m@?p`?OD?_A?^A?@D?SB?s@?bB?P??kN?cB?dB?@??GP?cB?A??A?????[A?\A?@B?K_?eB?K@?@X?[P?YB?ZB?pF?gE?YB?fB?`L?oD?gB?S@?@@?wB?hB?S@?`??GD?iB?S@?`??cB?jB?S@?`??KC?kB?S@?@E?{O?kB?lB?@C?wp?kB?lB?@?????mB?A??A?????l@?u@?pA?_@?IA?A??B?????l@?m@?@D?[B?l@?m@?PH?WC?nB?oB?P??_M?pB?qB?@??KF?rB?A??A?????[A?@B?PF?Sa?t??v??@e??g?ZA?A??A?????j@?k@?`K?[F?sB?tB?PD?[F?sB?A??A?????WA?XA?@L?{M?kA?lA?Pj?w]?kA?uB?`q?Ka?kA?uB?@w?Sa?O??P??@F?WC?M??S??@A??G?vB?S??`D?CF?wB?S??`q?gY?wB?xB?p@?gW?yB?S@?`??{A?
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const H = Math.random() * 6;
    const dX = 1 - Math.abs(H % 2 - 1);
    let dR, dG, dB;
    switch (H | 0) {
        case 0:
            dR = 1;
            dG = dX;
            dB = 0;
            break;
        case 1:
            dR = dX;
            dG = 1;
            dB = 0;
            break;
        case 2:
            dR = 0;
            dG = 1;
            dB = dX;
            break;
        case 3:
            dR = 0;
            dG = dX;
            dB = 1;
            break;
        case 4:
            dR = dX;
            dG = 0;
            dB = 1;
            break;
        case 5:
            dR = 1;
            dG = 0;
            dB = dX;
            break;
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2591951534;
    let startMs = 1669852293585;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "one.nio.server.AcceptorThread", "run", "one.nio.net.Socket", "acceptNonBlocking", "one.nio.net.JavaServerSocket", "accept", "sun.nio.ch.ServerSocketChannelImpl", "implAccept", "sun.nio.ch.Net", "java.net.Inet4Address", "one.nio.server.SelectorThread", "one.nio.net.Session", "process", "one.nio.http.HttpSession", "processRead", "processHttpBuffer", "one.nio.util.Utf8", "read", "toAsciiString", "byte[]", "java.lang.Thread", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.test.nadutkin.impl.HighLoadHttpServer$$Lambda$144.0x0000000800d01d28", "ok.dht.test.nadutkin.impl.HighLoadHttpServer", "lambda$handleRequest$0", "one.nio.http.HttpServer", "handleRequest", "RequestHandler1_put", "one.nio.http.Request", "getRequiredParameter", "getParameter", "java.lang.String", "substring", "java.lang.StringLatin1", "newString", "one.nio.net.JavaSelector", "select", "sun.nio.ch.SelectorImpl", "lockAndDoSelect", "sun.nio.ch.KQueueSelectorImpl", "doSelect", "processEvents", "processReadyEvents", "java.util.HashSet", "add", "java.util.HashMap", "put", "putVal", "newNode", "java.util.HashMap$Node", "java.lang.invoke.LambdaForm$MH.0x0000000800d08400", "invokeExact_MT", "java.lang.invoke.LambdaForm$DMH.0x0000000800d16000", "newInvokeSpecial", "java.lang.invoke.DirectMethodHandle", "allocateInstance", "iteratorFor", "one.nio.net.JavaSelector$1", "handleParsedRequest", "java.util.concurrent.AbstractExecutorService", "submit", "execute", "ok.dht.test.nadutkin.impl.BlockingStack", "offer", "java.util.concurrent.LinkedBlockingDeque", "offerFirst", "java.util.concurrent.LinkedBlockingDeque$Node", "parseRequest", "getPath", "java.util.Arrays", "copyOfRange", "sendResponse", "writeResponse", "one.nio.http.Response", "toBytes", "one.nio.util.ByteArrayBuilder", "<init>", "ok.dht.test.nadutkin.ServiceImpl", "upsert", "getKey", "jdk.incubator.foreign.MemorySegment", "ofArray", "jdk.internal.foreign.HeapMemorySegmentImpl$OfByte", "fromArray", "newTaskFor", "java.util.concurrent.Executors", "callable", "write", "one.nio.net.Session$ArrayQueueItem", "startParsingRequestBody", "getHeader", "trim", "ok.dht.test.nadutkin.database.BaseEntry", "java.lang.String[]", "java.lang.invoke.Invokers$Holder", "linkToTargetMethod", "java.lang.invoke.DirectMethodHandle$Holder", "ok.dht.test.nadutkin.impl.HighLoadHttpServer$$Lambda$144+0x0000000800d01d28", "ok.dht.test.nadutkin.database.impl.MemorySegmentDao$$Lambda$152.0x0000000800d0c860", "ok.dht.test.nadutkin.database.impl.MemorySegmentDao", "lambda$flushInBg$1", "ok.dht.test.nadutkin.database.impl.StorageMethods", "save", "java.nio.file.Files", "deleteIfExists", "sun.nio.fs.AbstractFileSystemProvider", "sun.nio.fs.UnixFileSystemProvider", "implDelete", "sun.nio.fs.UnixFileAttributes", "get", "load", "mapForRead", "mapFile", "jdk.internal.foreign.MappedMemorySegmentImpl", "makeMappedSegment", "java.nio.channels.FileChannel", "open", "newFileChannel", "sun.nio.fs.UnixChannelFactory", "sun.nio.fs.UnixPath", "toString", "sun.nio.fs.Util", "sun.nio.ch.FileChannelImpl", "java.nio.channels.spi.AbstractInterruptibleChannel", "java.lang.Object", "sun.nio.ch.NativeThreadSet", "mapInternal", "beginBlocking", "begin", "java.nio.channels.spi.AbstractInterruptibleChannel$1", "long[]", "java.lang.ref.Cleaner", "register", "jdk.internal.ref.CleanerImpl$PhantomCleanableRef", "sun.nio.ch.FileChannelImpl$DefaultUnmapper", "java.lang.invoke.LambdaForm$MH.0x0000000800c02400", "invoke", "java.lang.invoke.LambdaForm$MH.0x0000000800c11000", "invokeStatic", "java.lang.StringConcatHelper", "newArrayWithSuffix", "newArray", "jdk.internal.misc.Unsafe", "allocateUninitializedArray", "java.util.ArrayList", "grow", "copyOf", "java.lang.Object[]", "java.nio.file.Path", "resolve", "size", "readAttributes", "sun.nio.fs.UnixFileAttributeViews$Basic", "java.util.Collections", "addAll", "one.nio.net.Session[]", "sun.nio.ch.Util$2", "iterator", "java.util.HashMap$KeySet", "java.util.HashMap$KeyIterator", "java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock", "lock", "java.util.concurrent.locks.AbstractQueuedSynchronizer", "acquireShared", "java.util.concurrent.locks.ReentrantReadWriteLock$Sync", "tryAcquireShared", "java.lang.ThreadLocal", "setInitialValue", "java.util.concurrent.locks.ReentrantReadWriteLock$Sync$ThreadLocalHoldCounter", "initialValue", "java.util.concurrent.locks.ReentrantReadWriteLock$Sync$HoldCounter", "ok.dht.test.nadutkin.database.impl.UtilsClass$Memory", "java.util.concurrent.ConcurrentSkipListMap", "doPut", "java.util.concurrent.ConcurrentSkipListMap$Node", "getTask", "take", "takeFirst", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject", "await", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode", "ok.dht.test.nadutkin.database.impl.UtilsClass", "getBytes", "encode", "encodeUTF8", "resolveSibling", "getParent", "resize", "java.util.HashMap$Node[]", "sun.nio.fs.UnixChannelFactory$Flags", "toFlags", "java.io.FileDescriptor", "sun.nio.ch.FileDispatcherImpl", "duplicateForMapping", "java.lang.ThreadLocal$ThreadLocalMap", "set", "java.lang.ThreadLocal$ThreadLocalMap$Entry", "java.util.concurrent.locks.ReentrantLock", "java.util.concurrent.locks.ReentrantLock$Sync", "acquire", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode", "values", "java.util.concurrent.ConcurrentSkipListMap$Values", "jdk.internal.foreign.MappedMemorySegmentImpl$1", "java.util.concurrent.ConcurrentSkipListMap$Index", "createFile", "newByteChannel", "openOptions", "java.nio.file.OpenOption[]", "sun.nio.ch.FileChannelImpl$Closer", "sun.nio.fs.UnixException", "rethrowAsIOException", "getPathForExceptionMessage", "keySet", "sun.nio.fs.BsdFileSystemProvider", "getFileAttributeView", "sun.nio.fs.UnixFileAttributeViews", "createBasicView", "java.nio.file.LinkOption[]", "asBasicFileAttributes", "sun.nio.fs.UnixFileAttributes$UnixAsBasicFileAttributes", "wrap", "sun.nio.fs.UnixFileSystem", "translateToIOException", "java.nio.file.NoSuchFileException", "java.nio.file.FileSystemException", "java.io.IOException", "java.lang.Exception", "java.lang.Throwable", "fillInStackTrace", "int[]", "jdk.incubator.foreign.ResourceScope", "newConfinedScope", "jdk.internal.foreign.ResourceScopeImpl", "createConfined", "jdk.internal.foreign.ConfinedScope", "ok.dht.test.nadutkin.database.impl.UtilsClass$State", "afterFlush", "fullTryAcquireShared", "one.nio.net.JavaSocket", "sun.nio.ch.SocketChannelImpl", "throwConnectionReset", "java.net.SocketException",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
                ``
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    ratio *= 0.8;
                    const C = 1 - Math.abs(1 - 2 * ratio);
                    const m = (1 - ratio) - C / 2;
                    color = 'rgb(' + (dR * C + m) * 255 + ',' + (dG * C + m) * 255 + ',' + (dB * C + m) * 255 + ')';
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
