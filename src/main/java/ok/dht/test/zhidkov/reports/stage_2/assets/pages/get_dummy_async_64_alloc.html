<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BE`CACGWv@toB@?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????xsMptKhdN`{N`sKh{N`{N`sN]`sK`kN]`kK`z{K`sN]`zsK`sK`cK`sK`{M\`kL`{N\`cM`cM]`sK`sM]`kN`zcK`kL`sL`cM]SUVTTTUVVNUUTUTVTUVVNTVTVNVTUSVUVTSUUVTUSUUUSTVVTTTT\KUTK\KUUNMVKUTNUNNTLSVLSSSVKTSULSSTTMSVMUNMUMUKTSUKU\NNLKTVMMKTVMMMMSUMMLSVMMLSVMMNMUNMNLVMNNLVMMLVKUMLVLSTNNNMNMNLK\NNMMMNNLKTVNMMMNNLNNKTUMMNNLNMLVMNNKUMNMKUULNNMMNMNMMMNNLNMNNLNMNNLLUNKUMMNKUMMNMNMMNNMLNNMMMNNMVNLMNNLNMNNLNMNNLNMNMMNMNMMNMNMMNMNMMNMNMMMNNMMMNNMMMNNMMMNNMLNMNMLNKKSMNNNLMKVNLMNNMMMNNMMMNNMMLNNMMMNNMLNNNNLLMNNLNMNMMJpxhxpxxhxpxxxhpxxpppxxpphhphxpxxhxpxxhxpxppxpxpxhhx^MNNLNMNNLNMNNLNMNNMMMLLLNMNNLNMNNLNMNMMNMNMMNMNNMLMLMLMNNNLMNNNLNMNMMNMNKKMNNLNMNNLNMNNMMMNNMIxpxxxhpxxxhxpxpxhpxVMNNLNMNNLNMNNMKNMLLNMNNLNMNNMMLNKUNLLLLNMNNLNMNNMNLNMMMJxxhxpxxpppxxp`xxp^MNNLNNNNLMMKUNLMLMLNMNNLNMNMMNMNMIpxxhxpxxxhpxxpp`pphxpxxxhxpxxphxxaxhxpxxph^NLNMNNNLMNNMNKNLMLNMNNLNMNNMMNMLJxpxxxhxpxxxhpxxpx``xxhxpxxhxpxxpppxxp``xxxhxpxxpppxxpx`xxVMKUNNNLNMNMMNMNNLLKNNLNMNNNLNMNMNLMNNMJpxxhxpxxxphpxpypxhhhxhxpxxhxpxxppxpxppVNNLNMNNLNMNNMMNMNLJpxxxhxpxixppxpxxpx`phhxpxxxhxpxxhxpxxpxhpp`ppxxxhxpxxhxpxxppxpxppxpxxpphx`hxpxxxhxpxxpppxxppppp^MNNNLNMNNLNMNNMMNMNNMNMNNNIxxxhxpxxxhpxxppxpxxp\NNLNMNNNLMNNMMNMNNMMJqxppxpxpx\NNLNMNNLNMNNMMNMNMNIpxxhxpxxhxpxxxphxxpphhqpxxxhxpxppxpxxppphhhxpxxxhpxxxhxpxxpphxh`xpxxpppxxxqxphxx`hppxxxhxpxxhxpxxpppxxpx\NNLMNNNLNMNNMMMNNNNLMKUNLNNMIxpxxhxpxxxhxpxppxpxxppxp\LUNNNLNMNNLNMNNMMMNNMNLMKNLNMNNLNMNNMMMNNMMNMNNMIpxxhxpxxxhpxxppxpxxphxxxppVNLNMNNNLNMNMMNMNNMNMLKLNMNNNLNMNMMNMNNMMNMMJppxxyp``xxhxpxxxhxpxppxpxxph`pxhxpxxxhxpxppxpxxpph`xhxpxxhappxxhxpxxxhpxxppxpxx[NNNLNMNNMMMNNMMNMNNKJxxxhxpxxhxpxxxhxpxxhxpxxppxpxNMNNNLNMNNLNMNNMMNMNLKLNNNLMNNNLMNNNLMNNMMMNNMNJpxhxpxxhxpxppxpxpx``xxhpxxxhpxxxhpxxpppxxxhpxxppxpx\MNNLNMNNLNMNNMLMLMLMNNNLNMNNLMNNMNJhxhxxpxxhxpxppxpxp\NNLNMNNLNMNNMMMMKLNMNNLNMKUMNMNMNHxxhxpxxxhxpxppxpp`hpxxhxpxphxpxxp``xxhxpxxhxpxpx`xx`hpxxpppxxhxpxaxp]NLNMNNLNMNMMNMKKNMNNLNMNNMMMNNMIpxxhxpxxhxpxppxpxh`hxxxhpxxxhxpxph``px`x`xhpphx`xpSMNLMLMLMMLNLMMIp`xhphpphxphMNLMLMKJx`x`xpLMNKNMKIpxhphhUNKNLMIhx`x`xpLMMLNMHhpx`xhhUNKNKNIhhpphxxLMMHxhppNKNIhhppNLMMHhpp``hppNKNKJhppULMMHhpp``hppNKNKJhppNLMMHhppUUHx`[NLIhppNLMHpp\LMHxx`[KTIhphVKJhppNLMHpx`[NJ`hpMNKJhppNLMHppNKNHphp[NGxh`]NGxh[MMHx`\MMHxhTMLIx`\MKJxhTMKJx`\MIhx`\MHphp[NHphp[NHphVKLJppNKJ`xMMJh`xMLIph\MLIx`[KPppNKMIphVJ`hpMMKKKMIphVJ`hphVJxpNMHhpMMHxpLMHpxNLMHpxFKJhp[NGxhVKJ`x[NKJ`xMMHx`\MHpxELLJppNMH`xpNMHhpMMHxpKNHppNLIhp[NJ`ph[NGxpMLJhpMMHx`\MHpxTLLIphVJ`hhULIx`pxFMHhphVJ`xMKLJp`^KIhxMMHxpKNHppNKJhpMNGxhULJ`xMMHxhTMHppNLIhpMNGxpLMJ`xMLIx`h]J`x[LMHppNLIhpMLIx`\LIpxFLIph[NHppNKJhpMMHxhTMHppNMHhp[NGxhULJhpMLIx[LLIphVKJhhUMHx`]KKKMIp``p]Ip``p```p[MIh`h`pMNHppUKKKMJ`xMKKKMHppNLIhpMNGxpLMJ`xTNGx`\MHpxFKJhpMMHxhTLIppNKJqMMHxhTMHppNMHhpMNGxhVKJ`xMMHxhTMHppNMH`xMNGx`\MJ`xMMHx`\MHppNNGxpNKJhpMMHxhTMHppNMH`xMMHx`\MJ`xFLIph\MHppNKJhpMMHxpLMHppNLIp`aFKJp\KLJppNJ`hpMMHxhLNHppNKJp`UMHx[LKLKNHppNLIhhULIp``hpIiPsLiNgOeMuN|MyOeOaPhOiRpI~RzQbSrRgSjRoSaR{Q~QmRvQeScSvSkJ`TcM~JrI`OnMeNdKeKpKaLvNlOpPuJyKzKjLoLtL~LaMqMvM}MpO`PdP}PbQmQxQhSnSsIwIdJfJgJhJjJlJnJoJpJqJrJsJtJvJwJxJyJzJ{J|J}J_KcKgKhKiKjKkKlKmKoKrKsKuKwKxK{K|K}K~K_L`LbLeLfLgLhLiLlLmLnLpLvLwLxLyLzL{L|L}L`MbMdMfMhMiMjMkMlMmMoMrMtMuMxMyMzM{M_N`NbNcNdNfNgNjNlNmNnNoNpNqNsNzN{N|N}N~N_ObOcOdOfOiOkOmOoOrOsOuOvOxOzO{O|O}O~O_PbPcPfPgPhPjPlPmPoPrPsPuPwPxPyPzP|P_QaQcQdQeQfQgQhQjQkQlQnQoQqQrQsQuQwQyQ|Q}Q_RbRcReRfRhRkRnRoRqRsRtRuRvRwRxRyR{R}R_S`SaSdSfSiSjSlSmSpSqSsSuSwSqItIuIvIxIyIzI{I|I}I~I_J`JaJbJcJeJiJmJ`KaKbKfKnKqKtKvKcLdLkLqLrLuL_MgMpMsMwM~MaNhNkNrNtNwNxNyNaOjOnOqOtOwOePkPnPqPtPvP{P~P`QiQpQtQ`RdRgRlRpRzR|RkSrStSxSySzS{S|S}S~S_TprPKKKKKbAK[[[[[[K[[[[[K[KKKKKK_@c@f@KKK[[^[_B[[[[[[[[[K[[[[K~A[[K[[CKKK@]n@|A_@KK@@@]KCC@@r@l@KA]A@@Cf@KEAKCK@@^hCEEl@E@@r@|Ba@@f@@K@n@@ECKDBKKDD@B@ED@Ib@C@CCDGCBAE@@^@@@CBICCB@b@IACD@C@B@ICAD_@]AK@EB_@Ia@IGCBEAE@CEDECCa@@GAG@@ABBKDDB@CIEKC@Ih@DD@EAFC@B@b@CBCIIH@EIEE@B@KD@DBG@a@EGAIHC@@DA@AD^@@DIFB@E@HK@@AIG@@DBHE]D?DCD@IAEA@GBAB?BB@HCBBC?ID@DFECHAD^@@DIHBDC?DHHFB@@DFF@A]@@@BB@?IFI@E@GAIEGC?GGCBG@C?@FD@@CED@DC?AADEB@CC?GBED@CDCHAG?@C@BGE@?E@@FG@A@C@C@AE?DAFE?@BHHIC@@@AACKGIGED@A@?@C@AF@BGBCCH?HHDCGE?CFA@EHDAEIEC?@@FG@B@?BBHE@G@HAGB@?HHIAIG@H?@FDBHD@C@EC?@@@ED@?BCHBF@HF@AC@?@@CCA@H?DHFBB@AE@GCIH]IIIIGB?BABCG@@GGDB?@@GGE@@IDH?HA@DACFA@?CHCIACCAI?IEGEBDBBBFA?DC@@BFFC?@@GDEIACA@?DDFID@AEH?@FAFA@G@@B@?DAD@@ACKDBHECG@E@DF?@GIE@AEFBxDAIBDCGDCA@?EEAI@ICA@?I@CFC@BGAD?IICB@FEB?EDCFF@E@I@B?DGDAIBC?GCAI@HEBDBF?@@@CG@EFc@AAIFGCICCCIBKC@EBGB]BEDA@AG@@C@A]AA@GBGE?HCDA@BI@I@AHH?GADD@@?ECF@ECABGB@EKCCB@DIC?EBA@EFHIBCHC]AF@B@I@@_@@CE@EI@G@AHKAFIGDFE?@F@B@BF@@ADG?AGF@IAA@?FF@@EGIHB?@F@@EHHGD?BD@IEG@BAC@?FFEAIBE@?BHBCICBCHCmEEEE@FHCB@KFB@CF@EB@DA?DBGDBF@c@@AE@@HG@DAFKEEDFB@D@?IFCECGCDCBI?@B@GIBDG?BGEHHCCI@CF?CCAGDEE?BDDCGDI@DFBHy@CC@@DIID?B@HDA@CG@I?BIBGC@@@?AHDECHB@C@HA?ABCHACD?BBIBH@ACIBF]@@@GAAFC?IAGBEEHHBB@?DDAD@_@CDCH?AF@@H?BB@C?EIEHFW@C@F@?ACH@AKD@DFGBEKHG?EB@EHAGE^GEG@@?BAACKEE@@E?HC@CDKDFCFMA@C@E@KIDGDB]CD@A@?@@@@?@E@@HCI?IIBE?EAC@CUDHABE?CEAAH?FFBAE?HGAAB?IAGC?HBAFAKBIHF@?IDFGEF?C@DC?D@C@G?AFA@@K@@IECF?C@@H?@DAFBEKBGBEI?BBFFKHH@B@?A@BGE]HHIAC?EFED?@@@BDKEHADGCA?EE@?@FAH@@?BH@H@?HDGBE?AA@DU@B@ECB?IIAH@?@BCA?HGAC@?HG@@EBHMBBB?@FBDBI?@@FB?B@@AI?CCFB@?H@I@@?BH@G@?@A@@GDWC@D?AAB@@A@_FHI@?@@BBHD?AA@AE?DC@@VBEHHG?CCG@HEBUAF@JC@EF@CJ@D@IDKE@DEE?GFCIBv@ABFIA?EEED?CFFC@?A@AHFKADCCG@MCCHFJ@BHEBB?GEA@?DHCHC?C@@D@h@B@CIA?DDBUDHC@A?BHUBIBGSAFEI@?GCCBVAAI@aF@BF@AM??@F@HH?HHAH?AAA@?BHDA@?CCBC?F@?D@FF?BBDFFMA@GB?E@IB?CEBE?DDcEAA@Iv@F@F@EJEGH@T@DFB@?D@AD?]?GCFI?DCHEI?@@@B?G@E@@?BEAFSGGEF?C@HIA?M?@AAG?EI@@C?ADCD?AACBF?A@@C?@@h@AHCE?HH@CKG@DC?AACEAKBCEA?FF?EB@Bb@AC@@F?@BDB?BBACM@HEA?AC?EADA?@E@C@?ADIA?@CBC@?DAIB???EDD@?E@IGDOBHAD?EACEBKCCABLA?CEADIIEa@AA?CH@A?@@@EG?DHDB?IDAB?@II@C?BH^B@BET@@@@JCACI@TIDFE?FAAISF@F@?EI@FJAC@?I@IDb@GEG@A?ADBCKCCD?@I@FCQDD@DUB?ABFBB?DHFBKB@C?GF?AC@EA?BB@AOHA@I?AOBG@@@WGFBA?HCHMEF?EEBEC?CD@ELAA?EDFH?HA@A?@D@Aa@ED?GBCTDAFDG?H@EB?ASCEFC?HCGB@?EB@A?HB?GF@?EBAEDMB@HCJIA?@E@?D@DCDL@IFCYHH?@A@SGFD@BYBFBD?@?B@GH?@@CDB?B@@@?@BJ@ECJEEBEB?IFDGLE?EABF?@@BHDJEBE@?LJAGCFKFFGED?HGGHT@J^BFAV@E@B@?AGB@LCEC?BD?@ABG@?DI@@?FG?EC@?BDGAGJGG@JDD@GYF@AW@@F?@@CI?@@HK@AA@?DCD?BHBINC@D?CHABTIDHY@BID?BFBM@IH@?F@@?CEB@?HGGVBB@@?DJDDBI?@@@EF?CF@AY?L@FEH?BGBH@N?@B@IH@QCF@@?UXGDAA?EHIIC?FFEIO??ACBI?@L@IEGJ@DAA@?E@C@???F@DF?BCAHF??DEEAD?BBG@?J?DA@H?AIFAI?ABAH???BFD@???CHG@?EEIAA?HEF@???C@@A?CCE@AtEJC@CBB?GIBI???G@DFL@@H@FQDI?IF@WDCDFW??FGG@?DFCI@?HA@E???FD@F?C@D?G@LIIBII?GCDF??OHHBB_@FFEGIM@D?C@@?D@EG???@GEG?C@B@API@H?@@?CA@F?AC@?AA?AADAAQC@@B?X?D@BH?DAAANDAD?DF@A?@EEDT??HE@@?DFC@ATCG?A@F?IAG@?DCDDU@?GDFAG?@A@C???FEIG???CB@AJ@EEBA?BCBI???E@BD???HDAF?EEEAB?@@HS@B?CHAF??JCGFCWDDADDV?ADEAH?HDD@??J@GG@XEG?EE@?@F@@G?@BCG??LIBFGN??FD@FODGCC@?HINDFEMAA@E???DDDC?@@@H?H?BBHF@WI@E@?J?B@@D??@D@ECOAC@CGM@BC?BBXBAABM?QDHIDN@C@@I?HSGAGHYDH@E???@HFIM@@B@?@?C@CBH?@IF?F@?G@CEV??C@GF?@HF@D?@GG?@@?DCEYC@?C@CD?CBCBVEI?C@CA?@@G?GG?BBHDQHG@?EEWGAGC?D@HELAF?@D@NDDEDCU?HIA@@K@D@EN?KDDG@???BI@B?AAIJFF?HIAHB?EDG@?P?C@CAPT?ACA@?A@@A@OQAH@BF?HE@E?T?@DHB???FC@A?AC@@G?O@D@BD?FCHD???EGIAP??G@DG?AA@GD??AGF@@X@EIH?X?FBI@VP?BFACM@G@IGV?H@@H@?GAFAQ??@@C@N??HBIA?GEE@H?L@D@B@?@GB@J??GEDD??QFA@BJE@IE@PLECIE@?@FDES?R@DFH???@FA@?@@FGCJCJFDF@?IHCGW??DFHB?@?@BD@?AA@GE?@A?DAG?CFDF???@@ACR@U@BH@?EDEAAOIE?HIH?@H@@??WEBCF?DDDU@HPEDIB@?@GVHCG?BIFD?JNHBDC??O@GEE?FF@BBU?A@@C@?@DFDN??@@A@?S?HF@E?BGBG?I?DCDAB?HBA?CCR@A@A???BA@@??QE@@C?@CD@D?D?AEII?CHC@?M?EBBB???IIGEN@G@B?G?@DF@G@UG@@?AA?FDGD?J?BIAINAEF?BC?GFE@H?DAG?GA?CAG?BB?@HEC???E@BC?EEFIJC?IBFHBXCA@?@B?CHIE?N?@CGC?GA@G?G?FIF@BXBA@JDA?EEC?AAWAHGC???BECB?DFGD?C@G?BHD?CCD?AA?CCE?HH?EBBHSDDDBO@?@D@I?DHGDSII?EEH?DDDU@HQIICADJG@?FFF?@@@D??J@@P??B@@@?GBDH@??E@CEDMF@@A?S?BDGC???@EDGy@??@DGC?CCDDB?SE@AII?@DHCW??D@GF???C@@F?T?DAGCLIDCH@?JI@EA@?BEIFS??F@EB???D@H@M@Y?FDH?AACAB??BHDFB?@EDDL?O@EH@??Q@@C@JGHEH}@A?@@HC@LBDEAJ@?AAAA?WJBGCA?QXDBDE?@C@@@J?EEB@I?@ICBJUOCBEA?QTE@@BT??GIIDOIEI@CT?@A@GC?CB@@??JGHA@?S?BBAAPJPAAEFYCABC@??HDDCHJH@@FN??EBDFKLV@IAF?DDD?D??@FB@@??@BIF@?EEDD???@HBD?T?@C@@???E@AB?@F@C@T?@D@@G?HE@@???FEDDMV?GBDB???@@D@?A@HAA??CACICJAECD?J?FECDQ??ADG@?A@DHAPT@DE@C?@GA?IIOFCIB?]VDC@B???@BHI?BEABB?KDDFCD?EEGFJ??@@@E?N?@@AH???@HCBWHGCA@?PAIDFA?IACD???ADIBJ??BHEGN?QEBFAP@F@G@??DGEAA?GG@@?S?BFD@M??I@@B???C@AA?B@@AH??C@HF@?ED@DR?OBHC@??LCDI@?J?GAI@?@B@BH??DCFGD?IFAE?J?D@C@?DDDP?D?@GB@I??H@HAEN@B@D?RTB@ADL??BEI@?F?EFD@?IA@BI??E@FHI?@ECB???BGHB??WCCFC?RV@@@HLCCHCAMLCECA@?BBA@?J?@GCG???@AAD???BGHB?DHCFD??@EA@@?@IHA?QXCCAD???@EA@?T?@CGF?BDIBF??ECBFI?G@EC?}@NAB@A???@CEC???EFHG?BHFAGRX@IE@AMC@@HM??DHDAQLJ@@EH??RACFI?HCCH@??BBCIH?BCH?DD?HFFIO??CFABQ?WIBDB?BECB?@Q@A@@@M@@UABFLGBDBJZVIFAB?QN@EABL@?C@AF?D@D@GJODDDU@H?AF@ACNOHCFG@X@@ABXP?@ACD???AHF@M?W@GAD?H@FHH?M@@A@BNFEHG???BDCAMJ?ICBI??WA@F@JBHG@C?VII@I@RAAA?AA?BIC@V??@AC@R??DBE@?H@EG?F?C@FAFL@?DDAE?EHC@QUS@E@C???@@@G?ECE?HF?GGAD@??G@EFD?D@DH???@BAA?LJDDA@???CBEG?BCEH@?TEFEDB?FDD?EI?A@GIJ??GC@INLO@@@C?F@@F?A?AGFFI?FFG?ID?AAGUAF?IHB@?N?D@DA?DD@A?B?HFGABZDGYDD@OC@H?@@?DBAE???CCDF?BBBB?G?DDDFUF?CED@A??C@DCIMGGBER??HAGB???B@DD?M?E@@AM@BE@G?N@A@@@?GADC???HHIA?X?EBBA???@@E@?HEHDD??BICB@W@@D?IA?@AB?DD?CG@@UJP@@@HTFFIC?C?BB@@IN?GGGC@?AADE???BHHB?RSBDDG???CCHB?@@E@HVJ@@@AF?AGGS@@?BCH?CCQIBFANUXDADG?IBAGOH?GDEA@O?BDHH@?HAC?HITCEDG?VYBDBDJ?LA@CA?HGHE?@JC@HI@QBCD?BBPGC@?@@?@@EI???AIAF?@FBC@SE?@B@@?E@HA?IVI@GB?CCQE@@?II?EBFFRDD@HD?M@EE@D?PC@FD@SDGCC?Y?DCH@S??@H@H??RCIFC?@B@@@?V@@E@@?ABDC?P?EI@?AF?CBCCNUM@CBC?Y?BA@A?@G@@BN?@I@BA?C@ACR??EA@FT??CB@A???C@ECME@CIB?MFIFGIUA@E?EE?DHHC?J?IGD@???@EGG?ABF?FC?EDA@HLV@CB@D?FAAA???IAGIM?RAGFAR?JFEEE?FBCDF??GAD@GY@I?IBD?@@@A???ABCA???DDEBR??I@@E?@G@@GJ?AAFH@?@@?@B@?@BAJ@@N@AC@Q?QEHE@LWTEEIB?EAD@?I?C@ACC??@EI@B?F@GC?DDDD???CEHEHQ?@@E@EHZII@EJV?EABIU??BGAC???F@@@U?J@@ECN@@B@I??DC@@F?BBDE???DIE@???FHGB?UNIB@@N?RC@CC?D@EDB?L@HG@DJC@?H@HTAFIC???CDA@???@BBFJ??HEAG?DB@BEQ?ACFAGPEJEAEGSB@FA???A@@CV?L@C@H???AEA@?ED@DOD?@CI@A??CIC@@?@@EG?M?ABHA??OIGGI???DBAASC@F?@I?E@H@I??@BE@GL@IHA?S?AF@A???CGCD???D@FC?DB?D@AR@B@BHL?F@CDG?G@AB???IFG@M??FB@A?P?ICDFJDDD?D??BAFGH??B@GAHQ@@GC?QN@DH@???@@C@???BDGEOCDC@ZG?H@HIBV?DDFDE?GAADJ??ABGC?T?E@@A???@I@@?GG@AA?WBDAB@V?BGGFB?@@@@???@BBB???@@GBP??EI@@?@BDI@R?FIE@CUHC?A@F?@ADB?P?BBF@L??G@BA???DAAA?@C@@D?J@BA@@?EGCD???EAC?@B?CBD@M??HH@B?ZX@@I@?@GE@@TS@HA@FVID@C???ECC?@@?@C@A?LTDCD@?HH?FHC?@GA@AR?AACDIO@@C?GE?C@II??JBEA@U??GFDC?A@B?AC?@BC@C??UDD@BD?AH@BAMTEBIECJCDHD???H@GE?QTFIGE?WMB@@G?BBBH?@?FCCDAV?GGAGC?IA@D???DC@H?M?BCBC?RNDBGALGDEE?GM@BHB@??@@A@@?DBI@??R@ADB?VPCEA@JS?D@@CNI@@II??FHAF@?G@HLDDLBEH?BH?EH@HOOPDKFH?H?HFE@?IDBDJD?BDHF@?G@@?@@?BBB?AAT@F@@P??BD@@?HBIH?C?@@AD?GOHH@GEPIDA?FF?B@A?CC?G@E@?JPEIFD?@@@@S@?GAEG?D?FBCBD?BHA?GE?AFH?CC?@HH?@@?@EGG?@@E@?APGFAGJDFB?DGDDUE?DDHA@??GACDFSIEBB?P?EEDB???BCB@??JE@GA?@CC@B??FG@EFNVF@HAF?G@BHO?QBHCGPZXFIHA???BE@G?CCHG@OVA@BFA??IEEIA?BDHC??Q@B@@JLV@GFF??WHBBD?FDAHF??@@H@E?@@?H@G?AA@F???IDGA??OADDE???@CIF?B@G@B?SDCD@F?CFIBK??EBD@???C@@@L??GFC@?GGNC@F?ABBFI?T@B@BE?GEFAR?WH@GA?RSCFII???CBFE?CCDGF??AD@@F??E@E@D?BIGEZ?WGIAE???CAA@OM?BAEB?FF@DD?SEFHAIJ@F?DDDUCD?D@CHA??E@@EE?E@D@???EEID???@@D@?QNCG@AJ@@E@E?MGH@G@?F@E?FC?BGIGSONB@@@P?OD@@@JGNAG@G?CI@C@R?HC@H@?IBCCU?WB@CI???@DDA???@AAH?GDC@?A?ECCIA??DAGHD?BC@IL?JEAD@M??A@@F??RIFEH?FAC@DY?GAHGI?E@?IED?@@IE?LM@@DB??OEA@D?@?B@B@?GCGCD??GHEGH?GAABJ??A@BH???C@CD?RM@@@I?E@EAB?WHG@HIOE?@@@@M@I@D???CHEDU??HHBD?F?FC@IZ@@@GI??DD@BA?GEEB??VA@IFJDD?DD??FGA@F?OC@@@@?IFEBS??B@AB???EICC???CDCB?@F@@@??@BB@C?FBC?CC?GD@B???EA@DN??G@AC???DIHA?ADFAE??EEABALGGCB???IHC@RV?DE@DR??IAGFJBA@BAJ?BABBG?ICD?@@XD@D?DAL@@BD\??F@DC??J@HIAJBGCEFXWBBACI?EIAB???@EDD???GBGD?M?@EDE?FAA?FA?FDFFB??GEGBC?BD@@?QNBI@F??RAAEB??OE@D@?HDH@B??B@BCH?GAADS??AAAE???IE@@?RS@@HI?HDGBDO?HHAB@??@CD@@?HCBI??LAAIAYDDDD???@F@G@?ZC@@@@H?FE@A?RMIIBD??L@G@G???ICH@?AIFAG??AGFAGF??ABCGDBTBB@CQ??BAGCO??DCCE???G@AD?EDFDB??IFEAGPDCCD??QAFID?S?BHIG?V?@IF@?@II@?A?@FB@FW?@@@AA?HE@AZ?RFFFFP??HAEG???@IB@?EB@ED??@D@EDJE?A@AF?@BGDL??CE@EJLMBB@H?WTBCDA?DCDF@??C@C@B?ICII??JHEGI?N?@GIB??JD@AA?@I?@FAXCFACC??BBCB@?@E@DV??@IG@???DE@A???F@AINCF@II?JBFHEB?@@BYGE?CACGLDDDD???@BBC@XMFCACBLAEHCQ??CB@H?Y?FFDA???@GAD?HBGBH??FHBFD?@@?@A@?EAAFLT?H@EB???A@ED?OSD@AIS@@G@CQNEB@AHW@AGD??LEBDC?LMDB@GU?QIFG@?@@B@?C?@F@F@?QGCGHILEGDB???EGHE?UNHAF@\RS@@CF?BB@HH?P@BGF@?@FC?FF?BE@@???DEG@Q?QCAED?D?EADDLI@BIFS?CEC@E?@@@@M??AHEH?N?C@EGJ?\D@HE?@@@AB??A@AEFSI@BN@@?A@C?IIOBDIB???EC@B???BAFGVA@A@@L?HAAGA?ACHG???B@C?DDDEUATBCCGI??DHB@DS@FEHL??@EF@N?RHCGBUJ?IACF?HC@IH??FD@@F??FCIAC?@CABZY?GDFA???@EFC?V?@@CAXAF@H@?RA@A@AJGBI@?N?HIBCP?JHHAFX??AEAB?HG@A?HUIAEEI??HAG@H?AC@D???D@IDT??D@@I?N?DEGB?BBB@B??@HHB@THICJAA?BA@@T??BFI@L??@BG@?DE?AI@?@@D@GQLAA@FB?@H@?GE?C@BG?RSA@D@???HADAOEDDD?A?AIFD@?ECZC@@JCBHC???BHAC???@CIB??JA@CD?EBEE@P?CD@CD?@@DZIA?IDA?DDDAU@?@@BD@X?A@BDAXB@D@???@G@FQJPA@BC??JHF@C?EB@IC??BIHHA?F?GBDG\@FFAL??E@E@N??@ADEMP?HHGFJECED@??@@@@CPIF@@???ACBC???IECD???BG@I?@A@@E?ZBBHD@UAB?IDI?HFC@P??CHII??OADCG?@XD@GD?IFDHB??BB@AI?@EEB???GDDG?UMDCDC???@@@IJHAGGFM?H@@BGJI?I@IFPDE@ATLVFFA@M??DCG@???EADB?ADIFC?OABF@F?@@A@S??BA@ER??@G@AN?J@DBD?GG@CEN?IHIIIGLC@O@D@V@CDCN?WA@FB?DDDQMDL@B@BD??BHHC@?EEHCTUSH@@A???CABF?S?BCFE?@G@E@O?@A@B@?@AC@R??FBCF?SYH@HDS?RDE@C?CCHB@??EC@BIQ?@DBE@MCHEFP??HGDF?S?GIGC???BCBC?G@GBD??I@DAI?H@HC???FIF@R??FFDB?X?BCCIPCEEC@??CE@HC?@C@@S??IHAF??J@DFI???@EI@?CCC?@@@CL@CDDCJSH@HAHJEBGE???@@GC?QNCDB@J?LDFAE?E@IICJ?@@DBCZAADI?S?IEFG???CG@B???E@@@?BE@FJB?B@EFBW?BEIH@?IECA?V?BBGA?UN@AEC?DDDWJD?FIBAC??HD@@H?FDDDL??HA@@P??FAAB?Y?IDCC?E@F@E??@IG@D?HIF@?N?G@ABSM?@EDE?N?@F@H?ABHA@L?CACAH?@?CCDA?DGEFJ??@@CB?Y?@E@@??\ICGG?GAAEB??ABIADTFH@@T??BDDCRP?I@@G???CIB@?@@CD@W?D@AF@O?@@@G@TD@CA?VYDH@B???GAA@P??E@B@V@B@C@R?G@GAI?CC@C???AAGIP??D@@D??J@GHFN@F@II??GE@AE?@?@G@D?IBCD???BGG@?Y?@FHA??IDIH@MDD@@A??EF@BA?D@@@???H@DHP??AEDE?DDDDV??@GIH@R?EHBAD?DI@A???AE@C??W@I@C???CE@E?C@@DA??A@AHAWAC@F???DAIF??LG@DG?J?@CD@?G?FB@G?@GA@CJJ@FFF@S@FGA???ACBD???DDHERV?IF@@TBBACH?PCBFC@?DC@?DA?AAEA??WE@CB???@H@C??QDBCFJEAHE@?\DACHA?@@HBJ??BAEI???D@DCQ??I@CA?@@@AF??CDEB@??@AD@@?@C@HP??E@@I?M?HBCCMLJHAEF?G@ECC??DI@DF?GDD@V??DBF@??OAB@AM?OFAHG?I@@I?@?BGH@I??@CBD@JEB@@???II@CZDDD?D??@FDH@??CCBF@?@EACY?WAAFB???G@CA???ECGE?DAGAAW?HGHF@O@JD@EDQH@B@???B@GD??O@DCE?NA?CEIVFG@FG??AAFAHT@@GH???@I@E???CDE@?ONB@@B?GDE@CTLHGAGGZG?CCDC?CBHG???FBF@???CBC@?N?BGEARHBHHC??BFHGB?B@EC?LM@@AIUWWHBF@???BC@F?CIC@B??G@HG@O?@BI@D?EAADM??@HG@???@@DB???@E@@?F@@@CM?GICEH?EAISBH?G@AA?C?@GFC??JF@@@???EC@I?BHBAD??GCFAENDAA@?OSGAB@?DD?DD??B@@IB??B@BAHTCIEET?VEHBEO??E@AF?JMHEFBQDDCDB?V@@@I@?CNHBCHSECBDJ?O@H@A?LJIAC@?LV@A@D?@DE@@??@I@@EYGAA@??LIGDE???AIHBV??F@E@TC@@@DU?@@@I@?M@E@DB?EIGANLMC@BANONAEEE???@@G@?AAD@C??CC@CG?HCRFBF?G@AF???BAAI???CIC@SJ?FABG?AFFDB??FA@CFYFBAI??O@B@E???@BGD???BC@@?CHCFC??FBAAC??@EE@I?BDFGQ??BFE@S?RDBHH??WH@@D?GEHEF??IDICE?@BACJ??@GAH?DDJDD??G@GGAU?@@ED@?G@@A???BAEH???@HEC???@IC@?ID@CD??HGDAHTB?C@@DT@B@C???A@@@?UM@FBB???HIAD?@@CIG?Y@@@@@?E@EDJ??CIC@?J?EHHB?P?@FCAL??CDADNCEBHC??DAHDB?@@DD??RBB@D???GHEC???CF@H?EIEHC??CCCBGQF?IGIF?I@AB???@@AAQ??B@@CQ??H@B@?GC@IGXP@@@@AJEB@D?Y?D@@GJ??IFFCQWJI@GA?CC@B?@?@EEF@?E?ABFA?GG@EO??D@HGP?OEFBC?BAGC?FPDDDFC??AH@AA?F@A@?US@BBH?DODDDNOGBFIG??HDCCGJD@II???FFAF?T?BDC@?LJGHDB?@AH@@??EHBECPFADE???I@ACTP?BHBCLLVBBB@JHE@GCP?@IBD@@RIICIJ?OAEFEJ??IAAAYJXGC@BRGIG@IO?@FDA@ME@ED???BGFB???FHDC???A@CBMHGH@D?S@A@@@SBAHI???DE@D?N?DGAHV?JBDGFYI@B@I??HEE@H?CH@A??JIH@F???A@BA???E@@@?ACHEA??HBEGG?ED@H??RICBI???EFB@???BCHH?GHD@AM?IHBID?HDAF?OSCIADL??IHBB?Y?EDD@JHAAGDURG@@CG?@@BCJDD?DJD?@@@@H?RBF@DB?IBA@???BBCH???D@A@Z?J@EHF?@E@@@??IGAGELBB@I??RB@ED???@CDB??RGBAF?@GAG@QTHDEG@?@@D@ROSAA@@S??BFADXM?B@EH?CIACB?RDCEHC?G?C@G@?I@DFO?O@B@AT?L@ABE?A?HEF@?A@@FF?Z@HD@@NAFFFJ??FEF@???@BAB???CHEC?HHBDD?JABIFFUEA@A???ACHFL?LCIEB??JBDFGL@B@@D??ABAFA?A@BH??OH@D@\??@ADD???HBI@?CBEB?C?AEGAAP?@HHC@?CH@A???C@I@???@HCH???C@GEXDHDUID?BHGAF?U@FAA@?DH@@U??GCC@TN?ECEF??OCDDD?F@AF@J?C@IF@?IB@A\??@EH@T??GBGH??J@@DE?E@IH@N?BCAHBN@I@@L??GA@I???H@@I???EGC@?@E@@I??BECBA??@EBC@?BC@AP??@AGAP??ECD@?LJIAIB?@C@BF??B@HHH?IIEA?Y?@@ED???DCEG???EAEE?@@D@@??@HADB?@ICCT??DHA@???@HDC???GADA\BHPAD@UDBBBAFJR@@@B@?BIGC???@@IB???A@D@?S?FDACZ@DC@@??CF@@IQGDGD???AHE@J?WCEEGT??CAHC?DDDCUB?E@BEG?RIICDC?EFA@???A@BC???@@@F???D@FA?@F@AE?RCD@C@?HADBN??B@D@R??FHEA??LCB@C?AI@A?C?BE@B@?CI?AABJGBD@???AIIG?N?D@CHWFFMBAF?HAI@B?NBIAF?CHBC???ACEH???C@DI???BDDB?CC@@@TNHECH@W@FB?AA?@@B?BB?H@C@???@E@GZDEBOD@?@H@@EJMC@FCGLDH@I???FID@J??@IF@J?WIIIG?HGBF\A?EBIID?D@I?@@?@FB?DA?FDIE???AE@@?DADG?@N@G@@@YGBXEEBOA@@?@@?BIG?C@?IA@AMDDDDX?WH@HDH?OAI@CA?@GDAJ??EEFFTY?D@BCXUM@BB@?ACDFF@??AE@DAI?FDAF???DCEB???@D@F???CBGE?FB?BFG?GH@@GS?G@CGGV@CE@Z?WH@C@??W@@CE???B@@@?EICEI?ZGEDDD?BBCD??LDG@@WS?@DH@M?LA@@A?H@IT@@MDFEC@??HHE@E?EHIA???CECBM??@BHG?S?CF@@?BCGAHTN@AAC@UC@@A?N?DAGI???IA@BL??@HEH?FDCF?C?@EECD?YGBGAG?EF@HN??AHC@???@@HE?Y?GGFF?IGEA@??@A@@IRG@AG?Y?EE@A?Y?BGE@YDDD?D??BEC@B?XG@AGHUECA@\N?@I@F?QXADHA???CFI@Q@@@@C??GB@GB?HGJCFC?FFGA??QADFF??OACGF???GECA?B@BFA??E@DAF?AF@B??WD@D@???BICI?M?B@@A?GFGA@J?G@FG@?@GFC???ABBB?DC@@DW@BECNXLA@@D?@F@@ENABIA?@@@CF?EB@BJPOD@@CPEEG@DNE@CC?@@@@FQDHAH???@DHC?BIIAHN@D@@?@I@@WFBAB@PV?CE@@NGIAG@?D@A@?D@?EDD@@D@P??CI@FV@@@D@?ID@GZJ?E@@BIBC@MW?I@D@J@BD@@R@BAFOXL@A@BDBH?@@TCBAIVA@AABO@H@@YO?E@GBCCD?@B?D@GELDDECUDAAB?FF?@EBELBEEHC?EBB@T?Y@EIDPCBCBH?FCIG?L?G@BCYADHAI?DAA@??TBGCDSBAEHCJCGEA???A@CG?IGIFASIGCF?PQI@HFMEEA@AYHEFAXTWBAFHTICFA@?AD@EJFH?FCC@@@XAF\@CHB?HICIBJCACI\??A@@B?AEDCIN@FB@?U?@@FB?A@F@BJCCCF??JEG@B?I@EDC?I@CFYSW@C@EJCH@CE?DDA@??NIIE@?H@IDH?HH@IN??GH@HNCB@BF?D@E@PASEAB@?C@EDCX@B@EJCI@@AYBG@G??M@G@ATA@IAAQHFCB?J?CDCC?@E@@B?FCBF???FFH@?@B@CB?GDBD???CCCCLGEGB@?GEA@?VWC@AA?CCGFC?GCDFRDDDDM??@CBCC@RBCFB?J?CHEB?AHCCFQEB@D?TZC@DB?J?IBFA?D@HBD?DA@A???G@AB?BDDH@?@ECD?T?@@CCNO?AFAE?C@@@C?@EF@?M?EFGGRC@@@B??G@C@G?CCCA?J?EEAH?@@DB@QGEF@?\?@FGF?BQHFBCJABDDFMHED@LJ?BEE@MAAACELDIE@Q?RABBD??MAICA?D@AGI?HH@@?J?BIDCQCI@CHV@DAE?I?ICBB??JGD@H?GE@GEZCDGBQ?XCF@CO?\BGEGNAIDFB?@GIBJ??GC@G?B@ABHPE@AF??M@EBE?R?ADFCJEADCEZ@@@C??J@EAER@C@H@?BEBXCC?HC@I?J?DBHI?GGBDH?@CGEPD\DD?DJDDID@?FEGD?J?D@FELZ?@GCGSAFADF?AGDF??THCCC???AFA@?@DE@A?DIGE???BHCDJ?X@B@A?IGIBEJUF@@@E?@E@@?V?@GA@J?JICCA?@@E@@F?B@@@T?Y@@IHQR?@GB@?DC@FA@?BICA?V?A@C@JJ?DEDBNBBEE@?MIGIEBXIC@DMYUDD@DM?MDFCBUIECI@XH@I@?J?ABEDP??BBHB\IGAEIJCAABQZ?GAHE?M?@@@H?EEB@DVSI@FEAVDIIC?U?BBFB?F?BHC@?I@CI@WDD@@??XEB@CM??@FHCXEAFFEV@BAEMXWBDH@P??A@HB\F@IF@MVEAFEF?A@C@J??DB@CQDDDD?J?DIAHAJ@@ABPV?IF@DJ?XHEB@QBAGBGJ?FADFFQAI@FPMLEBCBMJ?@GBAJHAGEHSYHBDCGL@FEA?U?GE@G?L?ACAAPC@IAIY?@CB@GJGFGFT??ICIARNQHHAFJBBH@B?ED?DADOEDHA???GDA@R??CGBBNEI@@B?@ILIDD?FCI@?Q?DA@HM?JE@A@TE@EBERFG@CL\?FG@FS?UDAECWL?HD@E?AAA@GJ@@EA?U?@DEE?PUHIGA?EBENAI?@G@G@?@FAF???BBIG??NCGCFYHGGE?C?CF@EI?GE@C???B@DCLR?DG@HU@C@I@?Z@DBBG?IIDD??PCB@GP??GA@@JDD@UBD?AAFCI?DEFC?XLCFAG??NF@@BMPU@FDHODBFBB?AA?BBCQA@D@?U?BH@BN??IEA@?@EAH@?RIAHDE?F@CC?TWDE@@RZ?CDIA?JLDCHCJ@@B@HTBBHGQPO@DB?BBN@I@@JR?EFDI?@C@BHS?HBAGGQGEABM??AEAHLV?HACDN@HYO@@F?@G@@EMB@A?FC?BIA?AA?@IGDJ?JBD@A?IEIBSA?A@CAFXCC@H?O?CIA@?R?HACE?CG@ODDRGGEIIJCFD?EEWB@@?DDOCD@@?PQBAFB?@C@GJC@?B@BD?D@B?GE?@G@A?MLBDBC?@@FA?DJCA@CHOE@@UDFL@BF?DD@HJD?EHFFE?I@BD?R?HA?@EB?EF@@??JDBDA?B@HB?CT@@BI@?DA@FM?NAAH?DAR@C@@???IABA?EDEBC??H@@HE@?@BIA?MZFA@DVV?@II@RR?GGHC?AIDAIJTHAIABWB@CENNQ@B@B?J?CD@D??MC@FGPIH@HI?\AGCAE?@EHDR?P@BBD??MC@F@J?TA@@@YBGI@HQQEGEF@?AA@CNMLCBA@???DDBBJ??CDEC?I@HD@SUEFIDGNIBB@??JHII@??XGBA@?W?@GAI?BAE@B?CHIHVO??@@GD@?@EEC?S?H@@BXJ?GDH@ZHH@BD?H@@C???@B\@@@QAACH?DYDDDL?HAAHD?GI@@QR?GBSCG@N@A@BS??EGHB?EI?IEH?CH@@CJIIC@????DIDGDMF@AI??VBBFIRD?HCCD?DB@CDYDD@HMIMGFFI??XED@@?PODDD@OMLBDA@?@I@AA?FEIC?Z??BBFCH?EACI??MEEFF?TWGB@H?C@ECGNI@AJII?HG@P@@?IFAAL?THB@HXM?CCADNCCCCEJEDBXBBVG@@M@@XEEGDU?J@DGA?G??HCC?A@AFB?HAAZBBLF@AZACODBDIR??@C@B?M?EIEG?BAB@H?A@?@@@PCCFJEELIGBC?V?II@@??XEB@@ODAE@?DBHNHHBQ@B@?DUDHDGLBIBBAQA@@?AF?H@OBEE?@A@BX?M@EBCJJ?GGGCL@EEBE??BAIBC?BA@@?Q?BDHAJL?ABHCQL?FHE@?BEHBHP?IEID@?DEFA???@?BFBB?DBAC???DG@@S?Q@FDDQB@BGG?BBA?BBRC?DHCB?AFBB?PUEI@C??XGCFI?ACAAFRPBHDBDL@DA@?J?@DHA?O?B@C@OR?D@GC?@@@I?CJID@IC?AADAV?TH?@BEAVB@E@X??@@ADSYUCCDD?IIB@A?PDHDEFZ@AHIOO?E@CI?PQFAIAV??@AIF?ACA@@LJ@F@@CU@EF@?J?EBCC???@HG@???IEBBPDDDBUBR@AC@IUBAFF?NRJB@FHBL@A@@??PIEFAX??FB@CJ@C@FIN?EIFEDWHFAIOVLGAABSTZ@@I@YSZGBFF?CEC@EO?@@HBBUBGI@O??@AFD???BGBEJ??EBIFSH?GID@YAFBE@LCE@?HHSCB?@HCLF@@B?L?CIHE??O@CDESCC@D@??DGCFC?EGCHZMW@BBG?M?AD@AQ?XADAA?EDC@MBUIBIA@ZCHBIQNR@IM@@A?B@@G???CCA@P?JDCFCWCB@G@JJGFFDA?GCCINSWCDIALPO@B@@L?T@C@AVEEA@CL?IIDDCX@D@IYSREHAHP??C@A@?J?@CBB?DD\IDDPEBEGD?EIFQ@@OBAGMII?B@@BSJ?@CCEN?NEAD@?F@FHN@?E@EGGNFDBDNZ?BEE?BB?AEBGN?TCGH@MBDFHR@?BB@BAO@@ALAALHEAZAF?@GB?@HOHBAE?J?@H@E?G@BGP@QB@BACZ@IA\IDMIEC?F@?B@@@?J?DEA@L@I@I?EJF@CF?HCDIU?MB@BF?EITGFI?CC?BBDBO?XF@BC?E@@IZG?GGEE?BB@DJW?G@B@L@@XBEAVGGJGBHCSG@E@?A?BBAHNIIFD?J?BFAGPJ?D@C@NDDYCE@RGGH@H?ETBDBBJ@AQC@@?FAGEO??H@DA?R?DB@@?HDDDUG?HCD@HNH@BOEI?IIJGG@?HCAHO??GAF@?J?@DC@OAEFC@?QAAABD?HGGAQ??DEFWEE?ED@B??X@B@CMI?D@EBUDCDF@ZYBGBGA?@C@@?U?HHHB?O?A@HBNPOH@FDR@BA@SA?B@HB@LEEA?DDJIBC?GE?HC@F???HAAI?MW@C@E?GFHGODL@@DF@WIAAF???AEDOFC?DG@DT??ACA@?CC@MCEVFFGAD?@AHPC@?G@JACA?BCECUSRB@ACONQ@@C@TC@@I?@\AGAABWIE@RFCQACA?EEJIBE@??NFHBDS??AG@A?@@@@?BXI@IC@NIAHTIAQBG@?DUHGID?I@IA@PDTCEB@?@@@E?J?B@@@?XLDIGCU??@III?HBEGGJ?DID@D?CCB@?TWLIA@@I?BDDGNNWCDIEYL?GFEB?@GB@@SRIDDGDPABHDX?XC@D@J?TBBCE???@DD@??PGCH@OGDCGDV@?EIID?B@EAQ??CCEIL??@CHGQ?M@CAC?CB@A@?MABAAG?BFACMML?AF@GAXBECA??YHEEH?MWEIDAVCHB@@O?HBFFG?ABB@??YAEDCSJ?@@A@??N@@EBUA?AADI?EHGAI?IN@G@@ZI@ED??MHAFC??O@ACHNJ?ID@F?E@@E@P?EGEAC?CEFCO?VYDDDCUCXHDIHCU@@?ABAYACHDXJ?BEEA?T?BDBI???CEAIXBAHHA?LBBCAA?E@@BJ??CDA@QZ?F@EBY??AD@CNBBIF@W?@I@H@?BGE@??T?B@ABCJACFARJ?BF@H?LYGAB@XGAGGI?P@@@@D?F@EEYZ?IBBDU?M@HB@NYOFB@D?AABCE?WICCAGOA@GC???BE@P@@JFD@FVTL@@FAY??EEGBJBABHAMAEOCCDOCFAJBHVHFDBR?N@ABBVJ?BIAE?CCCE?FU@F@DCLBCI?AFLHAEMCC?@FA@PNQG@@I?FA@XDE?HHFCD?HB?EEH?E@DXC@WBHB?AA?@DAATDDJDD??CC@@AJ@I@?BD?CI?IEA?F@BA??PEABF???FC@DNBFHF@J?EECHE?A@BD?J?@EGC?JLDADB??ZDG@IY@@?GCB?EBIBF?@@IAJ?X?CCIBC?@C@A?J?G@@@??XIEBH?EE@CE?NII@FBLFE@CO?JF@CW@B?A@IG???C@HB?W?DCA@WGE@A@?AXFC@D?IFIE???HCDE?L?IIEFU?UHFDHQ@BBEC??EFDIFMFF@AV??@BC?C@?EBCDP??FFA@VW?GA@F?HABIG??ICADIMC@FBYU?@EA@?KAKBKCKDKEKFKGKHKIKJKKKLKMKNKOKPKQKRKS~@DKTKUKV`ATaAVcAUdAVKWKXKYKZK[K\K]K^K_@K`@Ka@Kb@Kc@Kd@Ke@Kf@Kg@Kh@Ki@_AHKj@Kk@Kl@Km@Kn@uAj@Ko@Kp@Kq@Kr@Ks@Kt@Ku@Kv@Kw@Kx@d@k@Ky@Kz@e@l@vAn@d@o@wA{@K|@K}@K~@K_Ae@`AKaAKbAKcAKdAKeAk@Bd@fAeBbAgBdAiB~@`Bm@jBaAfBcAhBeAaBp@xAr@zAgAKhAKiAKjAm@q@yAs@{Au@lBn@eAXfAZhA\jA^lA`@mAb@oAd@qAf@sAh@e@y@sBr@pBhArBjAmBbAKkAKlA}Aw@{Bz@o@YgA[iA]kA_@j@a@nAc@pAe@rAg@tAi@dBaAnBdAkBBm@{@bB}@k@_Aq@kAp@s@KgAqBiAs@t@q@cAoB~@kCu@fCbA}BlAt@kA_CZtB]aC`@wBc@dCf@zBi@lCdAgC|@cB~@nClAoC[`CmAKnAKoAKpAKqAsCeAs@gAjCjAt@cAmCB~Bx@uC\uB_@j@rAKsAxBe@eCh@tC}@_D~@|CdA{ChAg@]pCa@cCd@yBg@aDeA`D_AbDiAiClAfDjA`@^vBa@cDe@~Ci@gD_@bCb@}Cf@iD`@qCd@dDh@u@a@hDf@eD~@`@mAvCoAxCqAmDBzC~@lDb@jDg@qDc@rCg@sDd@kDi@pDBuDe@vDf@nDnAwCpAyClAwDg@yDh@zDi@g@tAKuAKvAKwAKxAKyAu@rAKzArDh@`@{AK|A`@}AK~AK_BK`B`E|Aw@oAoDlAeEpA`@aBKbBg@cBKdB}DxA~DlAgEdBhEyAfEqAi@zA_Ei@`@eBKfBKgBKhBKiBiEwAKjB{DuA|DwArEBi@sA`@kBKlBx@bBdElAz@xAx@mBz@jB{@lAwEn@uEc@tDh@yEBlEc@{Ei@vElBxEyAw@nBKoBKpBnEfBoEhBqElAkElA}ElA`FgBpEiB{@B~EoBaE~AbE`B|Ed@cFpBeFe@bFhBdF_BzEd@gFiBiFe@i@qBKrBsEvAjElAfFf@hF`BnFg@oFh@kFf@pFi@lFrBqFg@jFlArFh@sFi@mFwA|@jBo@sBKtBKuBKvBKwBtFB|@xAuFtBvFvByFuBwFwBxFyA{FlAzFvBp@xBKyBKzBK{BK|BK}BK~BK_C|FwB?`C</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????A??B??B?????C??A??A?????D??E??PY?CF?F??G??`??w@?F??G??@??_B?H??A??A?????I??E??pS?WC?J??K??@U?wL?H??L??@F?WC?J??M??@A??G?N??M??@?????O??P??`??o@?Q??P??`??{A?R??P??`??cB?S??P??`??KC?T??P??@E?{O?T??U??@C?wp?T??U??@?????V??A??A?????F??G??`@?_B?H??P??@D?[A?W??A??B?????X??E??pA?Cs?Y??E??P@?kf?Z??[??@V??F@\??E??pH?_O?]??^??@@?k`?_??E??@B????`??a??`S?kB?b??c??pH?WE?d??e??P@?[@?d??e??pD?SC?f??e??PG?OE?f??g??PX?[G?h??i??p??GB?h??i??p??sC?j??i??PA?cE?j??k??pA?KF?h??l??p@?GB?h??l??@??SC?h??A??A?????H??L??PJ?sC?H??m??Pf?cJ?H??n??@T?wL?o??P??@O?[D?p??A??A?????H??m??@A@sK?H??q??PD??H?`??r??pB?GB?s??t??P@?c@?u??v??pB?gF?u??w??@??GE?\??A??A?????I??E??@M?KC?x??y??@D?_G?z??A??A?????H??n??pM?wL?o??A??A?????`??r??`A?GB?{??|??p@????}??~??P??????@?@@?@B?__?A@?A??A?????H??n??`L?sL?B@?M??@A?SG?B@?M??`C?gG?B@?C@?`E??K?D@?E@?@D????F@?~??@A????H??m??@o?oJ?u??w??`@?GE?\??P??p@?_H?G@?H@?@B?KY?]??A??A?????B@?C@?P??sJ?W??A??A?????b??c??PQ?_E?H??I@?@W?GN?H??J@?`??cO?K@?L@?`N?CJ?M@?P??`@?GA?f??e??PK?WE?f??N@?pL?{H?`??a??@G?cB?o??O@?`N?GG?C??P@?`@?_fAC??P@?PI?_hAQ@?R@?@C?Co?S@?T@?PI?wmBf??N@?`S??I?b??c??PG?WE?B@?L@?@@?[K?b??c??@H?WE?U@?V@?P??kd?W@?X@?`B?SE?W@?A??A?????b??c??`P?_E?K@?P??pA?WD?`??a??P??OB?o??Y@?@C?SF?b??c??PO?_E?j??Z@?`B?WQ?j??[@?`B?cS?\@?]@?P?????j??^@?P??WQ?Q@?R@?p@?Co?b??c??`K?_E?K@?A??A?????K@?P??PF?_D?H??J@?pA?gO?J??_@?P??WH?`@?A??A?????f??N@?`I?wH?a@?A??A?????Z??[??`E?GE@Z??b@?pc?WA@c@?d@?@D?OY?e@?f@?`B?gc@g@?A??A?????u??v??PD?kF?Z??h@?PN?sS@c@?i@?pA?_T?j@?k@?@@?GS?l@?k@?PA?cH?m@?n@?pB?gy?m@?n@?`u?[j?o@?A??A?????</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

    const H = Math.random() * 6;
    const dX = 1 - Math.abs(H % 2 - 1);
    let dR, dG, dB;
    switch (H | 0) {
        case 0:
            dR = 1; dG = dX; dB = 0;
            break;
        case 1:
            dR = dX; dG = 1; dB = 0;
            break;
        case 2:
            dR = 0; dG = 1; dB = dX;
            break;
        case 3:
            dR = 0; dG = dX; dB = 1;
            break;
        case 4:
            dR = dX; dG = 0; dB = 1;
            break;
        case 5:
            dR = 1; dG = 0; dB = dX;
            break;
    }

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2594008277;
    let startMs = 1665595908560;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","no_Java_frame","java.lang.String","one.nio.server.AcceptorThread","run","one.nio.http.HttpServer","createSession","one.nio.http.HttpSession","one.nio.server.SelectorThread","one.nio.net.Session","process","processRead","read","one.nio.net.NativeSocket","one.nio.net.SocketClosedException","<init>","java.net.SocketException","java.io.IOException","java.lang.Exception","java.lang.Throwable","fillInStackTrace","java.lang.Object[]","byte[]","java.lang.Thread","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.zhidkov.services.ZhidkovService$1$$Lambda$150.0x0000000800d015b0","ok.dht.test.zhidkov.services.ZhidkovService$1","lambda$handleRequest$0","ok.dht.test.zhidkov.services.ZhidkovService","handleGet","ok.dht.test.zhidkov.model.storage.MemorySegmentDao","get","ok.dht.test.zhidkov.model.storage.Storage","entryIndex","jdk.internal.foreign.MappedMemorySegmentImpl","asSlice","jdk.internal.foreign.AbstractMemorySegmentImpl","asSliceNoCheck","dup","processHttpBuffer","parseRequest","one.nio.http.Request","java.lang.String[]","handleParsedRequest","handleRequest","ok.dht.test.zhidkov.services.RequestExecutorService","submitTask","java.util.concurrent.AbstractExecutorService","submit","newTaskFor","one.nio.net.NativeSelector","select","one.nio.net.NativeSelector$2","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","ok.dht.test.zhidkov.services.ZhidkovService$1$$Lambda$150+0x0000000800d015b0","one.nio.util.Utf8","toAsciiString","java.lang.invoke.LambdaForm$MH.0x0000000800c9dc00","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800d0a000","java.util.concurrent.Executors","callable","sendResponse","writeResponse","one.nio.http.Response","toBytes","one.nio.util.ByteArrayBuilder","entryAt","getParameter","substring","java.lang.StringLatin1","newString","java.util.Arrays","copyOfRange","jdk.incubator.foreign.MemorySegment","ofArray","jdk.internal.foreign.HeapMemorySegmentImpl$OfByte","fromArray","getPath","toByteArray","toArray","jdk.internal.foreign.AbstractMemorySegmentImpl$$Lambda$162.0x0000000800cbc418","apply","lambda$toByteArray$0","write","one.nio.net.Session$ArrayQueueItem","ok.dht.test.zhidkov.model.storage.BaseEntry","getTask","java.util.concurrent.ArrayBlockingQueue","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","execute","offer","java.util.concurrent.locks.ReentrantLock","lock","java.util.concurrent.locks.ReentrantLock$Sync","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquire","java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';``
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    ratio *= 0.8;
                    const C = 1 - Math.abs(1 - 2 * ratio);
                    const m = (1 - ratio) - C / 2;
                    color = 'rgb(' + (dR * C + m) * 255 + ',' + (dG * C + m) * 255 + ',' + (dB * C + m) * 255 + ')';
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
