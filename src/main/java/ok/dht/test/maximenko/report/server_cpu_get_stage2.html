<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BMlZAvBdDvFnGcLiNtQjRcTtUvUkZhc@??????????????????????????????????????????????????????????????????????????????????????????????????????????YXhZYRRhSI`[JISKKLH`QYXQZBQYJRZKKJKKIZR[JYTHTKHRR````pRZKJY`h\Jh`Q[H[Jh``hSJ`Q`SKLKKKH`SI[I[H`YZRhhYpRh`Z`[IQ`ZRZ`KI[HY`R``KHp[H`JTHh`IZZXp[LLIhZSKHQ```YQ\KLI\ISIUG`p``h`h`RhZSIRhZKI``JSLLKIx[KHZY`Z`IR`UH`QTJJZ[I``h]KJR`[JSIQUKIh`hRRZ`SIRZ`RSLH[KI`KHZhYQ\JQRYp`RKJ``QTJ`xZp``RY[JSKKR``hSIRhp[J`Y`Z[I\KI]HhQX`[KIRY`ZZ`TKKLJYhJQhZZRLLIQSJ`Q`RR`R`LKLJ`Qh`[J\J`RQhKLH[KHhJYh\J```Z`QR`hKHYhR`JZ`YZh`h`Z`RhPZSJWhJTHhCI`[IXSJ[IZX]LJ]LJTH`hKHY\JYY`TIYZTIYh\KKJ\JhhSHhhRJSKH`Y`ZYQhLI`JX``^JR`hhSJh\JYpKKLMJYZVH\KJSJ`QSJ`KIG???????????????????????????????????????????????????????????????????????????????????????????????????GkdAkdAwsAmqAdzAcvAqoAakB_sAzaBysAkqAvvA|tAk}AkjAexA_~ArbBssBdlAmpAlxBcyAfgBjgBboAdvAthBziBbsB`nA|wAaeAoiAedB{kAxsAp~A{aBteBvhAbmAqtA_|AnfBdxBxkAdnA`sAd{Af{Aw_BvaBueBveBtgBmhBwhAejA_nA`oAhtAyyAxzAu_Bv_B}_BkaBtaBmcBldBzdBffBylBunBfrBhsBusBkfAtgAgiAsjAtkAjoAaqAprAkuAbwA{wA~~Ak_B~_Bp`BnbB{cBadBgeBpgBaiBnkBbpByeAmfA{fAmgA`hA_iAqkAmmAsnAeqAnqAyqAtrAisAusA~sAouApuA~uAvxAfyA}yAkzAtzAzzAa{A|{An|Al}A`~A|~Ab_Bc_B~cBigBsiB_kBcrBvtB`|BwaCbeAzfApgAvgAygAojAckA_lAilA`mAemAomAnoAyoAkpAxpAcqArqAsrArsAvsA`tAbtAnvAwvA_wA`wAlwAmwAnwAqwAtxAsyA|yA_zAozAqzAwzAi{Av{Ah}Ao~A{~Af_Bm_Bz_Bi`Bl`By`B_aBbaBjaByaBcbBdbBobBbcBkcBgdBhdBidBeeBseBcfBgfBkfB|fBegB|gBuhBwhBgiBxiBdjBojBvjBckBokB_lBvlBfnB|pB~pBjqBqrBurB~rBjsBauBkuBivBuzB|{B}{B_|Bu|BudAwdA|dAffAufAlgAqgAsgAahAjhAlhAnhAzhA}hA~hA`iAniApiAviA}iAgjAxjA`kAekAfkAnkApkAclAtlAwlA_mAamAdmAhmAkmAwmAxmAbnAmnAnnAaoAsoA}oAupAdqAgqAsqAuqAgrAnrAvrAxrAtsAotAjuAmuAuuAivA|vAhwAkwApwAxwAywA`xAdxAmxAuxA}xAoyAtyAezAizA|zA~zA_{Ar{Ab|Ad|As|Aw|A_}Ab}Ac}Aj}Aq}Ax}A{}Aj~Al~An~At~Av~Ae_Bo_Br_Bs_Bd`Bg`Bo`B}`BgaBiaBqaB`bBhbBwbBybB`cBfdBsdBvdB{dBoeB`fBafB`gBbgBmgBsgBbhBihBqhB{hBpiB{iB~iBjjBnjBxjByjBekBtkB}kBflBjlBplB}lBzmBknBmnBnnBxnB}nBdoBioBroBhpBspBbqBdqBeqBqqBwqBtrBxrB{rB|rB`sBosB~sBktBrtBstBruBevBnvBtvB`xBfxBwxBdyBqzB`{Be{By{B~{Bv|Bv}Bw}B_~Bd~Bm~Bl_Ct`CcdC|dCldAndAodApdAqdArdAsdAtdAvdAxdAydAzdA{dA}dA~dA_eA`eAdeAeeAieAoeAqeAreAseAteAueAveAweAxeAzeA{eA|eA}eA~eA_fA`fAafAbfAcfAdfAefAgfAhfAifAjfAlfAnfAofApfAqfArfAsfAtfAvfAwfAxfAyfA}fA~fA`gAbgAcgAdgAegAfgAggAhgAigAjgAkgAngAogArgAugAwgAxgAzgA|gA}gA~gA_hAchAdhAehAfhAghAhhAihAkhAmhAohAphAqhArhAshAthAuhA{hA|hAbiAciAdiAeiAfiAiiAjiAkiAliAmiAsiAtiAxiAziA{iA|iA~iA_jA`jAajAbjAcjAdjAfjAhjAijAjjAljApjAvjAwjAzjA{jA|jA}jA~jA_kAakAbkAdkAhkAjkAkkAlkAmkAskAvkAwkA}kA~kAblAelAglAklAmlAolAplAqlArlAslAulAylAzlA{lA|lA}lA~lAfmAjmAqmArmAsmAumAvmA{mA}mAgnAhnAjnAlnAonApnAqnArnAtnAvnAxnAynAznA{nA|nA}nA~nAcoAdoAfoAgoAloAmoApoAvoAwoAxoAzoA|oA~oA_pA`pAapAbpAcpAdpAepAfpAgpAhpAipAnpAopAppAqpArpAspAtpAvpAypAzpA{pA|pA}pA~pA_qA`qAbqAhqAjqApqAqqAtqAwqA{qA|qA}qA~qA_rA`rAarAcrAerAirAjrAkrAlrAmrAorAqrArrAurAwrAzrA|rA~rAasAbsAcsAdsAfsAksAmsAnsAosApsAqsAssA|sA}sAatAdtAetAftAgtAjtAktAltAntAptAstAttAutAvtAwtAytA_uA`uAauAbuAcuAduAeuAfuAguAhuAnuAsuAtuAvuAwuAxuAyuA|uA_vAavAbvAfvAgvAlvAqvArvAsvAzvA{vA}vA~vAewAfwAjwAowAtwAuwAwwAzwA_xAaxAbxAcxAgxAhxAjxAkxAlxAoxAqxArxAsxAxxAzxA_yA`yAbyAdyAhyAiyAjyAlyAnyApyAqyAryAvyA{yAazAbzAczAgzAhzAjzAlzAmzAnzAszA{zAg{Ah{Ak{Al{Am{An{Ao{Ap{Aq{As{At{Ax{Ay{Az{A{{A}{A`|Aa|Af|Ag|Aj|Ak|Am|Ap|Aq|Ar|At|Av|Ax|Az|A{|A}|Ae}Af}Ag}An}Ap}As}At}Aw}Ay}A}}Ab~Ad~Ae~Af~Ag~Ah~Ai~Ak~Ar~Aw~Ax~Az~A}~A`_Bg_Bh_Bj_Bp_Bq_By_B``Ba`Bc`Bf`Bk`Bn`Bs`Bu`Bv`Bw`B{`B|`B`aBdaBfaBhaBnaBuaBxaB|aB}aB_bBabBbbBfbBgbBibBjbBlbBmbBqbBsbBtbBvbBxbB{bB|bB}bBacBccBecBfcBhcBicBocBpcBqcBxcBycBkdBndBodBpdBqdB}dB`eBceBfeBieBkeBmeBneBqeBreBweByeB{eB}eB~eB_fBbfBjfBlfBqfBsfBtfBufBvfBxfByfBzfB{fB~fB_gBagBcgBdgBkgBlgBngBogBugBwgBxgBygBzgB{gB}gB~gB_hBdhBehBfhBhhBkhBlhBnhBphBrhBshBvhByhB|hB}hB~hB`iBdiBfiBiiBjiBkiBliBniBoiBqiBriBtiBviBwiB_jBajBbjBejBfjBhjBijBljBmjBpjBqjBrjBsjBtjB|jB}jB`kBbkBdkBfkBlkBskBvkBykBzkB{kB|kB~kBclBelBglBhlBilBllBmlBnlBslBulBwlBxlB{lB|lB`mBamBcmBdmBemBgmBhmBlmBmmBnmBomBpmBsmBumBxmBymB|mB}mB~mB_nB`nBanBbnBcnBdnBenBgnBhnBinBjnBlnBonBpnBqnBrnBvnBwnBynBznB|nB~nB`oBboBcoBeoBhoBjoBkoBmoBnoBooBpoBsoBtoBvoBzoB{oB}oB_pBdpBfpBipBnpBqpBupBwpBypB_qB`qBfqBgqBkqBmqBnqBoqBrqBsqBtqBuqBxqByqB{qB|qB}qB`rBdrBlrBsrBvrByrBzrBdsBesBfsBksBmsBpsBqsBtsBwsBzsB|sB_tB`tBatBbtBctBdtBgtBitBntBotBqtButBztB}tBbuBfuBiuBmuBouBtuBvuByuBzuB|uB_vB`vBavBbvBcvBmvBovBpvBqvBrvBvvBwvBxvByvBzvB|vB~vBewBgwBiwBuwBvwBxwB{wB|wB~wBhxBixBjxBtxBvxB{xB}xBbyBgyBiyBjyBmyBnyBqyBzyB{yB}yB`zBazBdzBfzBgzBhzBkzBlzBozBvzBzzB|zBa{Bd{Bn{Br{Bs{Bw{Bc|Bd|Bk|Bm|Bo|Bq|Bs|B||B~|B_}B`}Ba}Bb}Bd}Bf}Bl}Bo}Bx}By}B{}B|}Bh~Bk~Bl~Bn~Bo~Bq~Bv~By~Bz~B}~B__Cc_Cf_Ch_Co_Cx_Cz_C}_C~_Cf`Ck`Cm`Cp`Cr`Cs`CfaCpaCraCuaC}aCjbCvbCybC{bCccCdcChcCicCscC{cC`dCadCedCgdCjdCldCmdCpdCsdCydCzdCpeCcfCffChfCkfCnfCzfC|fClgCpgCmdAceAfeAgeAheAjeAkeAleAmeAneApeA|fA_gAagA{gAbhAxhAyhAaiAhiAqiAriAuiAwiAyiAmjAnjAqjArjAtjAujAyjAgkAikAokArkAukAykAzkA|kA`lAalAflAhlAjlAllAnlAvlAxlAcmAgmAimAlmAnmApmAtmAymAzmA|mA~mAanAcnAenAfnAinAknAunAwnA_oAeoAhoAioAkoAooAroAtoAuoA{oAjpAlpAwpAfqAiqAlqAoqAvqAxqAzqAbrAdrAfrAhrAyrA{rA}rAesAgsAhsAjsAlsAzsA{sA_tActAitAmtArtAxtAztA{tA}tA~tAiuAluAquAruAzuA{uA}uA`vAevAhvAjvAkvAmvAovApvAtvAuvAxvAyvAawAcwAdwAgwAiwArwAswAvwA}wA~wAfxAixAnxApxAwxAyxA{xA|xA~xAayAeyAgyAkyAmyAuyAwyAxyAzyA~yA`zAfzApzArzAuzAvzAyzA}zA`{Ab{Ac{Ae{Aj{Au{Aw{A~{Ac|Ae|Ah|Ai|Al|Ao|Au|Ay|A||A~|A`}Aa}Ad}Ai}Am}Ao}Ar}Au}Av}Az}A|}A~}Aa~Ac~Am~Aq~As~Au~Ay~A__Ba_Bd_Bi_Bl_Bn_Bt_Bx_B{_B|_B_`Bb`Be`Bh`Bj`Bm`Bq`Br`Bt`Bx`Bz`B~`BaaBcaBeaBlaBmaBoaBpaBraBsaBwaB~aBebBkbBpbBubBzbB~bB_cBdcBgcBjcBlcBncBrcBscBtcBucBvcBwcBzcB|cB}cB_dB`dBbdBcdBddBjdBmdBrdBtdBudBwdBxdBydB|dB~dB_eBaeBbeBdeBheBjeBleBpeBxeBzeB|eBdfBefBhfBifBmfBofBpfBrfBwfB}fBggBhgBqgBrgBvgB`hBahBchBghBjhBohBxhBzhB_iBbiBciBeiBhiBmiBuiByiB|iB}iB`jBcjBgjBkjBujBwjBzjB{jB~jBgkBhkBikBjkBkkBmkBpkBqkBrkBukBwkBxkB`lBalBblBdlBklBolBqlBrlBtlBzlB~lB_mBbmBfmBimBjmBkmBqmBrmBtmBvmBwmB{mBsnBtnB{nB_oBaoBfoBgoBloBqoBuoBwoBxoByoB|oB~oB`pBapBcpBepBgpBjpBkpBlpBmpBopBppBrpBtpBvpBxpBzpB{pB}pBaqBcqBhqBiqBlqBpqBvqBzqB~qB_rBarBbrBerBgrBhrBirBjrBkrBmrBnrBorBprBrrBwrB}rB_sBasBcsBgsBisBlsBnsBrsBvsBxsBysB{sB}sBetBftBhtBjtBltBmtBptBttBwtBxtBytB{tB|tB~tB_uB`uBcuBduBeuBguBhuBjuBluBnuBpuBquBsuBuuBwuBxuB{uB}uB~uBdvBfvBgvBhvBjvBkvBlvBsvBuvB{vB}vB_wB`wBawBbwBcwBdwBfwBhwBjwBkwBlwBmwBnwBowBpwBqwBrwBswBtwBwwBywBzwB}wB_xBaxBbxBcxBexBgxBkxBmxBnxBoxBpxBqxBrxBsxBuxBxxByxBzxB|xB~xB_yB`yBayBcyBeyBfyBhyBkyBlyBoyBpyBryBsyBtyBuyBvyBwyBxyByyB|yB~yB_zBbzBczBezBizBjzBmzBnzBpzBrzBszBtzBwzBxzByzB{zB}zB~zB_{Bb{Bc{Bf{Bg{Bh{Bi{Bj{Bk{Bl{Bm{Bo{Bp{Bq{Bt{Bu{Bv{Bx{Bz{B{{Ba|Bb|Be|Bf|Bg|Bh|Bi|Bj|Bl|Bn|Bp|Br|Bt|Bw|Bx|By|Bz|B{|B}|Bc}Be}Bg}Bh}Bi}Bj}Bk}Bm}Bn}Bp}Bq}Br}Bs}Bt}Bu}Bz}B}}B~}B`~Ba~Bb~Bc~Be~Bf~Bg~Bi~Bj~Bp~Br~Bs~Bt~Bu~Bw~Bx~B{~B|~B~~B`_Ca_Cb_Cd_Ce_Cg_Ci_Cj_Ck_Cm_Cn_Cp_Cq_Cr_Cs_Ct_Cu_Cv_Cw_Cy_C{_C|_C_`C``Ca`Cb`Cc`Cd`Ce`Cg`Ch`Ci`Cj`Cl`Cn`Co`Cq`Cu`Cv`Cw`Cx`Cy`Cz`C{`C|`C}`C~`C_aC`aCaaCbaCcaCdaCeaCgaChaCiaCjaCkaClaCmaCnaCoaCqaCsaCtaCvaCxaCyaCzaC{aC|aC~aC_bC`bCabCbbCcbCdbCebCfbCgbChbCibCkbClbCmbCnbCobCpbCqbCrbCsbCtbCubCwbCxbCzbC|bC}bC~bC_cC`cCacCbcCecCfcCgcCjcCkcClcCmcCncCocCpcCqcCrcCtcCucCvcCwcCxcCycCzcC|cC}cC~cC_dCbdCddCfdChdCidCkdCndCodCqdCrdCtdCudCvdCwdCxdC{dC}dC~dC_eC`eCaeCbeCceCdeCeeCfeCgeCheCieCjeCkeCleCmeCneCoeCqeCreCseCteCueCveCweCxeCyeCzeC{eC|eC}eC~eC_fC`fCafCbfCdfCefCgfCifCjfClfCmfCofCpfCqfCrfCsfCtfCufCvfCwfCxfCyfC{fC}fC~fC_gC`gCagCbgCcgCdgCegCfgCggChgCigCjgCkgCmgCngCogCqgCrgCsgCtgCugCvgCwgCxgCygCzgC{gC|gC}gC~gC_hC`hCahCbhCchCdhCehCfhCghChhCihCjhCkhClhCmhCnhCohCphCqhCrhCshCthCuhCvhCwhCxhCyhCzhC{hC|hC}hC~hC_iC`iCaiCbiCciCdiCeiCfiCgiChiCiiCjiCkiCliCmiCniCoiCpiCqiCriCsiCtiCuiCviCihA???????_@???iB????_@hB?_@???g@?`@?hB?hB?_@??R????_@????_@????wG?AA`@D??X?g@???hB`@_@?R??A???@@uP?iB????XRz@?M@R~CIA??F@@{TM@?A??z@A??S??R????~U@??gG???A@McG?CMC?????A?~C@???F?@@@??@?sAHA@MA?XBY?C?X???SBA??Bg@@?Y}@MAX??F??F?A?@CC@???C?iBvB??A??BUD?g@?@Y?BA???F???A_UI?AA?B??@?@xB?BCnD?{WlGqW@F??M??C?H@C?^@F?DF??A??@C??@?UA??B???JuAUA@R?`@`@???@?_@?I?D?`C?eH??zC??@???rB?yW????@?@c@@CnHAOCvB?wD?DA?yCPB?@qB@?aE?e@@A?BBCFpAD??e@@yBe@?XJGnA??@A?Ha@AmDCkYAI@????N??|HG?iPaE@AbALAGDA?qCRA??@H?Ag[?@AJD?AS?Au@BClBjD?`A?@?C@?C??AC@qID|AF@DbEB???@@@B@?S@sA@?gHKAM?_@?nA@?IF@LA?B?AF?ADC`@A`J@AS?Ou@?ADyZ@H@AAvH???pCmD???~BH?AC_Cf@X|H??@@??_A??X?@AA?gIzGRB?AFA@aE?{I??iI@iI@WBnHtAP?BB??A?I@@rD?DaHi]?@?AqEM??A@?|@B@aILD@????kEVZZD??S@HA`JA?@@?EXf@??B|YW??wY?H?@?s@jEu]Cv@H@_A}DA@@EA@DCtAfDCj^?IBBCnDA?????F?@??|C?A?A?B@nEACJ?CzZnD@?R?@??hAOaBA{D?@CB?AP?BA@AqBuZhCA@K?G?aJ??PAA`Ck@?F?rD?N]O?AGsAMFcJAdJE?@tA?Cw@IA@RmAA?F~CG?@]AL???@dZ@dAE@CFmA@AwB|@???ADxBBb@wEjI?@??yEA?KAc]CAGJy^C??D?A@?PZ?E`@BAf@C?L?}@@g@xA??e]E??u@?AA`@?@BHC?@ja@cA??@D{GOAv`@fJOdKG_CWA`@BdIg@EC@F?}B?{@aAhCA@G@??C@@??hC}[kE@?jAPvEDuAF??cJ@fC??@?A?CACmZBwE?DDbCLw[n^@E@MpEB???@A{^@Cz@b@?`BIZOA?@U?E?oZ?Ag@CB?O@Af@WJ@b@?@[?DJB?A??@?yJ??a@D??eK??A?jA@jAE??|I@Ba@?PCaA?B??ZD@?gTAo@?ha@rDAAtE@?CDuAiCh_@z@INQ?@@xDByE@O?_F@?AA@aAQ?@P@@B?eE`Ao@F`@MHH?bEe@BvI{YwE?@?cF_AOBECE]mK?G@jACPQ?qIgAzGkH@fAV`A?B_KsJE@EEeEA?yH`Ae@pEr@?gVA??b_@?AD@GGCA?b@QEvD?f[?Acb@McB?AJlIA?B|@@aA?Ba@?HqKB?A?HsAB?A?@@IAJBAHFzb@iACd@?\A?DzBBbIt@E|AcI@w@@o@?T????H{XT@mA@?@@?eBA?NKcFAA\?@?y[A?kAI?yBBj@TC?ZD`d@cAwKA_B?GH?@AD?EC?C?aJ?EbCoKZGw@?DZeK?dKNBl@mDC\?@@E?E??sA}JHCWaBJ?E?C@?@BaAiAxDgAOw@CEu@Ad@A@GBgH~J@@??AB@?q@DAC??qb@KRA??FA?@@@DE?BMw@CVApE\?X?aBCIJ{@h@?gA?{BG@m_@cADB??Ha@??EEGC_Dl@?kAlABpW?D?@B@D??eFB@_CAwD@?}KMC?AAH{ABAG?@AQCBADu@kCmE|DzEEAFcAjKnEAj@?Bl@?CiCTbAgCeE~A@A@\CWTA?tb@?A?pIp@TkEQ[?@@gACu@O@]?@CjIi^??r@}JGAA@lA@iAFIe@a@Y?A?DBA|I_FvAB?E|AG?G?TB@jFD\EAEHkAl@@L@_JiJFABlFjFaDGA\|J_F_ArF?p\|AO?bB@vK@?@h@E]??J[bA?XDZ@@?w@@@{EEJ?@AE??ACHkFYiCS?gIL@bJGA@Q?@qA???e@AH|Et@}AyE@CRvKgCX\Fyd@lYjd@AQ_KmAAzEHQL??a@?}KPJ?l@aClAGR?gAbL?PP?Y??@W@{@P?kKA?D?K@k@hD????AAkA?A?Bnd@?BwJ?c_@TBiA?oKG?`LBfHD?l@A?C?|EnK?@AZA?{@A?HA\w@AL]\?C?PrB{E?a@OA@?tQLDhFAdL?@`[?ba@@fCff@AAF?N?@c@CC?Add@of@`a@@CF??FA??_J@?@j@@D?Ba@ef@@d@CFCkCA?}e@GA?AfCN??H@rII_e@@I??@?C?@?QAEue@yXnX?AyABGdFBbLABeF@?B?@hKvDI@_AzBiCAA{E?@BGTAeLBAAQGaAe@hADOcBhFCzCs_@ABAEAE??@a@JAc@LC`A?sf@c@eFB@?OwHg@CzKuc@?Lyf@EqCACtAIhInE{DNTxKlAqJDdJ}@|K`L@At@@A?AvE?wZA?@A?fDr\@v@bFlCB|X?BBAD?@t@Wf@@AK?Tgf@aB@Bw`@FaDGLt@@lIWD@?M?ABBub@t@?cIl@?i[RE??vAA@?kAdF?It@DN?BCsb@CiAAB?QLjAaBT?Dxd@ve@CA|@AABwf@}HzKuAh@|ZbBA?v@@@??F{_@C@BjAHC|E?@bJ??DO@[`AjCCDAgAC_\HbAB_E@fD?wDxA[k^AxXH@c@LsJmY?@zY??ABZAv@@fc@A??vA???qe@q@@~[kFCad@?zEVBcAAItAe@?CL@?Y@Az@E@df@ScATAf@GClC?vf@@dLBDze@??F?fCAJA??GyAA?lA@EZDqChFQA????A?DnABAz@I\?B@@W@I_AWA??@~Jpe@SA\qf@AkCJQlFA?GsKrIzClCAvDJ|AkC@AMbF@?lF?@??@lC?KAdD?hC@?AF@@@Ad@A@GnKrB@qKQFjC@J?EBIiAnVAJ?BD@LCdg@`BDvZ`B?ATgCIBkg@Ai@ag@eCBu@GjE@t]NjCIW@?Ekf@?}b@?GDl@BNP?GbK}\@HCF@Wea@kFCGmECAgC?n_@AAh`@?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?VhLBiLDkLFmLHoLJ?W?X?Y?Z?[?\?]?^mCCjL_@?`@?a@?b@?c@?d@?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@?o@?p@?q@?r@?s@?t@?u@?v@?w@?x@?y@?z@?{@?|@?}@?~@?_A?`A?aA?bA?cA?dA?eA?fA?gA?hA?iA|LDyLGnLImFKnFjA?kA?lA?mA?nA?oA?pA?qA?rA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~A?_B?`B?aB?bB?cB?dBfBElLGaNJpLL?jAcNeBxLVfB_@}La@_Mc@aMe@cMg@dBi@fMk@hMm@jMo@lMq@nMs@pMu@qMw@sMy@mA{@eB}@wM_AyMaA{McAqFfB?gB?hBtNFzLImFW?iB?jB?kB?lB?mB?nBx@GuNKnFMrLOtLQuLSwLU|FH?oB?pB?qByFjBjOlB{FrB?sB?tBoAIbNLqLNsLPoFR?uB?vB?wB?xB?yB?zB?{B?|B?}B?~B?_C?`C?aC?bC?cC?dCdMh@?eC?fC?gC?hC?iC?jCoAoBpOqBrOkBzFmBx@kC?lC?mC_GwBwOyB?nC?oC?pCuF`@~Lb@`Md@bMf@y@i@}Nl@iMn@kMp@mMr@oMt@pFqC?fB?rC?sC?tC?uCpAvC?wC?xC?yCy@zC?{C?|C?}C?~C~FJvNjAxNUjBKkONuOQnOTqALwNkA?_DjBWyF`D?aDrCUm@MlOPvObD?cD?rB}FtB?dD?eD?fD?gDfPpBqOiBiOkBrCnBbGa@yNd@kPg@|Nj@gMl@nPo@vFr@pPu@?qCsChDmCiD?jD?kD?lD?mD?nD?oD?pD?qD?rD?sDuCqB?tD{LuDhGsB~PeD_QvDtCNyPRvLTm@jAxPVoGkA?eBjGjDhQlDjQnDlQpDkGrDlGg@dBeCaGwD?xDnGOmORoQUqGPoFyD}PrB}FzD?{DnQfD?vDb@XmGrBpAxB?|D?}D?~D?_E?`E?aE?bE?cE?dE?eE?fE?gE?hE?iE?jE?kE?lEaQb@jPe@{Nh@eMj@dQm@_Op@cGs@wFqCsCrCdGmEqAnEkBeBwCtBuGU`Rc@zNf@lPj@cRn@?oE?pExCkDiQmDkQoDmQqD?qE?rE?sE]vDy@tE?uE?vE?wE?xE?yE?zE?{EiRd@bQh@bRk@~Nn@oPq@`Ot@pFv@rMx@tMz@uM|@vM~@xM`AzMbA|MdA}MfA_NhA?|EuQQzPUrRe@aRi@mPm@dRq@uRu@aOx@xR{@cO~@{RaAfOdA?}Eb@~E?_F?`F?aF?bF?cF?dF?eF?fF?gFtChFrFxAnNzAoC|A?iF?jFsPwCtPkF?lFSf@jRk@hRV{CR?bDvQsBnBbDsStB]mFtScDIg@cQk@wGo@vFnF|Gh@sRl@eQp@eRt@vRw@xFz@yR}@dO`A|RcAgOhDrAlDpQoDmRqE?oFn@yBxO{BzO}B{O_C}OaC_PcCaPg@sQfCcPhCePjCnBSoOVfTTh@iB`QlBtOsB_DUoBi@aSn@tRr@iGqCgRsCeGuCuGrBkB_D`Hj@kRo@fQs@wFv@wRy@?pF?qF?rF?sFo@k@vSp@xSu@dSy@bO|@zR_AeObA}ReA~MgA`NiA?tF?uF?vF?mFiTVqSxCc@yCvP{CfGwF?xF?yFb@iBhTmBlTsB?zFDg@dBtEvGvE?{F?|F?}FqBl@wSq@cSv@pTz@{S~@xGbAvTfA_SiAxTuF|@m@bSr@sBjBsOmBuSrBsB`D{PlB_HzD~SmDlRpDrQsDi@n@jTs@oTw@zS{@fS_AuTcAqFeAwThAnC~F?_G?`G?aGpBjBfUrB{CyDn@bG?cGHg@?zCgUsB}GzByO|B`G~B|O`C~ObC`PdCy@eCaGgCdPiCjUnDqQqDyCdG?eG?fGSgG{UoD_TdG?hGtBzDbDtBn@|D?iG?jGsGkGyGlGKo@nTt@qPfBrPsCeGz@cDh@?tEvGmGtUkBrCrB?nGvCoGvCpGnBuBbGqG?rG?sG?tG?uGrBmF}UpDkGqE_DnBhVqDvCsDdHh@uU{CfG}C?vGKwG?xGh@~EhSyG?zG}CyAoN{AsF}AtF_BqNaBrNcBuC{G?|G?}G?~GuB{B`T~BvUaCcTdCxUfCeTiCfHp@wAq@`Uw@kU|@tT`A}SdA~RgA`D~FqU`GsUjC^r@iGv@aU{@lU`AmHeAoUiA?~FuVaGoV|B`G_H?`H?aH?bH?cHtGyAhD|A?dH?eHpCfHeUkBzFgHNs@fRfBbVhHvAzCwP|C?wFyTiH?jH?kHgDqE?lH?mH`Wt@ySx@eS|@rVaAgSeA?nHqGoH?pH?qH{@_FiSaFkScFmSeFoSgFKrH?sH?tH?uH?vHqH{C?wH?xH?yHdDtE|TzH_WlB{F{H?|H?}HUeGtBtB|C_FjWbFlSdFnSfFoH~H}CfE|QhE?_I?`I?aItHyG?bIiHzA?cIcHcDxBu@gQfB?dI?eI{BqCkTtCoDmB~@rCUrEnRg@~GgCNfI?gI}@|CaWxF?hIyBuE?iI~@fB?hD^nFoGjI?kI?lI?mI?nI?oI?pI?qItWgE}Q_IvWaIhWpHiWcDkBlAdNnAfNpAhNrAjNtAlNvAqD{AsFdH?rI{Bv@vV|@fWbAcUgA?sIj@w@xFpFqTtI?uI?vI?wI?xIh@tD?yIn@zI{Hx@eW}@|SaAgWfAbH~FzVjCn@{I?|I}VeEyG{AiD~A?}I?~I?_J?`J~@hD^aJYiG`VdE?bJcHTY}D?cJ?dJ?eJ`HfJUdG|UgJ?hJoBiJ_Cy@sT}@qXbAzHsIq@gB`Cz@bU_AmUdAsVhAnCtFaHyF?jJ?kJh@XmGlJbI{@wVaArXgA`DmJ_InBc@kFrSnJtDmAeNoAgNqAiNsAkNuAmNwAgBfEzBiElBkE?oJ?pJ?qJoDrJ~XhBp@vE}T|FUhGuHsJqBtJ?uJgGvJ?wJ`IcJzXeJcVlB_HtB{HxJp@xHdI|@kXcAnUfAbHyJgDrDrGY?zJuA{JxA}@}XcAqYgAtV_GrUaGdCuDhGVoH}BaT`CwUcCdTh@bPfCqVjCxD~@xG|J_V{DnB}JsHsHmWuH?~JeDrG?_K?`Kd@zH~FaK?bK?cK?dK?eK?fKuBgK?hK?iK`CpFlXuImI_A_YfBzWhB{D`AmHfB?jK?kK|DaAcYhAnClKdYnAeXqAfYtAhXwAgByAlDmK}BwFbWjHcWnK?oK?pKn@qK~B|ApHeHwBrK?sK?tK|BrBsBuK?vK?wKhUaDdVsBeZsBoIqF?tI?xK`I~DxQyK?zKkD{K?|K|PVm@}K_IU{AbAzHhApU_GtYjC`EtBiZVuHwAiYgEyH`IwWjCxC~KpVbCrGyIr@_LyArB_@`L?aL?bL~QjEpRzE?cL?dL?eL?fLqAgLq@rCdGhL?iLcCsDy@iJdCjL?kL?lLo@wHnWyHxCmL?nL?oL?pLkDqL?rL?sLhZ_E?yK?tLzAuLxYvLr@wLs@cAsYhAjZ`GKxL?yLgZlBcDtE}DxF?iHzTzL?{L?|LrA}L?~L?_M?`M?aM?bMs@cMsZdLtZfLa[dA`YiAyV_GuDeG?gJaIdMj@fB}YkKqAeMhHfMbDzFfEmBkZxA}H|ApN~Aq@hBzInBdEsC?hHrH`FjSbFrWeFYgM?hMbXhEvIkEoBj@NiMx@jM?kM?lMUlH}GnChPpC}ImM?nM?oM?pM?qM?rM}AeAxV~FkVxG}IoCp[fAsX_Gx@sM?tM~YoAeYrAgXuAhYxAhE}AtF}IzIrBtCuMtBzFdAiH|BnBeAhH_GvM?wM?xMAyM?zMqZiEY{M~D}AKoEdAhI~@|M{BfBbAtImX}M?~M_[_Nf@jHbZoKoB`NlByEqR{EgEyAlDiF_BgA`DtF?aNzDsGfVuGtH`Fk[cFlWfFuBbN?cN?dN?eN?fN}CgNk@hAb[aGj[aFkWdFsWgF|BUoAhN?iN|[~A]gDoEiAdUyFaYkJdCzJvAiJv[sB]jNr[kNxZkLi@lNmEkH?nK?mN?nNeAtCxIoN?pN?qN?rN?sNiVtNoCuNvX_Bb\aFk\eFpBuKfZwK_BvNoYmBwCzFpDzGlExKpB`DiUmBV~FVwN?yJ?xN?yNdDiJ~\aDsIzFc[yLf@yF?zLe[|Lo\tBoXY?uDs@fBhOhB}B}CjV~C?vJ`\zAmBiFxWrBNzN_]_G{A|Jx@{N?|Ns[pAfXsAgYvAn\_BdA}Ng]vGhIuJk]`GyD~BnZcCuYeCyUhCr@~N?wLi@o@l\Vr@tH?_O~A`O?aO`BnKcZpKVtFhH_F?yGlVwAaZzAs\pNt\rNv\qDyCtNoCbObArFe\cNf\eNh\wAkJ{Ap]aGn[nM?cO?dO?eO?fO?gOsDkI|WmI~WoI`XqI~DiFpSwA~]|ApHhOeCgJUiOyI`EyQbEzQdE~VzAmBjOoEkOKlO_^jCvEmO]nO{CoOoApOdCZ?qO?rOwCzD?sO?tOzD_K?uO}AfBm^uOrAvO?wO?xOv]uH~AjKpIyOm@zO?{OfA|Oq]_CbTbCeHg@wHhCrEuDwIxHi@}OpYyHK~OoIz@p^`CkIdClHgCzUjCpB_P?`P?aPlJbP?cP`^eOmJgOd@dPuDePzAbK?_Nw]eIPg@~GwDpGyEeJnB}@wH__@xH[uFd[fPeJrBf@gPhAyFd]fP?hP?iPpAjP?kP?lP?mP?nPdWoPfBpPd_@kPe_@qP?rPc@lFh[eLuI_Cq^cC?sP?tPV|E?uPjJ`Fc\dFd@{F~T}F?~Om[hMtE`BpCbBsNdBp@vPcEwP?xP?yP?zP?{P?|P?}P?~Pq@dIrHyG?_Qc^nI_XpIaXwAxE}AjDeH?`Q?aQ?bQ?cQ?dQ?eQ?fQ?gQjBhQj\bFl[fFpArD?iQlHwDpGjQ?kQuEmNi_@lPf_@nP?tN?lQeVdCv^hC[mQrJrBdA}O?nQy\bFg`@gFdXqHl]qA_ZuAu[yAlD}AjD`BwJoQjEpQq[pCrJqQk`@mPg_@tNx\|Av@nQgPrQ?sQ~DdH?tQ?uQ?vQ?wQ?xQ?yQ?zQlEuI?{QvJzL?fPtJcPz^fO}^h@?iJt_@xPv_@zPx_@|Pz_@~Px@|Q?}Q?~Q?_R_B`Rw^`PwIyHh]{AqEeH?rK_EsEsEsCqHaRuJ_NcEsBwAbR`EzFbBhD{[wAkJ|Ak@cR?xJgJzLbKxJNdRtIeR?fR?gRj]sB[aNpXzK}E_Q~_@oIe^wAxE_ByAqQy]qNu\sNw\{A?uNqE`Ba_@sB~AgBjJyG}_@lI}WnI_`@qItEeHyJaQdAhRr`@rAt[vAf^jF`_@yHxInL{ZpLkBiR?jRaDjNSkRcD`NsHlRk_@`CkIsP?mRoJnR?oRfBpR?qR?rR?sR?tRwa@sAm]wAlZhEuW`I_a@dOa^fOo]~ChJwJ^uR?vR`]yNuDwRfKtBeCxR}a@eO`EzDca@|AiEyRk@sI^s@p_@|FuBzR?{R?|Rg^eE~I~A?yRsEgBfErJ`FtB~`@fPvHsEka@lIta@oIma@xAlK_BmVbB?oQ{`@uQ|`@}R?~R?_S?`S?aS?bS?cS?dS?eS{AfB~HjGaVyAt`@~AnAeHKnNia@fR?fSYgSmChS?iSiKjSr@lRnGkS?lS?mSaClF?nJ`KiJzAnSnJhJ?oS}BvG}EzG{IiEeIoJfIqJj_@fLcFvRpKpS?qS?rSuFsS?tSgKuS|_@aO}EbIaa@}Q?vS?wSbDzDxBxSfFyS?zS~H{S`b@}Au`@aBjH|So^{OzD}S?~So`@sBya@aCkHg@s^iC[_TFyMz[bLnIhK~a@fOeD`TsGeEhEdHwBeHda@sK?aTwAbThb@vQ?}R?cT?jNUdTuEoKq_@wAxEiFu^aCb^lIfb@pI``@xAhEiF_c@bCr^h@vYgC|FeTtI|KsItB{a@tA`ZxA{QgEyDfT?gT?hT?iToa@qD{]{Aqa@|AiE_Ba\tGmIjTl^kTi\lT?mT?nT?oT?pT?qT?rT?sTxAnFuIdOiKgO^vRcK{LeAnQn@tTwQ_E~ZwAxJ~Aic@bClc@eCs]iCeCjOkc@cCr]fC~AaOeDuT~b@tBlAg@dBiJVlKo_@aFz\fFgF}RmKvT~EtBfFvSbc@wT?xT?yT?zTeAmEpD_Qla@pItKfEvJjJv@uC?{Tm@|T?}Tr_@aBjH~TaF_UbB}Ex]eIsa@bI~B`UnYdJi@hRdF}FvBaUDbU?cU?dUfa@hBn]~ChJeUdEhLx[wMm@fUqDlGnJgUaFqRza@sRbFmFsDhUtJiUo[qM?jUwK{TwAkUp`@cFd\gFbClUid@dFsDmU~c@qIva@`QzJbQc`@dQe`@fQ?nU{J`Jx`@nPl`@{Arc@}A|b@bB?|Skd@eFm@oUld@aQb`@cQd`@eQ?pUod@tNy`@dHrKrK_EqUfd@xMna@rNz]qEpd@uNiDyRrd@fFs@rU|B{HoW}Ho@vP{c@bFuCsUaCaU~EzFpJnBnc@tLbYYf]rB?tU`Sj@mTp@rTv@jX}@rYdAsCaOvc@|LpDbI~BuU?vUuKdCn`@iCud@sNpa@uNiD_Bq`@cD`BmN_d@kJ?wUNxUyc@cCiFdC|d@jCt^yHvd@gFbCyU~@gBwd@|HxK~OxAzU?{U?|U?}U?~U?_VtD`V?aV?bV?cV?dV?eV?fV?gV?hV?iVsc@uGoc@lB~d@}HrAjV?kVl_@dCBbUcd@dUeBlV?mV?nV?oV?pV?qV?rV?sV?tV?uVyD_H{VaH|VcHtGfEjYjE_RoJfIvVcKfPd@wEoRyE{JiQi`@xD?jQj`@jCoAwVyIyKoDgHpKlSdHzC^xVbBjKjc@mId^pItKgN?lTd@mGaCyV|Gi@}AhDp@vVsB_Px^wKlE{Qpc@uAs`@zAmB~Ahd@rRgKtRse@vAdEtCfJyJkKjCjFg@ra@hB}A}EsEhB|^_O{KuDk@zVcLrD?{VcLwAhc@jFcC|Vwc@cJ?}V?~V_BcRfEgHCbUee@|@_L_W}d@rBnI`W?aW}]fNiHg@~KmBf`@cFdb@hB_f@aW`f@wAhKiEeIbWaKwKwAuRgFwQ}`@yQ?cW?dW?eWKfW?gWye@rB|CfMk@hWi@iW`FzFfKzF`e@aVae@cVbe@eVce@gVde@iV^jWvBkRb@kWtX|IuXyAfAlW^mWoE~Fne@xErZ{EgJjJ{e@xA~I_Bif@yApb@_BwB`Qmd@cQtd@fQbf@gWyK{Aqd@~AnA`Byb@eIeb@hPjGnWp@oWyBaR}@vPfApWbEwLjKvJ?eUq\qWvb@wAgBzAcCrWzAsW?tW?uW?vW?wW?xW?yWjf@zAmBmK`KeCiFzWwb@xNa]jCfF~Qcc@gOh@{WgEfEzB_IcXjCwe@xNxe@h@fAwRzA|W?}W?~W?_X?`X?aX?bX?cX?dX?eX?fXhAgXrEhXm`@g@`c@jCm\wAaf@jEme@iX?jX?kXxHgI?lX|e@}VtDmX|c@gFVmJcEV?bU~e@lVfe@nVhe@pVje@rVke@tVle@jC{\vKs@nXpf@eCzc@jC}DiHtc@wAgBgNj@oXxb@tScBvIuEpXeAiL|D|Jre@nIua@wAab@{Rbb@cEec@fE_LzKdc@dEh^{AiXeHnf@fC?wD~^zES|Vmf@{AcB{QgEgNaLqX?rX{d@g@q@hDo@xHzf@|AiE}I{f@h@mc@hChf@yEKmNv@sXlJtX?uX?vX?wXyKlG[yFob@dE?kG?gNte@sRlf@xAlKdBsd@wAxJ_B{b@xXcg@tRuf@fCcC{Vga@xAqc@hE|a@aI^yXkAzXgF{X?|X?}Xy@`NlB~X?_Y?`Y?aYrEzJpJrBcf@VhAbYsKpKoe@mSUoFrb@iS|JnN_b@{Dgc@xAxa@oL|@}OgLyAhDcYp@iItBdYu_@yPw_@{Py_@}Pk@eY~KrJj@gBSfY?yMac@iEfL}Aa`@rKaKaPb]lBfAoPeg@gCed@vJqJyOuJcKyYeKVgY|f@hBfLdHrK`QzJ~I{AcA{@fMjCnJ|]dNg\fNz`@eHeLaQwXdB_g@uX`g@wXig@hCb@{W{GjN`FzDxHlX}f@eCiFrDgD{V|\wAxc@_Bgb@cB?~T|KwUbd@eJgd@hY~@dIbg@kGs@iYrAjY?kY}c@~Rib@`Skb@bSmb@dS?lY?mY?nYog@_Sjb@aSlb@cSnb@oY?pY?qY?rY?sYjBtY?uYqDvYgg@~A~EzD[wY{KzJzd@bUtf@mVge@oVie@qV?xY?yY?zY?{Y?|Y?}Yrf@bFi@hI}Z~Y~f@zEmg@iCxf@sRVmQhA_ZaF`Z?aZ?bZ?cZj@xJc@fYhg@mBiB`LpZdUeBdZ?eZVyJyAlJkDfZ?gZcB~MeAhLoJdBlg@vXiJ_L[vRng@yAjg@vL?hZUiZfg@eOmJjSgLgNaLjZuKsP?kZ?lZ</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??@C????H??I??`A?[B?H??J??`H?WC?H??K??@C?[E?L??M??P@?[@?L??M??p??sE?L??M??@E?KD?N??O??PN?gA?P??O??@A?k@?Q??M??PF?[C?R??S??@K??LAT??O??p@?[yAU??O??`H?gsAV??W??@G??YAX??Y??pB?k~?X??Z??AS?s\?X??[??q@?cW?\??]??QA?[??\??]??a??K@?N??O??PP?kA?N??^??`L?_G?_??`??@@?W`?_??`??`B?Cp?_??a??q??_o?_??]??AB?Ca@b??c??Q@?oG?b??c??qE?{|@H??I??`C?_B?d??e??@W?GN?d??f??pA?gO?g??h??@B?WH?g??h??PG?OI?i??h??pE?WQ?j??h??@?????k??l??B?????A??m??D?????A??n??D?????A??o??D?????A??p??D?????A??q??D?????A??r??D?????A??s??D?????A??t??D?????A??u??D?????A??v??D?????A??w??D?????A??x??D?????A??y??D?????A??z??D?????A??{??D?????A??|??D?????A??}??D?????A??~??D?????A???@?D?????A??@@?D?????A??A@?D?????A??B@?D?????A??C@?D?????A??D@?D?????A??E@?D?????A??F@?D?????A??G@?D?????A??H@?D?????A??I@?D?????A??J@?D?????A??K@?D?????A??L@?D?????A??M@?D?????A??N@?D?????A??O@?D?????P@?M??`A?OA?Q@?O??PI?WC?Q@?R@?PG?SG?Q@?S@?`??WH?Q@?T@?pB?GJ?U@?V@?P@?WO?U@?V@?@F?{_?W@?X@?@S?cM?Y@?Z@?PH????[@?\@?`B????]@?M??PL?GF?^@?_@?`@?s]A^@?`@?P@?[^Aa@?b@?C?????a@?c@?C?????k??d@?B?????e@?f@?C?????e@?g@?C?????a@?h@?C?????a@?i@?C?????a@?j@?C?????a@?k@?C?????a@?l@?C?????a@?m@?C?????a@?n@?C?????a@?o@?C?????p@?q@?B?????Q@?R@?@J?WG?A??r@?D?????A??s@?D?????A??t@?D?????N??^??@E?WG?u@?v@?`??{h?_??M??`??[P?_??w@?PA?_T?_??x@?PF?WV?\??]??a@?[??L??M??pC?CF?N??y@?P??s??N??y@?P`?gC?\??]??PA?[??\??]??`??K@?z@?{@?pp??K?X??Z??QU?C]?|@?C??pS?WC?g??}@?@U?wL?d??~@?PJ?sC?d???A?@A@sK?d??@A?PD??H?H??AA?`P?SB?E??BA?PN?sS@CA?DA?`^?[Y?CA?EA?pC?KJ?FA?GA?P@?w]?HA?IA?@B??~?HA?JA?`F?Ke?KA?LA?@A?CJ?MA?LA?@?????k??NA?B?????A??OA?D?????A??PA?D?????A??QA?D?????A??RA?D?????A??SA?D?????A??TA?D?????H??K??PJ?kE?z@?UA?@@??N?z@?VA?`@?SV?d??@A?QD??H?H??AA?qD?{A?WA?XA?QP?KG?A??YA?D?????A??ZA?D?????A??[A?D?????A??\A?D?????A??]A?D?????d??~@?@F?WC?g??^A?@A??G?j??^A?@?????k??_A?B?????A??`A?D?????A??aA?D?????A??bA?D?????A??cA?D?????A??dA?D?????Q@?R@?pC?KG?u@?v@?`B?{h?_??eA?`??cM?X??Z??@S?s\?X??[??p@?cW?|@?C??@M?KC?fA?gA?pA?WG?fA?hA?@?????iA?jA?B?????A??kA?D?????E??F??`E?GE@E??lA?pc?WA@CA?mA?pE?KZ?nA?oA?PY?[d@pA?qA?@G?gUBpA?rA?`D?[WBsA?tA?p@?g^?KA?uA?P@?ST?MA?uA?@?????A??vA?B?????k??wA?B?????N??^??pU?sG?_??`??`I?kp?iA?xA?B?????A??yA?D?????A??zA?D?????X??Y??`X?c?@z@?{@?PK?oI?z@?{A?A@?wT?d???A?Pf?cJ?d??|A?`L?sL?}A?^A?@A?SG?}A?^A?`C?gG?}A?~A?`E??K??B?@B?@D????AB?BB?@A????CB?DB?@B?__?a@?EB?C?????a@?FB?C?????a@?GB?C?????A??HB?D?????A??IB?D?????A??JB?D?????A??KB?D?????A??LB?D?????A??MB?D?????A??NB?D?????P??O??PG?s@?A??OB?D?????A??PB?D?????e@?QB?C?????a@?RB?B?????k??SB?B?????A??TB?D?????A??UB?D?????A??VB?D?????A??WB?D?????A??XB?D?????A??YB?D?????A??ZB?D?????A??[B?D?????A??\B?D?????A??]B?D?????N??^??p\?KH?Q@?y@?P???B?Q@?y@?a@?wD?Q@?^B?AN?sE?_B?`B?q??GB?_B?`B?q??sC?z@?`B?QA?cE?z@?aB?qA?KF?_B?bB?q@?GB?_B?bB?A??SC?R??S??p@?wKAa@?cB?C?????a@?dB?C?????eB?fB?B?????a@?gB?B?????iA?hB?B?????A??iB?D?????a@?jB?C?????A??kB?D?????A??lB?D?????A??mB?D?????A??nB?D?????A??oB?D?????A??pB?D?????|@?C??PX?KC?A??qB?D?????A??rB?D?????A??sB?D?????z@?{@?@??SI?A??tB?D?????A??uB?D?????A??vB?D?????A??wB?D?????A??xB?D?????A??yB?D?????A??zB?D?????d???A?pr??K?WA?{B?@??[N?e@?|B?C?????a@?}B?B?????a@?~B?C?????eB??C?B?????a@?@C?C?????d??|A?`H?oL?}A?AC?P@?wN?a@?BC?C?????iA?CC?B?????A??DC?D?????A??EC?B?????a@?FC?C?????a@?GC?C?????d??f??`??cO?HC?IC?`V?OJ?JC?KC?aD?sE?}A?h??QB?kC?}A?h??aq?gD?A??LC?D?????A??MC?D?????A??NC?D?????Q@?y@?`@?wD?Q@?^B?`U?CF?N??y@?`X?OC?N??OC?AI?KF?_??PC?Q??KQ?_??QC?QD??XACA?EA?PB?CJ?nA?RC?`F?K[@nA?SC?`H?wY@HA?TC?@M?sc?a@?UC?C?????a@?VC?C?????a@?WC?C?????a@?XC?C?????_??x@?@??CV?A??YC?D?????A??ZC?D?????A??[C?D?????A??\C?D?????a@?]C?B?????p@?^C?B?????A??_C?D?????U??O??pQ?{sAV??`C?p??wVAV??aC?PB?KVAA??bC?D?????A??cC?D?????A??dC?D?????A??eC?D?????A??fC?D?????A??gC?D?????A??hC?D?????A??iC?D?????A??jC?D?????kC?]??QA?_~@kC?]??aG?K?AlC?mC?QX?oH?CA?DA?`F?cX?A??nC?D?????A??oC?D?????A??pC?D?????Q@?^B?@B?[E?iA?qC?B?????A??rC?D?????A??sC?D?????A??tC?D?????A??uC?D?????A??vC?D?????A??wC?D?????Q@?O??pP?gC?Q@?xC?`U?gI?_B?`B?p??GB?_B?`B?p??sC?z@?`B?PA?cE?z@?aB?pA?KF?_B?bB?p@?GB?_B?bB?@??SC?a@?yC?C?????A??zC?D?????A??{C?D?????A??|C?D?????A??}C?D?????A??~C?D?????A???D?D?????_??`??A@?W`?d???A?PC@{I?d???A?Px?GK?d??@D?pL?_G?a@?AD?C?????a@?BD?C?????a@?CD?C?????p@?DD?B?????A??ED?D?????a@?FD?C?????}A?^A?AA?SG?}A?^A?aC?gG?}A?~A?Q??sJ?A??GD?D?????a@?HD?C?????a@?ID?C?????A??JD?D?????A??KD?D?????A??LD?D?????\??]??@??[??A??MD?D?????a@?ND?C?????A??OD?D?????A??PD?D?????A??QD?D?????_??x@?PP?sV?a@?RD?C?????A??SD?D?????A??TD?D?????A??UD?D?????A??VD?D?????A??WD?D?????A??XD?D?????_??`??`p?gr?WA?{B?`J?_N?A??YD?D?????X??Z??QY?K]?A??ZD?D?????JC?KC?a??oE?}A?[D?QE??B?L??M??PD?KD?L??\D?pO?KE?]D?^D?`@?[W?]D?^D?`@?oX?_D?`D?AA?CV?aD?bD?a@?cXBH??AA?pD?{A?WA?XA?PP?KG?cD?dD?@??kC?A??eD?D?????A??fD?D?????A??gD?D?????a@?hD?C?????A??iD?D?????A??jD?D?????A??kD?D?????d???A?pY??J?a@?lD?C?????a@?mD?C?????iA?nD?B?????u@?v@?aB?{h?_??eA?a??cM?_??w@?QA?_T?A??oD?D?????}A?~A?P??sJ?A??pD?B?????N??OC?PJ?KF?_??qD?`??Cv?Q??M??QF?[C?CA?mA?PN?gZ?A??rD?D?????A??sD?D?????A??tD?D?????A??uD?D?????|@?C??`P?OC?vD?y@?Q??_G?vD?y@?q@?CI?vD?wD?AJ?CH?P??O??@D?o@?A??xD?D?????A??yD?D?????_??`??@u?or?_??zD?qG?Go?_??{D?Ad?OaACA?mA?PB??Z?FA?|D?A@?OV?}D?|D?qD?CI?HA?~D?QD?wz?N??OC?QJ?KF?_??qD?qC?Wv?_???E?Qn??eAA??@E?B?????L??\D?`H?{D?]D?^D?@_?gY?A??AE?D?????A??BE?D?????A??CE?D?????A??DE?D?????A??EE?D?????A??FE?D?????nA?oA?QY?[d@pA?qA?AG?gUBpA?rA?aD?[WBsA?tA?q@?g^?KA?uA?Q@?ST?MA?uA?A?????A??GE?D?????a@?HE?C?????P??O??@??g@?Q@?y@?@???B?d??|A?@T?wL?WA?O??@O?[D?A??IE?D?????H??K??QG?gE?b??JE?Q??GMCKE?LE?aC?c[?H??AA?aP?SB?E??BA?QN?sS@CA?DA?aW?GY?nA?RC?aF?K[@nA?SC?aH?wY@HA?TC?AM?sc?H??K??AC?[E?L??M??a??[@?R??S??@G??LAg??}@?AU?wL?d??~@?AF?WC?g??^A?AA??G?A??ME?D?????A??NE?D?????d??|A?pM?wL?A??OE?D?????A??PE?D?????A??QE?D?????]D?^D?a@?[W?A??RE?D?????A??SE?D?????H??AA?P??gA?WA?TE?@C?SF?b??UE?PI?ShAlC?VE?@C?Co?aD?WE?PI?wmBa@?XE?C?????L??M??@??sE?|@?C??@N?KC?YE?ZE?B?????L??M??Q@?[@?A??[E?D?????A??\E?D?????A??]E?D?????FA?|D?@@?OV?}D?|D?pD?CI?HA?~D?PD?wz?HA?^E?pU@kk?KA?uA?`B?KL?e@?_E?C?????a@?`E?B?????A??aE?D?????A??bE?D?????A??cE?D?????A??dE?D?????A??eE?D?????H??K??PL?kE?HC?O??pA?WD?A??fE?D?????A??gE?D?????A??hE?D?????A??iE?D?????A??jE?D?????e@?kE?C?????CA?DA?QY?OY?FA?GA?Q@?w]?HA?IA?AB??~?HA?JA?aF?Ke?KA?LA?AA?CJ?a@?lE?C?????a@?mE?B?????a@?nE?C?????A??oE?D?????A??pE?D?????A??qE?D?????eB?rE?B?????X??Y??Pi?O@@L??M??PI?GF?_??a??p??_o?_??]??`E?Ga@z@?{A?@@?wT?sE?{A?@??wC?}A?[D?qM?wA?nA?oA?AE?kc@nA?tE?aN?_]@HA?IA?a??{}?A??uE?D?????P@?M??aA?OA?Q@?O??QI?WC?a@?vE?C?????A??wE?D?????A??xE?D?????u@?v@?a??{h?_??M??a??[P?_??w@?AQ?SU?CA?DA?a^?[Y?CA?EA?qC?KJ?A??yE?D?????a@?zE?C?????A??{E?D?????A??|E?D?????A??}E?D?????A??~E?D?????a@??F?C?????a@?@F?C?????a@?AF?C?????a@?BF?C?????e@?CF?C?????a@?DF?C?????H??I??aA?[B?a@?EF?C?????a@?FF?C?????a@?GF?B?????a@?HF?C?????A??IF?D?????A??JF?D?????\??]??aJ?w@?U@?KF?aA?cE?W@?LF?AS?g}?MF?Z@?QH????NF?\@?aB????OF?M??AK?GF?^@?PF?A@?W\?^@?QF?Q@??]?Q@?^B?`Y?CF?a@?RF?C?????a@?SF?C?????a@?TF?C?????a@?UF?C?????a@?VF?C?????a@?WF?C?????a@?XF?C?????a@?YF?C?????N??O??`J?cA?k??ZF?B?????A??[F?D?????A??\F?D?????e@?]F?C?????A??^F?D?????A??_F?D?????a@?`F?C?????A??aF?D?????\??]??`@?[??z@?UA?PA?CN?bF?cF?pJ?sC?k??dF?B?????a@?eF?C?????a@?fF?C?????a@?gF?C?????a@?hF?C?????a@?iF?C?????a@?jF?C?????A??kF?D?????H??K??PG?gE?b??JE?P??GMCKE?LE?`C?c[?KE?lF?@??[^?A??mF?D?????A??nF?D?????A??oF?D?????A??pF?D?????A??qF?D?????_??qD?pC?Wv?_???E?Pn??eA_??rF?@??weAA??sF?D?????Q@?R@?PU??H?A??tF?B?????a@?uF?B?????A??vF?D?????a@?wF?C?????a@?xF?C?????a@?yF?C?????H??I??aC?_B?d??e??qI?wM?b??zF?QG?ky@b??{F?aW?KJAlC?|F?QJ?sW?A??}F?D?????A??~F?D?????a@??G?C?????a@?@G?C?????a@?AG?C?????H??AA?PO?SB?BG?CG?PA????DG?BB?P?????a@?EG?C?????a@?FG?C?????a@?GG?C?????a@?HG?C?????a@?IG?C?????a@?JG?C?????a@?KG?C?????a@?LG?C?????a@?MG?C?????_??rF?pl?ggAd??|A?@??cL?E??F??p_?cF@D??GA?a??[h?KA?LA?Q???J?T??O??q@?[yAU??O??aH?gsAV??W??AG??YAL??\D?@??kD?a@?NG?C?????U??O??qQ?{sAV??`C?q??wVAV??aC?QB?KVAd??e??PF?oM?WA?{B?`E?cN?lC?|F?qQ?GX?KE?LE?@F?g[?b??O??@??WZCA??OG?D?????KE?LE?P??W[?KE?PG?p??_a?}A?AC?QE?wN?a@?QG?C?????JC?KC?`??oE?}A?[D?pM?wA?A??RG?D?????HC?IC?PV?OJ?a@?SG?C?????A??TG?D?????iA?hB?B?????a@?UG?B?????L??M??`??[@?CA?EA?`@?{I?FA?VG?@@?GS?}D?VG?PA?cH?HA?^E?pB?gy?A??WG?D?????_??a??@A?co?a@?XG?C?????a@?YG?C?????a@?ZG?C?????a@?[G?C?????a@?\G?C?????a@?]G?C?????a@?^G?C?????a@?_G?C?????d???A?@o?oJ?HC?IC?pZ?KJ?a@?`G?C?????cD?dD?p??kC?b??aG?q??[SAb??aG?Q??GVAb??bG?aA?O[CA??cG?D?????Q??M??@E?[C?V??dG?@B?sqAa@?eG?C?????d??e??QF?oM?a@?fG?C?????a@?gG?B?????A??hG?D?????A??iG?D?????A??jG?D?????A??kG?D?????Q??M??pC?[C?a@?lG?C?????Q@?xC?PY?sI?CA?EA?QB?CJ?HA?TC?qI?cc?A??mG?D?????A??nG?D?????Q@?xC?PJ?GI?a@?oG?C?????P@?M??@??OA?a@?pG?C?????k??qG?B?????A??rG?D?????N??y@?@??cB?A??sG?B?????a@?tG?C?????A??uG?B?????A??vG?D?????A??wG?D?????A??xG?D?????A??yG?D?????A??zG?D?????A??{G?D?????A??|G?D?????A??}G?D?????A??~G?D?????Q@?S@?a??WH?Q@?T@?qB?GJ?U@?V@?Q@?WO?U@?V@?AF?{_?W@?X@?AS?cM?Y@?Z@?QH????[@?\@?aB????]@?M??QL?GF?^@?_@?a@?s]A^@?`@?Q@?[^AnA?oA?@E?kc@nA?tE?`N?_]@A???H?D?????A??@H?D?????A??AH?D?????A??BH?D?????A??CH?D?????A??DH?D?????A??EH?D?????A??FH?D?????A??GH?D?????A??HH?D?????A??IH?D?????A??JH?B?????A??KH?D?????iA?LH?B?????A??MH?D?????p@?NH?B?????k??OH?B?????}A?^A?QA?cG?}A?PH?aG?WI?A??QH?B?????WA?XA?`N?GG?b??UE?`@?SfAA??RH?D?????a@?SH?C?????a@?TH?C?????k??UH?B?????A??VH?D?????A??WH?D?????A??XH?D?????A??YH?D?????A??ZH?D?????N??^??`K?_G?iA?[H?B?????A??\H?D?????E??lA?qc?WA@A??]H?D?????a@?^H?C?????_??{D?q~?ObAk??_H?B?????L??\D?PC?oD?`H?VG?P@?Gm?HA?aH?`??G?@bH?cH?pe?c]?dH?eH?PC?wL?fH?eH?P[?O^?fH?gH?AM?Oi?a@?hH?C?????N??^??`_?OH?L??\D?`S?SE?`H?GA?P@?Cw?HA?iH?`??WC@bH?jH?PU?wY?dH?qD?`B?GN?fH?qD?@I?K_?kH?lH?P??wV?kH?mH?@?????a@?nH?B?????a@?oH?C?????a@?pH?C?????A??qH?D?????_??`??`Y?[q?A??rH?D?????A??sH?D?????A??tH?D?????A??uH?D?????Q@?S@?qF?gH?A??vH?D?????A??wH?D?????A??xH?D?????a@?yH?C?????a@?zH?C?????A??{H?D?????CA?DA?AK?kX?FA?VG?A@?GS?}D?VG?QA?cH?HA?^E?qB?gy?A??|H?D?????A??}H?D?????A??~H?D?????a@??I?C?????a@?@I?C?????k??AI?B?????A??BI?D?????A??CI?D?????A??DI?D?????A??EI?D?????A??FI?D?????a@?GI?B?????z@?{@?`k?CK?A??HI?D?????k??II?B?????A??JI?D?????a@?KI?C?????A??LI?D?????nA?oA?`d?Ge@HA?^E?pL@Ok?a@?MI?C?????a@?NI?C?????a@?OI?C?????a@?PI?C?????a@?QI?C?????a@?RI?C?????a@?SI?C?????a@?TI?C?????N??O??PI?cA?UI?y@?@A?sv?e@?VI?C?????A??WI?D?????A??XI?D?????A??YI?D?????A??ZI?D?????A??[I?D?????A??\I?D?????A??]I?D?????_??qD?a??Cv?A??^I?D?????d??e??AW?GN?d??f??qA?gO?g??h??AB?WH?g??h??AR?sI?A??_I?D?????A??`I?D?????N??OC?aC?GF?_??aI?Q??cy?A??bI?B?????a@?cI?C?????a@?dI?C?????A??vA?B?????</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

    const H = Math.random() * 6;
    const dX = 1 - Math.abs(H % 2 - 1);
    let dR, dG, dB;
    switch (H | 0) {
        case 0:
            dR = 1; dG = dX; dB = 0;
            break;
        case 1:
            dR = dX; dG = 1; dB = 0;
            break;
        case 2:
            dR = 0; dG = 1; dB = dX;
            break;
        case 3:
            dR = 0; dG = dX; dB = 1;
            break;
        case 4:
            dR = dX; dG = 0; dB = 1;
            break;
        case 5:
            dR = 1; dG = 0; dB = dX;
            break;
    }

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2903985278;
    let startMs = 1667768551167;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","java.lang.Thread","run","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","ok.dht.test.maximenko.DatabaseHttpServer$$Lambda$148.0x0000000800d006b8","ok.dht.test.maximenko.DatabaseHttpServer","lambda$handleRequest$0","handleMethod","handleGet","ok.dht.test.maximenko.dao.MemorySegmentDao","get","ok.dht.test.maximenko.dao.BorderedMergeIterator","<init>","ok.dht.test.maximenko.dao.BorderedMergeIterator$Source","ok.dht.test.maximenko.dao.MemTable","java.util.concurrent.ConcurrentSkipListMap$Values","iterator","java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapValueIterator","java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapIter","java.util.concurrent.ConcurrentSkipListMap$SubMap","loNode","java.util.concurrent.ConcurrentSkipListMap","findNear","findPredecessor","cpr","ok.dht.test.maximenko.dao.NaturalOrderComparator","compare","addSource","java.util.TreeMap","put","addEntryToEmptyMap","java.lang.String","compareTo","one.nio.http.HttpSession","sendResponse","writeResponse","one.nio.net.Session","write","one.nio.net.Session$ArrayQueueItem","one.nio.net.NativeSocket","libpthread-2.31.so","__send","entry_SYSCALL_64_after_hwframe","do_syscall_64","__x64_sys_sendto","__sys_sendto","sock_sendmsg","inet6_sendmsg","tcp_sendmsg","tcp_sendmsg_locked","tcp_push","__tcp_push_pending_frames","tcp_write_xmit","__tcp_transmit_skb","ip_queue_xmit","__ip_queue_xmit","ip_local_out","ip_output","ip_finish_output","__ip_finish_output","ip_finish_output2","__local_bh_enable_ip","do_softirq","__softirqentry_text_start","net_rx_action","__napi_poll","process_backlog","__netif_receive_skb","__netif_receive_skb_one_core","ip_rcv","ip_rcv_finish","ip_local_deliver","ip_local_deliver_finish","ip_protocol_deliver_rcu","tcp_v4_rcv","tcp_v4_do_rcv","tcp_rcv_established","ok.dht.test.maximenko.dao.SSTable","ok.dht.test.maximenko.dao.SSTable$FileEntryIterator","getOffsetOfEntryNotLessThan","getKeyByIndex","getEntryOffsetByIndex","jdk.incubator.foreign.MemoryAccess","getLongAtOffset","java.lang.invoke.VarHandleGuards","guard_LJ_J","java.lang.invoke.LambdaForm$MH.0x0000000800d0cc00","invoke","java.lang.invoke.LambdaForm$DMH.0x0000000800d0b000","invokeStatic","java.lang.invoke.MemoryAccessVarHandleLongHelper","jdk.internal.misc.ScopedMemoryAccess","getLongUnaligned","getLongUnalignedInternal","libjvm.so","OptoRuntime::new_instance_C","InstanceKlass::allocate_instance","__restore_rt","libasyncProfiler.so","AllocTracer::trapHandler","Profiler::recordSample","JvmtiEnvBase::get_stack_trace","vframe::java_sender","compiledVFrame::sender","vframe::sender","frame::real_sender","frame::sender","frame::sender_for_compiled_frame","OopMapSet::update_register_map","ld-2.31.so","__tls_get_addr","nf_hook_slow","iptable_mangle_hook?[iptable_mangle]","ipt_do_table?[ip_tables]","java.util.Map","getOrDefault","getEntry","getEntryUsingComparator","next","jdk.internal.foreign.AbstractMemorySegmentImpl","mismatch","one.nio.server.SelectorThread","process","processRead","processHttpBuffer","handleParsedRequest","handleRequest","execute","java.util.concurrent.LinkedBlockingQueue","offer","signalNotEmpty","java.util.concurrent.locks.ReentrantLock","unlock","java.util.concurrent.locks.AbstractQueuedSynchronizer","release","signalNext","java.util.concurrent.locks.LockSupport","unpark","jdk.internal.misc.Unsafe","__pthread_cond_signal","__x64_sys_futex","do_futex","futex_wake","wake_up_q","try_to_wake_up","__lock_text_start","asByteBuffer","checkArraySize","one.nio.http.Request","getParameter","__ip_local_out","ipv4_conntrack_local?[nf_conntrack]","nf_conntrack_in?[nf_conntrack]","nf_conntrack_tcp_packet?[nf_conntrack]","tcp_in_window?[nf_conntrack]","read","recv","__x64_sys_recvfrom","__sys_recvfrom","sock_recvmsg","security_socket_recvmsg","aa_sk_perm","containsKey","one.nio.net.NativeSelector","select","epollWait","libc-2.31.so","__libc_disable_asynccancel","iptable_filter_hook?[iptable_filter]","getTask","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.ForkJoinPool","managedBlock","unmanagedBlock","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","block","park","unknown","__pthread_cond_wait","epoll_wait","futex_wait","futex_wait_queue_me","checkValidState","parseRequest","one.nio.util.Utf8","toAsciiString","java.lang.invoke.LambdaForm$MH.0x0000000800d04000","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800d09000","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","OptoRuntime::new_array_C","TypeArrayKlass::allocate_common","AllocTracer::send_allocation_in_new_tlab","asm_exc_int3","exc_int3","irqentry_exit_to_user_mode","exit_to_user_mode_prepare","arch_do_signal_or_restart","siginfo_layout","nf_ct_get_tuple?[nf_conntrack]","skb_entail","tcp_chrono_start","LockTracer::UnsafeParkHook","Unsafe_Park","__pthread_mutex_unlock","__x64_sys_epoll_wait","do_epoll_wait","ep_poll","schedule_hrtimeout_range","schedule_hrtimeout_range_clock","schedule","__schedule","finish_task_switch","tcp_mstamp_refresh","nf_nat_ipv4_local_in?[nf_nat]","getNextEntry","jdk.internal.foreign.MappedMemorySegmentImpl","asSlice","asSliceNoCheck","dup","Method::jmethod_id","InstanceKlass::get_jmethod_id","libonenio.210fea54.so","Java_one_nio_net_NativeSocket_read","jni_SetByteArrayRegion","__GI___clock_gettime","__usecs_to_jiffies","JvmtiEnvBase::phase","dev_queue_xmit","__dev_queue_xmit","validate_xmit_skb","validate_xmit_xfrm","tcp_ack","tcp_clean_rtx_queue","inet6_recvmsg","tcp_recvmsg","__kfree_skb","ep_item_poll.isra.0","sock_poll","tcp_poll","tcp_data_ready","sock_def_readable","__wake_up_sync_key","__wake_up_common_lock","getHeader","JNIEnv_::CallStaticObjectMethod","jni_CallStaticObjectMethodV","SignatureIterator::return_type","Java_one_nio_net_NativeSocket_write","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ul, G1BarrierSet>, ","startsWith","InstanceKlass::allocate_objArray","syscall","ep_start_scan","unknown_Java","Klass::is_klass","os::javaTimeMillis","one.nio.http.Response","toBytes","one.nio.util.ByteArrayBuilder","append","apparmor_socket_recvmsg","tcp_send_mss","tcp_current_mss","popIterator","firstKey","getFirstEntry","signal","doSignal","enqueue","OptoRuntime::new_array_nozero_C","JavaThread::last_java_vframe","vframe::new_vframe","CodeBlob::is_deoptimization_stub","__nf_conntrack_find_get?[nf_conntrack]","tcp_recvmsg_locked","skb_copy_datagram_iter","__skb_datagram_iter","jvmti_GetClassSignature","__tls_get_addr_slow","raw_local_deliver","inBounds","tooLow","sk_stream_alloc_skb","__alloc_skb","kmalloc_reserve","__kmalloc_node_track_caller","___slab_alloc","sockfd_lookup_light","__fdget","__fget_light","ep_done_scan","java.lang.String$CaseInsensitiveComparator","java.lang.StringLatin1","compareToCI","do_trap","force_sig","force_sig_info_to_task","__strncmp_avx2","nf_nat_ipv4_local_fn?[nf_nat]","nf_nat_inet_fn?[nf_nat]","skb_clone","__skb_clone","_raw_spin_lock_bh","__put_user_nocheck_8","getEntryByOffset","frame::is_interpreted_frame","__inet_lookup_established","dev_hard_start_xmit","loopback_xmit","netif_rx","netif_rx_internal","enqueue_to_backlog","startParsingRequestBody","ScopeDesc::sender","ScopeDesc::decode_body","resource_allocate_bytes","update_get_addr","rb_first","InstanceKlass::array_klass","import_single_range","jni_invoke_static","JavaCalls::call_helper","syscall_enter_from_user_mode","kfree_skbmem","kmem_cache_free","tcp_event_data_recv","check_bounds","__setup_rt_frame.isra.0","get_sigframe.isra.0","copy_fpstate_to_sigframe","SharedRuntime::on_slowpath_allocation_exit","security_socket_sendmsg","apparmor_socket_sendmsg","aa_label_sk_perm.part.0","aa_profile_af_perm","__cgroup_bpf_run_filter_skb","tcp_send_delayed_ack","__netif_receive_skb_core","kmalloc_slab","length","getAvailableTables","java.util.LinkedList","addAll","java.util.ArrayList","toArray","java.util.Arrays","copyOf","one.nio.util.URLEncoder","decode","ipv4_confirm?[nf_conntrack]","nf_confirm?[nf_conntrack]","tcp_queue_rcv","javaVFrame::is_java_frame","simple_copy_to_iter","_copy_to_iter","copy_user_generic_unrolled","Arena::grow","ChunkPool::allocate","pthread_self","skb_clone_tx_timestamp","unsafe_arraycopy","remove","ksize","asm_sysvec_apic_timer_interrupt","sysvec_apic_timer_interrupt","irqentry_exit","one.nio.net.NativeSelector$2","findNext","hash_conntrack_raw?[nf_conntrack]","__siphash_unaligned","addEntry","fixAfterInsertion","lockInterruptibly","java.util.concurrent.locks.ReentrantLock$Sync","acquireInterruptibly","deleteEntry","jbyte_disjoint_arraycopy","__ksize","_copy_from_iter","copy_user_enhanced_fast_string","skb_release_all","skb_release_head_state","dst_release","ipv4_conntrack_in?[nf_conntrack]","JavaCallWrapper::JavaCallWrapper","__tcp_v4_send_check","valueOf","java.lang.Integer","toString","asm_sysvec_reschedule_ipi","sysvec_reschedule_ipi","ipv4_conntrack_defrag?[nf_defrag_ipv4]","tcp_wfree","sk_free","syscall_exit_to_user_mode","tcp_newly_delivered","getPath","substring","newString","copyOfRange","MemAllocator::allocate","vdso","__vdso_clock_gettime","tcp_tx_timestamp","__check_object_size","__virt_addr_valid","acquire","LockTracer::recordContendedLock","jvmti_GetStackTrace","sock_put","__tcp_ack_snd_check","sk_reset_timer","mod_timer","bpf_skops_write_hdr_opt.isra.0","tcp_release_cb","__build_skb_around","__cond_resched","nf_nat_ipv4_out?[nf_nat]","nf_nat_ipv4_fn?[nf_nat]","CallTraceStorage::put","RuntimeStub::is_runtime_stub","jvmti_GetCurrentThread","methodHandle::~methodHandle","tcp_check_space","sk_forced_mem_schedule","netif_skb_features","Java_one_nio_net_NativeSelector_epollWait","jdk.internal.foreign.SharedScope","enableWait","nf_ct_deliver_cached_events?[nf_conntrack]","InstanceKlass::signature_name","release_sock","tcp_stream_memory_free","mutex_lock","JNI_ArgumentPusherVaArg::~JNI_ArgumentPusherVaArg","skb_release_data","tcp_cleanup_rbuf","skb_free_head","kfree","SharedRuntime::complete_monitor_locking_C","ObjectSynchronizer::enter","ObjectMonitor::enter","JvmtiExport::post_monitor_contended_entered","LockTracer::MonitorContendedEntered","JvmtiEnv::GetClassSignature","ObjectMonitor::EnterI","ObjectMonitor::TrySpin","Unsafe_Unpark","ThreadsListHandle::cv_internal_thread_to_JavaThread","read_tsc","fput_many","getByteAtOffset","guard_LJ_I","java.lang.invoke.LambdaForm$MH.0x0000000800d08c00","java.lang.invoke.LambdaForm$DMH.0x0000000800d08000","java.lang.invoke.MemoryAccessVarHandleByteHelper","getByte","getByteInternal","compiledVFrame::compiledVFrame","CompiledMethod::scope_desc_at","ScopeDesc::ScopeDesc","ScopeDesc::decode_object_values","DebugInfoReadStream::read_object_value","ObjectValue::read_object","ScopeValue::read_from","Location::Location","pthread_cond_timedwait@@GLIBC_2.3.2","hrtimer_sleeper_start_expires","hrtimer_start_range_ns","Dictionary::lookup","tcp_update_pacing_rate","_raw_spin_unlock_bh","CodeHeap::find_blob_unsafe","ipv4_mtu","jdk.internal.foreign.HeapMemorySegmentImpl","makeByteBuffer","start_thread","thread_native_entry","Thread::call_run","VMThread::run","VMThread::inner_execute","SafepointSynchronize::begin","SafepointSynchronize::synchronize_threads","eth_type_trans","getChars","_raw_spin_lock","fput","tcp_mtu_probe","sk_filter_trim_cap","tcp_options_write","fixAfterDeletion","lock_sock_nested","not_walkable_Java","jni_GetByteArrayRegion","kmem_cache_alloc_node","ThreadsListHandle::~ThreadsListHandle","JvmtiEnv::GetCurrentThread","JNIHandleBlock::allocate_handle","equalsIgnoreCase","regionMatches","regionMatchesCI","tcp_event_new_data_sent","tcp_rearm_rto","oopDesc::metadata_field","JNI_ArgumentPusher::JNI_ArgumentPusher","RegisterMap::RegisterMap","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.LambdaForm$DMH.0x0000000800d04800","GangWorker::run","GangWorker::loop","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsTask::scan_roots","G1RootProcessor::evacuate_roots","G1RootProcessor::process_java_roots","Threads::possibly_parallel_oops_do","JavaThread::oops_do_frames","Method::bcp_from","JNIHandleBlock::allocate_block","__sk_dst_check","stringSize","OopMapStream::find_next","tcp_rate_gen","ThreadCritical::ThreadCritical","tcp_tso_segs","jni_GetObjectClass","lock","rcu_read_unlock_strict","MemAllocator::allocate_inside_tlab_slow","G1CollectedHeap::allocate_new_tlab","G1CollectedHeap::attempt_allocation_slow","MutatorAllocRegion::retire","G1CollectedHeap::retire_mutator_alloc_region","G1CollectionSet::add_eden_region","G1Policy::predict_region_non_copy_time_ms","AbsSeq::davg","G1BatchedGangTask::work","indexOf","isLatin1","nf_ct_seq_offset?[nf_conntrack]","values","ImmutableOopMapSet::find_map_at_offset","HandleMark::initialize","memmove@plt","asm_common_interrupt","common_interrupt","irq_exit_rcu","aa_label_next_confined","CompilationPolicy::compile_if_required","tcp_small_queue_check.isra.0","migrate_enable","nmethod::oop_at_phantom","GrowableArrayWithAllocator<ScopeValue*, GrowableArray<ScopeValue*> >::grow","pthread_mutex_lock","nf_nat_ipv4_pre_routing?[nf_nat]","GC_active","JvmtiEnv::GetStackTrace","call_stub","__slab_free","__tcp_select_window","migrate_disable","tasklet_hi_action","tasklet_action_common.isra.0","execlists_submission_tasklet?[i915]","__execlists_schedule_out?[i915]","intel_engine_add_retire?[i915]","queue_work_on","blk_done_softirq","blk_complete_reqs","scsi_complete","scsi_finish_command","scsi_io_completion","scsi_end_request","blk_update_request","bio_endio","submit_bio_wait_endio","complete","__put_user_nocheck_4","jlong_disjoint_arraycopy","tcp_rate_skb_sent","__memmove_avx_unaligned_erms","tcp_v4_inbound_md5_hash","_dl_update_slotinfo","__pthread_disable_asynccancel","isAsciiString","jshort_disjoint_arraycopy","get_signal","SafepointSynchronize::do_cleanup_tasks","WorkGang::run_task","sem_post@@GLIBC_2.2.5","sk_page_frag_refill","skb_page_frag_refill","nf_conntrack_put","tcp_rate_check_app_limited","tcp_schedule_loss_probe","__libc_malloc","tcp_update_skb_after_send","mutex_unlock","ThreadShadow::clear_pending_exception","__pthread_cleanup_push","java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock","acquireShared","java.util.concurrent.locks.ReentrantReadWriteLock$Sync","tryAcquireShared","java.lang.ThreadLocal","set","java.lang.ThreadLocal$ThreadLocalMap","cleanSomeSlots","Parker::unpark","releaseShared","tryReleaseShared","java.lang.ref.Reference","clear","clear0","JVM_ReferenceClear","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<397414ul, G1BarrierSet>, ","java_lang_ref_Reference::is_referent_field","tcp_ack_update_rtt.isra.0","copy_siginfo_to_user","clear_user","__clear_user","__copy_skb_header","ip_rcv_core.isra.0","apparmor_ipv4_postroute","copyout","ThreadLocalAllocBuffer::end_reserve","CollectedHeap::tlab_alloc_reserve","nf_ct_acct_add?[nf_conntrack]","ipv4_dst_check","tcp_rbtree_insert","inet_ehashfn","JavaThread::thread_main_inner","JvmtiAgentThread::call_start_function","close","task_work_run","____fput","__fput","security_file_free","tcp_rate_skb_delivered","jni_GetEnv","security_sock_rcv_skb","__pthread_enable_asynccancel","ktime_get","CardTableBarrierSet::on_slowpath_allocation_exit","ip_rcv_finish_core.isra.0","G1CodeBlobClosure::do_code_blob","nmethod::oops_do_process_weak","nmethod::fix_oop_relocations","frame::oops_do","OopMapSet::all_do","G1ParCopyClosure<","G1ParScanThreadState::copy_to_survivor_space","void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>","java.util.LinkedList$ListItr","Profiler::getNativeTrace","tcp_ack_tstamp","scsi_mq_uninit_cmd","sd_uninit_command","mempool_free","mempool_free_pages","__free_pages","free_unref_page","cubictcp_acked","run_rebalance_domains","update_blocked_averages","firstEntry","jint_disjoint_arraycopy","java_lang_Thread::get_thread_status","G1Allocator::unsafe_max_tlab_alloc",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';``
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    ratio *= 0.8;
                    const C = 1 - Math.abs(1 - 2 * ratio);
                    const m = (1 - ratio) - C / 2;
                    color = 'rgb(' + (dR * C + m) * 255 + ',' + (dG * C + m) * 255 + ',' + (dB * C + m) * 255 + ')';
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
