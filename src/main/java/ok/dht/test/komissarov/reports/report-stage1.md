## *Stage 1*

<hr>

Запуск `wrk2` и `async-profiler` производился из `ubuntu 20.04`.  Процессор `Intel(R) Core(TM) i3-10110U CPU @ 2.10GHz   2.59 GHz :(`. В качестве базы данных взята реализация `Артёма Дроздова`.

## *wrk2*

<hr>

#### *PUT*

Для проверки `PUT` запросов были взяты значения `rate (-R)` равные `[10000, 15000, 20000]`

`Lua script:`

```lua
key = 0;

request = function()
    path = "/v0/entity?id=k" .. key
    wrk.method = "PUT"
    wrk.body = "v" .. key
    key = key + 1
    return wrk.format(nil, path)
end
```

За допустимое значение `Latency` возьмём `1ms`, если сервер отвечает дольше, то будем считать, что он не справляется с нагрузкой.

Результаты `PUT` запросов:

* `wrk -d 10 -t 1 -c 1 -R 5000 -s put.lua http://localhost:19234` имеет показатель `830.90us`, что является допустимым значением.
* `wrk -d 10 -t 1 -c 1 -R 7500 -s put.lua http://localhost:19234` имеет показатель `0,99ms`, что также является допустимым значением.
* `wrk -d 10 -t 1 -c 1 -R 10000 -s put.lua http://localhost:19234` значение `Latency` становится нестабильным и при повторных запусках колеблется в диапазоне от `2ms` до `15ms`

Будем считать, что для исходной системы оптимальный `rate` - `7500`, поскольку имеет стабильный средний `Latency` в районе `1ms`

```Thread Stats   Avg      Stdev     Max   +/- Stdev
Latency     0.94ms    1.09ms  10.27ms   95.95% 
Req/Sec       -nan      -nan   0.00      0.00%
Latency  Distribution (HdrHistogram - Recorded Latency) 
50.000%  779.00us
75.000%   1.10ms
90.000%   1.34ms
99.000%   7.54ms
99.900%   9.90ms
99.990%  10.19ms
99.999%  10.28ms
100.000% 10.28ms
```

Видно, что **`75%`** запросов обрабатываются за **`1.10ms`**, но оставшиеся запросы выполняются за недопустимо большое время, сервер перестает справляться с нагрузкой.

<hr>

#### *GET*

Для `GET` запросов были взяты аналогичные значения `rate (-R)` равные `[5000, 7500, 10000]`

`Lua script:`

```lua
key = 0

request = function()
    path = "/v0/entity?id=k" .. key
    wrk.method = "GET"
    wrk.body = "v" .. key
    key = key + 1
    return wrk.format(nil, path)
end
```

Результаты `GET` запросов:

* `wrk -d 10 -t 1 -c 1 -R 5000 -s get.lua http://localhost:19234` имеет показатель `798.89us`, что является допустимым значением.

* `wrk -d 10 -t 1 -c 1 -R 7500 -s get.lua http://localhost:19234` имеет показатель `1.36ms`, что уже вываливается за допустимое значение.
* `wrk -d 10 -t 1 -c 1 -R 10000 -s get.lua http://localhost:19234` имеет показатель `318.23ms`. Виден крайне значительный рост `Latency`, при `rate` равном `10000` сервер полноценно захлебывается и обрабатывает только `86%` поступающих запросов, имея показатель `Requests/sec` равным `8635`.

Таким образом, оптимальный `rate` для текущей системы `5000`.
```Thread Stats   Avg      Stdev     Max   +/- Stdev
Latency     0.85ms  443.85us   4.36ms   65.81% 
Req/Sec       -nan      -nan   0.00      0.00% 
Latency Distribution (HdrHistogram - Recorded Latency) 
50.000%  840.00us
75.000%    1.16ms 
90.000%    1.41ms
99.000%    1.88ms
99.900%    3.58ms
99.990%    4.26ms
99.999%    4.37ms
100.000%   4.37ms
```

`75%` запросов обрабатываются за менее, чем за  `1.16ms`, при повышении сервер, само собой, начинает не справляться с нагрузкой.

<hr>

## *Async-profiler*

<hr>

### *PUT*

Для проверки того, как работают `PUT` запросы, были отправлены запросы с различными значениями `rate` `[10000, 30000, 50000]`. 

После профилирования видно, что сама операция вставки в базу данных стабильно загружает сервер на `7.5%-8.3%`, из чего можно сделать вывод, что работа базы на основе`LSM` имеет очень хорошую производительность при вставке данных, помимо самой вставки работает фоновый процесс, который скидывает данные на диск, но он так же загружает статично сервер, критически не повышая значения при увеличении рейта. Основная проблема при `PUT` запросах - работа с сетью, почти все ресурсы затрачиваются на обработку `HTTP`-запросов. 

Аллокаций же при `PUT` запросах происходит не так много, основные при создании `BaseEntry`.

<HR>

## *GET*

C `get`запросами дела обстоят интереснее, очень сильно на производительность влияет то по каким ключам и как бьют. Например, если постоянно делать запрос на один и тот же ключ, то данные закешируются и производительность весомо вырастет, если же ключа нет или запросы происходят по разным ключам, то нам нужно будет пройти по файлам, производя бинарный поиск ключа по файлу. Для улучшения перфоманса, можно проверять в файле первое и последнее значение, чтобы гарантировано понять, что ключа в файле нет и минимизировать количество системных вызовов.

Аллокации, в основном, происходят как раз при бинарном поиске по файлу 