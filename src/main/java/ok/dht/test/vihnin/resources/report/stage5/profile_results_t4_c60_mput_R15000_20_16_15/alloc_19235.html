<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BFoDAJNb@{AaBz|A???????K`SG@??A?@???O@???IG?@@Q@IaHHBWDGIXKIRXHI@XHBRPGXJOHJOIP?DHH`JYHhOKIIGPBH`I`BZEKHpJJNh?H?OCITJp?P?X?Q`ph?O?IOOA`@IX?B?@???WIBOA@?BAPO??GHA?????@A?I@P@GG?G?KIGJH?X`?WH`JCGI`@G`?YXQW`HOJG?@O@O`I\J@I@G??HBATIO`Q?AW`X`AI`OJcG@@O?PIhhKKH?I]IhXA`EIUJEGA`@QWOBIOTG[GHXGPOXI@R`RJGQAa@XH[G`SG@QJJLJRRI[J?``GJRYLH[H[HDGh`CI?hDGQYX^YAJMPBh^I`RTKJXYpSIAphhZTKLJIxZpJxCMKJQh`]IhGp`hZMKJhSJ`ZZp\J\KLHppJ\J]LJOTJphCIppXsGPb`Rp``IbLLNH`ah[NMHpx[MJh`i`pUMKMLKKMJhhpUMMIhxx[MLIa```haMKQ```h`p`]KMIh``[KLMKKQhkIBxhQahMNKIpxVNHqpNMJahhx``xTKSLMMLMIa`hxhhx]MLLIi``ahhh`pxp`phxNMHap^LLMLLMMKKLNKKLPp`ppzCSPqp[VIq`hppa[LQxpx`pxhhahpxhhx^LMMLKSLLRahp`ppxhha`hhpp`ap`i]NKKSLKUIihxhhih^SKULLLMLMLSN`Ij[SSKTNKTNLMNNLNNKNNNNLMLRqhhi\VIipp`apap[TKTMLRxxhppxp`iUTKNKKVKNMI?@KIVKLKTTNJp`hqhhxhaRxpasGhq]QjSULLSMSKSRax`xY`aSZax\SNKPipaahpa\UKKJpWx`p\SLLRyTULTMMMKTKIpa`a`ahpq`xaxhpa`apahpaahxx`xpxhzFXyTXhihqNSLTMKSLUNI`a[KO`hxNKLMLMTRxpxhaxxhaxhahipp`phYp`[KTMSLRppap`q]NLSKSLTMLKMKKLTKKQxp`qpiVSKUNXjUQipxpxa`i^RqhyVTNMNNMMNLTNKSUMKNNNMMLVLNMTNNNLNMNMMNLKUKSNNKNLKVNLNLSKULQapahaxhapa`qpa\ZqVL`EWzTSNKUMKVJxxhixippahpa`xqpipxahiihph`aphxxhxa`x`xxTTLTLRipahxxhihqCSLNKMLLULKVNIi`NR`aLTIa`[KPbKMR^K`HqVMJqDMQKYpxSSIy`TQxp[R]TIa]NJx``ah`x^MJa`USLNKKRpp]LNLKMNIpxUNKMNKMMKKNLQ`q]MKNJhiVMIqZx`x`hapDUHq\NOapCSPq[KXS`DXLYTQi`USHqh^LMMJiUMMIa`paUSJxpLTLNKKKSMMJhpxxVNIpa]MMJxpph`x^LIxppp`pxVLLMLLMNLLKNKMLMJa[SPhaKZ]PxaDTHip]PpqFNHizDXDZDXpaESHq`ph`q[KRphha[NKNMKMMJah[QxiNMKNLKKRha^MKNLJa``qCTKNLJa\MQpx``a[RpaNLLLNKNLMKLNKMKLKTJa]KPapLUKNJpiKUIxxT`HyMTGyPjSRVR\Qa`^RVPhiTQpqCMPax[SJah]PxiCUHy`\Qpx[Qpx``a\TIa`p`hiZih[SNLKNMIi^NIah`a`^LNLJi`hppp[KRxpSTLMLLMJakGLXLYqQy`MSKTJa`TSNKLMLLNLJxpphhhhp\TMNIxhhhphx[MQxh[TJqMNJhp`pahphhhaTI`[Pi`ppahhxp`a`ahpp`xpSVIpphx`xh[TMMIa[SNMLKMMLNXa`KZNPy`NQ[WxxKX^Qi[LR^SNKJaxSSLMLLKSLNJphpaUKPap`x^NJ`pp^NKLNKLLMNLLNJpxRiBI[HQ]JpihaTSJpx`phhhTSNKNNKMLKTQipxpLT\GUQTTJqKTKUKMSKSLTLKRa`xxh`hpiNRxh`ppi^NLKSLTHy]MKLSHa`ih^LLLQx``ih[Rxh`pha`hx`x``ihTR`xh``xp[TJyZxh`i[RpaVMKMLMLJi]XNPq`VPhqMSHqVNHqZqSKQqZih`xhx[LTKMMMIax``xh`hpphhx``pp`x^KNJpiULNMKLMJpphx`hxp]KLQpi[NLMLKLSJxxhp`^LMNMJpphhhphpSSLKSK`WbPjSTHaxMSIahhp`i\NJx`hpxSSMLJa`haVMIah`p`x`ha`pp`hp`pp`a\NMKKQxhp`px``xph`paFMMNLMKMMMLLLKLSKNLLMJxph`pahNKSNKLMMIiph`xphrCXSZFRpaVNHiph`hpxSUNJhppNRppVRURx``qMLRx`hiZa`paLTKMMJa[TKNLLMLMLJxi]LLLMKLPapUMKTJpp`i\LOpa`xhRxpxpxhhhh`xHahLNITMIcGFRFULSMULTGhXp`p`iaxpixxpx\Hhh\J``^MKSTVMKSTUMKQha`phhx^KLKMMKQpx`phhx]NLNKMNIxx^KNKMMMKJhh`a`hpp`a^MLKLKTKHh`LUMKLTMJkIVOeNaVhXtV{VwWqWpZhOgXcWiXhWeN|XuXnZsXwV}XhY`Zu[~V`[_WhZzWnWi\rZs[sZf\`\c\j\cZ|[g\z[r\w\_]l\f]e]d]z\{\gOqNsSxUcSsOoUnPdRtS{W_S~Yp[bQzRgSsTpVrXyXxNqOyOdPePjPuQvRdShSnSoSqSzS~SdThTnTzT_VlVqVxVkWrW~WbXdX_YkYoYrYeZmZuZ}Z~Zk[v[y[}[x\oNrNtNvNwNiOkOmOnOpOrOuOvOwOxOzO{O}O~O`PbPcPgPhPiPlPmPpPrPtPvPwPxPyPzP{P}P~P_Q`QaQdQfQwQ|Q~Q`RcReRgRhRkRlRpRrRsRtRuRyR}RaSbSjSkSmSrSvSwSxSyS|S}S`TbTcTfTgTiTkTmTpTrTuTvTxTyT{T}T~TaUbUdUeUgUhUiUjUlUmUnUpUqUrUsUtUvUwUyUzU{U|U}UeVgVhViVjVkVmVnVoVrVuVvVyVzV|V}V`WaWdWfWgWlWmWoWpWsWtWuWvWxWyW_X`XaXcXfXjXkXmXnXoXpXqXtXvXwXxXzX~X`YaYcYdYeYfYgYiYjYmYpYqYtYuYvYwYyYzY{Y|Y}Y_ZaZbZdZfZgZiZjZoZqZtZvZwZxZyZ{Z|Z_[a[c[d[e[f[g[h[i[j[l[m[n[o[q[r[t[w[x[{[_\a\b\d\e\h\k\m\n\p\s\t\u\v\y\|\}\~\`]fNgNhNiNjNkNlNmNnNpNsNuNyNzN{N|N}N~N_O`OaObOcOdOeOfOjOlOoOtO|O_PaPfPkPoPqPsPuP|PcQeQgQhQiQjQkQlQmQnQoQpQqQrQsQtQvQxQyQzQ{Q}Q_RaRbRfRiRjRmRnRoRqRwRxR{R|R~R`SeSfSiSlSpSuS{S_TaTeTjTlToTqTtTwT|T_U`UcUfUkUuU~U`VbVcVdVfVsVbWeWiWjW|W}WeXlX{XbYlYnYsYxYkZlZzZb[~[o\q\a]b]c]g]h]i]j]exLKKKKKKp@q@Kq@hAKq@KKhAq@Kq@FKp@Fq@p@KKp@KKp@x@Kp@q@p@Kp@Kp@p@Kp@Kp@x@q@FKaEKKr@p@K`AKq@p@v@p@Kp@r@p@p@KK`Ap@v@v@p@?jEKFs@K?KiDv@Ks@Kq@?kFKBB?Bq@`AKKB?APBp@uAKKp@Kr@Fs@q@Kr@KDFPZAHp@?q@Pt@r@p@KUDK?APK?BWq@?Hx@Bq@Jq@?J?r@x@r@DAp@DK?PKGFAF@KPIr@DDp@Cp@BBI?JKGKp@KKJJOMI???@MBP@KWK@BW@LJOB??GBB?BKDDJKLL?ACBuAAW@UUFq@UFFH@??@FFU@UFF??PBDQQJPbDDG?PUp@q@?FF?KC??@@LMDUBMBKBKQBBBMt@DD@KH?@?IB?KKJBAGDAr@BA?ADWLZQ?{GK@t@K@BKBZAMLLp@@JGZUDAKI@C@J??t@xGDD@BDJYKQB?GGA?AHDGB?WdAA|@p@UPbHCQKGDLGDp@@?KY?KWNt@?c@c@KP@?AAJGUIt@ZZFYYc@?@KPU?FRNDK|GLLs@}F?IDO??@AEXX?Oc@LcADDX@\\WCS?P?W?dAC?BBOGZH?@C?PbANWDNc@PGGx@P?DGs@@?@M?cBK@GZ?D??JXBYKCBB@r@q@ZYDOr@??ABMGZcB?r@X@YGIJS@FFBOOOFFEFFE?BOBX?JJc@Oc@A?cAq@NcA?A@Bs@ASUB?Aq@I@?YGDNFDD?J@H?vG@JJBAp@SAv@DDRKGMt@IYABv@AEKQ@E@U?q@KANALMc@?IJO?B?A^R@ZFEVTAQc@JD?@B@ADYEP??AWYs@fB@L@L?@Q?NWCIr@DDA?WOQEBQ?@?WTBBIH?ABVs@@ALFY??HB@BB@J?@@YJC@YK?\PB??QXEMMBGAP?r@?@BBD?DBBAPAJ@DKDDMaBAC?^MLT?BIW??q@BKVXGG???@Jp@?d@?DMBB?OEAEO?Dp@CQDYK?CCI\\AQC?VB?BBA`@P?UBZ?`@T?MLBEs@IIB@c@QX?G?@p@J?a@LMHD?@]?VVDRG@PICB?BB??@PU\?Z?FFEF@Kf@FOO?OEO@Jc@@WNc@BBAKA????R?e@CGRU@EPPW^I\P@?@?C?PA@BBMBB?Md@CXSJBMH@AA]bAEWBDD@QH\BL?KB?I@?e@?PI?NPe@QOUK`@GGEa@}@@T@Dr@R@^Qf@ADGDBM`@H?BBV_@CAE?OM@E@?\V`@c@J@ABH@PL`@?ADA?ABB?LAB???R[]LNABO@???@N^C?VI@?`@M?RAP?UBK?ABU?@_@CD?DML?ABDD_@BA?NLWBAE?ACDJ?C?@MAPICV@?FFDB?IT@DAOASUB]b@?XD?S?`@G??XRJ@?aBNNB?@DDG@QAT@?OM?K??CGFGDAG_@ZGD@FC?DM@f@AS@Xj@RJc@YLN???C@?IY\?E?DDJ[B?ASB@H?DDYd@WA?@TAVPUL?@Jf@BSCDZAE_@a@?\BLVD?E?^BG??AP`@^ZBB@@j@BDDCDRGc@EEFEAS?ECOEQFOQO?NB?BBIKKEG??AT`@LYG]ODWBBE?TSF???ZLVN?BDNAACCSD?d@C@?QLb@?@B@WD?@?NW?p@CCUa@GSE?c@?GR?AX?p@??[P@BDAAdAYFr@BA?[Q?Id@?CY?IV@@?_@?LWLB?IS?KE?DDa@j@|@@La@MAECN?QPU??UU?@A@?BELM??Wf@L@q@UBABS?A^AD?NW@CMLS@N?IAU]h@?f@DUBBDK?X@AS@BAc@?@?BKD@BBO@[?DDJg@[@?`@PACDDLM?CBM?AC?HBLWNEg@D??@UGA@n@AEARBc@H@G@?GBBe@DC??PI?AJ?^?BD?B_@???\B?NA@A?BBXfBG?MB?@BV@?@?@CMIYh@@OIN?@??DJn@THDQ@??B`@@?PI@UBA@F?Mp@GD???@@JJJB?b@O??`@@D\?]b@Yo@DJ?@]@?`@TRc@ZADbAYGKb@VSIY|@d@?BE?]JBA???EZB?[h@BP?@J??Uh@?AIBYS}@P?KCR@L?EUFOOEEHEE@?OFFRNFJUh@?@q@@?TCRLRZVB@?A|@?@AIT@?LVTYHDDP@i@?@?A@Di@G?ZGI\CX?????`@B??[CIBDMASAHEB?JDC[UABHD?C_@@DJJD?N_@?@ABAI?D@?EBEPd@n@EITB?AC?EIAVB[S???ORBB?QB[??`@?IKCY@i@OEEBNW?@J[?d@TRYHX?C?VA?d@DRN?R\@A?@U?_@B?]b@GG?b@a@@?Qe@BI???R@ABK?ABD?S?H?D[OCLj@Cd@F@GBH?IZ@@AXRZg@@??Ac@E?IXa@G@D?BA?WRA[?@MXRY?]AB?AADLG^]m@EN??@?@B`@B^?C?D?\\OFT?ILA?@?A?\QGE???BXH??EO?YB??a@n@@U?GZ@LO@@b@@J@\???@??MUn@WLB??A???ATBZ?ZGEQ?B?@?HZA]?MBWMHA@?Bh@T?U?IY???W?DDb@EX?NGG[[EIi@E@ZU?VH@@AIMA^?AI?[ZIAEPf@?BH?@?GMAAj@C@MBZCE?HGh@Od@_@?TDCd@Y?AI@?ZN?@?@F@WWLIDY@e@FFFOOEa@O?E@FOEUWBBVEI[SC@A@ATI?\DDLV???T_@??@B@a@GRNDa@M@?EIYHC@GB@l@HAY^?X??@IQH?[f@S?D?LZ@[@?ISf@@B@?@IDCAULMA@Sl@B?C?Z?XBd@?C[?I@i@?NWD@O@??A^Y@DA?LM??m@RDG??AVA?B?AEC??BOB??`@?Bf@V^C?B[?ABG?A@QTR?D?[??O?PNW?D??FB@?F@U?L\\LHi@EH\?@b@?BRCBPI@???LQO?R?@YHOQF??[CXVND?A?LNN??^CXBd@CRE??QRDD?e@D@\Ec@Dd@d@@A?LLMALI[?J?AQb@@ATZOQB?g@R?Z@A?Y?BAg@c@DF@?c@HBDDGN?AA?b@?Mm@?AN@BBL?TAAIYB?C??ILM@\A@AYPI@_@I??JQXDb@Q@AAA^ABRARE?CB?@CRWLb@???LQZGHZALAn@CP^]Vl@?b@@R?NV@?AE??@]BDDD@ND?TD??CC[D?BRVR^CGWS[^C@P?W@?@@HISUBf@H??c@EX??@MBAE?AQAXWF?U@_@CO?g@?JM?@OC?I`@P?d@@BPN_@?AE?KC?BL\BS?AGRc@OA`@@J@?YG??V@ADDD?F@W?N]Aa@DO?ILFFFOEFEEAE?OOO?BPDD`@^T_@@EH@?ICVI\?^C?A?T?BABBYCLAV@@AT[a@?MVAE??RWB@E?^??L@g@DDEUJC@]@@d@BIB?CE@VC@GR?E@@S?CHJGBB@D?DCCOQ`@A?c@HHARN??DB]V^??EHZ?BB?@SWJ@IHf@CCCB}@SP?AEHUEPAE?A?DGDAA??W?TD@[@?@@EQBMo@ADk@?@j@?Y??@`@AUBJL@@????@?UBB@QZZ?C@I?E@?TUGn@TZ@ZJ?@?AC@d@BD?ASQI?g@BAC?C@BAD??PI@?@BDA\]P?@g@?J?@C\e@LB@?@AP?XCEEUP?Db@@@ZE@ADf@UP_@@^B?Ab@?ICE@Y?[SZV??A@REB@U@m@?ZZ??V@??B@\@I?@?EBR?H@@@@XBCB?T@@W@@P??@MB@C@??PIBh@@@Y?NR[HZ@CN@A[Aj@IP?ASU??WEJT??JX?A[QNW@@Dl@@^RRFZ@V?NPI?H?AATDBJBLD?T?AEn@[HABCLBBB@V?V?AE@?E?O@g@YGc@l@_@BA?d@HD?BP@He@C@TD@YRS@L[?F?Bb@@_@U@ZEU?@H@MBCe@VDDQ[_@T?Q?@AJ@?QB@e@AJA@B??`@O@MSMP?Ao@]@L@ANYFY\?D??DD@@?@U^@MBYEAN?@FFFUUO?E?f@FEEUJc@UAEFAH`@^@CMBLBXd@BA?CH[?]?HQ\BMPXT^?@]??F?i@\NDPBBAe@H?a@OA^??n@IB?D@@??EWA@HR??DBD??l@@f@PC?@[R?VASRAN@Z@e@[?SB@?I^@BBBg@@@FCX_@??GUBCD??C@TJ?d@AZGI?R?]?@C??V?B?Nj@LMS?@\A??GG?EQ?AL?ASPAl@AB@L?^a@\Z??B@S?k@B^A?\EQOE???XB??@h@CP[LCG@AE?QBFBAT@@I?@L????D?IJAA?m@@@EDVh@?TXe@@X_@Q@?QQX?Q?h@_@`@V?ABZR]A\Cj@H@]IZS@?d@C?c@SNVH?@??QE^@?RWLQ??A?WIH??IW???H@D]`@QL@HYVV?@?@B`@?DDCR??XS`@S@?P@JAGAC?@@X@AAIRN?CWI@^?Ak@e@MY`@Jh@?L?@A?\U??LMAJC?TANo@CHMB@?L?S@JT@?U??II?@GE??ANW@BI@CHDNN??Y`@DE@@?AB]WF??ASYD?J@]J_@??G@`@XH?k@G?RA@?Re@FM??H^JRADDf@?j@@NC[?Ai@GB?a@AZ@A@DJUA??g@?L@SB@@]NWZ??@GT[E?VG@@`@BHE?@O??R?GE@@SPLBh@a@E@?@Y??o@SPPLB?@@@Za@CG?@FDDQC?B?PA?N??f@??`@Bb@OC\PBa@]?h@[E?@QO@?XP?@b@b@_@J@A?FFFn@OBEEEOEBOQQY?GAl@Ye@@?[G@C?U@W@b@?E`@D???BDB@?o@?CHB????ABBc@B?^@o@C?A?HDCGn@QXCS@?TH?PAD@V@@X@AIN@?f@@ADDNBC@A?F?@@@DWLGd@?A@H@AASDH?WVI_@C@C?A?H\Be@VU]m@b@@?BC`@BAPFZ@?TCBE@\QCG^@A@e@OC?M?e@NDDA`@C@Q?PBBCA^JFd@?OQL??B@?l@@?YX?^A@?Oc@DDC^BSC[o@CCh@B?VABJB@?m@@R@Ak@R@@CPe@LH?o@?Q}@@Q@?UPA@R@ZA??@@?DPAC@BBAHAWOB?a@C???@P@B?@_@NH?IDBC?CAS@XQb@@?[DB_@CHC@?B@V?ABY@@?W_@j@?GH?@DB?M?@?S?_@?RQf@?PC?@]B\?N[?A?D?A?ANAIE_@IHDH_@JG?E?CDAP?@B?@@D?NT@B@@GCRA??M@j@@FB?F?V@MCD@@@?_@BDF_@Cg@a@CLOV?ARH?@_@F@\T_@D?@Q@BA@DR??Cn@?ZAJ@NQC@FM@ZE@^_@?AMDL??A_@B??e@g@SC?PBBCR]Ak@?C?A@CGZGDV@@A_@R?e@C@^OXPA`@FE?Y?m@A@PD?GC?LVd@SH?@VADF@D\P?W?@@?@AS\ABJD??d@TC@?AMNC@W^D??i@AAf@C?JPQ`@Xk@?@A??l@n@@WMBG?Bf@EV@DEl@G?E?f@BIY?D?Dd@Bb@@A?i@EBk@B@FFEEEF?OFAOOOQ?DDTO?@@ECCTBUC?f@Xa@l@??GHU@?[PDL??@B@m@@??D??@DJ@???C@ARWa@J@CXd@C??Fl@DJHOMLCL[??_@NF?EJB?Sc@Ne@Cb@??BECDT@AUU?T?@F@@VFWDQ?@]FXA?Z???@]@OLAb@MNA??S??TIWBOc@AIF@?@?H@TXZ\A@TDDh@?@B?[PVVl@[?UB??@d@@@Xg@?IW?AEf@DO???VDZN?A@a@??LMFHXRI@?ZGTCATC_@NF?AYAWBCC?DD??AIb@b@GE??@ZEPBSAl@Y?AAH?JC?\BELE?a@?A`@P@DAP?JHOE?a@[@Z??ABG?e@Z@ET@W?C@Y?S?Bf@BOAX?C?@?YEHNG[G@?d@Z?@EL????DB?EE@I]b@HUn@A@DNPI@E?CJC?BB?CD?La@V???@^XYg@f@IPE@GE[?B?@B?IAFb@B??@?XEBDO?Th@??E@V@?c@WD[L?A@A@i@PXCAH?LLM@Td@?c@?a@M@AB@BU??BS@MF?TTD`@JOS@V[?W@?m@@ZB@@TC@WWFL?Y@?M]b@j@f@@AM@DPPZA??@[Uf@HTD?BHa@On@CGA?[LCLAFBFE@PQ?@?i@HGANBCA^g@@O?i@HB?f@k@RI`@?AI?@B@]^HGB??d@G?\?[Bn@E??NBA@ANJOLF@?S?IOc@A?B@FTXOc@A??LADTLR`@Af@LF?I?f@]]BCTM?MR[B?]GCe@?a@@IBj@?@COOGEEFDFFEEF?UQ^@C\b@@@@Yh@?QQDUU@?h@[a@MATAEOB@NB?AAE@??]HBBGYGAX??@d@EAO?Q]BM@D?k@??Q?@@HVDa@C]OMBAk@Cd@@H?DOd@?Q?@A@Nn@T?YBBBF?D?@@??GDEPH\@HGA@@g@E?@MS\ZLLQH?B@@@^??f@RNHL?JOAb@???AB\XR?AI@R@EAEI?]YAEXC?J?C@?@BMC?EYDWT??C?C@WXc@b@k@QLM@?ASc@E?LE@?c@B@DY@@e@@@?@D?AGm@@CB@QBCH?AEk@B?V@d@m@RXRNC?S`@G?XRE??BL?o@?g@?L?B^??CDBBN@I?^?@AJE`@XADFL?A??J??@L?NNEP?@?AZE@XA@@DL@?C?@Qd@B?`@?d@c@CIHZ?_@@ASQ@@ABBY@@A?A@Dl@Q@H??GHVF?H@U?BIm@HBSTPI??k@B?J?AE?Jo@B?Fd@JE?EBN]C?OBBm@?AXV]f@@A??JEe@\G?a@^HL???GWAl@o@ADQ?@GLLSh@SFTO]G??IGA@?Z@c@FOF@R?CIIIH@@?QAB?@?[BN@i@VBB@@??`@@BN@?B@DI_@@???]?GPCQCIY?k@H???QGAEJ?V@NC??A?ED@?JI_@?NS?BH@??U?PBj@[JF@IUa@b@AN_@XA?AD@SQA]?IPIe@QAY?@FJO?]?NC@C?@ABDh@I@?Q_@?An@a@ABMX@AJk@????NFl@CXQB@?[@k@?a@F?MBAS?B?VFJ@?BAi@?@Dc@A@?OCFFEEFE]Ob@FOOOQFBRA@@H_@AOb@@WA@XQZFAP???C??LJ?GIi@AHS?@Af@R@LZZABe@^CAO@A?Wf@XAAG??a@BAg@i@?D?BBBAN?A_@@@Db@@NPEX@AY^?^?LEC\?DCB??e@ICb@AALNc@S@BA?AXXT_@?RO`@]O\BTc@???CEGDZJ@FAf@ZMh@C???BJC?I?ACV?CB@@IBBB`@?c@k@A?BMi@@d@LD@HHLWC?S@J@@DMMO?AD?]C@??OEBJm@?BH@??c@?Q??DQQBA?@a@?IE?Q??QG??[R?VH?NSGA@a@@V?ECJ@ANH@J??JDb@S?Q??QV?@QE?AEAQ_@B?]?R@?R?DHD??RQX]@OA?@CYDD?GOT??@^?NA?VRb@@BBM??@g@D??c@AQLE?D??_@AEBS@ABAUBGGC_@Fc@A?@MRNF?Vl@@M?DD@??O@\??f@Hb@@F\JAR?f@Cm@CLF?ENALLP??B?ATA@AM@ACGMEVML????V??\?QX??B?N@o@BDD?A?B@O???h@_@W?Bb@?m@JNWAANPS?k@OMB_@AANh@?RAYId@E?WHa@@CUUE?XBBHa@C?@?@B@DO@?@?NCC@b@HDXO?L?AP?Yd@C^?AWb@Z^DBBA@`@\?A@LVBX?V?@@@GA?FCNEPRFBLM?@?YS]?I?a@Ll@RBA?Wb@@E?[?JIHBNVA?BE?@@OC?IBAR?@h@AF?PCAERB?JWL?H@h@B?o@GA\n@TWa@?@B?GG@@HM@N@[@@AL@P?l@k@BQQERFb@B?@G?Ba@@TD?ABUFOEEESOOOFEF??UL?@?@?I[C??D^IL?WB@@@HA@DDOAEYJ@??Og@h@h@AJ?S?NR?DCH\?BT@F@@W[RI@?@BF`@@b@Cd@JAGEAJBT?i@?[R^H@ICP?E@d@?HG?D?ADNR@W@???BCE??Ld@@DJV[g@A?AABCTGBB?CEd@PEWAJJEF?J@?L?T@@?Q`@Lb@S\^T?^BW[?I\@@??G?c@AI_@??h@?LA?@L@JDSS?DPi@@CEf@?GTI??d@YT@I@Ba@@V?BQQ?_@@@U?B??`@?CDV?_@CAJOAB`@@?X@NDZi@C@_@Nc@B??@?ABT?`@BDZg@GS]k@@DD?@@ABICG`@_@H@ZF?A_@B@M@?c@?DEAB`@XC?Gg@?ARb@Y@@e@Qb@@XC@?^A?J^PH?k@VGUP?_@?Q?D@@Hg@?@ON?CBA@AB_@T??d@\?BBAQ@@Lb@A?CC??JXEMOF?]C??A@B\@?LRk@Hc@FEj@A@E?c@]WZBC??@??@[BM`@?@QWD@k@TA@AA@Z?B_@EEBLc@?Aj@?D??DDECI?BAAEAEB@AB?B?CGDTAC??^BN?@R@BDAS@?ASH@PBf@l@BRWL??H@?@GEVQCIFi@Q?A??GA@d@PR?T@@_@AJCBk@AEI@k@QL@R???B^?C@VCIB@Db@?@e@MH?@U@Oc@?ND?FFh@DBB???Xb@Q?@k@U@CL@@?e@EBBXZABF@@f@C?A?JB@NQ?@?T@J^_@@MQXW?SA?\?H@b@AAURMl@HF@e@C]BHED_@BMLAHHRM?_@??@E?DPAB@@?Zg@AH[ACBL?AGb@JY?@@`@EUE@UOOFFE?FF?GL?FBj@A@???B?DMLAN????A?VT@JPB?A?a@O[S??HBLLRAC@S??FEXEOMOX???@@`@?@Q`@?IBQ?Y@P@b@A?]D?VND??A@ADC??o@Z[GI@?F?_@?Be@?g@OGm@@n@?B?PA?f@IAE?DBE@?QGWb@N?HIE?@DC??GVD?k@O@]Ei@?g@?LDDBMA??b@\C?S?@ODIg@A@@S@A?\j@]BLb@?@@Ne@Aa@DAj@ABMJIAA@@?N]m@DHAVV@B???@?c@m@?g@VBBMF??@W?Um@@]?PVBAT?C@BCA@g@TBDUU?J?@AB^@@_@??GBc@???e@CADAf@@EOB??PV?C?C\i@AEHBCCNX??[AD?a@@?CWMYYFFBZA@@??A?CBN?HPHBB?^i@A[CNJ?F?ON?X?Q`@d@?SC@CZG?J@D\??CC?E?ADJW@?@D?@?CTc@g@BEBLMe@@@j@CP`@QIIEa@h@JU???GCY]EUEAAZMM?@C@?LDB??D@S[?DG?C?Z??A\@l@A`@CVNM?a@Cb@FYI@]?PBn@B?@?Em@M@E?BA^GN?@j@JE?Oc@@]D???n@D]m@LHUDd@j@@BVVAC@i@NCUD??J\AC_@??]XQCNb@EVQ?@f@n@@AI?NYi@??@_@@G[@HB?@BDH?BA@ZBB?@??G?Rf@@^UIET^@]?MCLBN\A]?AS?@m@CDCMN@J^]?]P?@YH?J@WABAF@d@H?B??ABNARV@g@???Ge@B@@HBDW??]H???DC^?WWV@?@?Jc@?A?@??B@IB??_@?PIC^]?D?BRFFFOEEEOOFDD?EB\BAk@_@@F?@P?b@WB?Ff@A?c@[g@H[BMZZA@?Ja@AHa@j@l@DMWCF@A@CAAb@ABOP\XB?CTZF?f@[?CXDMd@CAk@C@@@CQ@MGYQBi@CB??g@?C??DO@DA?@@L??T?CYBB?QX?a@m@@BE??D?c@HD]@BLAEA@L]@Pg@B??Y@@CCc@XX[?GIHQ@?@??`@Wj@FDDh@?g@IG]?G?????AXe@?BJo@Z?@Y@??AR@AEPJT?R@o@HA^ACUZ_@Me@`@?@CAD?_@@PJAEZ@P?U?A?j@?C?Rj@G?BA?n@FI?A?[GA?@BD@CAL?@?AB@A?YM??@?`@e@G?D?ATGIYHBA??@IAEAAQLGd@O??]i@?d@e@AUIJJ`@Bg@A??A?WNAJ@ID?@??C@\?AIEBAl@B?Bk@i@m@d@ABMBn@@EBCAVf@HC?NNL??AIYA@??GSPCo@TU@@???f@B@N@XL@??JXHQ??FCD@Ug@??c@M@Bd@?Z?@?N?m@?BRQH?CW?So@D@@AEB\XE[`@f@@?@d@FIn@PI]Pe@Fl@CBAb@Bn@?c@JW?A?CADC?Ao@\?DBS@C@[Lf@@E@IARLMm@BA@?ADZ?@FCZNZ@H@A@?EFM@?JJ?@J?BA?R@@?Ao@?GR??m@A\PXCh@i@?a@JNLW??OSMEH??AFMHb@?LDh@JJl@@??[Y?Af@HDBGA???AG[ZAAENZN[g@@??Hc@?C@BV\Me@?@C?JAl@?j@QY\IA@e@a@a@@]f@?DJPP?BA@ABC_@?@?B?DHYAb@@_@P?Eb@B[CYg@Y?AG]n@EI@C?Go@R?CAL@Fc@FEEEEOF?O?OQFJd@@Hk@?@CRBFB?SBB?L@?AT[VRJDi@?ZYe@Al@\???Ac@?DBAXLNH?@@^i@M?BMAVa@Bm@CA@?@?Y@BJEh@M?F@@V@h@?BGBBT]J??m@`@?MB`@VBT?@BAe@Tk@?CLDD??@m@m@RA_@DA??@ZJ?@A@Ge@ACEBDa@AIe@A@f@?@QI`@@J???M@AT?FXGAE^DQ[D????f@?C@`@DNBk@IY_@??Ed@M@AAEMMRCCC@??AQ?d@?MUa@Db@@@\C\??SMAEQB?H]DFBb@?]YC?I?g@h@QQI?]e@B@j@ANW^@Y?@BCF?ANAHI?j@L?MLd@]_@Ug@@k@UAEAGDBd@IHC??C??g@?PP?QAB@@?Cc@A??H^BY@JAABAB?@A@?^NJDIH?e@N?PEC??A@D?BTS[SMD@k@AR?AD[Db@j@C\CUQ?A[?N^?BEN@?XSXA@g@N?j@CTTARn@Q?Bi@a@?Mc@D`@??h@?@[SBBAT[ROQ?@W@?H@\?@OD?DEj@GAE?[@i@LBSC?`@G?V???BO??@\]B@?CRAk@D@e@?ODA???b@J??IAOC@?k@D`@A@e@PCBBHGa@?B?C@d@C]ARP?Mc@?A?SEC@C@JO[DS@Ak@QD?i@??A?B?\A@P?@Be@W?^`@U@?@Xn@ECGSQCC??ADIf@A?W@A^G?RTA\Q@?j@?Ej@LDYAo@CS]NFa@H??VNIZ?S`@UA@@?@@W@BJn@?T@?]Bg@j@Ug@j@BLD[???Ne@^?B@M?l@?[GE@i@ZHd@MEBg@E???i@\BCHSD?@b@BBa@CEQM@ACV@T@Gl@g@YG?c@HTc@?C?EEFFCE?EOOOOQFNE_@?B?A@_@d@O@\OA?[??AM?@@B?@LRD??BAa@[@H[Z?WIBAl@EB?j@@@]G?@RGA^EB@@C@@DA?DRN@@?`@@T?l@D??NNRL@?H@@?H?ICB[De@M?F?@AC@RMd@@JJAL?A_@?b@@@ALI?D[Dj@o@?m@A@EV?VFJ@e@c@?@e@B@^LH?QG@]B?A@?A@c@vBGH?ED]@OLg@@C@?IH@@I`@@NSNB??AL?A@?WF?P?JA@@?B?Th@?@UBXQS?d@La@PE?a@]@OCB@@CL?AAYJ`@AG@BJDCEC[@U]Pc@@G?X@\EE@AEWD@C]_@[IFP?_@?BIn@?IF?[O@?BAEBVX?@??RP@?[SB]?DCCHABBDCFDi@FSn@XOECO^P@G]m@^H?Df@@BB@_@Mj@Df@?k@?AAFB?BBM?@C@A?@?W?JV?a@Z?BS[Tj@DAl@o@BM?@B@@E@?B?a@P?U?H?P@c@A?[d@k@C?Zc@??Me@[F?@@Q@HYVI???CC??A^VNAEIHL`@@B@?QX@A?]B[M?@_@ABMC[???XRG@LE@?E?@e@Tn@RIB?JAEl@?l@?AU?OQX[A??AVBBg@[?JFI@n@E@[SIB@@?SDDo@?HGB?d@D@F???TJ@Z?]^NN?X@@??QA?f@?OCLZHA^EL?@U`@Ao@l@V^D?CA?B@BL[S_@e@WCJ@B@e@HJ?HIi@A@EC?LR?J@o@?AF??I@BP?m@L?A?TD?@?GNII???@?QDA?a@XHR@?@BECC??R?S^O@\PI?d@ZA?A@e@ACNSVh@@CYLLn@@Bb@?TBc@FDEUFDFEn@c@c@EOFGW@A`@FMB?T@@^RYD?AAEAC\@@W?ABBO?@?A@k@C?\C\?DQ@?A?`@J@CZE@_@P[W@\??e@@j@m@?Dg@N@a@M?@SJ]AFZTIGZDC?G?@?^]h@CAIB??R\@??M?C@@IIE@BEBCA@?B[^i@JB?ABDb@@?C?D??PU?A?\?CVb@@?B@MN?AFEI?E?UA@?BQ@?Ej@?@DSB??`@DD_@MBCa@FY]?S?]DG@@@@_@\?@@AGGF@?On@?BA??C`@?DB??@D?L?e@?\CB@Ma@C`@CL@AHP??J?@QY?`@?^W??@@BAA?OBFH?SCGR?T`@CNVDE??@G?@ASD^@G]BT_@j@CM?AI]EBE???Je@Gj@Ci@DWLC@JH??k@MDm@G?O@?BAHUU@?AQBi@?@@?ZT@?X@G?QQ]?@ABCCM??HN@Ol@MX`@??A@i@@h@?O?VNBB?H???ARFJ?@W?VG]F??@?VSH@OWN@WC@h@O@U`@HXa@T]Ik@B??a@Ok@??A`@J?AY^W?Gf@E@B@C]AWB@Q?J`@HC?MFA?ZIE@MEO@@@JA@^??Ub@GPA?d@TB?@FAa@\D?AB??c@W?Cb@@^m@D?]B??G@XRSACB@IHDZC_@@UA??@ZG[P]BN?@@A?Ca@ADYXA?A@AO@^AE`@YY\@@@ZZ?Eb@@?EFDQ?A?\PVE?C?O@?MB??_@Uo@@E_@ZGB@GAC@@R]b@ZA?W?XB???C[TGn@@@\@?YVn@e@M_@^@C?N??D?X@E@a@AD@H@\?CMMVm@N??@XATE??R\DCe@DD?a@?]?@EZFFc@EFUFEIOE?YEQIDF?@^@???Ec@BB?@X?@n@k@?FI@?XVBAh@a@Aa@????BB[DDCAET@?I?S?M[SJYG?@?Fm@?ABF^?BU@U@^Rd@]N?A^d@U\L?@U@c@f@C?_@A^Dc@?T@XRA`@Yl@Aa@CVMM??Jc@f@RFAE@h@@N`@?J^k@P??TLa@]@BAe@EB_@D@AUVf@CQb@h@T?DD?UP??C?D@?VSC?V?a@IDn@CC@??ZPHAE\?@W?B?j@o@DA?@B?ADH`@J?E@?B@D@@?UAHCJ@B?X@LAE?EV??DBe@??W@A?@^Z^@ALNLC?C@??@@?J?OBW@@??@TE??LDZWDAHA@@BF?@EMBBb@G?@C@?o@@AJIDZ?JE@@A?G@^?BBXB?EAE@?Fg@@UBLDDC???D?SN?C@ZAi@Ld@\?\\]?@[QC?HBB^RR]Cd@b@DC??JC?ZMXAEA]??CQ?J@Be@MD??[C??MLD[CEUL?@A[S?Bc@E@e@U\V@?@[B?@BB??ALCc@A?E??SJc@AEHYAEDA@?Xg@\BRNa@F?Y??@G@?g@J@EDABBC?JY@?@g@?NAFHZb@B\@E?QXg@E@@?BV@?i@JP?l@Sb@@]AEDGQ?A?^@IPa@@?R@Ge@\H@e@D^GT?f@c@@^UB???h@c@I?h@d@FB?INe@T@FBh@?e@A@?DJDX??a@N@e@AGDYT_@@\i@?h@BB???\??G@XO@FMa@?d@??@i@UYGW?@HT@AH?XAVMIa@@CAa@X?n@?AWNQ\E@??Md@?C@?DBR?L??o@CQ@h@?HNP\e@U?D?A[TJ?J??G\@F?FFEc@E?AOOOF?EFZP???H?@d@W]AOJ?VYEI@b@?\NF??@AR?R@D??g@??Y??]Gj@I@^?Hl@o@BI_@BB?MCB@AA@?YGQ@@Jo@?RAk@??@ZBH@J@d@FJGBAE@_@]Hb@BH]?QBB`@C_@LAD?@@@C@PU?I@?C?@ANA@?BMG?A?CC`@MCHB@f@MJASAd@?D?AX]B?JAO[g@A?FCI?B@BBD@[l@?@A?Jc@l@\V@CGC@d@Ao@_@Q?MPAFF?H?d@V@a@MC?UBGCC@?EE?m@PDf@EMM?a@@A_@?ABW??h@PX_@CC@CAA^BJ?Q?I?C?F?@MECILf@HR?DARl@n@^T@@AUCMDC@?d@CD@?C?h@LMMd@B??\D@@An@EC\D??AZGj@@V??@c@?YI@[@\i@@B?@?@?DO`@Cj@B@f@?BC@QJn@J@i@APHb@AYc@AE?CCPm@@CYC@?MQE?AB@??@@L?TYDA?AEW^@?@HD?WNNACJ@??`@?f@LCCDP??DH?E?G??Jf@LDDo@??c@E[ZPd@E??BGCHPS?a@@[ZT?D@B?A?BQC?Z?d@_@Ca@CLC?QUTHG?@@?@@YJ?Ak@WBEc@FA@?@@@D@CDc@?^?\?H??c@A?@?VBb@?JAh@b@^WCC?@GY?A@AI?B?EC@h@ODJ??TEIh@HPg@PS@QV^EL???CNP?[X?o@HD?A?N@AGAS?I?XU??AYd@IA@?SICIPj@I?N??U??RR@?F?W_@DE??@D?I??TI?AV?@MANo@BC??OHIC?E@RNY?CJF@A?a@I@TZ?XEo@ARNh@??Na@?DF?a@L?HMe@B[HFO?c@EOFOEEF?h@FB?IAC?f@Z????X?\GZAAC??@Lk@BBL@CJ@?EAE@I?DAG]?M??A??IFIMPAE\?A?e@F@\E@WDSULj@l@?TT??i@?D_@UG?SFYVEf@Hj@Ai@CBD?H?BB]C?A@a@GEICi@A^BMg@CA?SNg@?B?UFNVAEa@C?@m@?GX?]ZGB@@??A@CLLBG??@DF??@a@@?NBB?C?@M?ACAa@?G\BABN@\@@A[Sg@A?Jj@L?Ln@H?ME?b@CV\\Bg@W?AHTAEN@WV\@AV?Cg@C@BE?R?Ci@DDPW@@F^FD?h@CN?PBR@?k@b@?F[b@SB?QIBICAETCNSE??D?IRH?T]SQE???W?QDGE\????Mk@YICA@GCJ?A?ASX?DCl@@NGD_@AAJe@P??JDb@S@Xe@?e@@VQD@EM[?n@ABB?j@?BX?C?RV???BFh@B?BB_@??D@b@L@T@Eg@NDi@??Wg@Cl@RAPEe@LB?AAR?k@If@@H?B?MAe@Z?Uk@?@@??Z^PAB`@?AP]^?G@G@AVA?Bl@A?@BIMi@?N??AJm@@FABGWA?@JDA@??ZCe@DDG?I?BA?N@??d@?`@?G\?B?ALAd@Bd@?a@ABBVe@?BAAHS?Y][EIBf@?AAEHD[Bb@?OH?h@B_@?^ISF?l@L?Dg@c@^A]i@BL???O@ZEAb@@b@DXF??IC?@D?H?N@`@J_@CX@A?BQ@HNW@???FP_@B@?D\V??C@?m@?@M?CO@L?\\@??@N???BB@JNg@AD?H??E@WP?E@VN?B@@T?Ec@GHG?RLD@@h@C]@k@DC@OCYGAY?f@?A?DF`@EUFFEUO?@OAE?IV@Se@i@?@FEB?BAZ@?@`@DQ@Ai@?m@j@CPDm@GAHIA?E@j@CCJ@BA]b@R\@Fk@D???@B?AN?TCTPYPA?AB@?NIY??Ib@_@@?D?@Ng@RVUA?@?@@m@[?DO?WL?ME@??b@AH?YWBDAd@^Al@?C?SYXAh@a@@VCBVAH@[Ad@R`@?Bj@@m@G?Q@@@V\F@JSCBa@??EEMDASJJ?Tf@I@o@?Aa@B??P@PFAMEE?g@??UN?d@G]SQDT?a@C?A?PAADBB_@?PH@?b@@X@e@CZC?Y?a@OSQX@@@B?H?@o@BTDWj@????MBEXCH??NQAE?FPQSP@@?@O?T?CW?Xl@J?EAYS@@W?AOn@QCG?_@??@d@M]HI?BHGDCSECG?`@APU[BVC?H^AGYb@?A@RPXl@HS?e@De@@??UPXBj@AWA??A?A?UDB??_@HEU[AAB@@IYZA??CWd@?[l@EQU@I?@?l@?AGTA]XR_@C?\?SC@CM@H?BVb@^H?LHn@T@MAAIN@o@A?@ZSd@B]?A?U\U??XHF@D@A?AGOZAFf@?AB@Si@?ABDBB?GS?@D?a@?@ALAMSN??SRHg@?FA_@JPBM?a@DV]C_@@AES?DU?ZF?H@Bh@@SBH@BAEWQ???[l@?PIP??DD@?AS@CAL@@YG?@_@MJ@^YAAHA@b@BOAT`@JBB?EBA?h@T_@NNJ?MIE??m@@Cf@@QJa@YB@??X@A?`@_@\JOIn@A@I?A@[AGF\?]Ad@M@_@BXA?FND?@?@[k@BGAOm@@AD?_@LEM@T@`@?AAQAN@DDD??Em@A@AFUUOEEEFBFE?FL]Zn@[?]??A@BBXCKAKBKCKDKEKFKGKHKIKJKKKLoBKKMKNKOKPKQKRKSKTKUKVKWKXKYKZK[K\K]K^K_@K`@Ka@pBMKb@Kc@Kd@Ke@Kf@qBOrBg@Kh@Ki@Kj@wBPsBRKk@Kl@Km@Kn@Ko@Kp@u@QeAq@Kr@Ks@Kt@Ku@Kv@Kw@Kx@Ky@tBc@uBz@K{@K|@K}@K~@K_AK`AgAp@_CRKq@`CaAKbAbCv@cCx@iAd@Kz@eC|@gC~@KcAKdAKeAKfAKgAu@g@xBi@KhAKiAKjAKkAKlAlCz@mC}@jAcAKmAKnAKoAKpAKqAKrAKsAKtAKuAKvAKwAKxAKyAKzAw@q@jCbAkCw@dCy@kAr@aCt@zCx@sCh@fAhAvCjA~@lAxC{@fC}@jA_AhCo@~BL}C|@nC_A~Cp@K{AK|AK}AK~AaD|AK_BK`BKaB_D}@yCmAKbB|Bn@gAcBKdBdD~@oCdAqCfAKeBlAcApCeArCeBu@fBKgB_AdAKhBKiBKjBiCL{@eAKkBKlBKmB{@hBkDjBgDdB_AnBKoBKpBlDo@_AmAeDm@}Bo@KcBhDa@mAkBKqBKrBpDdBnAiBoAp@pAsBKtBKuBKvB{Ci@yBa@{@wBKxBKyBKzBiA{BK|BK}BK~BK_Cy@`CKaCKbCKcCKdCrAtBuDvBvAuBvDa@jDgBu@eCKfCKgCy@hCKiCKjCu@kCfDo@u@lCeAk@{Bm@qAp@vAmCKnCaAfCrAoCKpCKqCbEiCcEa@pAbBwAcB_EvBlEm@gELy@lBw@rCoDjBmDa@sAhA|CkAsAj@sDjBwDxBxDzBnDoBrEo@rDa@nAsCmEdBzEm@qAcBaAtCtCj@{@uCKvCuEa@|DaC}DcC~Da@aAwCKxCxAvC|En@oEn@kEjCiEpCkAyCKzCK{CK|CK}CvEo@lA_A`DL`Ea@mAfAhF`ApEmBbFo@cFa@{Ap@`Fa@zAp@_FxCiFeBmFLxA~CtA|BzD~BhEgCwEyByDa@dEm@}EdBdFqCy@qBqDcBaFo@sEiAwCkAlFLxEpBoAcBnEa@y@_D|Ap@vFjB{AcBzFdBnFmBtFjA~@L}ALeERzBl@wAp@jFo@|FkA~Ap@~AcByFo@|AcBz@k@K`DwFdB{Fa@~FL}Aa@zAcB~Eh@fAj@cGdBw@aDKbDKcDKdDKeD_GL`GdBoFa@w@SKfDKgD~@hDpF}B{D_CeGa@jGa@yAiDKjDnG~Bz@rCyEp@cD}AqFzB_Bp@`B`DbGa@xFL`Bl@{Ea@w@k@fEn@z@aDgGcDiGeDqEpBtDLdGi@uCiAuFL_BcBqGpBdBhAtELrFn@wGm@sFa@kGfDmGkAKhD}GdBoGjDzGjBbBl@pG_CcHgDhHkAdBj@gHm@tGLaGdBz@q@KyCeF{CgF}CkHa@~GjBiHa@aHn@sGa@eBhD_HiAnHo@oHjAfGbDhGdDz@SlGgDyAzCfF|C`Ho@fHo@qHcDeHa@yGbDrHeDgBcBpHkAhBcBwHcDiBcBvHdDgBp@{HdDmHo@hBp@bB`DzHdBaIjBrG~AjHn@uGjBbIa@iBp@yHLdIo@tH{CkBcBcIo@}HeDlBcBfILlHyCKiDkBp@jIL|HdBiIdBlIa@eIo@hIdBnIa@kIa@gI|C`ILoI}CmIcB~HLmBiDsHfDdHhDmBzCuH}CqIjDpIdBxHdBrIgDjBcBtIa@vIkAjBp@xIL_IeDsI{CwIdByI|CzIa@eBlA|IhDlBp@nBlA{I}CuIa@nBhDtAkDKlDKmDKnD?oD</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??`[?GF?D??E??P@?_K?F??E??p@?gC?F??G??pD?SD?F??H??@?????I??J??PC?[WAK??L??pD?cG?M??N??PD?OgCO??A??A?????P??C??@M?KC?F??Q??@D?_G?R??A??A?????S??A??A?????P??C??pS?WC?T??U??@U?wL?V??W??PJ?sC?V??X??@A@sK?V??Y??PD??H?Z??[??`t?oG?\??]??`J?{O?\??^??`@?cP?_??`??@A?kR?a??b??pN@WG?c??d??@F????e??f??pE????g??h??pL??T?i??j??pF?GJ?R??k??`C?KnAl??k??PK?cR?m??n??pC?w]?o??p??pK?{T@o??q??@A?WU@r??A??A?????s??C??pA?Cs?t??C??P@?kf?u??v??@V??F@w??C??pB??O?x??A??A?????V??X??@o?oJ?y??z??@A?SG?y??z??`C?gG?y??{??P??sJ?Z??[??`i?OG?|??}??`??CB?~???@?pH?gN?~??@@?@L?CT?R??A@?PI?ShAl??B@?p@?Co?Z??[??pu?oG?C@?D@?PD?kF?u??E@?`G?cS@u??F@?pa?ox?G@?H@?@@?GS?I@?H@?PA?cH?J@?K@?pB?gy?J@?K@?`u?[j?L@?A??A?????w??C??pH?_O?M@?N@?@@?k`?O@?C??@B????Z??P@?p??sG?Z??Q@?p??gH?R@?[??pB?wB?~??S@?@C?SF?u??E@?PN?sS@T@?U@?pA?_T?R@?[??PG?GC?V@?[??@B????W@?X@?@M?oB?|??Y@?@??SA?Z@?A??A?????y??{??`E??K?[@?d??@D????\@?]@?@A????^@?_@?@B?__?o??_@?@?????V@?[??pB????V??`@?pD?gM?D??a@?@@?SL?b@?c@?`??SE?b@?d@?PD?[D?e@?f@?`@?SJ?\??g@?`B?c\?\??h@?pH?S]?\??i@?@I?s`?j@?j??PF?wz@k@?l@?P\??[?k@?m@?`X?SU?n@?d@?@B?KV@o@?A??A?????B??C??PY?CF?R@?p@?`??w@?R@?p@?@??_B?V??A??A?????R@?p@?`@?_B?V??j??@D?[A?A??q@?B?????V??`@?PF?oM?l??B@?@C?Co?r@?s@?PI?wmBt@?A??A?????V??X??Px?GK?V??u@?pL?_G?W@?X@?`I?gB?W@?v@?p@?[D?R??A@?`@?SfA|??Y@?@A?SA?t@?j??pA?WD?w@?A??A?????V@?[??@A????~??x@?`???J?~??y@?`N?GG?t@?j??`J?_D?z@?{@?@C?C[?V??`@?@W?GN?V??|@?`??cO?t@?}@?`N?CJ?~@?j??`@?GA?W@?X@?@K?gB??A?@A?PA?c???A?@A?P@?s@?y??}@?@@?[K?u??v??`E?GE@u??AA?pc?WA@T@?BA?@D?OY?CA?DA?`B?gc@EA?A??A?????t@?j??pI?_D?z@?FA?`??cN?GA?FA?`B?sr?GA?HA?@G?OM?r@?IA?P??C\BV??X??Pf?cJ?V??JA?pM?wL?~??A??A?????t@?j??PG?_D?z@?j??p??WE?GA?j??@B?_D?V??X??pr??K?V??X??PU?kI?t@?}@?PM?CJ?~@?A??A?????V??|@?pA?gO?T??KA?P??WH?LA?A??A?????Z??[??pD??E?W@?v@?p??[D?V??JA?`L?sL?W@?X@?PJ?gB?W@?MA?PI?WE?V??JA?@T?wL?~??j??@O?[D?C@?D@?pB?gF?C@?NA?`@?GE?w??j??p@?_H?OA?PA?@B?KY?M@?A??A?????W@?MA?`??CE?t@?j??PF?_D?|??}??`B?SB?Z??[??`g?KG?Z??QA?P@?_J?RA?SA?P@?G@?TA?UA?pD?cB@TA?A??A?????c??VA?p@????WA?]@?P?????XA?A??A?????C@?NA?@??GE?w??A??A?????u??AA?@`?SA@YA?ZA?pA?[w?[A?\A?`f?oV?]A?^A?`@?OP?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1799992810;
    let startMs = 1668014175577;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","one.nio.server.AcceptorThread","run","one.nio.server.Server","register","one.nio.net.NativeSelector","enable","epollCtl","java.lang.ClassLoader","findNative","jdk.internal.loader.NativeLibraries","find","java.util.concurrent.ConcurrentHashMap$ValuesView","iterator","java.util.concurrent.ConcurrentHashMap$ValueIterator","one.nio.server.SelectorThread","select","java.lang.String","one.nio.net.NativeSelector$2","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","handleParsedRequest","ok.dht.test.vihnin.ParallelHttpServer","handleRequest","java.lang.invoke.MethodHandleNatives","linkCallSite","linkCallSiteImpl","java.lang.invoke.CallSite","makeSite","java.lang.invoke.BootstrapMethodInvoker","invoke","java.lang.invoke.Invokers$Holder","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800ca1c00","invokeStatic","java.lang.invoke.LambdaMetafactory","metafactory","java.lang.invoke.InnerClassLambdaMetafactory","<init>","replace","java.lang.StringLatin1","java.lang.StringConcatHelper","newArray","jdk.internal.misc.Unsafe","allocateUninitializedArray","allocateUninitializedArray0","byte[]","java.lang.Thread","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.lang.Class[]","one.nio.util.Utf8","read","toAsciiString","ok.dht.test.vihnin.ServiceUtils","getHeaderValue","one.nio.http.Request","getHeader","trim","substring","newString","java.util.concurrent.AbstractExecutorService","submit","execute","addWorker","java.util.concurrent.locks.ReentrantLock","lock","java.util.concurrent.locks.ReentrantLock$Sync","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquire","java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.vihnin.ParallelHttpServer$$Lambda$156.0x0000000800d4cf48","lambda$handleRequest$2","handleForeignRequest","one.nio.http.HttpServer","getPath","java.util.concurrent.ArrayBlockingQueue","offer","RequestHandler0_handlePut","ok.dht.test.vihnin.ResponseManager","handlePut","emptyResponse","java.lang.Object[]","java.lang.invoke.LambdaForm$MH.0x0000000800d48800","java.lang.invoke.LambdaForm$DMH.0x0000000800d49000","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","sendResponse","incRequestsProcessed","java.util.concurrent.atomic.LongAdder","increment","add","java.util.concurrent.atomic.Striped64","casBase","linkMethod","linkMethodImpl","varHandleOperationLinkerMethod","java.lang.invoke.VarHandle$AccessDescriptor","java.lang.invoke.MethodType","insertParameterTypes","makeImpl","java.lang.invoke.MethodType$ConcurrentWeakInternSet","java.lang.invoke.MethodType$ConcurrentWeakInternSet$WeakEntry","createSession","no_Java_frame","java.util.Arrays","copyOfRange","one.nio.http.Response","startParsingRequestBody","getTimestamp","java.lang.String[]","getRequiredParameter","getParameter","java.lang.StringBuilder","toString","writeResponse","toBytes","one.nio.util.ByteArrayBuilder","ok.dht.test.vihnin.database.DataBaseRocksDBImpl","put","getTask","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","append","java.lang.AbstractStringBuilder","ensureCapacityInternal","copyOf","parseRequest","write","one.nio.net.Session$ArrayQueueItem","convertData","newTaskFor","java.util.concurrent.Executors","callable","getShardId","ok.dht.test.vihnin.ShardHelper","getShardByKey","java.lang.Integer","valueOf","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","ok.dht.test.vihnin.ParallelHttpServer$$Lambda$156+0x0000000800d4cf48","java.util.concurrent.SynchronousQueue","poll","java.util.concurrent.SynchronousQueue$TransferStack","transfer","java.util.concurrent.SynchronousQueue$TransferStack$SNode","tryCancel",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
