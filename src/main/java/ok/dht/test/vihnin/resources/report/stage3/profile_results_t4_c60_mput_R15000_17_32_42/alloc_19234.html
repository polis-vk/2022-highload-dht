<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BEuCALOx@lA{mA?????????A{Jh\LNVTVMVSUUTKG?@qG?W?BqapsNNMSSTTVNNKULJhxp`x??DVG?????EVKSSTULO??hilL`brzkL[`kN]^[`qD\]\[`jmN[`[`sLhrkK`rz{L`bqaipi????????DN^`{KpdM`{N`rj{Lh{Mh{MhcNLUTS^MVLTUVShxqiaaryiqiyajqxqqibyiqabyqyaayybqixyqybx{MTTU]VS^UUVUS[[S[[]US[[UT][US^US\VVS\VT\hiyryqjbicNUS^S]^VS^VS\^UT^S\^VT^U]UV]S[]`ycLV[[^S`jirjzqjjyjbcMU[^U\]]T\[\\]]U[[^[hizbcNU^^S`bcMV\]][^[[`jjjrbjzzbrjbjzcNV^S`jdL`qcM]^[`bzzjbcK`brcK[`zzjrrzjrkL\[`zbrjrkM^^`rsK\`jzcK`zrrzzcM`jzrzrcK`jkM][`cL[`zrzzzcN\\`uK]\`cL]`cM^\`sL^\`rkL`rzkN][`kM^]`jj{N^]`rzsL]^`jtL`rkM`rcL`zcN]`ryzsNV]p{M]\]K[^S\S^K`ibiqqcK`cMN]\]T\[`zjjrcNTheKxlMh{MpeMh}M`{K`mNhtNh{M`|L`lK`dN\`mL[`sN[`kL`r{L`zsK`cL`rkN`zcN]`zcN`kN\`sK`cN\^`sK\hcM`cN^pjcN^`cL`cK`cL`cN`z{M[`sM\`cKhrcK`sK`z{N[`sN\`kL`zsM`jcM`nM[`zcN`jsM`cL`zkL`zsL`cN^`kL`cN^^`sK`rkM`kM^`kK`zcL`dN^^]pzbbeN\`{L`jcN`cK`cLhrcM`zkK`kK`sK`sK`zsK`zsL`zsL`kN^`zruN\`kM[`sM`cN\`{K`kK`kN^`cN]`cM`cL`kN\`{L`jcN`{M[`kM`cL`sM[xzrkL`rdK`kK`cN`rsL`zsL`kK`kL`rsK`lM]]`kL`kK`kL`kK`cN\hrkKpkK`cM]`cL`kL`cN`zkL`cM`zkL`cM`cL`kN\`{K`zkM`sM[`lN^]`cN^`{NhcM[`{K`zkL`sK`kM`cK`{N[`cM`dN^[`kM^`sN\`kK[hkM`cL`z{L`cMhkM`kN\`?F`cG?????????z}MptNheG??DhcUpnNpmLO?kKptLanNxnKakUxfLpcSh??FKpeUavMxuG????a|Ti{SicVakVakUx}Vx}MxfMpz????DxvLxnNp}Mp|LxnNh}LasVxnNpcTi~KacUakVp}LpcL`kK`{L`cN[hkN[`{K`zkN]`{M`jsM`sM\`dN`sK`sK`sK`sL`cL`sK`sK`zlM^[[hsN`kN]`kM`cK`{K`zkN`cL`cL`sM`kM`cMhcN][hsL`cN]`kN`rsN`r{LNpsM`cN\`kKhjcN`{N[`{M`rkM`zcLhkL`sL`sM`jsM`zsN[hkN\`{M]`kM]`{L`rkM`kL`cM`kN]`zdK`cM`cN]`lL`{N^`ylK`kKhjsN^`cL`sK`kK`kM`rsL`zsN]`sN\`cN`kN\`sM`zsK`lM[hkL`kK`kN^`rkL`kL`cN`zcM`{L\`kL`kL`sM\`{M`j{K`kL`sL`zkM`dM`dN[`kK`cM`sN\`rkKhkL`cL`cN]`sL`z{N\`zsK`kN`z{KW?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????GuImMiOqPbPhNoOxN}QuNgPnNcQuPbRuIhL}RbSmSlSzRuSxStScKcJyQwS}J{NrRcM}MqLnMtK_NgOwPoRiJnJqJsJbKjKrLyLpMuMxMaNbNfNoNvN`OsO`PaQhQ{QpRvR{RnScTzI|IaJdJfJhJkJlJmJoJpJrJuJvJxJyJ|J~J`KaKdKfKgK{K`LfLiLkLlLmLnLpLsLtLwLxL|L}L~L_M`MbMeMfMgMiMjMkMlMqMrMsMwMzM{M|M`NdNeNgNiNkNlNqNrNtNyN|N~N_OaObOdOfOlOnOpOrOtOuOwOxOyO|O~OaPcPePfPhPiPkPoPrPvPyPzP{P|P}P_Q`QbQdQfQgQiQjQlQnQoQpQrQsQtQvQwQzQ~Q`RaRcReRgRhRiRkRlRmRnRqRsRuRwRxR|R~R_S`SaScSeSfSgSiSjSoSpSqSrSsSvSyS{S|S}S~S_TaTbTdTvIwIxIyI{I}I~I_J`JbJeJgJjJtJwJzJ{J_KeKhKiKkKlKmKnKoKpKqKrKsKuKvKwKxKyKzK|K}K~K_LaLbLcLdLeLgLjLoLuLvLzL{LaMdMhMoMtMvMyM~McNjNmNpNsNwNzN}NcOeOhOjOkOmOqOvOzO{O}O_PdPjPlPmPnPpPsPtPxP~PeQkQmQqQuQxQ|Q_RdRfRjRtRyRdShSkSzS`TeTfTgThTiTjTpbRMMMXXMMXMWWMMMNNWXM[XWWMWkBW`@XM?[???`@???X??M?M???`@MvB???[M???X???M[???C???C???C[???C??Mt@?c@???C?W??C???C???C??MW????CM???C?M??CG???C?W?C???C???CI?[?`@M????C???CM?W??MGM????C???C@???C??N?IMCMt@NN?G?GGM?@W???C??C??C?[xB???C?WG??\?E??C??C?E\??@M???C??C?@@M?GE??C??C??C??C??C??CvC??C?My@???C??y@?XDD?@??C??CM??C??C\?C?MWG??C??C?@@?MX?D?|C??C??C??C?WHM??C??C@I??C??CM?CB??C?MH?@?C??CM??C??C@\?C??C?AEHM??C??C??C??C?@?W??C??C?@IB???C??C??C?B@??WIGIGNN??GGNGGD@??C?X?C???C??\??EMH??M?K?\D@?K{@?C?@?C???C?@@AM??C?@M????C?KM????C@?{@?@@?c@??@M??@WB??EBY??C?JM?@??C???CHYHM???CAIMEFF???C???C???C??Y????C?G@@MY?@@??H@?M?C?L?CF??C?M?C??F??@pD??E?C?@Y?@?GH@???CYYW????CzD??C?D@LA?WLG???CB??C?}D?C???C?H?CY@?C???CM??C@?JEG?ML??@?C?@@H??DM?E?C?N?C???C?ANDIIBGNNGGND@JD???C??AE????C?HA??C??@?BJ?G?M????CB???C?E??C???C???CB??H?@??@AJ??@?sD????C???CM?J@??M?CNEAL@AB???C?@?C???C??F@??E?F@??@??C???C??G?@??C?@?E?DF???C?D??C???C@???C??AED????C?@??C???C?@B@??E@?dE??A?C?K??C@??C?E??C?ED??C???C???C?I@?E??F?C???C@I@??C???C?E??CE???C@?A?B?A??C???CLW??FA??N????C?I?A??D@??C???CM@D?C??DA?c@?F?B?BJ?C]??CS@?NND?ICGGGNDGG@??C???C???CB??@A?B@???C???CF???CJ???C?B??C@??AF???A?F???CEDG???CE?J??CF?H??C???C?@??CKK?D?HF????C???CGL???CA???CE?A??C?B@?L?B???CK???CA??EDH??L?O??KB??C???C??FK??F?G@??B??CK??BH??JJ??C?LK??C???C??AB?I?B??CE??FK????C?B?G@A??@??C?@??C???C??HBE?A??BI????C???C@KB??E?DIJ??CA???C?K??CO@?@?LLNF??C???C???C@K@K?@??D??C???C?AI??C@??@?H??IB???DA??B??CD??B?ID?D?C?GK??C?F?NN?ICGGDNDDGGAC?C??S?F???CAI?B??CX??CBJ?A??C?A??CHJ???CF??JDH???FA@??KD?@??AL??CF???CGD??F@???KF?H???CA??I?G??LB?F?K?G?@O?B?E??JKDG?E?B??CD??G?E?B??CIA???C???CJ@?A??CF???CB??@H?I@??D?E??I?GG??@@H??E??CFB???CA?BI??C???CB???CEJ@???C???C@??@AKA?B???C?D??CB@?A??CF?BA??C??BII???FK?D???C??@@?FKL???C??J?@DA??B?F??H@???B?@LA??L?B@?E??CJ?FE??C???CA?B??CJ?J??C???C@LE??F?@@?W?C???CA@AA?F??C??H@?B??KH?F?B?@?H??I?@??IG@GDDDDNMNP?L??C??D@DIK????C?@??CFL?B??C???CHK?@@@D??C@??AH?GB???CBG???C?FE?@J?A?M?C?J??CLJK?I??CB?P@A?LGH?ED??C??E?BL??G?@L???C?D@J??C@??A?HF?G?@J?F?@I??@L?D??CJF???CH???CFK?D??CG???C@J@?K??C?D?@@DJ?@???CGB??AD?@?K??CD???CD?@?KIH??B??CH??IG?@B?AB??CA??FB?@B???CH???CAL?I@??C???C@?F@JF??C??J@B?A@???CBALX??CF???CIE?K??C?F??C@?AE@??CK??G?@?Hf@AJDF??E@??C??A?DBD?@??C???CHD?AD??CB???CGD?@?E?D@A???CB??JH@?D@???C???CBG?K?D@?B??@I?J?F??C@AG?N?CEF??NNGGGGPPGGGG@@???C?IYF@@E???@?H]?I?FLB??GA?@@F@?E??CE??F@?@D???C?A@??CF?@I?@L?L?F??CBJF?D??C@?K?HE??L??CIA??G@?A@?JK??CDE??@L?G@???CEK?K??CI???C@E@?BB??CA@???CJDJK?M?CD?H??CAD??E?B?D@?ED?AIL??F?KAJ???CK?I?@L?@???CED?D?H?B@?@??CDBGA???CD@??F?@@??B?AJ???CL?IK@B??CE@?@??C@@??@L??G??CE@?A?@?EA?J??CA@J??E?B@A???@EH?G??C@??F?@?B@@??CFD??JD?@@J@???CB???C@I@???CG?KB??CB@?@?@?LB?K@?C?DB???CB?D@]?CH?A??CJ??AHG@F?F?L??C??@DLE?KE???C@?J??CI?JB??CBI?KF?G?A?KO?C@G@?O?CI?D?AD?D???CEG@D??NPILGGNGPGGG@@???C?J@BA??C??@@LH~@@A@?AA??C?A?AH?@?H??CH?F?@EA@??GAH?B?EMB??CLE?@N?CH?A@AI??C?H@J??C@?@E??CK?B??C?HLDJ?ALB?I???CKHD??J?@?BEA?@?DE??M?@AGJD??M?I?J?F@?D?@?@?D@KD??H?H@A?@?KF??IB[?C?AF?@J?L@?F@B??C@A??A?H@???C@?I@B?BAD@???@F?HFDB???C?F?@L?A?@F?G?@@K?I?@JL?@???CJA@?K??C?BI?G?@G@JE?@??C??K@?HDD???C?FHBGI?B?A?@?B?EI@DF???C?F?ILE?@?A?@?EG?E?BADA?@??@L?B?@?BK??GAB??C@D?D?D?AA?GL??CK?GA??CK@?@??CFF?E?BA?GLB?G??C???CEDIJ@?@??C?AHB@?G?AI???CFJ?L@??CK?K?D?H@JE@?G??CB??J?@@D??E?L?A@DA?JD??A??CIE@G???CI?@DKONDIG@GDDDNPP?H??K??AIA@??CF?LB?KLJFF?B???C@G?LL??CH?GABB?GDA??G??CB?IF??CJ?IKE@F?B?KJ??F?AB??G?EA@A?@H?HLK?J?H??C?EE@A??CA?AF??CBAF?AI??C?AD?@A?B@B?@?D??AHALD??CB??B?@EEG?L??C@@?@J?@HIN@??B?DID@J???CE?I@JBD??C?AE?E?DGB??F@X@@@??AAH?E???CIBGH?E?@?AH?BIDL??C@??A?B@@?@E??CFK?KB??LFE@?@??CF?@B??DC@J?AA@?H?A@?I??C?L@G?@?LB?@HE?O?JJ?@??CAD?BD??CH@?I@?HD?@B??BEE?H??@A?LF@?A?J?F@?FBK??C?AH?L\F@@?JD?BQ?@E?JDD@?E??BFA?IG?KFX?C?GAEK??CE?FL@??CKD??KASD?HHF??C?BKH?AI?@BD???C?@FDDI??C?@?EADDH?AL??O?E@?@@??CJ?@DFE?I?@BH???CF?DF??CJF?AH?KBJ?@B??E?BBA???CF?@FKD@?NPIKGPNG?DGDGIH?R?C?DD@@?JB@J??K@H?KG???@?@FALEB~@JE??C@?HJ?ADW@??JEGSGF@JAL???CD?IAJ@?R??E?BIGDAA@PP??C@J?EAEM?CA@?K@F??CHJ?I?A?DD?@K@E?I?DRH?K@IH?B??LF?@B@L???CHH?BF?I?@D@?KA?G?BARAJ?E?@D?FEV@?E@?LJ@??CK?G?@GGAH?@?@F??CFRL?@E@?B?@FGMD?A?JEBAI??C??HJ?BBHQ@@??CA@G?@@E??C@??A?@E@FG@???CB?IAB@I??CF?F?A?BDEH?@AK??CLRA?I?JG@?@?FKJFLE??O?CFLFB@???CI?@FDEPD?A?J@?KI?E?L?AA@?FILR??CD@A@?L@??C?@L??CLAHAD??GGATQ@BB@??CJA?@?@@?EA?L@??CJ?DHA?@E?@J?F@?Q?@BXF?@?HI?JLHTDKD@????C@@@BDF???CQ@EA?KAD?B?F?LVBFGGB???CDL??AJFA?H@R@D??CK@?JB??CAF?@?A?BHFFQE?@K?J@?I?LF?EF?BAG??CD@?@?I?@?KJBD?HF?B?@?NI@GDPNGGGPG@F@P??C?JD@@@EDTA??H?G@LAH?KJF@?B??CBIAO??C?FJF@I@A?E?@??DA?A@BH?@I??CBO@FEI?Q?J??FDH@BF@??DIOH?I@E?@?K?IKE?KIHA??C?A@L?@?A@E?A?B@I?OKH?LF@?FDF?F??CDJ@?D@?J?BJL?@K??CE@?J?JHIG?@DO@??CF?DEAKD?H?B@?@??CBD?IAD?EO@OBGD@E??CD?@?BT?KEEJED???C@?@JIFD?D?A??IB@DDE?AO@??C@@@A?JF??C?G@BB?@A?DB??FB?I@@@O@?BB?J?GI??CEH?BGL@??CAAOG?@?JE@EH?I??CF@?@HE??CAI?ABIA??CDOG?GA?B@G@??J@E?D?BG??CADI?DE??CLE?BG?DJBA?QE?GD@?KGK@??K?@D?@LIFB?H?B?G??CFEOAID?BH?E@?BD?KI?A??GGB?BLGBF???CB@DOEA@??CB?E@?@A?J?HJ?DBBAL?A???CDLIH@FLO??CA?@@??CFIK?L@?KHK?GEOL?I?D@?AB?KE?GF?FKK??C?DE@?BI@?IAOE?L@S@I?I@?H?BJE@?AD??COH@J?@@?@JB?E?NIEPDGNGPGGG@B?V@??DJDAHD@A??C??JA@JEAF?KK??B?@AKD@@Q?L@??EGK@K??CAA?B?L@@K?FAQD?H?@FF?FAA??CLL?EJ??CBD@?@E?@E?LF?FJB??CEB@R@?JBE?FE?BJ??CB@?EA?LF?AAHAF???CLARKFJ@??CH?FHA?G?ALG?@?EF?FLB???CBBILR@KK??CLG?GE?LE@@??@F?LFH?FK?GB?H?A@IQI@@??C?LGBE?J?HGLD??@B?J@A@?F?@?GHAR@@??DCGK@?@F??CHH?AGJ@??CEF?H??CHAAIBFQJ??CF?H@IAB?H?@H??BKH?@GQ@LK??CALJ??HG@@??EAG?E@?ADD?RK@?GEB?KF@??CDB?AJJ?D@?EQ?KA?@J@HDK??BA??LIJ?@BLL?E??IDFB?DGD???CIK@FQD@I?AE??HG?AD?EBEDF??HH?JJ??A@@EQB@K??AEI@Q@@??G?@@DB?DJ@H?R??KI??CFKHIFHQ?KLL??DH??CH@IBAA??BAF?BQ?BK@DE?@?BGB?]?LF?A?GB@?LFJ?E?B@E?RE@G??CHIAA?I??CBB?HF?@HB@?I@?E??CEDH@?KA??CD@QHA@??C@K?A@?LKE?A?@?NGGFDDDDDNPP?@@?DK??C?GA@IJF?KA???HB@KB?KLD??FH?KABA?GF??CB?H@?@D?J@@IA?@??CA@?AG@@D??C@@?JH?G?@@KG??J?CE@D@?F?H?KK?A@JD@D??CL?GBJ??CKG?K@?A@YJDAKL?E?F??EEL?DA@?@GA?A?D?AL?EIBIA??CL@I?F??CBKBHD???C@@JJ?@AK??C?D@L?AHJE@T@???CBBDJHKQJ?IFG?I?BLAS?C@?@LL?B@AD??A@?@?DJF?B?AJHE?@@?LK??CBG?G?E@?FABHB?@?HFH??H?IGFKODFG?DL??C@KGK@???C@K?@L@?D?IADA?E?BLE?FK?D??CLLLD?HAH?@?J?HF?KA?BJH?J?@E?GF?AELKE??CAD?K?LE?E@?A@?KAHB?E???LCIHD@D?@?BE@??DFG?@?JB?B@AF@?F??KLHA?GB?IAK??F@B??@JFAF?D??@A@I?@H@J?B?F??CJIBK@A??@?ADQKEJG??CE@?H?GBHEL?@?H?EBA?BAK@??AL?GA@?I??CED@?IH@?G??DJH@J?@AB??G@?GBG?EHB?H?FB?HE?HA?HI?BE@F???CBJ@F?@B@?A?F?BJ?@?JLJB?@A?A@?D@?E?KHD?GA?LIE?IGBNGPGNGPGBGKL?G?@KA?@?BJ??CKAFF?@@@?FEA??D?I@@I?BFBAI???C@E?LD?@A@A?H?@?@A?@IEAH??JEGK??@IAL??C@?B?AFD@@?@H?JD??CJD?J@I??CDE@?LAA?KF?K?BK?A?GAADGB??JHE??@F@?BE@?J@A??FB?BGG??G?BKIDL?EBBJ??C@?@?BH@?FKJ@?J?@@??@IDF?@?LAEDEF?B??C@?GHJ??CEAF?@?EJ@??EFEJ?B@?EF??G@B@H?I?@BYH@?K@?@@??CEK?H@?EJT@E@?@GKHJ??C?EDL?K?LB??BKEEEK?KK?JD@L??CALK??@AJ?A?IIEL??CBAEIL???CA?@DEAKG??CDI??Q?BK?BAL@FA?G@??BI?HG@@?@@E?@?O?BEJA?@??CJEHJFI?K??CB?LAEJ??CHJ?EKRL?F?@EIG@?LF?GE?@?LGHD?J?@??CKKKKK??K?AGHABI?@??CLKFE?@??CH?IIIKB?LF?D?AAAA?AE?J?EIK?A?H@@J??EAF@??DDFF?@LH?FD??@AO@GJE?@?DD?@A?EAI@I?B@??E?GBA?FLL??@?J@?EH@GKH??C@?@A?L?D@I?BA@H?LB??I@?KA@?BDBH@?H??C@?A@K@F??CBHB?@?NDP@IDPN?DADGGFJQD?E??@EFJBB?D?EA@F??BBI?AFBKJ??E?FD?K@?A@FI?HJ???CFEFB@FIJ???C?GD@G@?EHB?@?H??CB@EKKG?FA??CG?BEG@?IB?J?GE?A?H@FFAJ??D?BAG?BI?EAD?ID?LGK??C@@JF?A??CFF?B@@K?@?HA?DG?G?@@DD@H??IHK?G?LA??CI@K@A?FA??FCA?BDG??CLJDD?D??CI@EJK?@A?B?K@?@??CAJA@A?JDK??CH?HAK?D@L?AG?B?AGL?ED@?@@??CHB?@@FB??CJGF?K@??AKD?BE@K?@?@G?@ED??CD@D?@HH??C@@?HFE??C@BD?F@??CIEF@B?FG?@?H@?@@?B?KA@?FDL??CBD?KH@@??CBA@I??S?AJ?GKGDE?B?BKG???CHAEHGF?GD??CG@?DBB?KB?GBE?K?A?DID@?ARKFHK??@BKH??CELF?EG@??CKF?G?EDABH?E?@?JD?ABGF?B@B??CBE??HB@JE@??I@@??CA@GKA?B??C@A?@J?EAF@F??D@H??CLK@HD???CJFE?IE?HF?@B?HJD??CKHF?@??CBJEHD?II?AJF?BE?@E??CJHKB?KK??CELIL?@E??CI?@GI@@??C@GK?B??CK@@D@??GE?K@@?IAL?@OH?@IIA??CDJFKMF??CAIA@F?@LCN?PPCGGGGG?GGDH@FG???C@L?K@?GAAADBT?@?@PJAHJ?AJ??C@GK?@J@?I?@G@@?F?AF?IDA?DAL??C@AJV?@HE?@KI?G@?L?D@L?FD@??CEJOGK?K@?IK@A?JJG??CKG?GA??CJFHH?@D?A?IDM@AFF?JQ@@?@LI??CGBJ?AL??CAKJI?@KAI??CA?EKAD??CBAATK??CAAG@?@A?A?H@G?HGK?@?IHFJ?AK@??CIOEADJ??C@A?K?DA@?DL?DE@??CIBEF?EA??C@G@TBJKD?D?A?F@J?@?HADDK??P?DK@OE@J?@J?IH@?HB?D?@AA?JB@?D?DFE?BH?J?@?FD@@E?DA?I?IFI??CBGFEVI??CGDB?BGAG??CIB?LEH?IL?DITGL?BL?AKB@?A?H?EEE?BAA??CJ@OEI@?D?JEBJ?HKJ??CBB?@?J?DHH@@TK@D??CD?BFG@??C@BI?E?K@?LH?F@BBB??CAHOJB??CLDJ?AI@?F?K@?FBAD@??CI?BD??CEEIIHOG?B?AK?A@AHB??CEF?IL?LG?K@?AGEG??CF@V@JI??CFFLI?HK?O?@EFA??@?FHLD?ABDJ??C?ELEJKH?E?@BT@G??CDL@D?@@B??C@G?@G?F@?@EL?D??CEGG@@?@B??C@B@?I@G??C@ITEDJ?J@H?B?H??CBJBDE?@@K??CF?G@@G@??IGLCGNDPGGNG@@JU@IL??C?E@AHA?EJ?J?@@?EEBI?@G@??@?J@BJK??IJB@?B?@GAA??CAL@?K@??C@@?JHIE??C@D?AFI?D?KEG?AG??CG@HA?@@K?H?@?B@AF?@L?L?IA?F?D@EG@I??@FL?@@L?I?@F?E@AB???C@D@G?KH@G??CAD?@F?H?E@AF?J?F?@FFB?@D@?B?JE?G@@??CJ@G?F@??CGE@E?LAF?KOGL?DE?A?IAB?@@BJ?@?FF?HHD??CHGA?FF??CAHD?JBH@?J?DA?JH?EOEBB@@?@?@JTF@?DGHK??CA@E?@I??C@L?@@D??C@@@G?GB??C@A?FA@E??C@K?BF@H?B?K@?A??CI@EGKD@??@?H?DI@DGGF??C?IB?@@?LAFJ@?@??CGG?J@HLF??CJ?LB?D?BDKE@?DB??C@HFF?DI?L?BG?AA@E?F?EE?D?G@?B@D@DK???CIK?EBAH??C@J@I??JLB@H??GACEFAE?BG?@f@F?@KB?LIGID??CI?IEA??CBGB?KFA??CKIF?FD?@?@FHEH??F@?HDK?DG?L?@K@G?G?D@?AH@E?B@??CJFF?AI?HDB??K@FG??C@KFK???CAAKGB?@GB??CD?FBB?FB?I@@J?@??CKBI?@KDI?D?A?@@@?@E?FAH?BE??CDADE?AK?B?IA?IF?@E?A@H?HDF?GIPGNNDGGGP@A?K@??C@?BGIDEF?U?DG@I??@BJ@?I@?AOD@I?H@GI???CKFGL?EF?GU@@I?A@@F??C@B?@@??CJIHD?LDAU?CD?D@BFU@A?FA?H?A@?F@LL?AF@??CBJUDFG?@@?HB?HE?AHH??G@@EE??CE@E??A?DF@BAKVG?L?B@?IAL@@??C@B?IA??CHGHF@?B??CIIEU@EA@?I?B?BA?JDF?E@A?B?FF?ALG?@FI??CIDB@?K?Q@J@KVFE@F??C@D?I@?F@DG@??B?ADRK@@GF?J??CJLA?K@@H??CB?FE?UKKHHGL??G@A@?JG?GF??CG@EFB?HUB?@KBH?B??CGI@J?LK?@KH?KVDAA?@?JD@?HAL??CI@DE?@A??CHV@LJ?IFIB?G?@F?ABA?DA?JA??CFFHE@?G?K?F@?@EEDB??CF?BJ@?G?A@@E?@@I??C@UFFG@?B?EBK?FF?EBQFHG?DI??C@DA?IA??CHGVDAFIH?@?@HE?I??CGJFJ?HGE?@?JK?KBD??CAL@OAD@S?CG?GG?GKLILD?A?@H??C@DKFK?@??@AVAHB@?@FAL??B@??CAJLA?@@@??CG?@B@BEB?@?LBV?F?K@EJAHF?IR?CH?IB@A@A??C@@V?E?BDLD@A?GF??C@?IJFDG??CLKA??B@FLUJ@EF???CHBD@?@I@??CGA@?UNDPPMGGGDNGG@@B???CAG?F@K@J@?AB?G?HLB?G@?HAHH???LCDAJA?F@?BA@??@@KI??CHGL@??O?@@EH?JLLF??C?E@@?LAJJHK??B??CBAJ@BI?ET?CI?@EAHEF??CKI@??K?KHLIB?@@?FBG?F?ILA@??CJL@B??@@?LBH?B?GGKBD?A?AB??CBIKH@?B?F?D@?A@@?A@?FJL?LB??CEADM?A@@??CK?@@H@?GTBILD??@WJAJD@A?K?Q?LGB?G?EB@?FB?HGK??CKEG@?@?HOB@JB?@ADB??C?@IAAB??CADD?@?@GHE?@?EIA??CF@A@?L?J?BI@A?AE?A?DEH?JAK?O?GJ@K?@?G?@@AF?ED?ELD??LEA@??CDA?@J@?B?BJ@H?@E??CKBI?BAA?IH?BB?@L??CBDLF?@D?@?LL?F@BB@??CB?IDI?FQBBB@F?B??CH@?BGK@EN?CL@A??B@K?@D@?@E?A?F@@IA?K??C@E?DGDEGB??C?@?DLIB?AFEA??ED?FBIB?GKA??CE@@??@G?@EH@?@?ADA?@G@J?F??CG@?D@DQ@JI?F?JD?D@?EKEJ?KEA??CEDB?FJ??CID?@DDA?@@?H?KE??CBFF@FD@?@??CB?ADH?BKJ?ED?B@@??C@J?D@D??C@@A@?K?IG?DG?KD@GE??C@B?B??CIHGHFB?D??C@?JAE@?PDGBIDDNPGNGK@D??@EAH??GBH@?@D?JHAD?DTJ@@?@I?@?EE?BB@A?IA?T?K?JIBBDQDG@?TFPJB?ADKHBEB???CB?IAIHJA??C@H??@B@?KI?I@JBB?T?@?K@G?I?EKDK@T?D@?@LAA?BI?E?F@E?BA@?@?LG?GDE?E?DAABU@@??CBL@F?H??CDBK?F@G??CG@FI?EB?ED?B?JDFDM?C@KAB?VE@I?DHDE?K??CAIE?B@B@?Q?B@?I@?D?@FB?KHI@@TL?@?I@?@?JLEDAL???CK@JV@DG?HB?@JH?AE?J?FB@?D@??CHEJ?GDDA?AL?H?J@J?B?BAETKBA??CBF?LAA?F?BE@G@?@@??C@@A?A?FA?H@E?G??C@EKLB@?G?T?BJ?FBKLB@??CBV@?A?@HHDI?@@I??CF?I@A@D??AE@??G?KA??ALBB@E?V?B@?E?BLB?F@KT@??CDIEH??LG@ADBB??AI??C@HEJJJT??CGE?@B@A@?L?K?@AOI?L@DLAT?BEAI?D?HF?@@JH?KG@???C@@LLBETG@??CEE?JLD@?S?AG?F@??CAF@L?A@F?D?@?B@GD?AQBDGTKB??CFGF@A??A?BD@FK?@G?@A?@G?A@K??CBFLTL@??CGAAI?@D??CHF?H@LI@@??C?LK?@?KEJJEF?BT?CFGD?A@JEB??C?D?AE@ID?ABG?E?NNP?CGGGG?GGDGBHDE?D??CH?BL?@GI@KUEHK??BA?J@?BD??CK@AD?LIF??C?@DKA?@IKH?A?E?E?E@L@@LUJOG?A@F?KJ@?KE?@@BJ??K?GD@DUIG?@AE?@B?B@??C@KEA?E@I??C@?LLIJ??CJ@LB??H@D@?J?@KKJ??CBJLO@@J??CAA?DB@??CH@@?JL?@J?IEVEI@?F?B@A?BD?L?BHJB?GJA??C@BUE@?AAQH@I?KHE??CBG?HHB?D?F@DAEOA?K?L@?@JJDE??CK?BLL?JD?JG@@???CAGDKF?KFK??CVKK@D@@QF?KA?@??CHBBG@B?A??CIBJ?I@?BQ@AIDKUB?H?AJB?@@EF??C@@?AGH?@@?LFKO@DB?Y?J@?LLD??C@@E?B@H??CFHHVI@@?K?LH?IFB??CEH@D?Lf@@?JBL?DHFE??CJL?@EB?E?BL@?KJ?BKG?EBOF@??C@BIDE?FA??C@F?K@AJ??C@AB?@?A?CFKFVI@A??CJ@F?H@?@KQF@?GE?I?GDBHBH?L??CK@OILGSAI?B@BL?@??CIBDJ?G@D??CAA?@J?H?HKHDVBJ??CFJH?E@BJB??C?JJE??C@@EGK?K?B@A?@?@HF@??CEDLAGU?Q?IB@?EID?IH?G?@GA??CBAIJFUF?@BE?D?@IE@??CED?G@B?F?AAIOILF?A?JD?EAD??C@E@?IFA?GPGLGPNNG?GGG@@?IK@G??C?KLA?HDAA?AH?B?GBA??ADEAIL??C@J???B@KFA@F?B@??CEBA?E?I?AFB@G?I@??CKHH?EED?@?DLDH?L?D?HAG?DBBH?F?A@?@F??C@HLGA?@?G@@?B?BEBFT?C@BH??B?IGJDD?EG?EBG??DJB@?AJ?BIB?L??CBD@F?@J?D?@A?D@LEU?@CELF?AI?I?@GBJA?B??CAA@?HJA@??CI?EF@A??CDK?@H?A@L?AFA?L?F?DDIAE?B?FB?JAB?IJ??C@AJF?J??CH@FF?@GH?G?AL?JEL??CL@HB?BG??CBL@?KI@??CDA?II@@F??CD?@G??CGLA@E@?G??CIAJ?@BGKL??C?DE?EL?B@BBE??L@@?B@?B@?B?GBIL?I?EB?BB?DGIB??CIII?JBA?EJ?F?K?IFGGG??L@@??CFB@I?@EL??C@F?KI?@A?@?EFI?F@@GD?A@???CDFH@?K?@FGD?LD?GI??CK@@?A@F?AEL??E?JJVHG@JD@L??A?LB?@@@@?@DL?I?D?@?GHIB@F?G?LB?@?G@??CGAJLI@E???CDI?AE?@HEG?@HK??@LF?DB@?E@?G?BAF?KL?KF@L?F?@E?V?EJB?E@L??CIED?@LD??CJDG?@AI?V?AJ?IA@@??C@DK???CKGIED@F??@JK??FEFIF?KAL??KJ?N?ICNP?GGGDDDG@A?@?J?G?@DJ@DF?@?@B?F??C@@AEA@??HFI?I?@GE?GBI?B@@??@I@?FFB?G?D?GF@EA?@A?JH?DK?LF?@?G@AB@?BGA??CH@?H?A?DD@H?@I@?I?L@?@@G??CBIB?D??CFDL@?HA@B??CL@?B@??CAHADA?K??CKDL?EFBB?@A??B@?AEE?EFG?J??CDBBBI?BCEJB?H?AEBG?B?HE?IE??CBGBAH?LJ??C@?@@A@?AE?@D?K??CIDAHDF?G?F@?@@?B?JB?GE@J?@B??CI?@EAD@??CEDEG?@?@AI?HG?@@??C@@D?@K??C@F?FFFBB??C@@?EFL??CBFA?AJ??C@I@L?AJ?Y?@EA?JB?GFA?KG?@A@??JCJJ?J??CBDF?@DBKA??CEI?FHOGB?@B?GA?EB?B?E?JH@BE@?@F???CK@DLGJIJ?Y?CB?BB?BLF?K?LFA??C@DAI?K??@C@DHA?L@A??C?IHBF?F@?@D@?G?@?AEJ@GL@??BA??@@JFQB@I@?L@??H@@?F@@??BALAJ??GE@?LF?AB?G?FBRJGED?BD@??C@F?D@A?H?ABE?@?J@BA?@BLLU??CEBE?AF?IA?G?@AA@?AJ?B@?@?@A?I@?@@H??CE@FEFB???C@H@?@?BBK?IHD?FD??CALGE?@AD?H?BK?L@?@G?DDB@?@@?NII@GNPP?GGDGHEBFPE??C?B@AHJBB??CKF??@A@?FEA?BD?aA@?BKKF?A@??CAA?@FD@?EJ?GE?EF?@@?HF?E?G@A?I@@?AD??C@EF?EAS@?@DE?LG@??KA@?AE@?BAL?@KA??@?EG@GF?EA??CDB?DKAI??CH@?@B?E?AGH@D?G?H@H?AI@?GJ??CBF@??KEG?K@B?HE@?I?FF?BDA??CDD@D??FEB?K@LBB?F??C@@HE??@A?@@BL?G@@?KE?@G???CKBKHEF@??EJ??@BGLBEZ?CD?@@A?KI?FL@I?B@??CBGK?KH??C@@@?K@?@A?K@?HJ@G??C@?L@DJ??CAAG?LB?EJ?D?ADEA@??CFI?KB?LFI?KK?H@?IL?LD@?@J??CHKGB?@@J??CL@E?KK??LJ?FEE?@A?SEF@@F?E@?@EEB??F?CB@?E?B@?JE@@AF?EB??CL?@I@B?@?@HA?EJB??CGH?@KEL??CG@?KGL?J?HL?DD@?@aAELHI?GB??CIIA?AE?L?@@@FE?JL??CALK?LL@??CBAH?A?ID?BHH?E@JD??CHE?GBG?D?@@?FEA??CGJA?@I?B@?IEA?@FI?K?GD?JHG??ECGJ@?A?O?@I?BBLFE?@EJ?B@??I?@@@E@F?KD??CJ?ABAQEJ?IE?ADLG?E?@I?D@B??C@A?FI@E??C@H?DIAE??C@F?BKG?NIPFGGPGNGGG@AA@G???C?@FEBJ@IF??C??K@DHH?DLDA?LE??C@?KEKD??CBGG@??KAI?HI?@DG?E@@?D@?A?U?AHABA?EB??CD@?F@HK??CBDKB?@??CHL@@?AF??CEBDA?BH??CHGA@?F?@LB?K?JBAB?@?EDEJI???CK@EF?L@JA??CJ?BA??CGKA@F?G?JBJB??@?@KH?IKHHD??E?GBBAJD??I@DB??@F?FI?@GAI??BG?KHII?@@VEH@@??ELF??CBJF?JABF??CL?K@@A??CJJ?JE@?@?JG@?@LFU?CA?@G?ID@A?AKLA?@?Q?DGG?L?EJ?AH?@@EDL??CAE?BH?IL?@FF@?HAB??CGA?IO?CEJH@?D@?@A@D?@?FB?ADJ?EF?@?DK?DA@GJ?LB??CH@JG??D?EALKFF??JH?G@LE?B??C@GF@?EE@?GB??ELG?@AIH??D?JB?@@@GL??EJ?A?@GL?EJH@?L?J?FD@?ELF?EG@B??CBD?@A?B@?IDBF???CGIJ?EDLJ@??CK?JA?I?ABEDH?EL?D?A@F?@@?FGBL?@A?L??C@@JEK?B@O?CB@?@@@IE?K?I@?F?I?DGFA@L??D?@@JB?@K?JIDK??B@?D?FGALEK?@?G?BHI?FJ?B@K?EE?D??CDGBL?B?@KJK?I@?LA?@AJ?DH?@QH?B@EAE?@D?N?HEB?KK?N?IGCDDPDDNDDJI?AKBB??C?@@F@?EH?KAF@??@KBI?FLB??KD?BGF?@DB?J?GB?@?KDA@LA?EA??HK?@KG?E@??CLK?AEHBDBJ??C?DB??CJDKEK@?F?@?@FE?J@K??CB@L?IF@?D?@I?LKHQ?GJG?@D?IK@LB??GEAE?A@?LLBD?L??CDGL?J?DEDA?H@E?GA?FB?@H?B??C@EGB?I@??CL@B?GGGJDFB??C?@?ERBI@@@KHD??I?B?@BBKA?JF@??G??CKDEAFK@???CL@@?EBIB?D?AAE?@RBGBGL??KI?I?DFIHF@?E??C@@?DHKJIA??CL?@B??C@BBJLFF??JBI?AJ??@@AHL?K?J?GB?A@@FBF??D?LE?@@AGB?GA??BHK??CH@HF?FD?F@@?AG?AL?L?F@DL?AHA?JF??BKBAH??CBLI?@@??CDH?@KIK?GB?GB@?A?@?@FH?GFIB?B?BJF?G?B?@@@J@?K?G?@?A@FL@?@J?KG?@DA?D?BEEB?FD??CDB?AIKH?@F?J?DIF@??CGFG@??KA?AJHG?JR?CF@F?E@HG@??CFBJ?A??CG@EB?H?LI?K@JK?@?A?LIH?DBFI??CGA?@FG@?DK@??@H?IBF?BLE?AI?G?EJIH?K@?I?DG?KL@A@??CJK?IG??CIFG@?E@@??CEFA?@D?DD@?D?LFEA??C@EF??AA?DGBB@?@L?N?IGCGDPP?GGDD@L??A?]@BFIDAJL?LD?PG?HGBE@@?BD?GGQ?CIBH?@@@?@?FD@I?F??CLBLD?EDI?J?F?@AD?@A?IHBKS?@L?LEAGB?FA?R?J?H@LA??CJ@AGSIJL??CL@D?A?AERBF@?@DJ?@?JFEO@IA?F@Q@@?IATD?@EAB?JH??CIIL?HJD??CLSHIJBF?E?BIJ?AR@?AGEFD?LIJ?H?@AK?L?EK?BAFSHA??CEH@?GFG?GLRA?E@@J?GG?AI@O?FE?KFJ?E@EG?@@TD?@AE??CLEGA?@@I??CBK?D?HL@F@SD?EH?B?BGA@RJJ?I?K@B@?L@?DOAL?JEIG??CB@UE@K?BEK??DGIF?K@K?JE???C@ELAA@SGB??CFI?ELJA?R?HED?DD?A?C@@BS@K??CGK@?@AEHR?CE@?KGH?S?@JEK??LB@?L@GSLB?JB?KE?FGJJ?R?LHBF??A?LDH@SGEB?@A?H?@DDZO?DDIJJ@?L??CA?BEIB@B?F@?S@G?D?AHEE@@?@RU?FF?L@K?I@@@??DH?AHH?EK@???CAHJH@HKSF??C@JB@?@G@DZ?C?@@BD??CIJ@E??E@?BA?BIK@B??CBB]EBE?HD?@?@EBJP?CGFK?FH@?ED?JG?@B?D?CE@@SAJ?E?BEIA?ARA?DFDFL?@AG?@?L?E?KILBAD?@BS?KD?DKH?B@?@I@JIZ?I?NPIKGDNDP?GDGEAB?H@@?E??FDFL?D@@NJDLB??@LFTAETDBQA?@LH@ZA@@CE?D?AHD?GEA?JF??BPE@AHAF?KLC?CBOBFKFH??CFLHF?FK@?G?AJ??DLEG@@L??D@I??C@ID@J?@??CEPDBA?DBAG?H?GA?K@OGG@??B@AI?BH@?AB??C@LDL?H@P?CEJF@?@E?@?L@@?LB?B@A?@FPJI@@]?CG?EBJFO@J?GE?@G??C@FBEK?LB??CAF?L?EA@BGB?FKP??CHK@@@D?DO@?D@B?GE?DL@A??BBF@??C@BE@???CLI@AZAGBIS?C@KE?GIO?CAE@G?JEF??C?GFA?LBJF?FANH??CJ@IDD?IBUO?L@ED?HH?@?CAPKHF??CD@JB?A@O@?FD?@HL@?HBYJE?@LB??CEBBRKGQL?HG@?LBBGOD?@G?B?L@?LBH@L?D?B?KFGP@AEE??C@@?HB@O?C@J@G?@??CG@BDI?EB??C@L@?B@?EHG?BPJIL?J?BBFE??LBO@GBG?GJE??CAJ?I@BBA?V?EI?@D?P?@H@?K@E??C@B@LP@J@H??C?DDFB?O?@@G@??J@D?LDNFBE@??CJD@D?BO?C@K@FG??@HD?@H?FED?L?@@@?DD?@?JAA@?AJ?I?DIEFKP@@??CKG?B@E?@OAKHA??E?BHALK?AAH??C?F@ILIF?P?BF?A?H?D@EG@@FP?IAINGNPPGG?DGHA?FB?GEE??H@@BSEF?GGA??FIK@LSLHC?@IL?E@H?LA@?@?LF?ADK??CAJII?G?J@?L@D?GFL??C@?L@HBJ?L@?@?J??CHDHBDAE???CK@LBH?FL??CIDI?A@G?@?LB?FD?@L?BH@J?E?B?C@JE?KAD??CHBK?L@E??CI@?FA@??CF@D@?AB?P?@BD?HA@??CIBA?KFG?LG?@?K@I?JF?@HF?A@??CELL?GB@?BA?K?E@E@??CGJB?I?EB?DA@H?JD?G?@D?@BEI??C@J?B@?LGF?@@B?A@A??C@H@?E?@?H@IF?I@@??CBJ?HEK@??C@EB?F@??C@@E?@FF??CA?@B@HD?BAI?D?B?B?LILA@@?F?@?H?@AAJH@??CB?FDE?JDG?IE?BS?CGEBFF?KI??CB@A?B@@E??CK?DA?DE@?@LEB?GG??C@@?IEFI??CLI?G??BAGE@HE?E??CEBEK?@HH?Z?@@?FBBF??C@DB?HU?C@EIG@?D?LFFI??JDG@??CLHH?FFDE??CD?FBAI??CFEA?@F??C@BE@?@AK??CEJK?A??CHDIK?BG?A?HDEJ?@K?E?DHFE?@?L@AB??AABF??CEKJG??G?@FAIBD?L??KLDK?GA@@??C@?AG?@G?@KF@B??@@J?AJ?@EB?J?DFK@?J?KHNLJ?JJI@?E?FJE?HJ??CKEFD?I?NNP@GGDPGGGG@LABB?B?BO?@EA@G?FGIK???BJ@AF@?BDG???CAAL@G?A?EGBZI?GD@??CKBJIU?ABH?FAE@?IG??C?@@FA??CBHEHFR?L?@LH@@?I@G?U?@A?@B@?A?BHAJBZ?B?I@IK?KKK?HU@?KKB@@G??CA?@??AHILBL@?A?BZEIFE?I@L@??CO@@ELF??C@EA??L?IDJ@FL?I@??CAJ?LK@E??CDABR@?G?AFAI@?JJ@?V??IJAKAB??CJ@EZBG?AZDJF?H@H?U?F@?HEK?EFH?KAZ@F??CHFAG?@H?U?JDE?@HH??CEG@EP?@?A@D?EEI@IO?CEA?E?I?CDI@A?I@@A??CJ?AKF?A?EHJJAR?@EL?D@?@II?EFAVA@??A?FBIDBF?AP@?J@?IFFD@P?C@A?G?LA?@G@G?BBA??CFELZE?F?K@DJ@?FK?HFOF@?B?F?A@@IB?@A?E?@@?HFFAZG?A@L?IA??CL@E@?@FK??CAB?@G@??CIFIK?F?D?@@DRAF@?AI?D@?HAAVA?@FAIED???CDLL?ABHD??C@PDEG?K?@LKF?IOF@E?@?KFJBD??CJL?HB?@?BEGE?BE??CHEBJ?FL??CB@RIFBD?F?H@?FDFAV@?BHB?KE?B?@DE??@G@@@F?A@??KI?GDHFAP@?@J?@?GG@?@AO@LLDB??B?EB~E?EBK?FL@?@?AABZIGBGPPNGDNGDAA@??F?HIQ@@EAHE??C@AL?OEEB@HK?FA??G?A@B@K?I?EKKB??HFD?AH?@AE@D???CHLB@?IB?L?@?GJEJ@?@?A@A?A??@AA@LSIB@??C?DHKD@@AR?CD@???ACGE@@L?AI??C@LSHDL?G@?H@?GEDR?CEAA?A?AI?F@B?A@BJ?A?E@AY@?D?HEJG?BKDSK?L@?B@F?B?KGF?EJ??CID@B?GAE?@?HSHBBGB??C@B?BJRL?IBKLE?J??CLIH?BDG?DL?E@?K@HF?@?AS@GB@?AL?F?D@RLG?@IGA?DAA??C@J?BE?FI?G@LSD@?GJ?AIF?EFP?CIJ?DIEI??CIA@?AK?H?EEJFJ???CFBBLJSL@?IL?AA?B?E@DRF@I?DG??CABJ@HQG?@?BJH?FB`F?@AOKB?@?BD?IGDJFT?GK?AGAF??@A@?@F?@FEJ??CAJSK@??C@JLIJ?@RJF?BGAA?@??C@JH@?HGJ??CK?LKLA@E??CAG???C@ID@FD?FJI??CS@DKG??C@A@BE?R?C@@D?AGEHH@??CK?AD??CBDHKDS?E?DAGI?AFFG?R?FBA?FB??C@@BS@L?J?BFLEF?@RL?GE@?FLA??CI@EL??IBD@?FAESF??@CE@K?LDEDP?CB?FAFEG??CH?@JA?DF?A@ESJEH??CDB?AIDAR?C@@@??KHB?@HJ?G@K?P?BDCNGGNDGGG@AADJ?H??C?IKL?@GJE?H??E@BFE?@J?A?E@DAB?L?@?HBDH?K@D?B?A?HB@D?@?LB?BAE?G@?FE?AG@?H@?E?DD?D@AD?DQ@A?ELJ?@?@H?BEE@??CF@?GLA?G?@@L?FGBJ?H?@D?AIEI?U?B@AB??IA?BKL?@E?@FJ?@@?L@H?T?LH?F@??CA@BBKH???CADL@?E@K?A?L@?HALJ?@?E@?A?EB?L@@D?HL??C@EI@?GL?BF?E@??@LAJH@?@J?@@??CJ@FJ?AO@?HJG?K@DD?L?@?GGF@H??CB?G?IFD?HJJE?AB??CHAA?GGE@?D?AJ?BEE??C@LE?LF?A?BDL?@@@L??CE?KF@F??CFJJK?BG??CG@?BB?L?ELFK@?@@??CDB?D@LIF??CJ?BK?AE?FBHJ?A?H@AK??JEEE??C@BA@?@?BE?D?KEG?@A?BDFD?F??CFHBEA?@?@AI@E???HF?A@BF@H?L?A?BD?B@?BBAEI??IB?E?AD@G@I?K?T?F@?HIH@?F?@@?AGAU?CFBB@@??BEE?FH?@D?AE?BB?IIIDO?C@FB??DL?EABI?DLG??CLGAG@gAMAMBMCMDMEMFMGMHMIMJMKMLMMMNMOMPMQMRMSeAPfATMUMVMWMXMYMZM[M\g@QMThAVjAXkAZi@\j@TnAWh@YlA[mANqAUiAWh@]M^M_@M`@sAVoA]uA_@vAWtA^k@NxAXM]wADbAFcAa@Mb@Mc@Md@Me@Mf@l@]Mg@Mh@Mi@Mj@Mk@Ml@Mm@Mn@Mo@Mp@Mq@Mr@j@s@Mt@yAn@Mu@Mv@dAMMw@{Aw@Mx@My@Mz@M{@M|@l@YrA\`BZpANaB[m@\b@g@M}@M~@M_AM`Ab@^k@aAMbAMcAMdAMeAMfA|Ay@}A{@_B`@jBz@~A|@^{@lB|@^gAMhAMiAMjAMkAMlAmB`@nBhAoBjAqB[a@iApBkAsBjAo@\n@_@MmAMnAcB}@MoAMpAMqAuBkAp@aAMrAMsAp@mAyB[g@tAMuAMvAMwAMxAr@\}BNb@yAMzAtB[_@{AM|AzBnAs@uA{BwA_@rA~BzA_C}AM~AbBNq@~@dB`AaCsAbCjAo@}AcC`@n@_BM`BMaBMbB`C|AdCkAq@oAwBqAv@_AeB`@jC`A_@cBMdBkC`@v@eBMfBu@vA|BxAlCwAmCxA_@bAfBdAhBfAhC[iCpAeC`BfCbBw@}Ax@}AnCcAgBeAiB`@_@gBMhBzA`@uChBd@dBx@\pCqA^iBMjBMkBi@}AwCNrC~A{C`@w@\sC~AtCdAoC`@rBNqCaBgC`@d@`@xCjByC[M}Ad@N~CbB^lBMmBMnBMoBMpBe@mBaDoBMqBMrBMsBMtBr@}A`D`@a@uBMvBMwBMxBMyBm@}AiDvBjDxBa@zBM{BM|Bz@}Ba@~BM_CM`CMaCmDwBkDyBtDxBe@bCMcCuDyBlD~AqD_CrDaCwD`@|@dCMeCMfCMgC}C`@xDeCyDgCnD{BoDtBM}B|D|B_DkBzC~A{DfCdDnBbDpB~DtB`EgCaEoBcD`@cE}B^hCeDqBfDsBz@N|@`CeEnBbE`@gEaChEoB_ApBiE`@vDcC}@qBfEtB}@pBmE`@_AqBlENnErBgDtBkErBpENoEsBe@iCMjCsEjCjEsA_E[`A\`A}ArEtBqEsBuE~AtENxE`@wEtByENvENu@kCMlCMmCMnCMoCMpCzElC{EnC}EpChD~AaF`@_FmC|EoCbFnCs@qCMrCMsCMtC?uC</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??PY?CF?D??E??`??w@?D??E??@??_B?F??G??p??__?H??G??@H?oJ?I??G??p??{f?I??J??pZ?ci?I??K??`E?Sn?L??M??PL?{R?N??M??pB?_L@O??A??A?????P??C??@M?KC?Q??R??@D?_G?S??A??A?????T??C??pA?Cs?U??C??P@?kf?V??W??@V??F@X??C??pB??O?Y??A??A?????X??C??pH?_O?Z??[??@@?k`?\??C??@B????]??^??p??cF?]??_??p??OI?D??`??pB?wB?a??b??@C?SF?S??c??PI?ShAd??e??p@?Co?D??`??PG?GC?f??`??@B????g??h??PK?cD?i??A??A?????I??K??P@?Kn?S??j??`C?KnAd??j??PK?cR?k??l??pC?w]?m??n??pK?{T@m??o??@A?WU@f??`??pB????p??q??pD?gM?r??s??@@?SL?t??u??`??SE?t??v??PD?[D?w??x??`@?SJ?y??z??`B?c\?y??{??pH?S]?y??|??`l?gb?y??}??PC?cc?~???@?`??KF?@@??@?@B?_D?X??C??@P??P?X??A@?`@?SM?y??|??Pj?cb?B@?A??A?????C@?A??A?????P??C??pS?WC?D@?E@?@U?wL?p??F@?PJ?sC?p??G@?Px?GK?p??H@?pL?_G?p??q??@W?GN?p??I@?`??cO?J@?K@?`N?CJ?L@??@?`@?GA?M@?N@?@A?s??J@??@?pI?_D?~??O@?`??cN?@@?O@?`B?sr?@@?P@?@G?OM?Q@?R@?P??C\Bp??G@?@A@sK?p??S@?PD??H?]??`??PH?cE?a??T@?`N?GG?S??c??`@?SfAA??U@?B?????M@?N@?@??s??J@?A??A?????p??I@?pA?gO?D@?V@?P??WH?W@?A??A?????J@??@?pA?WD?X@?A??A?????V??W??`E?GE@V??Y@?pc?WA@Z@?[@?@D?OY?\@?]@?`B?gc@^@?A??A?????f??`??@A????a??_@?`???J?J@??@?`J?_D?~??`@?@C?C[?d??e??@C?Co?Q@?a@?PI?wmBg??h??PI?[D?b@?c@?PA?c??b@?c@?P@?s@?d@?K@?@@?[K?J@??@?PF?_D?~??A??A?????J@?K@?PM?CJ?L@?A??A?????J@??@?PG?_D?~???@?p??WE?p??G@?pr??K?a??e@?pH?gN?a??f@?@L?CT?p??G@?Pf?cJ?p??g@?`L?sL?d@?h@?@A?SG?d@?h@?`C?gG?d@?i@?P??sJ?d@?i@?`E??K?j@?k@?@D????l@?m@?@A????n@?o@?@B?__?]??`??PM??F?]??p@?P@?{H?q@?r@?P@??@?s@?t@?pD?cB@s@?A??A?????]??`??@Y?_F?u@?v@?p@????w@?m@?P?????x@?A??A?????]??`??PZ?_F?y@?z@?pB?gF?y@?{@?@??GE?X??A??A?????p??g@?@T?wL?a???@?@O?[D?y@?{@?`@?GE?X???@?p@?_H?|@?}@?@B?KY?Z??A??A?????p??G@?@o?oJ?p??g@?pM?wL?a??A??A?????Z@?[@?`@?CY?~@??A?@@?OV?@A??A?pD?CI?AA?BA?PD?wz?AA?CA?`u?[j?DA?A??A?????V??Y@?@`?SA@EA?FA?pA?[w?GA?HA?`f?oV?IA?JA?`@?OP?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1799992719;
    let startMs = 1666189962339;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","one.nio.server.AcceptorThread","run","one.nio.http.HttpServer","createSession","java.lang.ClassLoader","loadClass","jdk.internal.loader.ClassLoaders$AppClassLoader","jdk.internal.loader.BuiltinClassLoader","loadClassOrNull","findClassOnClassPathOrNull","jdk.internal.loader.URLClassPath","getResource","jdk.internal.loader.URLClassPath$FileLoader","java.net.URL","one.nio.server.SelectorThread","one.nio.net.NativeSelector","select","java.lang.String","java.lang.Thread","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.lang.Class[]","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.vihnin.ParallelHttpServer$$Lambda$156.0x0000000800d0a678","ok.dht.test.vihnin.ParallelHttpServer","lambda$handleRequest$2","requestTask","handleRequest","one.nio.http.Request","getPath","substring","java.lang.StringLatin1","newString","RequestHandler1_handlePut","ok.dht.test.vihnin.HighLoadService","handlePut","byte[]","replace","java.lang.StringConcatHelper","newArray","jdk.internal.misc.Unsafe","allocateUninitializedArray","allocateUninitializedArray0","one.nio.http.HttpSession","sendResponse","one.nio.server.Server","incRequestsProcessed","java.util.concurrent.atomic.LongAdder","increment","add","java.util.concurrent.atomic.Striped64","casBase","java.lang.invoke.MethodHandleNatives","linkMethod","linkMethodImpl","varHandleOperationLinkerMethod","getVarHandleGuardMethodName","java.lang.StringBuilder","<init>","java.lang.AbstractStringBuilder","set","java.lang.invoke.MemberName","one.nio.net.NativeSelector$2","one.nio.net.Session","process","processRead","processHttpBuffer","startParsingRequestBody","writeResponse","one.nio.http.Response","toBytes","one.nio.util.ByteArrayBuilder","ok.dht.test.vihnin.ServiceUtils","emptyResponse","append","ensureCapacityInternal","java.util.Arrays","copyOf","handleParsedRequest","getParameter","no_Java_frame","write","one.nio.net.Session$ArrayQueueItem","java.lang.String[]","getTask","java.util.concurrent.ArrayBlockingQueue","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","getRequiredParameter","toString","copyOfRange","ok.dht.test.vihnin.database.DataBaseRocksDBImpl","put","one.nio.util.Utf8","getHeader","trim","parseRequest","read","toAsciiString","java.lang.invoke.LambdaForm$MH.0x0000000800d0c800","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800d0d800","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","getShardId","ok.dht.test.vihnin.ShardHelper","getShardByKey","java.lang.Integer","valueOf","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","ok.dht.test.vihnin.ParallelHttpServer$$Lambda$156+0x0000000800d0a678","java.util.concurrent.AbstractExecutorService","submit","newTaskFor","java.util.concurrent.Executors","callable","java.util.concurrent.locks.ReentrantLock","lockInterruptibly","java.util.concurrent.locks.ReentrantLock$Sync","java.util.concurrent.locks.AbstractQueuedSynchronizer","acquireInterruptibly","acquire","java.util.concurrent.locks.AbstractQueuedSynchronizer$ExclusiveNode","java.util.concurrent.SynchronousQueue","poll","java.util.concurrent.SynchronousQueue$TransferStack","transfer","java.util.concurrent.SynchronousQueue$TransferStack$SNode","tryCancel",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
