<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BEjCAFIZ_Ay|A?[`HxEKUNLKJx\LMJpTJhhhhh`TLJhhph]Hh`xTLJph`\HhhhkGSQDJLLHYi`XLMI\GhpYpQ`Y``Z`pZhZYUJ`^H`Z\I`Yp`Z`LI`pY`p`KJEMI[Hh`pSI`\LJQphI``r@xDLGhh`hDMJMLJ`SQTIp`SMHhpFJ\I^JSKMJLMJ[JpLLJ]JR`xIaZ`UJSLMHTIxSLJ[J\JSNKJ[J``L`Xp[J`xLLMKKJh```h`]Ip`LNLLI[RMMJh```p`Rphh[LJp\MGxhRphSMLIhxKMJh\LJ`xXh``p`p``hNIKUI`hhIq`rVIp``xFLIp]LIx`hh\MKJph\LLMHxRyLLKLLKMKLJp`h`p\NIpTLQhhVJpp^I`hpxLKJxh``hxJi]KIp[RTLMJp]KKL`Ia]KMMJp\NLKKMLKLNIxp]KLPhh`i\IqTMMLKMKNJ`x^IxpNLNJSTKKMNJpSRhaVKMKLLJi`TMKLMLKLLMLJC[LLKNLIp`ajLSKQphh`hphpxULLKNLMKKSJpx`ph`aVJxhppSQxMQqRx`x`x`hp[Qxh```i^Ja]LKQ`x`aVMLLKNMKKNLLLMMJaTSMKKTLLJcGa`pxSQa`iUMLNHq^LMLNKKLQxphhpp`phphp`xp`pp`xh`px^KLLPah`xx\KPi`hhppSVKLNKMKMMJa`hpphpph`ppaTQpx`x`xhrCSMMJiKUJap`phhahhx\NKNMKLNLKQah`xhhpx`hhpp`xx?rxhhhp`xphh`?ara`xh`aVNHj?E[Yapp`phpaLSKKRi[TLKKMNM`HqSYa]MLNJax[TKMNLMKNKQahphpx`xppVJa`ahpa]LLNLKSNKLKRq^LKKRpphxx^LMMLKRxhph`i`pphhxhp\KTKTLNJha`a^LMYyCZx`x`xhx`a`i^NLKRi`iSUNKLMNMMNKLRpxhxpppa`x[UKTKNLNMLMMKSMKRip\SNMNKLRppha`pahahx^MLKSNKKULMKNMLRa[`DWih`a\TLNMMLNLNMLMKSKSMMIbhppx^NJi`ppxhphi`hW?DOFWEVhkL^NKNMMMNMLMMMLRa`xx`xxhhpxp`xxppx`pppa]LKTLRzFPxx]Pqhxha\NLLRahppa`xhppa`xx`aURxpppx`pa`xa`hppx`aphpx[TNNLLMLKSLTNLKMKULMNLNJxxhahphahphxxhx`xhpxpx`kHqZyUObLSNMMKSKRahhxx`xppha`a`phpx`xpxha`ahpxTTKQahpa`xhxhpx]Ri`xhxhpxp`xhxpxhpp`i`hxha`aha`xp`q^LNMKKS`KLOjTSKRi`i]MMMKKSKUNIi`ihha`ppa[SMKTKUKNJapp`i`xhxpphhaha[SKUNMMKTJxphxphap`a`xphpa`aphx`xppha`xx`ah`ahrCWip`iDXq]LMKRa]RpppaTRih[TMMKSMKLLSKTKKRi`xhi]KNNMMLLLKSNNKNKLTKRSUKRx`px`apphxh`p`i]TJiSUNKNJxx`xp`ppjKXq]MIq`i[SLKSKVKNMKNLMNKNMKNNLNKNNJhhaxxhpppphhxhhpxx`hx`xa`ppppa]LMNMMNIahahhxpph`xxpphhxhp`qSTMMLNMLMMKNKNWbMSIqNSMRhp^PqSX]SMPq^MKKSKSMQxx^MMMKNMKKSKRa`hxpppxhpUSKLTKRx`xxhpxhhx`pa`a[UJi^NLNIxpxp\TNKMKGD[]LLYy^P`ihiLSNMKLUMKNKMRhx`xpphhxx]KTMMLNKMNMLMMKMRi^NJi`hpxh`xhpppaSVIi[TNLLMNLMNKKQq[TLNKKRiha`SUKSMMLLRaTWjDYyUMJqTSMLNLLLMKSLRa`hxxp`pppxhpx\Rpxpha`ppphhxp`pa`p`i`a`x`pa`x`x`a]LSKKTKSNLNLNIyVLNNJaSYqUKPqNRa``jUQbMR]QyTTMNIihpE[MNJiNSLPxpha]PapxpTSKTNNJppxphha`xxhha\Rah`xha`a`pppWrha`iSTMHL[UMKQaWcHqhpphpxpFL`\OrERapNOi@xjxphxxa`phpxha`pp`xpphqUQxpphpa[Qq^MLNLMLNMMKSMNJxhxa`ih[TMKTNMKMKNNLJqphx`pi^LKUJi`ppa[SKVWqULQyTTLNJipiTTNMJax`xxhpppp`xp`pi`pxpp`x`xxpx`xhphaphhiVLNNNKMLLMKKTNMKLLRx`px`xp`pxhppxpiRapahap\MMMNKLNMWyUTIyLTLRxp`qURah`iDYi`xxLSKTMMLNLMMLKKVJaphxp`xhx????EU`jyD`zrD]LNLNLNLKMMKUMNJaxhpxhhppa^KSKUNKKKUKK`NQhx\Qy[TNNIqSUMMLKRxha`x`px`ap`pxhxUSLKTNKKRax`a[TMNNKNKNLMMLNKNIi`xx[TKRa`haSSMNKKTMMMLKRxpha\TNKMMLKSK`CTKMQahx`pp`ahi`hx\SMMNLKKUKQa`i``i[TLMMMMNJi`ahph`aha`px^MMMLNMKMMNKRpaTTMNKMMMLNJaphppppphpppx`xphx`pa`xphcGbIbKWy``aUQqSSLLRiLYpppxURahhxUTLQa[LTMLMNMKNLMLNMKMMNLKUKLJixTRxpppp`ap`x`xpxhaVNKNKKTNKLSMLMNJpxphahzLR^PySTLNNMLJa^Qi`xp[TNMKQhpxa`xphhpppppa^KLLRxsJ~M_O~RuP{RvTaQiSaS}TqTrOvOhR|SsJcTfT|TyT~P`UwSrT~ThSlUsUpUtUaMiUnUbVaVxJ`VqU{J_VjOkLgMmM`OwOvM{KhM|OfSbKqKrKtKaLjLyLbMlM{MaNmN~NcO{O_PcPgPxP|P`QdQmQpQvQeRrRyRrSsSdTbUrUyJ|J~JaKcKdKmKoKpKvKxKbLcLeLfLgLhLiLlLnLoLqLrLtLuLvLxLzL{L|L}L~L_MdMfMoMpMqMtMuMxMyMzM}M_N`NdNeNgNhNiNjNkNoNpNqNsNtNvNwNzN{N|N}NeOfOgOhOkOlOmOoOpOsOuOyOzO~O`PaPdPePfPiPjPkPlPmPnPpPqPsPtPvPwPzP{P}P_QbQeQfQhQiQjQkQlQnQqQrQtQuQxQyQzQ{Q`RaRcRdRfRiRkRlRmRoRtRuRwRzR|R_SbScSdSeSgSjSkSlSmSnSoSqSuSvSxSzS{S}S~S_TaTeTgThTjTlTmToTpTsTtTwTxTzT{T_UaUcUdUeUfUhUjUmUoUuUvUwUxUzU|U}U~UtJuJvJwJzJ}J_K`KeKfKgKhKiKjKkKlKnKsKuKwKyKzK|K}K~K_L`LdLmLpLsLwL`McMeMiMjMkMnMrMsMwM|MbNcNfNlNnNrNuNxNyNaObOdOiOnOqOtOxO}ObPhPoPrPyPcQgQoQsQwQ|Q}Q~Q_RbRgRjRnRpRqRsRvRxR}R`SpStSyS`TbTiTkTnTuTgUkUyU{UcVdVeVfVhfONNNNs@Ne@e@Nb@e@b@NNh@h@Ne@h@b@e@NNNb@NNNb@Nb@N?zBb@b@?NNN??b@i@Nh@e@Nb@?JN?g@@@h@@N?i@Nh@e@@g@aC?i@b@]?e@J@Je@~@@N?g@Ni@?Ng@Nh@@?N?@@??E?@?}BJ?B?@b@eAb@@?g@?@??Nb@N??b@??Sg@b@b@??b@b@Bh@BNNb@JaAK?K??N@???g@?N?NN??S??N?E?ELNaA?N??N@BJe@@????b@??N???N?Ne@?@NN@??????@??e@?N`C?A?N???A??@??N???@?AC???G@e@??????hA@C@?e@?A???eA]]b@E@EEEB]EEEEBq@C]C?A?K?@??AGK???S?Jh@?CCNS?nE?i@?@???Nb@????A?@@CNg@EBb@?b@e@?NFh@@??@?Fb@@?AN??L@@Cg@C?A?J??N@CNEB?Mb@??CN@?F?b@??@Ge@??N?AP?NqE?A@?GBK?PI@?A??g@N~@?L?Sb@F??C@CUG?A?C???SJ@NL@?A?V@JU??@LBe@P?D?AC?@C???g@OFB?D@SJ??@BG@C@?AA?NBGLB??IU???CR?CV?ADS??@?A@?@??A?A@G?N@NBKQ??@K?WJ????A???DWC?HC?R???ACBO??pE@?J@?AAG@C???M?OMDCB?KC???M?@??A@O?U?A??@?G?FC??C?F?@?ANL]OF?G?KWq@GAD?A?h@??A??L@E@CA??]]]ITKEII]EEIBB??A????@@C@??M??@M?Q?H???@BK@@?A?C?JQ?ACI?FV??R@?@S????@CV@??ALMF??g@xE@B?@?A???@@@CO@BHK??G??Ab@O?A????DD@C???F????@VkA@????L@C???@?AV@?ABQ?@HLIb@J?K@G??KUOF@?N?AB?S??@@C@D?AM??@HL?@?K?AA@??@R?@?J?A@QM???A@@?H?????@?H@WK?QFK@?F??N?A??C@?HB@TK?K??C?@?A?@R@?A??NB?TA@@?F?EHJ?@CB?JG@Y??K?]B??H?A?q@N@CM?@?AL?@?T?A???@?DA?@C??E?R?A@V?H???@?A?I?@T?HI@??_@G?P@?AKAW??@C?????F@?LB@???OFLK@@?AT@?W?A?BS?@SJ@?@]]IK?EEBI]EEAE??R?GUK??@@R?@P???@?A?G^BK@???DFIMB??F??@AC@JUU?CAK?@C?R@??A?LC^?A?QS???A@@@BKPOL??GCXMR@O?A???@RCB@K??P@?A?BC@?FS@?U@@C??@???A??@P??ACXHBJU??RT@@?@A??@?A?MQ??CX??@@P?@LO?CM?M@?@?A?B@RBYGY??Q?@??AB@CV?@???F?E?e@??AL@M?HV@DB??R??A@I@@K?SH???@D?BG@??A@@??A?JJ?OCTI@?B@SJ@?????ADQGC?A??@?HE????G?AO@CF?A^Q?E??@?@AA?G@C?J?@?A?C??E?@DN??A@?JL?AE??C?@?D?@?BP???@AM@@C?@????CA?B?BK?K^??@DOPG?K?UT??@P?@?J@?A?@T?A??CH@?CK?P?CBMOJ^ST?@C@?QR?A?AC??JX@G?HEFI@???JVA?EE]EVEEEBF@@C?B@OK?HXQ?@A?A??@??Y?NA???@CWB??B?@D?Fh@MBK@??[??A???@??NG?@??A?A??@??@PR@_@??BK????@?GZGDQ????AA?d@@?A?@?A?BK?@@F??ATZ???@?A?S@?@??A@??ZIB?ON?@?HAZSC??@DB??H??@C?G[??A??S?JW?A?Y@W?A??B@??@?AkA?Z??HO???@@JU?D@EBK???BA@\UW???Z??A????@@D?O??@?@D???AG?A?[??Z@CU??W??@DM??@B?HKB?S[?AV??@?ZG?B???@X@JHP?@@C?A?@M@D?J?K?R@@C@IPR?A??G??@@C?@????AW??AB@D?@??BKI?VL[?FB?COE?^?A[X???F???@F?@DB??g@?EB?Z[O?A????@?@?H@@?I??HIB?K@@D??OZBK???[?C@C?A??CR??@Q??A?@???@@DTMB?@?A??Z@G?H?@????@D@?F?URTB??@[URZ@???]VV?EEEBEEEEA??B?[A?[@BKB??B??b@@D?EB@C?M??@?@K?A?T@??P@LBDBB@@C??SKF?BG@D@??AW?FG?@??AJ?OO@??W@D@??O?@@D?GA??A?@????W@D??CSL?@C??E??@GY???e@?A??C@BSTIO?IC???@^@@?M???J?UBG@?AI@???A@?HN@??@?H@?H?I?@X@C????LAE@?D?O@C??J?J@?CXJR??TWHL?_@d@@?AL??OB@Ce@@?B??O?OAYQ@@IMB?U??V@C?U@J??EOFO@?W?BK??@??@LB??@B]IB?Q@_@?F@AE?@???JU@??C?@??A_@?@PF?AC?PB?CUR?JhA@?AFW???QK?X@??X?]?A?I@?P@@C?@???F@DJ???e@@GY???GHTA?KP?X@?A@??P@??ASN??B@?A??N@IB?F@?B?@@ED??X??A?ML@??@d@@J??J@?A@??@?BKO?@??A@?A@CI???AP@??@F?FWB??RI?@DL@MJ??^A??@B@D?RESN???AI@??H@D??@@?HI??HJ@BGX@S?B@VV?EEE]EEEBEA@F??D\?K?@?R?AF?@?GORF?@@??B?RP@???@?A?\U??@@D??K?@CPR?OX??a@?FK@?H?CG?Fc@?S??@?A@??V?BR?U@???D@DB??I?@C?A?^AT?a@?A?@@G???FE?????@@DC?F???LB@?@?a@?H?N??O@X??FE@B??@?HG@?BIX?F???C@OMFBI@??D@D?B???@?H@??f@a@TIA???@@R`@a@?Q??E??H@@IV?AS?LU?@@@D??BM?UT@DC???@?AMB?@?@?A?M@?U@?A@???J??@@D?C@BJ?QUTF??Z@CR??@?T_@?A@UB?@?AF?@B]\?A?????@URL@@Q???@D?@??@??AB??@MD@D@?U??E?H@??Z@M?????c@@OK?@?????L@D@??\?A????a@TC?@A????@?H@??L?@??AC???@BB?R?@?@??A???B?@\?A@???@U?A??@???@X@ARS??@a@@???\E?V@?Q??@H??HCJ??J@?A?@?D?D?A?GI??RF@J@@P?@IR????\??@@C?Q??@MC@D???@???HP@??Z??AB?A@??@@D?T??T?@@f@IKEEIVGEEEBA@?CUR@??Sd@??AR?I@???@CWBC??@???AE?@??@D?a@??Q?CIBCM??F^@C?L?@@EB???Qa@??B@_@C@??FQ?@C?@???@?AQFTD@?G?DA??RA?G?A@?@P??@[@B??@??QS?@BLC??A@????@?J@D??U@L??A@?P@U??A??T@?BG@DB??MLC@CE??^??[?H?@Ba@?B?A@??I?C?A@?HF?@?B\@R?@?B??A?A@OCH?H@I?BB@S@OA?@?JA@UR?@C?^?A??U???@@D?DFO??S?CGB??\^?TA?C@Q??H?@I??T?Gf@@?VQ?B@BK?@?@??_@BMH?Z?B@K??@B???@V@MKP?@@DM?F?@?@?AB?B^?@?A?@J???@?A@?M@?@B????@@??A@U??F??GAEP@@@??A???P?SO@C\@@BM?U?CX@?PE@?A???ECC@DAB?????Ga@U@d@AV?A?BF???@\@DB??DF?QSB?@M?^??@D?LJ??@?AA@@??CJU?@BB?AG@D?P??@?@CJF^?S???CXa@??R??J@?U?TC@PR?C??B?@@D\M?E??L@?Af@@?D??S?K?BF?@@@D?PI??B@?F@@@OKVV?EI]EEEEBA@B??B@DY???IIK??D@Q@AI?O???@??@A@??????EB?@C@??AI????@@?A?@L??C???A@??@???A?@??@?M?@?JM?C?@K???C?@K?H@O??K@M???@??CB?@D?J??@?IB?@M@???AL?@??PD@?AG??@RSLBR@?@?U?A?@?J?C?@M??O@@?P?H??@??@M???@?A?C@AE?[M?@RAE??@?@??F??@?S?C?@DP?F?@F?A?M@@I??PA@????C@CV??BB@?QSO?@@UMR??M@???C@?AGM?H?@K?LL@?@??A??d@??BJC@DB?BOM@?A??@_@@??A?B?P??@@C@??R?@?A??M@@@?A??C????CTI@???D??A@??@?I?H??WK?C?@?AU@??d@??H@???@M?HB?U@C???@DO??L?@?A?@s@@I?BSf@D???A?JC?J@@D?E?I??@??A@?VB?R??FD?I@?Y@????Q@???H@?@??TCVR?I@???A@???J@M@?A??a@??@JB?C????@@TIC??B@??A@U?@P?TI??C?@PO@??A?Z?@?BM@IK?Aa@?A?C?@KR??@DQ?B@Q??A?@?@P??AQC???F@@CVXEEEE]EEBEI@?PC?@MF?I??@@?A?@??CE?QF??@??OG?@AE??@@Q?S???C?BG?S@??@J??A@EPK@?BG?BAQ@D??@C?BO??G?@DB??@???J?A@@???@?A??@?G??AC???SE@@??A@?@????AM?@???CG?\AHSJ??@?A?@?C?@JUA?@??C???A@????@?@DA?P?G?A?E?@@??@?A??C??@?HC????@?Q??@@????@D???ST@CV???@?SB?FEa@?@?OW?HO?P??@CCV?????C??H@@????RH@DB@BCK?AF???@?L@@C@????HQGTI@AB@C?AJ????GLC?@AW????O@?A@@?R@?MA???C@?G?A????@??@D@?LKP?G?A??@@@??A?R??FTGODR@F???G?A???@@@?A????@??Q@CMC????BG?FA@@@??F?I???G??@CC?????P?@D?@@???A?J?R?@@CVL????@?@C????@??A?AG@???DO?F?R@@B@C?????O?BGCV_@?@?A??F??@?@?A@??K?QC@?H???@_@??A??@???@@?A?GFK??C?H?@?@??@DBT??@RG?LF?@?M?@?A@???CC?HA??I@?@?H??@????ZIV@VEEEECEEBE@BF??L?C@D@CQ??BK?HQ?YG@?A@?U????@@D?C?M@M?????Y?B@?CWU?????@CVASZ??V?FB??@@???@@D?LP??C@@D?A?K@L??APO@Y???GEBE@?HCM@Wc@??F?AGH?A@ER?@O???_@C??FC??@M?VP@R?U?JUI?@B@?GEBT??Z??CIB@??@??@??F?L@DMICV??????I@@CG?M@HO???AJ@B@?PC?HC??OT@?W?A@?@?S??B?K@?TW?C??A@JR?@BOZGYH?FCB?@?A[??C?@?A????@?DI@@D????T?@@CS@P?????F?@?@G???FKP???@?C@DQ???B??@a@@@?@???B?K??JC@?G?A?C?????@f@@@???@MEB?OMS?@C?WQ@SM???@?@C????G??P?S@K@?K??@@DM?B@CHM???R@E?PR?A@@??BG?H?KPP?C?@@D?T?MD???A??Y@??Q@M??@???@C@C?SP??W@?A[??@??T??ZC??@?C??MA?S?B@A@[@@??L???G?A?@@?CQS?L????G?@C@I?P??BO?@D?@@?P??ASFM?@?C@D?U???@UW?AIY@??K??A?C??@F??GCV?PQ@K?@FI@?DS??C?AC?KO@@?A????@@R??AR@????IC]VGYEEEEEEEBE?A?C@@??AE?J@?S?@@CAO??@?AM?JW?J?]GYBB@S?F@EBDB??E?@@?SO@??@?M?B@SQ??@?GYA?T@J?Q?@@D??D??@J?PB?@U@?@DQQA?BM?@UR@?@?K@M?M??@???DGY??U??@@@OC?F??DB???@D??]??@?A???@@?@HT?@B?SRG@?A??CQ@??LBKS@OQ?@?A?@?B?GD?HL???@AG?H?@SBT?@A@@DHSU?G?J?A?@@S?T@?FCOQ??@T@?AOC@????@?CJ?F?c@G?A??@?]B?S?@D???G??@R?]?@I?L?@?D??S@?@LB?@TJ??B@@CO@BBQL?GYAX??B@??BAPD??@?@@D?J??@P?M?@??Q@??GYQO?@MUP?@CW?C?L??@M?]??@?@EB??TK@??@@@DI??F?@??A?GA@BR??A?@??@??I@@D??F?@?G?RA@B@P??O@F??UG?R@?AU_@@???@UR?@??d@P@?A]???RKGO@BKC?@???M?F@??@K@FI?K??GQ@RB@D?????@??A@R?@????A?G?@?@???A???@?@Q@DUOBS?S?GBK@Y@?P?AII???@D?@M?Jd@????B@@DK@???@?HQJ?@@?@??A?PS??@G@CKC??K?Q@?AM@]P@??A???B?@@GVBYEEI]IEEEB@?O@?H[?????DD?F?ROX?F@?FA@?B??X?c@?AG?MD?T?QSLVB@????A@??KW??@?A?@?D?B??AGI??@??@C?LKBG????@D@???SC?HI??@CD???A?UOA@A@CWL@??????ADE?G??@?FT??@@??CXL?????BD@Wc@O?VQ?O??A?@@???W?A@?Q??D@JP?URc@??@JU?@?S??YH@?A`@JD?H?O?A[???@?@??@A?BBX?@?TFD?D?A?HTVO???@??A@???W??FI@D?C?BM?W?A?@?@S@?A?A??@c@?T@GY?I?S?EYDV?@?T??O?H?@B@?@?AL???Hc@DDVA??I??LY?a@@?@?Q????AB?Y@HDLB?????I[@@@D?OQ????TX@D@?L???AQ?R?@c@@?AB?M?Z???DVY??LT??O@@D?@[?I???A???@?DX@J???B??]@@DQc@QH???IB@?@?Y??A???S?D@AE?[?T???@?A@??X?F@?HP??C@?L?AV??AB?@?@X@S?W??QK?HD??@??G?A@??B@?@FI??OHc@H@?A?D?Q???YC?FXM?@S??BK?[?@??D?FCO?JX??@OA?C??@IQV@?H?U?@O?AD?Hc@?H???@D??@B???c@@F?@???D?@AQHc@??J@ZC???C?Y]V?EEEVEEEIBA????@O@Wc@?PA@T?ZO?S?[???@^@?HPE\D?AKI?ZF@??A?W??B?@???H@TBG?QSBZKOL??@PCX?O?@?QITL@D`@?L?CT??FHT@FG??A@??BMLH@?AC??ZF?@BK??ED?@B@C????MBHZL@D@OU???B?AL@@ZH??AT??O??Y@@C????E?C?AB[A@HPX?A???P\_@?ZG?J?B?B?WB^@@S?TMQ??AIG@EZ??HB??RQTC@?A@TOL?JO@D`@?PZ@?B?F?M??G?J@@ZCB?JF??C?AQD@BQ??SJ@????@@?QFBYL???@DGM?O?@^BR???@?f@??J@D???F?Z?[@BL@?J???HI@c@??@EB?AO?ZL?[LCG????JHO@K?@\@?UF?A??K??WD@?H???@?OB?GY@MB@T?JUB?L?Z[????@A?AH??@X@O??@I?@HL?@?c@H??@SJL@A??ZY^@???T@UQ?AL@OY?S?I@?A??GZ?^BR??SA?G@@C?QPJ?HDBKC?@?B?I?L@DODZJ?FQ?STM?@?C@C??B????@@B@K@??TTEEB?YE@??Z?A?Z?LJ?[@M??@??@???F\U??@???HZ??WJ?B@?AL?@?@LGHLEQ\??RZ@?A?H?IWa@BFI?@B?I?Q?G@D??Z?TYO?AUB@@??@VVFEEECEEEEBG?B??@@?A?OHZ@?R??LA@Q@??GYFB?????@?@DDP?O????A?@@@U?LB??OL?@?@GYHFC??B???A@?D?@A?E???@S?@?GY??BE?O@?A?G@??Z??H???@@I@ALILTc@??QG@D??ZR??@?H??@DKSS@C??E??H@@?A@OBQ\P??A?@UL?G?A@?A^??@U?O@C??P@?RT@D?F@?OS@?A???@?@?GY?QB?QO?@I@DDBB?????A?@?@@??A?B?A??@@FIG???B?[FI?@?@A?J@?F???W@IG??_@F?????@@D??@I??@?A?L@CP?W?A?A@???@@QS??^B?G??A?@???O@?AH@??@?A?@@D??G???@?H?@F?@F@LB??@?L@??@?@A???G???@AO?@?HO@C????@S?@?F??@@??H@D??B??@?GY?LH@?B?S?@DD?S?@O?HQ???@@I?AF@?????S_@GY?Y?@??OFM?L?D?@@?DO???J@Ld@?A@?@?B???AG???@@?HLAEI?@@??@D????BTAG@DOX@?????A???@?C@?H?@??SH@AE??@?_@?@?A??_@LH?G?@?AG?\LA???@F?L@P?J@D???G??R@?A?@J@??P@CB??BQ@@?A?@B???DP??@??G?JW?HQ?@@A??I@VKEEIVECXEE????G@[?CBP?S@??A??a@?@TP??@F??M?@@?@AUR^J??H??@@?H?WJPD???@???H?@??Z??IA?@??@K?@GYB?B@???@CU??V?QK?@?@??P?G?@E?@??@?A?PU@?d@TI??@????@@?CAL??@???A??@D?????F@???@@OF??@U?\?BK??@??R?GBR@???C@HL???@LV???DGA????T@@C???D`@?A??L?@K?Z@?DM?@QO?@C???G????^@D?@???P`@a@??TC??@@C?J?@???@?F?@CB??@D??B??@O@?S^G?????H?L?@MW`@?A?FR?@?@??CXT??B?Q@?A@?GI@?AE??BB@?GC@DPF???U@BK?`@BCF@?F?A??@J[@?EA??V?K?@@CEa@TJL?G?A??@?G@BKM??BY??@JD`@?K???@AE??@CJB?A?@????@C?F?@?@???A?H@??d@??A@L???@PBCVHK?@????A?@??G??A@????@?BCWc@SK@?????F?@^?P??A@P??I@W?A???M@Q@O?F@?L@??A?@???@?BY@D??@?F?Q?H@PMC?@?A????@@???@D??K?F?@@D??@C?R?????G??Q@@DP??S\D?A???BC\?A??d@???F?@`@a@J@?L@?HO?O?@B^?A?X???F?@@VVEEEECEEEEB@S?@S?@D?P?M?D?AB^?@??P?A?AYB?R?@?@A???_@D??FM?H@?@LR?FCL???D?LA@?^EJ?FI]T??@?EA@CV?U@MB@?A??Q@@??R?CP???QB@@?CAK@????A?@P?W??CVE????@K?c@@D??@B?H?A@?^???CV@???P@?@?H??C?@??F?@????@?S@D?J?@???R??C?^JH@?D??PR@?@?A??^@??Q?A?JC??@?@?A???P@O?@D@FH??B??JAC?XR@?AJ?F??@@O?@D??M???B@CVX??[??H?I??@@E?@?@AF????@CV???@@IPB???@??Q@@DE@???RC^@???A@@?A??C??L?@?A@O?@?@?A???@M@??@?A@??B?@B?ACM?@M??A??@@E??K@?P?B@?@C@UCR???B?@?@AP@?@?A??S??@PC?@DJ?OBK??@M@?@^T?B?K?F??C@?@@D?????M?@@D[?X???F????@_@P@?ESX???K?@@DV?BO?@?A???@@?@??A?R?`@??@R?@C?AK??@?A@K?@@?L?????@??CX@M?MA?B??@D?@@?P?A?M??X?@C]???HG???@?\A@M????@A?O@LC?A???@A@?@I?P??@?AD@D???R?C?@?H@?@???M?@???@IK@????C????]IV@DEEEEBEEEIM???WR?X@??@?A??R??f@@??EB@B????@@C?Q?@C???AA???G??@@DG?KB???GY???@`@?A?RRA??a@?@D\B????@?@C?F?Y????F?G?@??@\@?O??PG@D??MB@?R??A?[@??K?@@DM??Y?@U?R?W?G???H?a@??Q?@?`@CG???@???A?@?V?????A@B?@???[@D???@K??A@??G???@C?MA?@??\??AG??@??H@???W??@?HE?D@???IB?V?S??G@D????]?@IU??@@???AX?J???@@?AT?@[?J?A?@?Q?B@Y@B?B??@??@@?D@?B???A@??W?I@@?CBR?@??X?A@G?????A?@?@M?G@C??HP?@??@@D?W?????F@???GV?A??Q?@@??`@?@A?H??@@@C??J?@I??A?@MG???@@D?A??@W??AR@?GT?H??B@??@?`@@DU???@???A?@?G???A?@R??@?`@?A??\@R??K??@???Y?H@????@??L@DR?@?????F@??`@@??F?????@?^@D????@???A?@?@???@??A??@@?@D???B??@?A@E@?????_@@D??@?@JU????G?@?A?@B@???V?A?I@L?@@@C??A???@@DP?G????@?H?O@?@G?H???UD?@?IF@????DVIG?KEIVEEEBAa@JUBW@???F?G?@M?A?RC?@M??A?@K??@?@??A@??@???BA??\@??H?@??B?G??@D?A?@?B?BKC??@R@??A?P@?@??@CWL??@????A?\??B@?A@????G???CG??@????MC???@???@A???@??@?HUW@P?\?A???UZ?@@D??????d@?A@?@??????@DB?\?@?A????@??G?DA@?P???@?AC?@@P?F??A???@?JU@X???????@D??@G???A???@??@CW@Q??????@@D?@C???A????@?@@D??????@??@DF@???????\A?F@@?H?L??W?G?@@D?BM???@?AC??@ZU?????@K@?A?@???M?@OF\??@?@??A??G?@?A?@?????C?@D??R@????A??@@????A?@???\@?A???@?@??A??G???@?A@???C?@?A??I?@C??F?@?I????@@D??@G??A????@???@GCR?????C?F?Y_@@??A??????D?@C@U????????H@D@???AR???@?@@C??????@??@D?Z?????A@??@?@?A??QF@W??@DGB??T?U@CV??@?@?A?J??C??@@D?????Z??C`@a@?@?????AE@??@??@D?????\?@@D?A@??????AG?@M?@D???S??D@]VK?EIVEEBEEAM@R??@??@PFOC?@?@H??@???@?FG?U?@?@?@A?IB@??A?@???@??C@D??U@E@??F??@@??A@??M???C@C???@?@I?U??@@??A??@??U?@CWc@??L@????QA?@C???A?@?B??@?@GYU???@UB?L?@?_@???A@????@??@@DM?@???F?@A??@??@D???@???C?F@??d@??@DWE??P?@?C?A?G?@???H?@?M?@@DWJ??M@K???CW?@?????A?@?@?@EB??S@??@?CV@???E?@??A@?C???K???@M?@?@?AB?@??@@D??????C?H?@d@????_@?ABA@?@@?A????@J?C@C?T?@???H@?B@???C?H?P`@?@?@@C??????@?A?@?@??@?A???@?@?@C????????@CW@?@??AL????@@?A@T??????C@CRd@J?@?A?B??@??_@@D???L@??AE?@?d@????C^@???@?@??A?E`@C????F@??K?Q@@@D????@??AA??@@@?H??MS??G?@CG???@?B@CX?M?@??UR??@?@H?C?A@??@??F??F@??C?@?D????@??@@D??d@???S?A@??@@??????E@??C@D?????B@@C??@d@K?H??Q?@??@?CGP?????@?A@??@@?A?FI??@?a@?]CKKEEGVEIIBEDP?@???GF?F?@WK??Q?C@??H??C???@??JD?UFU@???AX???@HA?EC????W?C?@ABS@????A??C?CSE?FC???J?D?@CW??@?????FO@?@LIDCX????[??DHT?@??`@D?H??L?DI@?HD?@?????@Y@J??DD??ATO?DS?B@D@??????@?@A?@[Q??FA??D????AD`@?B???@IU?_@@?C?A?????T@?D\_@B??????OP?C?@DJ??A???H@Q@?XAC??????D@D??W?@?A???LT@C?AG????a@??D?A@??@?????AX??DDBM???W?W?FH?F@S??@C?A?F???DC?F?D?C??UJI@DS?R?@@?A?H?@_@??A?E?D???BD@C?QQ?@@?A?U?C?D???A???DHT@?@DH?OM??@?A?X@@??A?????HWCMCG???????E?AC@@??R????I?DDD??SH?D??BI@C?@M????@?A?@TCDB?K????BD?@CJ@ES???@FIF@OCCAE????T?@DLB@?T???@?FBX?AD??c@??A@?B?W@D?F???D?R?IBC?@RFA@@DP???Z?D?\??@F?UU?R@?Z??ID?HA@XBB???H?@?B?WC?A?QPDA@?FIKCL????@R?FC?O?Z???ABD?@????A??H@?@ID?F??@?XJ]EMIKEIIIVV?@FTG?W@DUQ?BA??@C?VKO\G??ARJA??B@W@DB???B@?LB\[AQ??R?A??f@SV@?ATF??Q?^G?AAIG????^K?V?@?COF??F??G?I@@C?LI@???FD??DB?F@?A@?MC?F@GYJ?A?B@?Z?C??]P?A?@@D?D?OQ?G@CB??X?KCG???CPP??@@DC??S?@LBPA?\@D?A????@BR?@[@?EB@?Y?LTM?[Y?E?@ZCB?E??VXc@?@?LXIB??MALG?QYB@@DBP???RCLBX?@F\P???Q?`@B?[@AEW?????GLB?VGf@?IPL???LRCG?@D??U???TP?ACDM\?JB???Q@F_@???H@UB???[@LB?@??MB@C??MSY??@P?@?DBE??QBSX?J?R@@CI?P?`@?@?AR?DH?@B?A??G?B?@?O@D???CK?LIBP[\??M?DG??M?BV?@M????XCBJQUSG?RC??@?A?@BOC???AZ???@TP?H?@?R@M??@?A@FU[?YP????@HG?BJRV?????@?AD?G??@??F???CCM@?A?R@RM?RZ?F@Z??U?@?S?T@?Y@R?R?Q?DJT@JUXA???@@D?\B?Q`@S???@D?W?PB?GV@L???\?DDVO?AYF???@Wc@?G???X?AQ??^@C?FK?I?@???V@D?M??@?[@PC??X?Q?OFf@K?D??@KVV?EE]EIBEIAL?@L@H?ED?BB_@??AM@H?A@K?FT?c@???@?`@V@?IB?@???H@?EWJLP?FM@?S?@??C@DFS?@??@?\ABH?@TS?A@???[??H`@D`@R?@???f@??A_@ADBQ@@D?????C?@TE?@@MQL?D?V?MTAW@@D???R\??S?CG?@???M??[SB?_@?@??AM??@f@?H@GYQ?EP??@@D?IW?@?F?I??@BCF?I[???O?@d@AEG?Ff@????A??@?_@?HR?@??O?UQ@@@D?@?L?OR???@@??@@C?????@U`@@D?GHB?PE??A@E?@W?F??B??I@@?FI`@?S??J??@@C??C?BM??L?@G??@I@B??JB@W@C????WTAE?A@G???OC?VH??@FBW@C???CJ??H@?PGJQ??@@DIB@??WLB??J@Z?P?B@IQ??J`@CVO?M@@UKJB??\??B?@@D@LT?A[?A??P@@@AI???D????@`@a@JL?R@c@AI?U?W@??AP?@J?Q?C@C?S?F@@IB???G??WP??@U???GWc@?PTQ@??@PRL@@S?Q@@D?????H`@@CI?@??J?DP?_@?G?F@?A???@?@??WA??P?K?@?`@a@JB]?????F??@?WX?APO??@??@PDGF????H@??A@?ZC?A?A??B?@BZ@D?J??AR[?A@B?@@IB?B??R?@?W@C??@???VVKBIE]EEBEEKPP@?@??@F?E?@???F?@I??DS?@D??U?@???A@B?@??I@?CR??D?U@?A@??@?U@@D?BQ?@???A?@I?@???@GY?@KA????SD?T@??@SJ@??@???@[@?O@??JC?W?A@??@@C???@L??@LB?@???D?[HLXP?S??@??@ST?@@?F??O?XD??@B@KBB????@@D@M@LB?A???@?@O@?A?V???D??@?A???@LB??@@??B?QBK@Q?D?@?A?T?O@@??A?@??????@@C??GD??A?JA?@B?@?A@R?A?C??A@Q?OD???@I@BI@?@?H?K?BP@O@AE@@????????@AM@D???A??SF@@K??@??Y??L??H@?D???@?A@???@?@D??L@???@??A@?@?@?H?BM?F@@?HD?@????FSLB@?@T?@??F?BQ?@@DG????@????M@S@I????@D???DK@?AED?@?I??A?BJ?@?@@?HR@H?MSJ?@CCH?@??S???A@@?????A@?J@???H?D???@??S?@?@??????A@MP@??C@DS?B?@?@UDR??@A???@@D?@K?C?A??H?@?@?BF`@I????G@?@A??@??EB?K@?@?U??ADRQFI?@?@@DA@?????@C???@?D?A?T@D????@Wc@S?P?@@?AB???@_@??A??IDB?OJ@VV@EEEECEEEEB@?A?@@???FM?D@?AFB@???@??A@?@??@DM???EDKC?A?@???@?K??@K@????R?ACBQDK?@@D??HB@??BK@??@????CK?@?D??@?A???C?H`@@C???W???K@CG?@?K?@??A??@?WD@C?????R?CJB@@?V??F????@QD?S?A@?UQ?K@?A@??C?D?A???@?D?@?H?Qd@???@OA@??@?F_@?A??QC@??A?@?J?L?@C@D???@M??QF?D?@A??A?@A?Q?@?CDGO??@???FL??D@???A@??K?P@C?AQ?@@F?M?H?BD??C??A@???B?@??@D?@??PPBM??C??@@?H???@?@???CW??I?@B?TID?O@??R????@@M?C?A?@???B@ICBL@??C??A??T@C?A@??P??OJD@D?@??GOA???T@?@?Aa@???A?CJ?CWS?D????FA@U@??@@?C??I?J@C?F??@@?BQSQJ@??HC?HD??J?@?@?F?R@@??LBH@????CDGQS?J@?@?A??@?Q?a@IB@???D?@?AQ??@@?Q?A?@????K@C@D???DK??A?@I@??@@?C???O@?C?A?^?@??SJO?@??@??HC?L??A@??CW??@K???F@??@??DP@??OJ@B???CGUD?IQ?@D???@R?@@C?S?@L?OC]VK?EEEEVEEBACL??@@?@AU?TJ@?BKJI?@B@??J@DL???B?@@D??@I@R??FQH@??@@CB??@?B@??D?@A??@EB?@K@??@_@G????A@??@\@?B@?T??A?@@??T@@C????I@@D???@?L??HGY@O??P@?A??`@?@@?ABF?@MJ?@?@?DB???@??H??@@?UTIP?@??F?@@CXB???@???A?@I?@OJU?@???@J?@@D?P?@?Q?BKK@@?J?BM@??K?@@?A??J@@A??A?@?BLQ?@?@D?R??@B?AQ?@@?B?R???@???@@?A?V???@BKJ?@?@?JTE??@K?@A?A@D???@?LP?@?Q@????A?@?Q@??@?FM?@G?J?H@?LBH?@@?AU@@???MFL?E@?B@FI@?BL?B@?ECV@FQ?????AP@?@?@?ASER?D??@?@D??A??[?P???@@??FHI?@???@T@@D???@???@C?Q?@?UFI@J@????T@D\U?J@?@???A?@I@FIE@??A??@d@@??L@@PR????@APJ@@D?F?@??@?CABB@??@O?S?@?CSBK?@????@T@?@A@???H???A?@@?R?@A??Q?H@I@@DJ?@?B???A@?S@M@?A?I??@H@?@D\PM??F?@@C?PI@?D??F??_@@IBP@Wc@???B?@[@LQ?@???OF??@GQ?R@]V?KIEVEEEEBAP\?@?X??FO??@??@D[????M?H@A?@EIf@?AD?AE?@?@?H?A??D?@?a@@D?HM?GE@D???@???ABW@????@@D?M?SV?@D?J?@????AB]?@??J@\@?????XJ@U????@^@B?C?H@?L??@D?GT??@??AQ@?@J??GA?????@?@@D??WA??TII@B@??VO?@F???@@LB?E??@??V@D??@?TO???A@?T@@U?R?H??@?@O@D?Q????@?H?@G@A?HE??????G@@D?A????@?AAG@@??H?R??PG??@@D?D??T???AHG?@T?@?A?B?f@?G?A?@??JO?B@QGSG@B??H???G?M??@@DM@?T?GLBPH?@@?@?A???@?J?@_@C@??J??@A?IB@@G??A????J?@@K?@???IF@?AP@@?@?AM??BE@L?@M@???@?L@D??J?@?I@?H@B@A???@C???B@?TE@KO?G????@D?I@?BW?A???@A@?H@????A?@?c@@M?@?B???A??@@HB@D?J?????@@@D?@?AQ?O??A@I@@??F??K???@@@D??VHO????AE@@??@?A??@?R?@@D?B?@?A?@HL?@C??H@@C?????@@BK??@G?HFI?@?B?T?@GY??@?F?@?A??a@\H?@D??U?L@??@DG?@??Q??]IVHEEEVEBEEE@MT@@BK??L?Ea@@?AQ?@SI??@?@D???O?TB@X@@@L??P??B?U@@@?A??SD?U?@@?D@???A@?A?Y?@@LB??????@@@?@?AKIQ???@D?@@???AU???Y?H@@@D?T?L???@@C@?@?FOSHB???@@?@A???B[??KEB@?@?JP??@A??JB@?@?FB@Q???@@D??@?O@OF???T@_@??@A???B???@?Aa@@?@B?ALB?J?@@?@@D?PBO??@?A@J@??XP???SP@@E@BK?CK???@?@ALK?@@?A??B@MI?^?@HHI?T[A@?DF?B@Q??@?@A?NANBNCNDNENFNGNHNINJNKNLNMNNNONPNQNRNSNTNUNVNWNXNYNZN[N\N]N^yA[zA]t@\{A^tAJuA_@vAOwA`@Na@Nb@Nc@u@]xAd@Ne@Nf@Ng@Nh@u@i@Nj@Nk@Nl@Nm@Nn@No@Np@~AH_Bj@`Bl@bBq@Nr@Ns@Nt@eBk@aBm@cBo@w@h@iBl@fBr@Nu@Nv@Nw@Nx@Ny@Nz@N{@sAGN|@sB|@lBm@jBp@y@n@dBp@tBo@kBHy@q@gBu@x@}@v@h@uBp@|AKN_@}A~@N_Ao@`ANaANbANcANdAo@r@mBv@nBx@pBz@rBEm@s@hBE{@t@~BEj@_@vBExBaANeANfANgAo@hANiANjANkAw@lANmA|@bAyBdAm@u@x@w@oBy@qB{@}@nANoAgCcAj@pANqAlCqAj@rANsANtANuANvANwANxANyAmCE}@v@{By@iCE|@eANzAN{AbCiAcCkAk@}@v@lAfCEtCjAdCp@_CNr@PN`@N|An@c@kCdAk@}AN~AN_BjCoAnCsAN`BuCp@NlAvCg@j@LNaBNbBNcBwCkA_AzAsCEaDp@`Ah@bAlA_AfAm@dBNeBNfBNgBbD{Az@h@bAh@l@tAoCvAqCxAp@aB`DcBcAhBxClAhDEcAeBfDgBt@iBNjBNkBNlBNmBz@lAjDHpDfBgDp@iDHk@w@hCz@yCON~@dAjBrDlBuDgBeCmA`AlAgAPzC|An@HdDmAeDgAyDp@_DmAiAlA{DmAgA~@tDmAl@nBNoBoDmAjApBqDp@xDkBsDmBcDHvDx@|B{@mDbBl@qBNrBNsBNtBNuBl@`B~ClAbEEl@vBNwBNxBn@yBlEwBmEb@NyB|C~A}CEkDuApCwArCyAk@zBwBHlA{BN|Bk@}B`EmAaEElAvAlDyAtEEdEfBfAh@gEcBjAoBcEEiAh@vEgBzDEp@MsE|ByEH|D`@{Cb@|E|A~Eb@fElB{ENr@~@wEkAzEp@aFOwDEoExBnDkAmAHm@~BN_CN`CNaCrEcBnAlA{@bCeF_CfFaCj@cCeEh@iFEdFp@oA~@mAEpAlAjF`CgFEbFp@_EEmFmAp@dCNeCnFaCnAh@`FmBlFEuEwAkFfBfAlA_FHtFxAhFmArFEpAh@oFlApFExFHqFeCcFb@~DEuFgB{Fp@qAlAkEjA|FmAhErBiEtByFmAzFyB_GsBjEuBsFH}FkA~FEqAh@`GEwFEbGp@cGHvFyAaGtBrAlAeGmAoAP}Db@gG`@}EHrAh@hG|AjGb@dGuBfGEiGHkGHdAfCNgCNhCNiC?jC</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??PY?CF?D??E??`??w@?D??E??`@?_B?F??G??@D?[A?H??A??A?????I??C??@M?KC?J??K??@D?_G?L??A??A?????I??C??pS?WC?M??N??@U?wL?F??O??PJ?sC?F??P??Pf?cJ?F??Q??`L?sL?R??S??@A?SG?R??S??`C?gG?R??T??`E??K?U??V??`B?c\?U??W??@D?G]?X??Y??@c?_O?X??Z??pSA?U?[??G??`@?wS@\??G??pH?CD@]??^??PC?KD@X??G??@A?KB?_??A??A?????`??C??pA?Cs?a??C??P@?kf?b??c??@V??F@d??C??pB??O?e??A??A?????F??P??@o?oJ?f??g??@D????h??i??P?????j??k??@B?__?l??k??@?????U??W??pH?S]?U??m??`l?gb?U??n??@S?Cd?o??p??@C?C[?q??r??p@?Co?d??C??pH?_O?s??t??@@?k`?u??C??@B????v??w??p??CH?v??x??p??sH?D??y??pB?wB?z??{??@C?SF?L??|??PI?ShAD??y??PG?GC?}??y??@B????~???@?PJ?gB?~??@@?PI?WE?~???@?@M?oB?A@?B@?@A?S@?C@?G??pI?_D?o??D@?`??cN?E@?D@?`B?sr?E@?F@?@G?OM?G@?H@?P??C\BI@?A??A?????C@?G??`J?_D?R??T??P??sJ?A??J@?B?????}??y??pB????F??K@?@W?GN?F??L@?pA?gO?M??M@?P??WH?N@?A??A?????F??L@?`??cO?C@?O@?PM?CJ?P@?A??A?????}??y??@A????z??Q@?`???J?z??R@?`N?GG?L??|??`@?SfAq??r??@C?Co?G@?S@?PI?wmBA@?B@?@??S@?C@?A??A?????F??P??Px?GK?F??T@?pL?_G?F??P??@A@sK?F??U@?PD??H?v??y??pu??H?V@?W@?pB?gF?V@?X@?`@?GE?d??G??p@?_H?Y@?Z@?@B?KY?s??A??A?????C@?O@?`N?CJ?P@?G??`@?GA?[@?i??@A????C@?G??PG?_D?o??G??p??WE?E@?G??@B?_D?v??y??pD?OE?F??Q??@T?wL?z??G??@O?[D?\@?A??A?????~???@?`I?gB?~??]@?p??[D?z??^@?pH?gN?z??_@?@L?CT?~??]@?p@?[D?b??c??`E?GE@b??`@?pc?WA@a@?b@?@D?OY?c@?d@?`B?gc@e@?A??A?????v??y??`i?_G?A@?f@?`B?SA?A@?f@?`??CA?v??y??`g?[G?v??g@?P@?{J?h@?i@?P@?G@?j@?k@?pD?cB@j@?A??A?????v??y??`t??H?l@?m@?p@????n@?i??P?????o@?A??A?????C@?G??pA?WD?V@?X@?@??GE?d??A??A?????C@?G??PF?_D?~???@?@K?gB?p@?q@?PA?c??p@?q@?P@?s@?R??O@?@@?[K?~??@@?`??CE?F??P??pr??K?F??Q??pM?wL?z??A??A?????b??`@?@`?SA@r@?s@?pA?[w?t@?u@?`f?oV?v@?w@?`@?OP?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1799952983;
    let startMs = 1666883048889;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","one.nio.server.AcceptorThread","run","one.nio.http.HttpServer","createSession","one.nio.http.HttpSession","<init>","byte[]","one.nio.server.SelectorThread","one.nio.net.NativeSelector","select","java.lang.String","one.nio.net.Session","process","processRead","processHttpBuffer","parseRequest","one.nio.util.Utf8","read","toAsciiString","java.lang.invoke.MethodHandleNatives","linkMethod","linkMethodImpl","java.lang.invoke.Invokers","methodHandleInvokeLinkerMethod","invokeHandleForm","java.lang.invoke.LambdaForm$Name","java.lang.invoke.LambdaForm$NamedFunction","java.lang.invoke.MethodType","invokers","java.lang.invoke.MethodHandle[]","java.lang.Thread","java.util.concurrent.ThreadPoolExecutor$Worker","java.util.concurrent.ThreadPoolExecutor","runWorker","java.util.concurrent.FutureTask","java.lang.Class[]","java.lang.invoke.LambdaForm$MH.0x0000000800d48800","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800ca0000","newInvokeSpecial","java.lang.invoke.DirectMethodHandle","allocateInstance","jdk.internal.misc.Unsafe","varHandleOperationLinkerMethod","getVarHandleGuardMethodName","java.lang.StringBuilder","toString","java.lang.StringLatin1","newString","java.util.concurrent.Executors$RunnableAdapter","call","ok.dht.test.vihnin.ParallelHttpServer$$Lambda$158.0x0000000800d4cf48","ok.dht.test.vihnin.ParallelHttpServer","lambda$handleRequest$2","handleForeignRequest","handleRequest","one.nio.http.Request","getPath","substring","RequestHandler2_handlePut","ok.dht.test.vihnin.ResponseManager","handlePut","convertData","ok.dht.test.vihnin.ServiceUtils","emptyResponse","one.nio.http.Response","append","java.lang.AbstractStringBuilder","ensureCapacityInternal","java.util.Arrays","copyOf","one.nio.net.NativeSelector$2","no_Java_frame","sendResponse","writeResponse","write","one.nio.net.Session$ArrayQueueItem","toBytes","one.nio.util.ByteArrayBuilder","getRequiredParameter","getParameter","copyOfRange","startParsingRequestBody","handleParsedRequest","java.util.concurrent.AbstractExecutorService","submit","newTaskFor","java.util.concurrent.Executors","callable","java.lang.invoke.LambdaForm$DMH.0x0000000800d49400","java.lang.String[]","getTimestamp","getHeader","trim","getTask","java.util.concurrent.ArrayBlockingQueue","take","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject","await","java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode","getHeaderValue","getShardId","ok.dht.test.vihnin.ShardHelper","getShardByKey","java.lang.Integer","valueOf","java.lang.invoke.Invokers$Holder","linkToTargetMethod","java.lang.invoke.DirectMethodHandle$Holder","ok.dht.test.vihnin.ParallelHttpServer$$Lambda$158+0x0000000800d4cf48","ok.dht.test.vihnin.database.DataBaseRocksDBImpl","put","java.util.concurrent.SynchronousQueue","poll","java.util.concurrent.SynchronousQueue$TransferStack","transfer","java.util.concurrent.SynchronousQueue$TransferStack$SNode","tryCancel",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
