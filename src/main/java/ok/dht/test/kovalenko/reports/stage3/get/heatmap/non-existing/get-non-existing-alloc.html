<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BMp\AnArEcHnHpJ|KzLkPhRcSoXu[g_B???????????????????????????????????????????@??@??G?G?????@???????GG?????@G@?OG@?????O?????G?P?O?G@?@?GG@??GG?G@?HGH@?GH????@??H?G??@?HGGA?@O?@?G?@??O@?I????B@HG?@G@??G??G???OGH@?OGA??@@????W?@@G??@GO?H@G@O??IA???@G??@G?AGG@GHA?G@@@????O??????@???@HH?G???G@?@G?H?@???????GG?@G?@OG?G??GG?GGHG?@??@G?@?????@G?HG?GG?G?G@?@??GA@G??@@??AG??W@A?????@???G??GA?GAG@A??W@????@OH?@??H????WGG?A??G@?H??@??GG??@?@??@GG???H@??H?@??????@?G??G???@???O?GGGG??G?@G??@HHHG?X@H??@?G@G?A???G???@?@G?I???@?@@??@@?@?O@????@?@A@?????@G?@@????W@???@?CG??@?B@?G??GA?G?G?G@?????@?GA???A??A?GH???G?@??@?G?GH?@O??GG@O???GG?G?G@???G??O?G??G????@@?G??OGOH@H???@?@@?????G?@??@G@?B????@?HG?GOH?G?@???@G???G??@?O??G????G?GG???@???G@G@GG????AP??G?@??@??HG?HG?@G@@@G?@?G????@@GHG??W????O?H?G?@@@??G?G@GI?G@??O???G@??@@???G?H@@????@O?@O?G?@@?@??HG???@O????G????O?@Q?@???G???@?@?G???GH@?GHG?GAHG@@?@@?@O???O??@?GA??????????G?G??G?@??G??@??H?@G??OG?@????@??G?G??@??????Q?????G???H??@A@??@??@?H@?@??GH???@GG?X??OGG?????G???H???@@?@@?G?G@H?A?GG?G@?????H?GG@???O?@@?H?????H@??G?G???G@??@???O@????GG?G?P?@?G??@?HG??O?G@??I@?@G?G@??G@?G?H?G??@?@@H??@HG??P?GGO??H@????H???@GG?@?G@???@??I????G??@G???PG?HA?@O???@AG??G??@H???@??@@@??GGG?G@?I???G@?G???@?GG???G?H@?@?A@@G???G????HH@@G?@?@GG???O?GG@???G?GH??G???@?W@@??@?G@@??@?G@??GGGGH@?@?G??@A??@?@?@?????@GGGG??GA@GG?????GG@?@??@J???@??@??OG@A?@?G?H@???G?????O??HG@????????G@@@@@G??@@?G??O??G?H??GG@G@@O?@??H?????QA??@G???@HG??@@????@?G??G@A@H?G?HG?????@@??P?O?GGG???@G?@O?@?G?@G@HG@GH?@@??GGHG????@??G@@??G???GGG@G?@?@A????O??X??HP@GGGG|gA|gAhdBwkAzrAxaBplAf|AudB}zAcpAn~AtrAfoBbuAgcBeqAmuAcwAocBbiBlnBo~BxjAnmAizAc|A}_Bt`BvdBftBvjAvpAd~AneBpfBriB|iBojB_mB}nBpjAkkAfmAvoArpAhvAyzAb`Bi`BecBofBsfBvgBalBcoBtvBaiA`jAblAilAmoAnqAurAruAqxA}yAhzAo}Ah~AtaBwbB`eBihBxjBckBykBboBfwB~wBj~BreCrhA`kA`lAgmAimAipAarAqrAqtA{tA|uApwAmxA|yAazA~zAq{Ab|Aq|As}Am_B``Bz`BlaBgbBqbBueBigBugBmhBnhBblB}lBbmBtmBzoB~oBrpBtrB{rB`sBbsBisBiuBlvBtwBs_CmbCzbCoeC`hAdhAehAkhAmhAnhAshA{hAkiAviAxiAojAtjAekAgkAlkAmkA~kAelAklAxlAcmAkmAvmAanAinAvnAznA{nA_oA`oAcoAjoAqoAzoAjpA_qAcqAxqA{qAlrA|rAcsAfsArsAwsA_tAatAdtAytA}tAjuA}uAcvAfvAjvAnvAsvAyvAewAhwA_xA~xAeyAwyAszAj{Am{Ag|Ao|Ar|A_}Ae}Am~Aa_Bd_Bj_Bo_B{`BgaBuaBzaBabBvcBcdBgdBmdBpdBdeB_fBcfBffBjfBxfBsgB{hBuiBajBjjBkjByjBbkBfkBylB`mBdmBfmBxmB{mB_nBgnBonBpnBsnBznBroByoB{oBdpBjpBbqBeqBkqBqqBvqBprBxrB}rB~rB{sBitBqtButBduBhvBawBcwBexBwxBazBtzB{zB_{Bc{Be{Ba}Bl}By~Bv_Cn`Cr`Cz`CcaCabCncCpfC~gC{hCfjCsmCanC}gA_hAbhAchAfhAghAhhAihAjhAlhAuhAvhAwhAxhAyhAzhA}hA_iAciAdiAeiAgiAhiAiiAjiAliAmiAniApiAqiAriAsiAuiAwiAyiAziA{iA|iA}iA~iA_jAajAcjAdjAfjAgjAhjAijAjjAljAmjAnjAqjArjAsjAujAwjAyjA{jA|jA}jA~jA_kAakAbkAckAhkAikAjkAnkAokApkAqkArkAskAukAvkAxkAykAzkA{kA|kA}kA_lAalAclAdlAflAglAhlAjlAllAnlAolAqlAtlAulAvlAwlAylAzlA{lA}lA~lA_mA`mAamAbmAdmAemAhmAjmAlmAmmAomArmAtmAwmAxmAymAzmA{mA|mA}mA~mA_nA`nAbnAcnAdnAenAfnAgnAjnAknAlnAmnAnnAonApnAqnArnAtnAunAwnAxnAynA|nA}nA~nAaoAboAfoAgoAhoAkoAloAnoApoAuoAwoAyoA{oA|oA}oA~oA_pA`pAapAbpAdpAfpAgpAhpAnpAopAppAqpAtpAupAxpAypAzpA|pA}pA`qAaqAdqAfqAhqAiqAjqAkqAmqAoqAqqArqAsqAuqAvqAzqA|qA~qA_rA`rAcrAdrAerAgrAhrAirAjrAmrAnrAorAprAsrAwrAxrA{rA}rA~rA_sA`sAasAbsAdsAhsAisAjsAlsAmsAnsAosAqsAtsAusAxsAysAzsA}sA~sA`tActAhtAitAktAltAmtAntAotArtAstAttAutAvtAwtAxtAztA~tAauAcuAeuAfuAguAhuAiuAkuAluAnuAquAuuAwuAxuAyuAzuA{uA`vAavAbvAdvAevAivAkvAlvAmvApvAqvArvAtvAuvAwvA{vA|vA~vA_wAawAbwAdwAiwAkwAlwAmwAowAqwAswAtwAvwAwwAxwAywAzwA{wA|wA}wA~wA`xAbxAdxAexAfxAgxAjxAkxAlxApxAsxAtxAuxAvxAwxAxxAyxAzxA{xA|xA_yAcyAgyAiyAjyAlyAmyAnyAoyAryAuyAyyAzyA{yA_zA`zAczAezAfzAgzAlzAnzApzAqzArzAtzAuzA{zA|zA`{Aa{Ad{Af{Ag{Ai{Ak{Al{Ao{As{At{Au{Aw{Ax{Ay{A{{A|{A}{A~{A_|A`|Ae|Aj|Ak|Am|Ap|Av|Aw|Ax|Ay|A{|A||A}|Aa}Ac}Ag}Ah}Aj}Ak}Al}Am}Aq}At}Aw}Ay}A{}A}}A_~Aa~Ab~Af~Aj~Ak~Aq~Ar~As~Av~Aw~Az~A|~A}~A__B`_Bb_Bc_Be_Bg_Bh_Bi_Bl_Bn_Bp_Bq_Bs_Bt_Bv_Bx_Bz_B{_B|_B_`Bc`Bd`Be`Bf`Bg`Bh`Bk`Bl`Bp`Br`Bs`Bv`Bw`By`B}`B~`B_aBbaBcaBdaBeaBfaBiaBjaBkaBnaBoaBqaBraBsaBvaBwaB|aB~aB_bB`bBdbBebBibBjbBpbBsbBtbBubBvbBxbB{bB_cB`cBacBbcBccBdcBhcBncBpcBrcBscBucBwcBycBzcB{cB|cB_dB`dBadBbdBedBfdBidBsdBtdBzdB~dBaeBceBeeBfeBgeBheBjeBkeBleBmeBpeBqeBreBseBveByeB}eBafBbfBdfBefBgfBifBufByfBzfB|fB~fB_gBbgBdgBegBggBhgBjgBlgBmgBogBpgBqgBrgBtgBygB{gB|gB~gB_hB`hBbhBehBfhBghBhhBjhBphBqhBrhBthBuhBwhByhBzhB}hB_iBaiBciBeiBfiBiiBkiBmiBoiBqiBsiB_jBdjBfjBgjBhjBijBljBnjBqjBrjBsjBtjBujBvjBwjB{jB|jB`kBekBhkBjkBkkBmkBukBvkBxkBzkB{kB|kB~kB_lB`lBdlBelBflBglBhlBilBklBmlBolBqlBrlBslBulBzlB|lBcmBemBjmBlmBmmBomBqmBsmBwmB}mBanBcnBenBhnBinBknBmnBnnBqnBunBwnBxnB|nB~nB`oBaoBioBloBpoBqoBtoBvoBwoB}oBapBbpBcpBepBgpBipBlpBnpBopBppBtpBupBwpBypBzpB{pB~pB_qBaqBcqBgqBhqBmqBnqBoqBsqBuqByqBzqB{qB|qB}qB~qB`rBcrBerBfrBhrBirBkrBlrBnrBrrBwrByrB_sBasBdsBesBgsBksBlsBnsBwsBxsBysB}sB~sB`tBatBdtBhtBktBmtBptBrtBttBvtBwtBxtBztB{tB~tB_uB`uBbuBcuBfuBhuBluBnuBpuBquBruBsuBtuBvuBxuBzuB|uBavBdvBfvBivBjvBkvBmvBovBpvBqvBrvBsvBwvByvBzvB|vB}vB_wB`wBewBhwBiwBjwBmwBnwBqwBrwBswBxwBzwB{wB}wBbxBixBlxBnxBqxBrxBsxBuxBxxB|xB_yBayBcyBeyBgyBhyBjyBkyBlyBmyBoyBpyBryBtyBuyBvyBwyBzyB|yB}yB`zBczBdzBfzBgzBizBnzBpzBqzBvzBwzByzBzzB}zBa{Bb{Bd{Bg{Bh{Bj{Bl{Bn{Bo{Br{Bu{Bv{Bx{By{Bz{B|{B}{Bd|Be|Bh|Bj|Bk|Bm|Bn|Bp|Bs|Bt|Bu|B}|B_}B`}Bc}Bd}Bf}Bh}Bk}Bm}Bt}Bv}Bx}Bz}B{}B|}B}}B~}B`~Bb~Bc~Be~Bf~Bh~Bk~Bm~Bn~Bq~Br~Bs~Bx~Bz~B|~Bb_Ce_Cf_Cg_Cj_Ck_Cn_Cp_Cr_Ct_C{_C~_C_`C``Ca`Cb`Cd`Ce`Cf`Cg`Cm`Cp`Ct`Cv`Cx`C|`CeaCfaCiaCjaCqaCsaCvaCwaCzaC|aC}aC~aChbCjbClbCobCpbCubCwbCxbC}bC_cCacCbcCecChcCjcCkcCqcCwcCxcCzcC{cC|cC}cC~cCddCldCsdCtdCudCwdCydC~dC_eC`eCbeCkeCmeCqeCseCueCzeC{eCbfCdfCefCjfCkfClfCsfCyfCzfC|fC}fC~fCbgCegChgCkgCngCogCpgCqgCugCxgCygC|gCchCehCghCjhCmhCqhCthCuhCvhCzhC~hC`iCbiCgiChiCkiCliCriCviC{iC}iC_jC`jCajCjjCljCmjCvjC{jC~jCnkCskC_lCdlCglCjlCklColCimCjmCmmCrmCzmC{mC`nCdnCfnClnCnnCunCynC{nCioCnoCooC{oCbpCdpC~gAahAohAphAqhAthA|hA~hA`iAbiAfiAoiAtiAbjAejAkjAzjAdkAfkAtkAmlArlAslA|lApmAqmAsmAumAhnAsnAdoAeoAioAooAroAsoAtoAxoAepAkpAlpAmpAspAwpA{pA~pAbqAgqAlqApqAtqAwqAyqA}qAbrAfrAkrArrAvrAyrAesAgsAksApsAssAvsA{sA|sAbtAetAftAgtAjtAptA|tA_uA`uAduAouApuAsuAtuAvuA~uA_vAgvAovAvvAxvAzvA}vA`wAfwAgwAjwAnwArwAuwAaxAcxAhxAixAnxAoxArxA}xA`yAayAbyAdyAfyAhyAkyApyAqyAsyAtyAvyAxyA~yAbzAdzAjzAkzAmzAozAvzAwzAxzAzzA_{Ab{Ac{Ae{Ah{An{Ap{Ar{Av{Az{Aa|Ad|Ah|Ai|Al|An|As|At|Au|Az|A~|A`}Ab}Ad}Af}Ai}An}Ap}Ar}Au}Av}Ax}Az}A|}A~}A`~Ac~Ae~Ag~Ai~Al~Ao~Ap~At~Au~Ax~Ay~A{~A~~Af_Bk_Br_Bu_Bw_By_B~_Ba`Bj`Bm`Bn`Bo`Bq`Bu`Bx`B|`B`aBaaBhaBmaBpaByaB{aB}aBbbBcbBfbBhbBkbBlbBmbBnbBobBrbBybBzbB|bB}bB~bBfcBicBjcBkcBlcBmcBqcBtcBxcB}cB~cBddBjdBkdBldBndBodBqdBrdBwdBxdBydB{dB|dB}dB_eBbeBieBoeBteBweBxeBzeB{eB|eB~eB`fBhfBkfBlfBmfBnfBqfBrfBtfBvfBwfB{fB}fB`gBagBcgBfgBkgBngBwgBxgBzgB}gBahBchBdhBkhBlhBohBshBvhBxhB|hB~hB`iBdiBgiBhiBjiBliBniBpiBtiBviBwiBxiByiBziB{iB}iB~iB`jBbjBcjBejBmjBpjBzjB}jB~jB_kBakBdkBgkBikBlkBnkBokBpkBqkBrkBskBtkBwkB}kBclBjlBllBnlBplBtlBvlBwlBxlB{lB~lBamBgmBhmBimBkmBnmBpmBrmBumBvmBymBzmB|mB~mB`nBbnBdnBfnBjnBrnBtnBvnBynB{nB_oBdoBeoBgoBhoBjoBkoBmoBnoBooBsoBuoBxoB|oB_pB`pBfpBhpBkpBmpBqpBspBvpBxpB|pB}pB`qBdqBfqBiqBjqBlqBpqBrqBtqBwqBxqB_rBarBbrBdrBgrBjrBmrBorBqrBsrBurBvrBzrB|rBcsBfsBhsBjsBmsBosBpsBqsBrsBssBtsBusBvsBzsB|sB_tBbtBctBetBgtBjtBltBntBotBstBytB|tB}tBauBeuBguBjuBkuBmuBouBuuBwuByuB{uB}uB~uB_vB`vBbvBcvBevBgvBnvBuvBvvBxvB{vB~vBbwBdwBgwBkwBlwBowBpwBuwBvwBwwBywB|wB_xB`xBaxBcxBdxBfxBgxBhxBjxBkxBmxBoxBpxBtxBvxByxBzxB{xB}xB~xB`yBbyBdyBfyBiyBnyBqyBsyBxyByyB{yB~yB_zBbzBezBhzBjzBkzBlzBmzBozBrzBszBuzBxzB|zB~zB`{Bf{Bi{Bk{Bm{Bp{Bq{Bs{Bt{Bw{B{{B~{B_|B`|Ba|Bb|Bc|Bf|Bg|Bi|Bl|Bo|Bq|Br|Bv|Bw|Bx|By|Bz|B{|B||B~|Bb}Be}Bg}Bi}Bj}Bn}Bo}Bp}Bq}Br}Bs}Bu}Bw}By}B_~Ba~Bd~Bg~Bi~Bl~Bp~Bt~Bu~Bv~Bw~B{~B}~B~~B__C`_Ca_Cc_Cd_Ch_Ci_Cl_Cm_Co_Cq_Cu_Cw_Cx_Cy_Cz_C|_C}_Cc`Ch`Ci`Cj`Ck`Cl`Co`Cq`Cs`Cu`Cw`Cy`C{`C}`C~`C_aC`aCaaCbaCdaCgaChaCkaClaCmaCnaCoaCpaCraCtaCuaCxaCyaC{aC_bC`bCbbCcbCdbCebCfbCgbCibCkbCnbCqbCrbCsbCtbCvbCybC{bC|bC~bC`cCccCdcCfcCgcCicClcCmcCocCpcCrcCscCtcCucCvcCycC_dC`dCadCbdCcdCedCfdCgdChdCidCjdCkdCmdCndCodCpdCqdCrdCvdCxdCzdC{dC|dC}dCaeCceCdeCeeCfeCgeCheCieCjeCleCneCpeCteCveCweCxeCyeC|eC}eC~eC_fC`fCafCcfCffCgfChfCifCmfCnfCofCqfCrfCtfCufCvfCwfCxfC{fC_gC`gCagCcgCdgCfgCggCigCjgClgCmgCrgCsgCtgCvgCwgCzgC{gC}gC_hC`hCahCbhCdhCfhChhCihCkhClhCnhCohCphCrhCshCwhCxhCyhC|hC}hC_iCaiCciCdiCeiCfiCiiCjiCmiCniCoiCpiCqiCsiCtiCuiCwiCxiCyiCziC|iC~iCbjCcjCdjCejCgjChjCijCkjCnjCojCpjCqjCrjCsjCtjCujCwjCxjCyjCzjC|jC}jC_kC`kCakCbkCckCdkCekCfkCgkChkCikCjkCkkClkCmkCokCpkCqkCrkCtkCukCvkCwkCxkCykCzkC{kC|kC}kC~kC`lCalCblCclCelCflChlCilCllCmlCnlCplCqlCrlCslCtlCulCvlCwlCxlCylCzlC{lC|lC}lC~lC_mC`mCamCbmCcmCdmCemCfmCgmChmCkmClmCnmComCpmCqmCtmCumCvmCwmCxmCymC|mC}mC~mC_nCbnCcnCenCgnChnCinCjnCknCmnConCpnCqnCrnCsnCtnCvnCwnCxnCznC|nC}nC~nC_oC`oCaoCboCcoCdoCeoCfoCgoChoCjoCkoCloCmoCpoCqoCroCsoCtoCuoCvoCwoCxoCyoCzoC|oC}oC~oC_pC`pCapCcpCepCfpCgpChpCipCjpCkpClpCmpCnpCopCppCqpCrpCspCtpCupCvpCwpCxpCc\?????????x@?ADUD?????uA????h@???VHAAx@?B?????AA???????OAHD??????B????A?AA_E???????LAuA??x@??ObB??AmQgQEA?A?AEA?B???{@A?NaI?D?E?qNA?uA?N?x@???j@??Dn@??N???@BJ?QGG????G?H??VfA?{AA??fB?????tDvV@??Hh@@?cBH?@R??@@??R?}E?@EmB?@@??lT?@@wE?t@jBAxXvRQ??t@????@?kBkE@?aBeA@@kFBF?|@?e@?MMkFpA??F????A?aB|@F?pA@??G{@?qBOD?DA?JkA??V??H?ASLf@?Fe@U???MA@@sB?@????`UlVF??dAlB??dAEeAASuE@H@??OkA?rW?`E@GN?B?f^l]@??@hAEDL?@?A??@@fA@jAUj@@?f@?@kAa^H?RgF?fB??FBSQ?`EMwBsBtDEHR?jAGBe@?FE?An@wOG??A??Ly^{At@cZ??@@V?N?@Vf@qBQqGlBiV?B@?????{^wB?@ya@?e@?@Gq@b@??zMwYB?@??J@Shb@@???zA?BkBOF@HF@@kBRu_@n@qPHA?xFN?|@T@fBBAARA?f@A???@dA?FtM@?nAjBb@?U?@?A?zb@FM@J??kE?BmBw^M@@@e@@@e@h[?G@?@@}]?QAj@?mE?nA?cB???_XL?`\?kUpV??@`G?wB@@R@???v@SBwEq@A?h@ADxG?AFt@sGB@sG?bBvGDlBeAEUJF@??T@@V????hAtGE@?~B?@b@oc@t@?zA?tGm_@JuE@~BqGxG?@}E|Q??gA???B@?Q_Vz`@@hASJaB@xFq@?M??iFJ@q@??}AdA??b@?zATb@dY~D|b@Ab@@~Bmd@AhA@Sjg@?{@|BmEgF?v@?Lv@eAbB@{@TcB@pAx`@?L?p\?jf@?@oa@?db@f@?}Z?@?D@@fA?k`@yG?nA@O@`G?fTyGL@?EgA?z_@OA?Gq@@|BTj@?N?_Cv@?A?A?J??MAvG?gd@T{d@??@jA??rI_H@?n@}A_H?nA~D?@B?A}GjAj@E?E`h@le@qBse@MjY@ig@}\B@??jd@@?S?@gAie@}A?Q??mBkb@?OU?A?_CsB@v@@G?|BADsTkc@?ud@aH?@G?h@@_Ech@__@lFD?iFQ?AD@~h@n@aHN@?@@R?gg@bH?kA{h@uWB?@bH{Ah@|@@HFDlFV?L?E??mg@UG?T`b@@~g@?mf@Jji@?BfA_CgAjBph@Tf@?}G?wh@fi@?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?VcHBdHW?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@hCC?WmHYoH[qH]iCd@?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@?o@?p@w@WuHZpH\rH^?q@?r@?s@?t@?u@?v@?w@?x@?y@?z@bIXnHZcI]iCq@lC{@?|@?}@?~@?_Aw@`A?aA?bA?cA?dA?eA?fAbCGcCgA?hA?iAg@jA?kA?lA?mA?nA?oA?pA?qA?rA?sAbCtA?uA?vA?wA?xA?yAvIeA?zA?{A?|A?}A?~A?_Bw@DfHHdC`B?aB?bB?cB?dB?eB?fB?gB?hB?iBw@jA]jB?kB?lB?mB?nB?oB?pB?qB?rB?sB?tB?uB?vB?wB?xB?yB?zB?{B?|B?}B?~B?_C?`C?aClIYvH\kCq@lCs@fIu@hIw@jIy@pJkA?jBrJlBtJnBsCpBrArBy@tByJvBzJxB|JzB}J|B~JbC?cC?dC?eC?fC?gC?hC?iC?jC?kC?lC?mCaKZmI^?nC?oC?pC?qC?rC?sC?tC?uC?vCqCGcCI?`BiJbBkJdB?wC?xCi@fC?yCtAiCxCzC?{C?|C{KHhJaBjJcB?}C?~C]_D?`Dg@aD?bD?cD]lAvCjBgKmBuJoBvJqBwJsBxJuBtCwB{JyBz@{BuC}B?bC?dDzCeDqKhCrKjC?zCeL|CuK[wH^?d@xHf@zHh@jCfD?gD?hD?iD?jD?kDaD\kCd@{Lg@{Hi@?lD?mDnC{AeJ}AgJ_BpLkBsJmBqLpBiKsBsLvBlKyB}C|BwCnD?oD?pD?qD?rDzKiB`M]nIr@eIt@gIv@iIx@kIz@gLI}KaB{CdBmJsD?tD?uD?vD?wDmM^dIr@nMu@dKx@cMlBhKoBrLrBjKuBtLxB?xD?yDqCEeHG|KJhHLjHNeCzD?{D?|D?}D^mBdMqB|CtBkKwBuLzBnK}B?~D?_EoJiBsIaAtIcAoCfAwIH?gA?`EnCfA?jAoLmA|IoA}IqA_JsAaJuAbJwAdJyAoCzApC|AfJ~Ak@q@bKt@oMw@eKz@_NnBsCaE?bE?cEdDdE?eE?fE?gE?hE?iE?jE?kE?lE?mE?nE?oErNoBwMsBeMwBbN{BuCpE?qE?rE?sE?tE?uE?vE?wE?xE?yEkND?tAqAzE?{E?|E?}E?~E}@pBdDtBaNxBmK{B~CbC?nDiMpDkMrDhOqB`NuByMyBgM}B?_F?`F?aF?bFeD`B~KcBlJeB?sD?cF?dFpObFvAr@uMv@pMy@k@d@aMh@jCj@?eF?fFnDrBxMvBfMzB?gF?hF?iFrOaB{C}CiLkA?_DkLfA?aDmLcDqJjF?kF?lF?mF?nFg@oF?pF?qF}ObB_LeBsOcFpDaFqOiBxOsB|NxBjO|BwCcCpKeCsAgCtArF?sF?tF?uF?vFhPtBiOwF?xF?yFrDe@yHg@cDj@}Hl@?zF?{F?|F?}F?~F?_G?`Gk@nCvKpC?aG?bG?cG?dG?eG?fG?gGvDoC?hG?iG?jG?kG?lG?mG?nGfPcBhL~CjL`DlLbDnLkAfKjFcPlFsDoG?pG?qG?rGqDs@cKv@vOz@zD}CxA_D_PaDaPkA{DsG?tG?uG?vG?wGrDxG?yG?zG?{G{MFrCIgHKiHMkHO?zDgDfG|PiBnQGfDKpQNeCPfCR?|G?}G?~G?_H?`H?aH?bH?cH?dH?eHpPuBnOzBcNbCoKdCzCgCmPsFnPuF_RvByO{BkOnD?fHjMqDlMvCdRwB}N|BhMfHfRrD|AxBiP}BvLcCkPfC_DgHkDhH?iH?jH?kH?lH?mH?nHl@oHPpH_AyBoObCwLeC?qH?rH?sH~@tH?uH?vH?wH?xHhQ~CaQfA`PbDcQjB?jFdQmF?yH?zH~@f@|Li@|H{H?|H?}HsRzB`RcCjRgCcLjCyL{CfLaC}@aEsNcEuNeE?~H?_I?`IeNbAuIdAmCfAgNgA?aI?bIlQvG?cI`AdIl@uGPeIsQHdCJ|MMqQPfCfI?gI?hI?iI?jI?kI?lIzDdB`LxCi@mI?nI?oIaEuHuRpI?qI?rI?sI?tI?uI?vIgPbFwRkA~O`DbQcDbPkFdPmFePfA?oF?wIkQuGPxIxDpCwKrCyCtCyKvCtS_DiQbDyRjF{RnFyAyI?zI?{IaA|IyDlG_QnG}QdH^}IrA~I?_Jm@eB?`JoDaJ?bJ_BvH?pI?cJ?dJ{S`DuSkA{DkF?eJ?fJ?gJ?hJ~@iJ?jJ?kJi@lJ?mJ?nJPoJ?pJ?qJ?rJ?sJ?tJ?uJ?vJ?wJ?xJ?yJcScAfNDrCgAfSbIWcIbE{B~C_FoDaFX`JuTbF|Dt@pNx@tT|BjPdCaRhC`DzCzLaChSIoQL?zJ?{J?|J?}JxA~J?_K?`K?aKxAbK?cK?dK?eKxTu@vMy@_AwF?fKaAuGPgK`AbEtNqB|CdEvN~H~AhK?iKbA}BiRdCyTrFuDjK?kKgTfAxRcDdEeJgEgJ|Rg@cDfD?lK?mK?nK?oKiUh@}LlKjUpK?qK?rK?sK?tKeTbJmTqJnTuK?vK?wK?xKgUaDjQjBzRsGxSvGaUv@vT`F?aJ`ByK?zK?{K?|KkD}K?~K?_L?`L?aL?bL?cL?dLIbClOfHhRvCm@eL?fL?gLeBhLnJhBxDhGl@jGyDiL?jLYnDeRpDmOvCnEbD|SkFvSnFyAwIdBxIcAkLz@gF{OiFlUi@?lL?mLYcC~RhC`DkCtKmC`BaGxPcGzPeG~M}DhVcDdElFeQnL~LjD}DyG?oLo@oD`ViB`BqC?pL?qL?rL?sLZj@rPm@_Io@ItL?uL?vLl@wL?xLfVbJIyL_K`C?zLbUvG?{LqVkAhTlFsDnF~SzI_TbI?|IeVjLsEjBuUtGWwGvUw@I~DdNhBzTJiSNuQQ?fIcE|L?}L?~L?_M?`MeWx@tEjF}SfAeEaM?bM?cM?dMhUhJpEbGyPdGwD|DcAcEaS~H~AeM?fM?gM?hM?iMiWy@}DjM?kMXlMtOdFuOiBcAmM?nM?oM?pM?qM?rM?sMbTiBhCtM?uM?vM?wM^xMz@yM?zMrTdAdSDjE`E?{M?|Mm@wCaLeCsAyCtAgHlRiHnRkHpRmH_@}M?~Mp@_NcXlHqRaCsWz@nWcGoV|D_@`NCaNiBkF?bNCcNxElFaWfAjWbMlWdMgEdNkVqEyEmFwSoF?eN?fNp@tD?gN?hN?iN`XxCi@jN?kNhDpA~IrA`JDeOuAlNxA?lN?mN?nNaAoN?pN~VqNmVdCnSnIZfD?rNi@sNuVpDgViBItN?uNyV}DqD{@oI}@qI_AhBKtQO?vN?wN?xN?yN_BzN?{N?|N?}N`@gDbD~N?_O?`OIaOyCbO?cO{XL}MOlHQgCdO?eOtWkMtXeClPhCnVlCkXeC?jN|WeAg@D}WiAzIkA{ImAgXdGwDfGaYsC?bObYvC~EMjSQgC|GwQ~GyQ`H{QbH`@lKmUqKlEsK?fObViBa@fC_DiCxCkCYdDxLgCaXgO?hH?hO?iO?jObDiD_MkDZlD?kO?lO?mO?nO?oO~NsE_OuEaOwEcOyElDtAqApO?qO?rO?sO?tO?uO?vO?wO?xOhYNgWyO?zOzVp@qUrJoTtJ?{OdB|O[nFyApFo@fHfYbOgYiBvE}O?~OfZcOlXqA{YuAnXyAmN{AbM~Ak@_P?`P?aPsSiBnYgC_SzCqErCySuCa@qHtRsHo@bP?cP?dP?eP?fP?gP?hP?iP?jPcTeH?kP?lP?mP?nP?oP?pP?qP?rP?sPXsDqMuDsMwDYtPuXoIfEpIpSrI?uPcYfAeShAiNjA]vPy@wP?xPtCyP?zP?{P?|P?}PpYeCsAeDkRgOrYhOtYjO_Y_OI~B?~PuDtFoPvFcFqIqSuPpDaJgBk@~Hm@bA_Q?`QlSiI?aQ?bQs@kO?cQCdQoWqBcUeEbS_I?eQ?fQnUrK?gQ?hQ?iQ?jQ?kQ?lQ?mQ?nQd@lJjTnJcViG}PkG~PmG`QiBeXjHoRlHd@fC?eD~ZhHsYiO`FhDrVkD[oG?nLyXuNhZvCeZpDfEwHiZrAmXtAqAvAcJxAoXmNqXbI?oNrXxL?qN`@oQ~XoIhFrBy@dEdU_I?pQ?qQ?rQ?sQr[eDs[hO`[hDfFrI?tQe[bJ|EhD?~N`Y`OeBuQwTiBrE_C`KaC}@vQCwQXxQa\sB?dEb\hKg\dEh\iKdTqB?~IdZfAeEyQI_Fi\eEi[zQ?{QbEgFrB~H~A|Q?}QkYmK?pKk[sKmYgBo@~Q?_R?`R?aR?bRfFcRwZDjEhAxZkA?vPzZxPdFdRjVhF|OqEp@eR?fR?gRl\`FnFpKn\tK?hR?iR?jR?kR?lR?mRr@lJm[vG?oJd@mIoSoIiAlOvYnRy[xHx[qDgRiBf[l@?oR?pRmF_I?qR?rRc@sR?tR?uRu@zFsP|FuP~FwP`Gj\~IfW_E|\mO?nRrBfEjDhExNjEzNlE?vRc[sFcRvFsFiRx\kRy\mRaZO?wR?xR?yRbFzR?{R?|Rc]gEwNiEyNkEwA}R_WaC{E{N}X}Nc\gCqYhHt[jOuYjDn[jGdWbJm]hC?gH?gO_[iOu[~Nr@fCbLhC?rFeUkKuBgHq]hHmRjHq[mHZ~R?_Su@`SsVoLxUzKyUiBwFjR?aSwXqDhEjJ?bS|XyN?cS?dSCeSuBiCoYlCnBuKrUwK?fS?gS?hSPbJj]hEd]kEwAiS?jS?kS?lS?mS?nSnZsCxKuCnBsJpTuJiEoSpCpS?qSz]{Km\hFoEaFr@mIz[sAiDvA|[yAjZ|AoN_BiBrSjDsSpBsI?tS}@uSz@vSKzQ?wS?xS|AyS{WzMZzS?{SiThJp@|SlZdFp]kGo[nGmZhCt]sFKeM?}S?~S?_Tx]_SxBiC_^mCvB`T?aT?bTjXcT?dT?eT~EzJ{T|J|T~C]~J}T`K~T~C]bK_UdKZlLhFfTg^tCzSiB^gT?hT?iTIjT?kT}VxLjFiDs@mD~W|MoFlT?mTk\oF?nT?oT`TkG?iL~FiEk]lE?iS?pT?qT[rTeYeG{PgGq^zBzOhFr^zB?yM~\rDq\GxIaICcIv]gOr]jOa[`OuBrFd[uFm@sT?tT?uT?vTn_@hHn]xRg]mP?zRi]|RyBfMpWhMxBgHbXjHw]aCrRiG?oHl^nIeG|Dc_@mTk^iFo@wT?xT?yT?zTe_@jEe]iSb^kSd^mS~_@kEwAvRp^gE?{T?|T\yI?}T?~Ts]yCbRtF_]tR?_U~]jC`S|CrFaFxBrFp_@vFu@`U?aU?bU?cU?dU?eUk_@vCj^iBzFbJa@jNa`@zIbW|IaTmGl_@HhN`EpFlAxYtE`OvEbOxEdOrA{[uA?pO|YrO?fUo^}Ao`@gAyIiA_FvPs\vB?yPeFgU?hU?iUa@mI_BjUdVkGt^iBq_@tTr_@vTnBkU?lU}FfS`^hS~^uCl`@iBeBmUtBPkSgIg[aQ``@lEf_@nU?oU?pUhGkCu@qU?rUh^tJbZtGW|OfGgF`AsU}CtU?uU?vU}^hFbGlGKwU?xUw_@oH~`@dF[yU?zUg@{U?|UmWfJf`@sF\pFc@|SaGaJ{]rD_GtIrSvIq`@uEyYxEs`@sAiDzE?}U?~U?_V?`Vh_@iB{VuL|ViG?aVwWmGd@sNyEbV?cV?dV?eV?fVaDgV?hVyFiV?jVs^{S?dNu\fRqFaJyBkV?lVja@vCw\qKlYmVgBeFr@sNmAiS_`@lSe^nSeDnV?oV?pVpXqV?rVCsVc`@uRiAtVCuV|a@lVkZ`PaGaFzBaTeGfG|FvVkG{OvAwV?xVtViB^yV?zV?{Vu]vFx^jCsKlCY|VC}VKpQ?~VgD|DvW_Wca@qEaa@lCvZeC?mIjF~Nab@oVbb@mN}[oN~[qNtE`W?aW?bWgGhOd\iD\wI{BcW?dW?eWs@fWlA`Ep`@mA`@rNvXoIkGuJiEwJqTyJwFgWChWYiW?jW?kWClWz^dTg_@fJmAmE{NoE`@mW_@nW?oWpBtQmFpW?qWa@sN{FkRf]V_@rW?sW_AxDuFnO_AtWt\iFoBuW?vWbFwW?xW?yW?zW?{WnEbK?|W?}W?~Wfc@oOd@_XxEeJiXhFnGxVpE`X?aXgZ~Oib@zVjb@sF?jKfUvF`]{FtP}FvP_G}b@bIWhWsb@aWtb@vU~a@rKoUfOo_@sFpc@kK|AbXrAfT{`@uTs_@rDuFnRXfBwa@hV|ExRt_@zRvE~M_@xFm@cX?dX|`@rDk@_@sHeX?fX?gXnc@aXub@iO`FxRzc@{Rv[sL}a@iBaVgBoGkCKhX|c@dX}c@vCpG~VrQgGp@cF}`@vC`d@jOo]kDrGmIgb@gGKeQj[qKlEgQl[iX?jX{BgMqWiMa@lJtFoJbGiLhBkX?lX?mXv^_T~FnXc@tDrMvD?oX~QeHqEpLwVrLyc@dFwUbJgc@zB?vScc@oI|DpX?qX?rX?sXmGpT?tX?uXuGxRad@|R|]kJnDfTrc@sKpU`Fb[nEp[kHdXaCka@vEr`@yEaFzEmDvX?wX?xXKhKlAhApFvPv`@yP?dRhc@qEbApEu@m@vByXe\`Fc@cFpBuPiAcQbc@qWy`@nI\zXtF{X|FdSiBsGdBwGm`@{IdGlG~c@`@?eX_d@gXxWuMyWwMxa@jVX|Xg`@aUh`@cUj`@eU~@}X?~X?_Y?`YoGzCwb@qE{b@vJ?oSi^qS{_@qEwG{Msd@aY?bYbe@mJkTvG?{XyF|NtBzDmb@}DnFnKne@{D_@cY?dYlDGfDeY?fYx_@oIwGiAu`@sB?wP{ZvBw`@dRw[iBlc@fJeb@aPec@sWlb@bIW}VoBpGfQrGwd@hFnb@vUzd@lH}BlU}FxK_a@QhWgY?hYde@vMzW~Ae`@bFgGiHfXmHoe@fAjNkAr\sBpe@xPdFiY?jYdc@lRz\Vb]hB\aMkWcMlGdNuGhD`AkYmc@iFqc@lY?mY?nY?oYga@zUha@|UlGgJ`CyO?pY?qY?rY?sY?tY|GiD\yQ`e@aJxb@iA_FlA{FaStc@qB?fTYuY?wT?vY?wYrBxYCyY|d@wEzYrAiGzEmD|EfO~EzBgM?zY?{Y?|Yze@jAyZsB{e@vBqe@zBj_@zMc@_Nye@aCzGa@tHc@mAvRvFtF`@}YvFjKpa@vLa_@jLvD~Y~UdLae@dFhB_ZC`ZoBnLdd@qEs@aZ?bZlAcZCdZb`@hCu^jKlAaIyb@eC?_XfGyMc@eRv\gRsEvPy@eZ?fZiAgZbAhZ?iZ?jZ?kZ~YvO`ZxOpb@_OsFlZ?mZ?nZzQaHld@lX?oZ?pZ_b@oIvBqZ?rZ}BsZ?tZ|_@xT}_@zTy_@}D[uZa]_Jqf@iGqa@sMzUsE?}K{U_L|UaL}UcL\nTd_@bIcWkGia@tF~e@bMhXfJ{a@hFoA_Xgf@~Itd@yRh]{Rsf@bIWdZee@`Ffd@iB[vZ?wZaf@xZ?yZnf@nExe@iBob@mCge@{Cag@oTdGiLIzZgOmC`c@oW}e@iBrf@bZkf@kA}B{Z?|Zhe@wJve@vKsUxKre@dFyB}SvA}Z?~ZoZvCsc@tFwc@hFid@zYif@|Yff@jDrE~Pxd@tK`CfIcEhImSaQpg@wKtUiB{E_[?`[qd@aFZa[za@gJb_@jDhGzC|e@mRxf@hUfg@uGPdZ~GaFbd@}DoF_Ro\aRea@vG?pHrg@{Yeg@_Jhf@xEla@DzEzEma@~Una@`Vhd@iBqb@pVcb@rVoAmI|g@|Yng@vP~d@zP|Z|Ptg@gI`a@bQy]aCkg@|Cr@jNzBcW?b[?c[fe@bUi`@dUgB{H}R}Hqg@uF^d[ke@nJP{XcFcJfa@aFvd@eCuf@oErFaJ|f@rZfb@bTmA}Rof@uF`_@kTl@aVra@nG{c@yFoAsN_c@~Pm^DzEvAn^dAmCzAnN}AhDe[?f[Cg[pd@qLxVsL_f@mY?h[?i[ic@|Wjc@~Wgh@bFta@cVua@j[?k[ed@uTvc@vC|^mLrG_XzGeXce@iB{Bl[?m[ac@dFaEn[aAo[n`@nG~f@tZtBwRaCgHv_@kH[p[Cq[bh@aC_h@mNrb@pNsXmGdg@cM`f@hJs@r[?s[zX|@pI~@yd@oEIt[aCiCdL{C?u[?v[`g@dLog@|Zrh@{Gte@iF_g@aVih@iBug@xKda@mGwe@wMoEaJzFiB~GaJeh@vG|G~NpZcPqZePrZgPsZiPtZdFyf@mZzf@`Hah@sBlf@yPeF{P?w[?x[?y[sa@oIhEz[?{[oAlJcG|[?}[?~[?_\?`\?a\iY_H{f@bHnd@hF`WbIW{L}g@yEaFpOjGsO}YuO_ZwOxg@{Cdh@vFlg@bIbg@lGjh@oIwg@kDKb\aCrFje@|Mcg@uFvClAcAc\gSvG?d\th@nGsg@kDkh@sFme@}Nyg@V`H~Pzg@bFzh@|Ctf@bImh@}W}d@iKoh@xRKe\}f@xO{\nI_e@n@`Ip@yh@rAiGpOjGfUt`@~Aod@dHvb@b[cGhT`H_CpGqQ?f\?g\bf@rYdf@tYKh\?i\hg@yZsh@sMci@f\di@qYcf@sYef@aCvg@bFf\`CXj\{G|Dvh@{X_GtSqh@jCd`@aC}h@iBuc@vTnGk\ba@zBi_@iF{g@pH{GfGuh@~Axc@gBgi@rD~b@dNue@mHpf@_Ccd@lCuZl\?m\?n\vf@fRqFaFbi@eHkd@jLfh@dJ|h@vFrd@vS_\}Nii@bJmGjSc^lSai@oIwf@zBnh@dVva@o\hi@mCxh@iFd@jN`i@rZlh@rLhh@mIei@}D_i@iB`CRvQ}GxQ_H?p\
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??`B?WM?H??C??P@?[H?I??J??`g?kT?H??C??P??SH?K??C??`G?sK?L??C??@@????M??N??@L?WL?M??O??@R?kW?P??Q??`A?So?R??Q??PR?ga?S??C??@@????T??U??pS?s_?V??W??`[?sW?X??Y??@A?kH?X??Y??`k?wJ?Z??[??@D?gV?\??]??`??[R?^??]??P@?_u?_??A??A?????`??C??pH?_O?a??b??@@?k`?c??C??@B????d??e??p??oB?d??f??p??CD?g??h??PG?GC?i??h??`@????j??f??`@?[E?k??l??@t?wA?m??n??@W?GN?m??o??pA?gO?p??q??P??WH?r??A??A?????k??l??PY?o@?k??s??pN?WD?t??u??PD??B?v??w??`@?SG?x??w??@@?[d?x??w??pA?{d?x??w??pb?[g?y??z??pP?WI?x??{??@@?gJ@|??}??`M?wA?^??[??`??WT?^??~??P@?GH??@?A??A?????k??l??pR?g@?j??@@?PB?oE?A@?B@?`C?cC?C@?B@?@J?OE?D@?B@?@L?o@?D@?E@?@I?OC?F@?G@?`C?oA?F@?H@?pA?oE?I@?J@?`A??O?I@?A??A?????A@?B@?P@?[C?K@?B@?`C?sH?L@?B@?p??G@?M@?N@?@??k?@O@?A??A?????P@?C??@@????Q@?R@?`@?oW?S@?R@?Pb?{^?T@?U@?PV?[m?V@?W@?`@?GP?V@?W@?`V?CR?X@?Y@?`E?sH?Z@?C??@~?wj?[@?\@?Px?Wd?]@?^@?`E?CfA_@?C??PM?sm@]@?`@?@R?w^?a@?b@?pb?GG@c@?A??A?????d@?C??PBASs?e@?f??@@?WB?f@?C??@@????g@?h@?pR?gj?V@?W@?`@??O?V@?W@?`T?{Q?i@?C??`G?SJ?j@?C??@@????g@?k@?PW?Wp?g@?l@?PB@[y?m@?n@?@M?gg?o@?Q??p^?{a?X@?Y@?PC?kH?E??Y@?PN?sS@p@?q@?pC?ku?r@?s@?@^@sX?r@?t@?@@?_S?u@?A??A?????M??N??`p?cM?v@?w@?pH?oh?x@?y@?PD?Oe?v@?f??p@?se?v@?f??@W?Gj?z@?{@?@d?wF?z@?|@?PO?wQ?}@?z??p??gE?~@?z??@B?_D??A?A??A?????a@?b@?PY?wF@@A?AA?@A????y??BA?P??ST?y??CA?@X?_X?DA?EA?`??OV?DA?CA?@C?oV?DA?FA?pQ?o\?]@?f??p??OQA]@?GA?`L?Wz?]@?HA?`M?Wy?IA?AA?@C????DA?JA?@@?o\?DA?KA?@j?OX?LA?AA?@B????DA?MA?P??_\?[@?NA?Pz?SO?]@?OA?p??SOA]@?PA?`[?KI@QA?AA?@A????[@?RA?PN?KP?SA?TA?@V?OQ?UA?VA?P@?oB?WA?z??`A?oH?XA?A??A?????SA?TA?`q?WR?SA?YA?`E?WE?UA?ZA?p@?gC?[A?\A?@B?OL?[A?]A?`I??N?^A?_A?@F?GO@`A?y@?@E????[A?aA?p]?GO?bA?cA?P??oA@dA?eA?pG?oI?bA?\A?`G?K@@fA?A??A?????k??l??`C?S@?k??gA?pN?KC?k??hA?p@?sC?iA?jA?`B?k??kA?lA?@A?WB?mA?nA?PD?gn@mA?oA?`A?cr?mA?pA?@E?CN@qA?cA?P??C\Bz@?{@?@f?{F?z@?rA?pK?wS?sA?_A?`Q?sW@dA?eA?`F?oI?WA?tA?@A?CV?qA?cA?`@?cXBv@?f??@i?[j?]@?J??p@?KEAuA?b@?PU?Gg?vA?wA?pE?ob?xA?C??`??G]?uA?b@?Pc?sg?]@?yA?@O?We?SA?YA?PT??F?zA?_A?P@?C`@x??w??PG?Cf?{A?z??Po??G?[A?|A?P@?GD?}A?~A?p@?[m??B?~A?P@?SC?@B?A??A?????x??w??@e?wg?y??EA?PF?WQ?SA?YA?pV?[F?SA?AB?@[?OK?}@?BB?`??KJ?~@?BB?PD?Wc?~@?CB?@G?OM?z@?|@?@s?GS?z@?DB?p_??P?sA?EB?PM?wI@sA?FB?P`?wj?GB?A??A?????[@?NA?pH?[M?T??A??A?????V??W??@V?kW?V??HB?@B?kJ?IB?JB?PA?kU?KB?A??A?????SA?TA?`H?oP?}@?z??`??[F?[@?\@?pK@wd?DA?FA?PO?k\?DA?LB?pX?[T?MB?B@?@U?GE?NB?AA?@C????MB?OB?@@?GE?MB?PB?pz?CH?]@?QB?p??_FA]@?RB?PE?Wh?]@?SB?PR?oi?TB?AA?@A????MB?UB?P??GH?DA?VB?@C?sR?{A?WB?pD?OQ?UA?VA?@??oB?WA?A??A?????[@?RA?@??WO?XB?A??A?????d@?C??puCWy?WA?_A?`J?[]@YB?y@?@A????d@?ZB?p??Wy?d@?[B?@D?K|?\B?f??P@?sN?]B?^B?`C?sz?g@?_B?@@?Wo?g@?k@?`gACs?`B?aB?pe?OJ@bB?BB?PK?GB@`B?cB?PJ?OK@bA?\A?@??oq?SA?TA?`r?[R?}@?dB?@C?S[?eB?fB?@C?Co?qA?gB?PI?wmBz@?DB?@I?KO?mA?hB?PI?_hAy??z??`m?SJ?DA?A??A?????]@?PA?PB?GH@XB?iB?P??WA?XB?iB?@??SD?jB?AA?@A????y??kB?PL?CU?DA?lB?@H?cJ?[@?lB?@I?_V?T??mB?@r?WY?nB?C??@D????T??oB?P??_Y?pB?A??A?????[A?aA?`^?GO?^A?qB?@@?W`?^A?qB?@u?or?^A?rB?@??sn?sB?A??A?????[@?NA?@L?[M?T??z??pU?wD?P??A??A?????|??}??pJ?sA?tB?uB?`F??]?tB?vB?`C?c]?wB?xB?`@?Ci?wB?yB?pK?sj?wB?zB?PK?Sl?{B?A??A?????iA?jA?P@?k??|B?}B?@A?cB?~B?z??p??_D??C?z??p??[E??C?z??pD?cF?IB?JB?@C?kU?KB?z??`@??C?k??hA?`??sC?@C?AC?`@????BC?CC?`B????DC?EC?pA????FC?GC?PN?SY?FC?HC?pC?w]?IC?JC?pK?{T@T??mB?p_?gX?[A?KC?pB?CE?LC?MC?P@??M?NC?A??A?????y??kB?pM?CU?@C?AC?p@????DC?OC?P?????PC?QC?@B?__?RC?A??A?????k??s??`O?WD?SC?TC?`D?k@?UC?z??pA?WD?VC?A??A?????Z??[??pA?KV?WC?XC?PW?_t?WC?YC?p??{u?WC?XC?pK?Cy?WC?ZC?pE?oS?WC?[C?pH?{X?WC?A??A?????d@?C??pl?[p?WA?\C?@??Kz?]C?A??A?????SA?AB?p^?SK?[A?aA?@L?WN?^C?y@?@C????[A?_C?@E?cN?WA?[??@D?K\?WA?[??p@?W[?WA?`C?p@?ON?WA?`C?@L?{M?d@?C??`kC{x?aC?OC?P?????bC?A??A?????[A?]A?PO?[O?cC?dC?pA?[[@zA?A??A?????t??u??P@??B?t??eC?p@?KC?t??fC?`A?[C?gC?[C?@??_w?gC?A??A?????T??mB?@i?CY?hC?A??A?????y??z??po?SJ?DA?z??PD?oD?iC?A??A?????MB?PB?`x??H?MB?jC?`@?CI?[@?z??@M?SD?[@?\@?pv?Wd?@C?AC?P@????kC?A??A?????DA?LB?``?kT?lC?A??A?????X??Y??pH?cI?X??mC?PK?CL?`B?nC?`E?cO@`B?oC?PH?CF?pC?oC?@D??b?m@?z??`A?Od?qC?A??A?????[A?]A?`C?wM?rC?z??P??sG?^A?A??A?????gC?[C?P@?_w?gC?z??pC?{e?sC?{@?@Z?[EBsC?tC?PK?KHBsC?uC?@_?sKBsC?vC?pz?wPBsC?wC?`p??[BT??oB?@P?SZ?xC?A??A?????T??oB?PQ?SZ?pB?yC?`K?gF?R??z??PG?S`?zC?{C?PD????y??CA?p\?[Z?]@?GA?@F?Oz?|C?A??A?????z@?|@?@M?sQ?eB?fB?p@?Co?mA?A??A?????gC?z??PA?{e?sC?A??A?????DA?lB?PJ?gJ?]@?}C?p??SPA]@?~C?@F?Sv??D?A??A?????t??u??PB??B?@D?ZA?pI?kL?AD?z??pI?KB?[A?]A?PH??N?@C?AC?PA????BD?OC?P?????`A?A??A?????CD?C??pS?WC?p??DD?@U?wL?m??ED?PJ?sC?m??FD?@A@sK?m??GD?PD??H?d??h??`Q?oB?HD?ID?P@?[@?JD?ID?pB?gF?JD?KD?@??GE?`??A??A?????R??Q??PU?ka?LD?MD?`??WW?LD?J??pK?KT?ND?MD?@D?oV??D?b@?@L?cs?]@?OD?PM?{t?PD?y@?PA????QD?RD?pB?GG@uA?b@?`Y?Wg?RC?AA?PB????y??SD?P??KU?TD?A??A?????T??z??pR?sD?UD?A??A?????[@?z??pq?gK?M??A??A?????^A?qB?`B?Cp?^A?VD?@A?co?{A?z??p}?cG?{A?WD?@@?wQ?XD?YD?@u?cL?ZD?A??A?????XD?YD?`x?cL?[D?\D?P@?wR?[D?]D?PF?_o?ZD?C??P??gL?ZD?C??@Q?gM?m??FD?@o?oJ?^D?k@?@A?SG?^D?k@?`C?gG?^D?_D?P??sJ?iA?jA?pC?k???C?hA?pF?cN?~B?`D?@Y?{I?d@?C??`~Cwy?aD?y@?@@????d@?bD?P??wy?bC?C??@A????d@?cD?`??{x?dD?eD?`@?OA@fD?\C?p@?wI?gD?\C?@??[|?hD?A??A?????z@?{@?@Z?cF?z@?iD?pO?oJ?}@?A??A?????z@?iD?pP?oJ?FC?GC?`U?gY?FC?fB?`@?KW?MB?B@?@X?KE?x??w??p_?[g?y??A??A?????[A?KC?P@?CE?UC?z??PF?_D?kA?lA?pA?WB??C?jD?P@?WH??C?jD?@@?kH?IB?kD?@??_X?SA?TA?@F?kP?SA?lD?@K?gN?SA?mD?PJ?[L?nD?{C?@c????DC?EC?PB????SA?TA?`b?wQ?d@?C??@yCgy?oD?A??A?????`B?nC?pF?gO@pD?oC?`??G`?`B?Q??P@?GG?Q@?Q??@P?kQ?S@?A??A?????T??oB?pe??]?V??qD?P@?SE?rD?[??PF?gD?]@?}C?`???H?[@?z??PK?GD?sD?z??`L?[f?V@?tD?PA?_X?K??z??P@?{J?uD?A??A?????SC?TC?@??k@?UC?A??A?????z@?|@?PQ?{Q?MB?B@?PL?sD?vD?wD?`B?GE?xD?yD?pE?k`?xD?zD?pR?{b?{D?AC?p@????|D?{C?pX????DC?EC?`A????E??F??`E?GE@E??}D?@`?SA@p@?~D?pA?[w?r@?s@?PT?KV?y??CA?`Z?cX?]@?PA?@F?SH@a@?A??A?????]@?^@?PC?CfA_@?A??A?????T??z??P[??E?z@?z??P@?KB?z@?DB?Pb?CP?T??z??PW?wD??E?A??A?????DA?lB?@I?cJ?@E?A??A?????]@?~C?PB?Gv?T??oB?pT?W[?P??AE?P??Km?sA?EB?`q?OK@BE?AA?@@????z@?CE?@??CP?[A?]A?@N?[O?[A?A??A?????pD?Q??`??S_?m@?U@?@B?ke?g@?U@?`S?cl?DE?{C?PG????EE?{C?pD????FC?FE?p@?k\?{A?z??pY?GF?[A?]A?@??sM?SA?TA?Pw?cR?IB?kD?@@?SZ?V??W??@P?_W?GE?HE?`E?OO?GE?IE?`A??G?GE?A??A?????t??fC?PB?[C?JE?KE?P@?CR?@D?z??PE?cB?UA?z??P@?cA?}A?~A?P??[m?bA?LE?p@?go?ME?A??A?????SA?TA?`v?cR?mA?oA?@H?{r?mA?NE?p@?Oz?Z??[??`W?_W?OE?A??A?????ZD?C??`L?gM?PE?_A?`F?kC?[A?_C?`B?_N?QE?RE?@B????SA?SE?`??CF?y??EA?`C?SQ?y??TE?PE?[U?]@?UE?p??kSA]@?VE?@F?gA@WE?A??A?????g@?k@?ptBct?o@?XE?P@?s`?o@?XE?pJ?_c?M??YE?@M?k[?ZE?q@?`??K|?ZE?[E?`??Cu?ZE?~??@@?kT?ZE?\E?@??GR?]E?A??A?????X??Y??p`?cJ?X??^E?@I?gN?d??h??PP?oB?c??A??A?????z@?z??@C?[B?sA?A??A?????k??l??p??O@?_E?`E?`N?GG?mA?hB?`@?_fASA?AB?`W?GK?aE?RE?`A????bE?cE?`B?cC?dE?RE?@A????eE?fE?@@?oO?gE?RE?P@????hE?iE?`???D?jE?RE?@@????eE?kE?@D??K?d@?C??@iCwx?LC?_A?`@?Od?lE?mE?@U?gM?nE?oE?p??sI?pE?oE?p??WH?lE?qE?PA?K^?lE?rE?pD?Ka?sE?tE?@??gI?uE?A??A?????SA?YA?PN?gE?sC?tC?ph?GIB|C?b@?@L?{w?vE?AA?@C????DA?wE?@@?c\?xE?AA?@A????DA?yE?PK?{Z?[@?zE?@]?OS?{E?|E?@??KI?}E?A??A?????UA?VA?pD?wB?[@?RA?`F??P?[@?nC?@K?_L?pC?oC?`A??b?m@?A??A?????y??TE?@D?WT?~E?A??A?????[@?z??pg?WK?{A??F?PQ?[W?@F?C??@A????{A?AF?`@?WW?BF?z??pB?SM?CF?DF?P??[M@CF?EF?`??cP@CF?EF?@e@CU@CF?FF?@t?{]@GF?A??A?????{A?z??Pl?wF?[@?z??@l?[K?V??HF?pG?wN?X??HF?pD?{G?IF?A??A?????sC?tC?@Z?oHBz@?iD?@N?kJ?DA?FA?PK??\?xE?A??A?????z@?|@?@q?CS?T??oB?@c?o[?[@?z??@t?gK?M??z??pV?wJ?[@?z??pm?cK?SA?A??A?????SA?AB?PA?wJ?JF?\C?P@?_i@KF?z??PC?ci@LF?\C?@??oR@MF?A??A?????sC?{@?PT?OEBDA?yE?`M??[?z@?DB?PS?kO?mA?NF?pA?o[BeB?NF?@P?Sd?d@?C??pnACu?X??OF?@C?WO?X??OF?@E?SP?Z??PF?`E?[Y?^??N@?P@?w|?QF?z??`A?S}?]@?VE?PB?[A@|??}??@??cA?^??A??A?????[@?z??@J?GD?sD?A??A?????z@?DB?p]??P?mA?RF?PB?{RBeB?RF?PX?S[?{A?WB?`A?KQ?V??W??@N?[W?[A?|A?`A?GD?LC?SF?P@?[g?TF?oE?P@?WH?UF?B@?@?????VF?A??A?????{A?WB?PH?SQ?x??w??@E?Cf?{A?A??A?????|??}??@J?sA?Z??PF?`B?CY?AD?z??PQ?WB?d@?C??`eCwx?dD?WF?`A?c@@XF?A??A?????^D?_D?`E??K?YF?ZF?@D????[F?OC?@A????{A?WB?`G?SQ?vD?\F?P??GL?vD?]F?@@?cN?^F?z??`??wD?^F?z??PA?cD?_F?A??A?????JD?ID?PD?kF?`F?q@?`F?cX?aF?A??A?????y??kB?@O?GU?]@?RB?`F?[h?sC?uC?Pf??LBDA?FA?PS?s\?]@?PA?`e?[I@M??z??PJ?sI?o@?A??A?????DA?MA?PC?g\?x??w??pq?_h?]@?bF?`@?{PAz@?DB?`R?kO?sD?z??pH?Sf?cF?z??P@?WA?dF?A??A?????M??z??`H?gI?V@?tD?@??_X?V@?A??A?????sA?EB?`F@?L@sA?\E?@??su@eF?A??A?????]@?GA?PB?Cz?y??CA?PK?[W?fF?\A?@??cA?fF?A??A?????SA?TA?PU?OQ?SA?gF?PS??N?JF?\C?@??_i@KF?A??A?????T??oB?PD?_Y?pB?z??@G?GC?vD?\F?pC?WL?hF?iF?`@?gT?T??mB?`y?O^?z@?{@?@`?oF?z@?jF?@Y?gN?}@?BB?`??WN?~@?BB?p@?Gq?SA?AB?@@?wJ?zA?kF?@C?c^@^A?kF?`B?wG@LF?A??A?????]@?RB?@H?_h?uA?A??A?????pB?yC?@I?gF?R??A??A?????eB?RF?pj??\?|??}??@I?sA?lF?mF?pE?wLAnF?oF?P@?kS?pF?oF?P??CF?tB?qF?PC?WH?tB?A??A?????M??YE?@P??\?[@?zE?`_?SS?[@?rF?P??w_?sF?A??A?????t??fC?P@?[C?m??FD?Pf?cJ?m??tF?`L?sL?z@?iD?`c?OK?vD?\F?PB?SL?hF?uF?PA?GY?hF?A??A?????|??}??PH?sA?vF?A??A?????DA?LB?@f?CU?wF?AA?@A????DA?xF?@E?oU?XB?yF?@??GB?[@?z??`D?cC?zF?A??A?????T??mB?Pv?w]?QD?{F?PU?oF@|F?C??@B????QD?}F?@B?wF@`B?aB?Pl?gJ@bB?~F?PD?w@@?G?B@?@?????eE?~F?p??CQ?nD?{C?@S????[@?lB?PE?SV?@G?AA?P?????AG?BG?@??ki?CG?DG?p@?sA@ND?z??P@?gS?g??h??pB?wB?_E?EG?@C?SF?@D?z??PD?cB?UA?A??A?????sD?z??pD?Of?T@?A??A?????ZD?C??`K?gM?M??N??@N@KO?M??FG?@P?wS?o@?R@?`P?ob?g@?U@?pL?Gl?g@?GG?pJ?gm?HG?A??A?????y??TE?pA?ST?jB?A??A?????dD?WF?@@?c@@j??@@?pD?wE?j??IG?@A?_C?y??CA?pN?_W?x??JG?pC?GK@rC?[??@A?{N?SA?YA?@S??F?QE?A??A?????V??HF?pJ?{N?vD?wD?Pp?oF?KG?AA?@A????DA?LG?`@?G]?DA?MG?`U??c?V@?tD?@B?_X?V@?z??P@?gL?NG?A??A?????y??EA?@??OQ?X??OF?pj?KQ?OG?A??A?????SA?YA?`M?kE?V??PG?PI?oT?eE?QG?P??GJ?RG?A??A?????{A?z??Pk?wF?T??z??PQ?sD?v@?A??A?????MB?jC?@??CI?[@?A??A?????T??z??PZ??E?z@?A??A?????[@?NA?`|?OQ?[A?KC?@D?CE?SG?SF?P@?[`?TF?oE?@D?WH?TG?B@?P??SM?TG?B@?PC?{M?UG?\A?@??KF?UG?A??A?????VG?AA?@A????T??WG?PT?kK?XG?A??A?????[A?]A?`D?{M?|B?}B?@??cB?~B?A??A?????DA?MA?pA?c\?z@?{@?@X?_F?z@?YG?pG?kI?m??o??`??cO?UC?ZG?`N?CJ?[G?z??`@?GA?[@?z??pO?[D?BF?z??@F?cM?\G?A??A?????M??O??@P?_W?]G?z??P??wG?^G?z??PA?OA?]@?SB?P??{h?d@?C??@u@Ks?C@?B@?P??CE?C@?_G?`B?SG?`G?aG?pF?kJ@`G?A??A?????hF?iF?`??cT?hF?oA?PA?OQ?bB?BB?`J?GB@KB?bG?@??sG?cG?A??A?????M??z??PM?{I?T??oB?pa?o[?dG?A??A?????z@?|@?pn??S?t??u??@E?CB?]@?B@?pA?_@A]@?eG?`F?st@fG?A??A?????hF?iF?pB?gT?mA?z??`L?OX?T??z??`b?KE?M??oC?`X?OZ?M??O??PM?_W?]G?A??A?????X??mC?@??wK?pD?A??A?????DA?yE?@O?C[?DA?gG?`B?G]?DA?LB?pa?kT?tB?vB?PO?K^?hG?uB?P@?sA?iG?uB?@?????jG?A??A?????X??^E?p@?SN?sA?B@?`??oa?sA?kG?pD?_b?sA?hA?PA?GT?IF?lG?P??cE?SA?YA?pX?oF?mG?kF?@??[P@nG?A??A?????MB?PB?`y??H?TB?A??A?????K??z??PA?{J?uD?z??P@?WQ?oG?A??A?????{A?z??ps?CG?k??gA?PE?GC?M??O??`I?{U?pG?A??A?????y??EA?PA?OQ?qG?z??P@?kJ?[@?\@?PJ@wd?rG?A??A?????sG?AA?@B????y??tG?pE?oZ?y??TE?p@?ST?[@?RA?Pe?cP?[@?rF?`A?w_?[@?rF?@G?K`?ZE?[??`??{|?X??OF?PB?WO?WC?uG?@??KP?vG?wG?@S?{_?^G?z??P@?OA?cF?A??A?????M??z??PE?[I?ZE?z??`@?Oo?m??tF?pM?wL?_E?A??A?????T??mB?@\?_X?T??mB?`Y?WX?LD?A??A?????X??^E?P??ON?xG?yG?@??sV?SA?TA?@y?gR?m??tF?@T?wL?_E?z??@O?[D?j??@@?@@?kE?zG?{G?@B?w@?JE?KE?@??CR?@D?A??A?????x??w??Pg?wg?V@?z??PF?oM?I??A??A?????y??CA?P^?S[?|G?C??@@????Q@?}G?p`?OW?P@?A??A?????~G?uB?@??????H?A??A?????CG?DG?@??oA@ND?A??A?????V@?tD?@@?_X?K??A??A?????t??eC?`??KC?@H?{C?PD????T??mB?Px?O^?AH?A??A?????y??EA?@@?OQ?qG?A??A?????SA?TA?@G?oP?d@?C??P|Bgw?BH?\C?@@?CU?{E?|E?P@?KI?}E?z??`??KI?{E?z??P@?cF?@D?ZA?`H?kL?AD?A??A?????fF?\A?P@?cA?fF?z??PC?sA?CH?z??@E?KB?WC?XC?`??Op?DH?EH?PC??D@WC?XC?p??{K?[@?z??p^?CK?MB?B@?pS?CE?NB?A??A?????[@?z??PH?wC?X??HF?`M?CH?X??FH?`??_L?[@?z??PG?wC?ZE?A??A?????z@?|@?PN?wQ?j??IG?@??_C?LC?_A?p??Od?GH?HH?P@?_C?nE?A??A?????ND?z??@C?kS?
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1666008847804;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "java.lang.Thread", "run", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "jdk.internal.net.http.common.SequentialScheduler$SchedulableTask", "jdk.internal.net.http.common.SequentialScheduler$CompleteRestartableTask", "jdk.internal.net.http.common.SequentialScheduler$TryEndDeferredCompleter", "complete", "jdk.internal.net.http.common.SequentialScheduler$LockingRestartableTask", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$236.0x0000000800d9b5c8", "jdk.internal.net.http.Http1AsyncReceiver", "flush", "handlePendingDelegate", "jdk.internal.net.http.Http1Response$BodyReader", "onSubscribe", "jdk.internal.net.http.ResponseContent$FixedLengthBodyParser", "jdk.internal.net.http.Http1Response$$Lambda$286.0x0000000800da5d18", "jdk.internal.net.http.Http1Response", "onFinished", "jdk.internal.net.http.HttpConnection", "closeOrReturnToCache", "jdk.internal.net.http.ConnectionPool", "returnToPool", "jdk.internal.net.http.ConnectionPool$ExpiryList", "add", "java.util.AbstractList", "listIterator", "java.util.LinkedList", "java.util.LinkedList$ListItr", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.test.kovalenko.shards.MyServerBase$$Lambda$200.0x0000000800d157c8", "ok.dht.test.kovalenko.shards.MyServerBase", "lambda$handleRequest$0", "handle", "one.nio.http.HttpServer", "handleRequest", "RequestHandler0_handle", "ok.dht.test.kovalenko.shards.MyServiceBase", "ok.dht.test.kovalenko.LoadBalancer", "balance", "one.nio.http.HttpSession", "sendResponse", "writeResponse", "one.nio.net.Session", "write", "one.nio.net.Session$ArrayQueueItem", "proxyRequest", "ok.dht.test.kovalenko.ServiceClient", "getJavaNet", "jdk.internal.net.http.HttpClientFacade", "sendAsync", "jdk.internal.net.http.HttpClientImpl", "jdk.internal.net.http.MultiExchange", "<init>", "filterChain", "jdk.internal.net.http.FilterFactory", "getFilterChain", "linkLast", "java.util.LinkedList$Node", "handleGet", "ok.dht.test.kovalenko.dao.LSMDao", "get", "ok.dht.test.kovalenko.dao.aliases.MappedFileDiskSSTableStorage", "ok.dht.test.kovalenko.dao.aliases.MappedFileDiskSSTable", "entryIndex", "ok.dht.test.kovalenko.dao.Serializer", "readKey", "readByteBuffer", "java.nio.DirectByteBufferR", "slice", "ok.dht.test.kovalenko.dao.LSMDao$MemoryStorage", "ok.dht.test.kovalenko.dao.aliases.MemorySSTableStorage", "java.util.concurrent.LinkedBlockingDeque", "descendingIterator", "java.util.concurrent.LinkedBlockingDeque$DescendingItr", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$268.0x0000000800da2e58", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber", "requestMore", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$WriteSubscription", "jdk.internal.net.http.Http1Exchange$Http1Publisher$Http1WriteSubscription", "request", "jdk.internal.net.http.common.SequentialScheduler", "runOrSchedule", "jdk.internal.net.http.HttpClientImpl$DelegatingExecutor", "execute", "jdk.internal.net.http.Http1Exchange$Http1Publisher$WriteTask", "jdk.internal.net.http.Http1Exchange", "getOutgoing", "java.util.concurrent.CompletableFuture", "completeAsync", "java.util.concurrent.CompletableFuture$AsyncSupply", "postComplete", "java.util.concurrent.CompletableFuture$UniCompose", "tryFire", "java.util.concurrent.CompletableFuture$UniRelay", "jdk.internal.net.http.HttpClientImpl$SelectorManager", "jdk.internal.net.http.AsyncTriggerEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$230.0x0000000800d993a8", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription", "handleSubscribeEvent", "jdk.internal.net.http.SocketTube$SocketFlowTask", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$228.0x0000000800d98f48", "read", "handlePending", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadSubscription", "signalOnSubscribe", "jdk.internal.net.http.Http1AsyncReceiver$Http1TubeSubscriber", "java.util.concurrent.SynchronousQueue", "offer", "java.util.concurrent.SynchronousQueue$TransferStack", "transfer", "snode", "java.util.concurrent.SynchronousQueue$TransferStack$SNode", "jdk.internal.net.http.Http1Response$HeadersReader", "tryAsyncReceive", "jdk.internal.net.http.Http1Response$Receiver", "accept", "jdk.internal.net.http.Http1HeaderParser", "parse", "resumeOrSecondCR", "java.lang.StringBuilder", "java.lang.AbstractStringBuilder", "byte[]", "jdk.internal.net.http.MultiExchange$$Lambda$207.0x0000000800d88eb8", "apply", "lambda$responseAsync0$2", "responseAsyncImpl", "jdk.internal.net.http.Exchange", "responseAsync", "responseAsyncImpl0", "uniHandleStage", "uniHandle", "jdk.internal.net.http.Exchange$$Lambda$241.0x0000000800d9e480", "lambda$responseAsyncImpl0$10", "checkFor407", "jdk.internal.net.http.Exchange$$Lambda$215.0x0000000800d8a4d0", "lambda$responseAsyncImpl0$9", "sendHeadersAsync", "thenCompose", "uniComposeStage", "jdk.internal.net.http.Http1Exchange$$Lambda$259.0x0000000800da1408", "lambda$sendHeadersAsync$4", "jdk.internal.net.http.Http1Request", "headers", "jdk.internal.net.http.common.HttpHeadersBuilder", "setHeader", "java.util.ArrayList", "java.lang.Object[]", "collectHeaders0", "build", "java.net.http.HttpHeaders", "of", "headersOf", "java.util.TreeMap", "forEach", "java.net.http.HttpHeaders$$Lambda$201.0x0000000800d82a10", "lambda$headersOf$1", "java.util.List", "copyOf", "java.util.ImmutableCollections", "listCopy", "java.util.ImmutableCollections$List12", "curServiceUrl", "hash", "ok.dht.test.kovalenko.utils.HashUtils", "getMurmur128Hash", "com.google.common.hash.AbstractHasher", "putString", "java.lang.String", "getBytes", "encode", "encodeUTF8", "java.util.Arrays", "resumeOrEndHeaders", "java.util.HashMap", "toArray", "java.util.concurrent.CompletableFuture$UniApply", "java.util.concurrent.CompletableFuture$UniCompletion", "claim", "java.util.concurrent.CompletableFuture$Completion", "postFire", "java.util.Collections$UnmodifiableMap", "jdk.internal.net.http.HttpRequestImpl", "firstValue", "java.util.Collection", "stream", "java.util.stream.StreamSupport", "java.util.stream.ReferencePipeline$Head", "collectHeaders1", "append", "ensureCapacityInternal", "addHeaderFromString", "computeIfAbsent", "resize", "java.util.HashMap$Node[]", "checkOpen", "java.nio.ByteBuffer", "allocate", "java.nio.HeapByteBuffer", "establishExchange", "jdk.internal.net.http.ExchangeImpl", "jdk.internal.net.http.ExchangeImpl$$Lambda$218.0x0000000800d8f770", "lambda$get$0", "createExchangeImpl", "thenApply", "uniApplyStage", "uniApplyNow", "jdk.internal.net.http.ExchangeImpl$$Lambda$237.0x0000000800d9ba78", "lambda$createExchangeImpl$2", "h2Upgrade", "setH2Upgrade", "jdk.internal.net.http.common.MinimalFuture", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$255.0x0000000800da0b30", "lambda$run$3", "handleEvent", "jdk.internal.net.http.SocketTube$SocketFlowEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadEvent", "signalEvent", "signalReadable", "jdk.internal.net.http.SocketTube", "readAvailable", "jdk.internal.net.http.SocketTube$SliceBufferSource", "listOf", "toString", "java.lang.StringLatin1", "newString", "copyOfRange", "substring", "newIncompleteFuture", "jdk.internal.net.http.MultiExchange$$Lambda$208.0x0000000800d89338", "lambda$responseAsync0$4", "readBodyAsync", "readBody", "jdk.internal.net.http.Http1Response$$Lambda$285.0x0000000800da56c8", "lambda$readBody$3", "jdk.internal.net.http.ResponseContent", "put", "addEntry", "java.util.TreeMap$Entry", "java.lang.reflect.Constructor", "newInstance", "newInstanceWithCaller", "java.lang.reflect.AccessibleObject", "checkAccess", "verifyAccess", "slowVerifyAccess", "java.lang.ref.WeakReference", "com.google.common.hash.Murmur3_128HashFunction", "newHasher", "com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher", "com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher", "java.lang.invoke.Invokers$Holder", "linkToTargetMethod", "java.lang.invoke.DelegatingMethodHandle$Holder", "reinvoke_L", "java.lang.invoke.DirectMethodHandle$Holder", "invokeStatic", "java.lang.StringConcatHelper", "simpleConcat", "newArray", "jdk.internal.misc.Unsafe", "allocateUninitializedArray", "firstValueAsLong", "java.util.stream.ReferencePipeline", "mapToLong", "java.util.stream.ReferencePipeline$5", "newInvokeSpecial", "java.lang.invoke.DirectMethodHandle", "allocateInstance", "jdk.internal.net.http.MultiExchange$$Lambda$296.0x0000000800dad668", "ok.dht.test.kovalenko.utils.HttpUtils", "toOneNio", "one.nio.http.Response", "java.lang.String[]", "java.time.Instant", "plus", "plusSeconds", "ofEpochSecond", "create", "iterator", "java.util.ArrayList$Itr", "java.net.http.HttpHeaders$$Lambda$270.0x0000000800da32b8", "lambda$headersOf$0", "grow", "java.lang.invoke.LambdaForm$DMH.0x0000000800ca0000", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$254.0x0000000800da06c0", "java.util.Collections", "unmodifiableMap", "requestForKeyJavaNet", "requestJavaNet", "java.net.URI", "jdk.internal.net.http.Http1Response$ClientRefCountTracker", "jdk.internal.net.http.Exchange$ConnectionAborter", "createHttp1Exchange", "jdk.internal.net.http.Http1Exchange$$Lambda$273.0x0000000800da3db8", "jdk.internal.net.http.Exchange$$Lambda$239.0x0000000800d9e000", "registerCleanupTrigger", "connectFlows", "subscribe", "jdk.internal.net.http.SocketTube$InternalReadPublisher", "java.util.concurrent.atomic.AtomicReference", "java.util.TreeSet", "java.net.URI$Parser", "parseHierarchical", "parseAuthority", "parseServer", "parseHostname", "jdk.internal.net.http.Http1Response$$Lambda$287.0x0000000800dac000", "getBodyParser", "java.lang.invoke.LambdaForm$MH.0x0000000800c90000", "invoke", "java.util.concurrent.CompletableFuture$UniHandle", "whenComplete", "uniWhenCompleteStage", "java.util.concurrent.CompletableFuture$UniWhenComplete", "jdk.internal.net.http.HttpRequestBuilderImpl", "jdk.internal.net.http.ImmutableHttpRequest", "java.lang.invoke.LambdaForm$DMH.0x0000000800d80c00", "one.nio.server.SelectorThread", "process", "processRead", "processHttpBuffer", "handleParsedRequest", "ok.dht.test.kovalenko.dao.utils.PoolKeeper", "submit", "java.util.concurrent.AbstractExecutorService", "newTaskFor", "jdk.internal.net.http.Http1Response$Http1BodySubscriber", "onComplete", "jdk.internal.net.http.ResponseSubscribers$ByteArraySubscriber", "uniWhenComplete", "jdk.internal.net.http.ResponseSubscribers$$Lambda$293.0x0000000800dacfc0", "jdk.internal.net.http.ResponseSubscribers", "lambda$getBodyAsync$2", "lambda$responseAsync0$3", "jdk.internal.net.http.HttpResponseImpl", "jdk.internal.net.http.Http1Response$$Lambda$243.0x0000000800d9fb70", "addEntryToEmptyMap", "retrieveProxy", "sun.net.spi.DefaultProxySelector", "select", "sun.net.spi.DefaultProxySelector$3", "java.security.AccessController", "doPrivileged", "executePrivileged", "one.nio.util.Utf8", "toAsciiString", "makeHash", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$262.0x0000000800da1ce0", "lambda$run$5", "lambda$run$2", "jdk.internal.net.http.HttpClientImpl$SelectorAttachment", "resetInterestOps", "java.util.HashSet", "java.util.HashMap$KeySet", "java.util.HashMap$KeyIterator", "readStatusLineFeed", "putBytes", "wrap", "requestURI", "getPathAndQuery", "java.lang.invoke.LambdaForm$MH.0x0000000800c0fc00", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$260.0x0000000800da1860", "jdk.internal.net.http.ConnectionPool$CleanupTrigger", "addTrailingOperation", "jdk.internal.net.http.HttpConnection$TrailingOperations", "jdk.internal.net.http.Http1Exchange$Http1Publisher", "lockingScheduler", "java.util.concurrent.locks.ReentrantLock", "jdk.internal.net.http.Http2ClientImpl", "getConnectionFor", "jdk.internal.net.http.Http2Connection", "keyFor", "keyString", "java.lang.invoke.LambdaForm$MH.0x0000000800d92400", "java.lang.invoke.LambdaForm$MH.0x0000000800d91c00", "getTask", "poll", "jdk.internal.net.http.Http1Response$$Lambda$244.0x0000000800d9fda8", "jdk.internal.net.http.Exchange$$Lambda$295.0x0000000800dad430", "start", "jdk.internal.net.http.Http1HeaderParser$$Lambda$279.0x0000000800da6fa8", "lambda$addHeaderFromString$0", "java.lang.invoke.LambdaForm$MH.0x0000000800d02800", "java.lang.invoke.LambdaForm$MH.0x0000000800c0d000", "newArrayWithSuffix", "java.util.Optional", "map", "ofNullable", "java.net.http.HttpRequest", "newBuilder", "spliterator", "java.util.AbstractList$RandomAccessSpliterator", "encodeASCII", "jdk.internal.net.http.ConnectionPool$ExpiryEntry", "java.lang.Iterable", "jdk.internal.net.http.Http1Request$$Lambda$272.0x0000000800da3748", "test", "lambda$collectHeaders0$1", "responseAsync0", "exceptionallyCompose", "uniComposeExceptionallyStage", "java.util.concurrent.CompletableFuture$UniComposeExceptionally", "onNext", "asyncReceive", "java.util.concurrent.ConcurrentLinkedDeque", "offerLast", "newNode", "java.util.concurrent.ConcurrentLinkedDeque$Node", "putConnection", "one.nio.http.Request", "getParameter", "java.util.function.BiPredicate$$Lambda$269.0x0000000800dc4000", "java.util.function.BiPredicate", "lambda$and$0", "jdk.internal.net.http.common.Utils$$Lambda$164.0x0000000800d044a0", "jdk.internal.net.http.common.Utils", "lambda$static$12", "java.util.function.Predicate$$Lambda$154.0x0000000800d40000", "java.util.function.Predicate", "lambda$negate$1", "jdk.internal.net.http.common.Utils$$Lambda$153.0x0000000800caf698", "lambda$static$5", "java.util.stream.AbstractPipeline", "evaluate", "java.util.stream.ForEachOps$ForEachOp$OfRef", "evaluateSequential", "java.util.stream.ForEachOps$ForEachOp", "wrapAndCopyInto", "wrapSink", "java.util.stream.ReferencePipeline$2", "opWrapSink", "java.util.stream.ReferencePipeline$2$1", "jdk.internal.net.http.Exchange$$Lambda$263.0x0000000800da1f10", "lambda$responseAsyncImpl0$8", "jdk.internal.net.http.Exchange$$Lambda$214.0x0000000800d8a288", "sendRequestBody", "sendBodyAsync", "jdk.internal.net.http.Http1Exchange$Http1BodySubscriber", "completeSubscriber", "jdk.internal.net.http.Http1Exchange$Http1BodySubscriber$1", "jdk.internal.net.http.MultiExchange$$Lambda$209.0x0000000800d89580", "getAddress", "jdk.internal.net.http.HttpRequestImpl$$Lambda$221.0x0000000800d95dc0", "lambda$getAddress$5", "java.net.InetSocketAddress", "java.net.InetAddress", "getByName", "getAllByName", "getAllByName0", "java.net.InetAddress[]", "getConnection", "jdk.internal.net.http.ConnectionPool$CacheKey", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1", "java.util.TreeMap$EntrySet", "java.util.TreeMap$EntryIterator", "trim", "purgeExpiredConnectionsAndReturnNextDeadline", "purgeUntil", "java.util.LinkedList$DescendingIterator", "toLowerCase", "findFirst", "java.util.stream.FindOps$FindOp", "java.util.stream.FindOps$FindSink$OfRef$$Lambda$14.0x80000001d", "java.util.stream.FindOps$FindSink$OfRef", "events", "jdk.internal.net.http.HttpClientImpl$SelectorAttachment$$Lambda$251.0x0000000800da0000", "java.lang.invoke.LambdaForm$MH.0x0000000800d80000", "invokeExact_MT", "java.lang.invoke.LambdaForm$DMH.0x0000000800da9000", "getSettingsString", "getClientSettings", "jdk.internal.net.http.frame.SettingsFrame", "int[]", "java.util.concurrent.LinkedBlockingQueue", "java.util.concurrent.LinkedBlockingQueue$Node", "whenCompleteAsync", "jdk.internal.net.http.common.Demand", "java.util.concurrent.atomic.AtomicLong", "java.util.HashMap$Node", "jdk.internal.net.http.ResponseTimerEvent", "hostString", "java.util.Base64$Encoder", "encodeToString", "readResumeHeader", "entrySet", "java.lang.Class", "getConstructor", "jdk.internal.reflect.ReflectionFactory", "copyConstructor", "java.lang.reflect.ReflectAccess", "copy", "appendToOutgoing", "jdk.internal.net.http.Http1Exchange$DataPair", "parseRequest", "withoutPadding", "java.lang.Class[]", "jdk.internal.net.http.Exchange$$Lambda$240.0x0000000800d9e238", "lambda$establishExchange$3", "completedFuture", "java.lang.Object", "getBodyAsync", "jdk.internal.net.http.ResponseSubscribers$$Lambda$292.0x0000000800dacd98", "lambda$getBodyAsync$3", "getBuffer", "jdk.internal.net.http.PlainHttpConnection$$Lambda$226.0x0000000800d93db8", "java.net.http.HttpResponse$BodyHandlers$$Lambda$202.0x0000000800d83650", "java.net.http.HttpResponse$BodyHandlers", "lambda$ofByteArray$12", "java.net.http.HttpResponse$BodySubscribers", "ofByteArray", "getPath", "checkRequestMore", "resumeReadEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$267.0x0000000800da3080", "emptyResponseForCode", "registerTimer", "jdk.internal.net.http.Exchange$$Lambda$278.0x0000000800da6b58", "lambda$wrapForUpgrade$11", "checkForUpgradeAsync", "java.util.concurrent.atomic.AtomicInteger", "jdk.internal.net.http.ConnectionPool$$Lambda$298.0x0000000800dae8d8", "contextRestricted", "CONTEXT_RESTRICTED", "jdk.internal.net.http.common.Utils$$Lambda$271.0x0000000800da34f0", "java.util.stream.LongPipeline", "java.util.stream.FindOps$FindSink$OfLong", "java.util.OptionalLong", "jdk.internal.net.http.Http1Response$$Lambda$277.0x0000000800da6910", "lambda$readHeadersAsync$0", "jdk.internal.net.http.Response", "readResumeStatusLine", "toBytes", "one.nio.util.ByteArrayBuilder", "java.net.InetSocketAddress$InetSocketAddressHolder", "jdk.internal.net.http.Http1AsyncReceiver$Http1AsyncDelegateSubscription", "jdk.internal.net.http.AbstractSubscription", "updateTables", "java.lang.Long", "valueOf", "asReadOnlyBuffer", "java.nio.HeapByteBufferR", "jdk.internal.net.http.Http1Response$$Lambda$289.0x0000000800dac6f0", "waitingGet", "java.util.concurrent.CompletableFuture$Signaller", "wrapForUpgrade", "jdk.internal.reflect.DelegatingConstructorAccessorImpl", "jdk.internal.reflect.GeneratedConstructorAccessor9", "jdk.internal.net.http.RedirectFilter", "getNode", "hashCode", "java.util.ImmutableCollections$MapN", "java.util.ImmutableCollections$MapN$1", "java.util.concurrent.locks.ReentrantLock$NonfairSync", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$245.0x0000000800d9d678", "jdk.internal.net.http.MultiExchange$CancelableRef", "jdk.internal.net.http.Http1Exchange$$Lambda$275.0x0000000800da64a0", "jdk.internal.net.http.MultiExchange$$Lambda$266.0x0000000800da27c0", "lambda$responseAsyncImpl$7", "now", "java.time.Clock", "currentInstant", "jdk.internal.net.http.PlainHttpConnection", "cacheKey", "ok.dht.test.kovalenko.dao.base.ByteBufferDaoFactoryB", "fromString", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$232.0x0000000800d99c98", "startSubscription", "jdk.internal.reflect.GeneratedConstructorAccessor8", "jdk.internal.net.http.AuthenticationFilter", "java.lang.invoke.LambdaForm$MH.0x0000000800c0c000", "jdk.internal.net.http.Http1Response$$Lambda$294.0x0000000800dad1f8", "sun.nio.ch.Util$2", "jdk.internal.net.http.TimeoutEvent", "java.time.Duration", "addTo", "findConnection", "java.util.stream.ForEachOps", "makeRef",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(' + value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
