<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BNp[Aa@w@tAcKhMvMzM~OrQyRrWfY~YzjB?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????G???@O????@??G??@??IG@????@???@G??GG?A????@@?@?@?G??@????????@?GGHH?`hJP??H???G?????G??G???HH????G???????@??????????GG?O????????@??@?G???????G?G????@???@???????????H???????G?G??AH???G?G??GH????????G?@????????G???@??????????????OG??????@?G??@?????????????????@G??GH??@???G??????????@H???????O???G@????H?@?G???G?G@?O??@G????????????????H???????G??????????@PQO???G?????@????????G?????????????G@H???????@????A??G???GA??GI????G????????H@??@???G???A??????????GG??H???QAGGG?G?????????@??@????@G??O??@??O????????HG????????????@@IA@I??@????????????G??G???G??@?G??@????????A????????@????@??G??G??????@?????G@?G?????@???@@@?G??G?????????????????G???????G?????????????@???G????A??G????????G???????????G???????????????????@????????@????G?G??G???G???G?@?@??????????G???G???@?@??H?G??G@???????????G?G????G?@HHG@???IHHPH????????G???@HQPG?????HHHHGA?????????????????AAG?????????????@?@???????A?B?G????G?G?????@H??????????????????????????????G?H????????????G@?????????QH???G?????GG?????@?@??????@????????GQO??????G????????????????????G???????????????@H???????????G??G??????@???@????@?@??GG??G?????????@@?????????G????????????????????????@A?????????????G????G?????G????G???G???G?????G??????G??????????????????????????????????????????????????????G?????????????????G?????G???@?@????????@G??@O?????????@???????????????????G???????????????G?O??????????@@??????G?G?????P?G????????G??????????????????G???????????????????????????????????????????G?????????G??????GG????G?@?G?@???????G???GG????????@??????????????????????@???????????????????????????????????????????????????????????????????????????????????????????????????Grn@rn@zq@p}@ht@ur@`s@m}@cv@t~@vgAvq@ldA}fAzkAalAio@`p@|t@}v@y_Al`AscAlhA{iAep@yp@kr@dw@ew@p~@qaArbAahAmp@op@`q@sr@vv@xv@n{@a}@}}@t_Ag`Aq`AlcA_dA`hA{hAuiAjjAskAomAknAfoA`pAsn@do@fo@po@vo@lp@qp@fq@sq@wq@gs@js@qs@rs@~s@bt@nt@ut@xt@`u@ju@mu@wu@{u@yv@{v@~w@kz@mz@q{@w|@k}@r}@s}@_~@u~@|~@h_Ar_A``Ao`Au`AraAzaAibAlbA|bA}bApcArcAtcA~cAbdAwdAheAoeAueA_fA_gAfgA{gA|gAihAjhAohAthAxhAzhAgiAkiAtiAijAljAdkAxkAflAglAfmAvmAymAjnAloAqoAtqA|qA}qArrApuAzvA|xAwyAtzAw{Aun@vn@wn@xn@yn@zn@{n@|n@}n@`o@bo@ko@lo@mo@no@to@xo@yo@zo@{o@~o@bp@hp@ip@jp@kp@np@pp@rp@up@wp@xp@zp@}p@_q@bq@dq@eq@hq@tq@uq@xq@yq@{q@}q@~q@_r@`r@ar@br@dr@er@xr@yr@zr@{r@|r@}r@_s@as@bs@cs@ds@es@hs@ls@ms@ns@os@ps@ts@xs@zs@{s@|s@}s@`t@at@jt@kt@lt@mt@ot@pt@qt@rt@st@tt@vt@wt@eu@gu@lu@nu@ou@qu@}u@~u@`v@av@ev@fv@iv@jv@kv@lv@mv@nv@ov@pv@qv@rv@sv@tv@uv@wv@_w@`w@aw@bw@cw@gw@hw@iw@jw@kw@lw@ow@sw@`x@bx@sx@ux@vx@wx@xx@yx@zx@{x@ly@wy@yy@{y@}y@_z@az@cz@iz@lz@nz@oz@pz@uz@p{@r{@t{@s|@u|@v|@x|@y|@{|@~|@_}@c}@f}@i}@j}@v}@x}@z}@b~@d~@g~@i~@j~@k~@l~@n~@w~@x~@y~@z~@{~@}~@~~@`_Aa_Ab_Ac_Ad_Ae_Aj_Al_Ao_A{_A|_A}_A~_A_`Aa`Ab`Ac`Ad`Ae`Af`Ah`Ai`Aj`Ak`Am`As`At`Av`Aw`Ax`Ay`A`aAbaAcaAdaAgaAiaAjaAkaAlaAoaAtaAuaAvaA|aA_bAabAcbAdbAebAfbAgbAhbAjbAkbAmbAnbAobApbAsbAubA`cAbcAecAhcAncAocAqcAvcAwcAxcA|cA}cAcdAedAgdAndArdAsdAudAxdAzdA}dAaeAceAdeAfeAgeAieAjeAneApeAqeAweAyeA{eA|eA}eA~eA`fAffAjfAkfAlfApfAyfAzfA~fA`gAagAbgAhgAngApgArgAsgAugA~gAbhAhhAkhAnhAqhA~hA_iAaiAbiAciAdiAeiAfiAiiAmiAoiApiAviAyiA|iA~iA`jAbjAdjAfjAgjAhjAkjAmjAnjAsjAvjA{jA}jA~jA_kA`kAakAbkAckAgkAjkAlkAmkAnkAokApkAqkAtkAwkA}kAdlAelAhlAjlAmlAxlApmAqmArmAtmAumAwmAzmA{mA|mA~mAanAcnAenAgnApnArnAsnAtnAxnA`oAaoAboAdoAhoAioAnoAuoAbpAjpAmpAopAqpAupAwpA`qAdqAeqAkqAlqAmqAnqAoqAvqAxqAbrAcrAerAgrAnrAprAqrAurA}rAasAbsAlsAmsAnsActAitA|tA`uAiuAjuAkuAvuAyuA|uAcvAevAgvAhvAjvApvArvAsvAuvAvvAwvAxvAyvA{vAiwAjwAlwAqwAoxAwxAxxAzxA~xA`yAhyAjyAkyAqyAsyA{yA_zAkzA|zAa{Ad{Af{Az{Am|A_}Ai}Ak}Atn@~n@_o@ao@co@eo@go@ho@jo@oo@qo@ro@so@uo@wo@|o@}o@_p@ap@cp@dp@fp@gp@sp@tp@vp@{p@|p@~p@aq@cq@gq@iq@jq@kq@lq@mq@nq@oq@pq@qq@rq@|q@cr@fr@gr@hr@ir@jr@lr@mr@nr@or@pr@qr@rr@tr@vr@wr@~r@fs@is@ks@ss@us@vs@ws@ys@_t@ct@dt@et@ft@gt@it@yt@zt@{t@}t@~t@_u@au@bu@cu@du@fu@hu@iu@ku@pu@ru@su@tu@uu@vu@xu@yu@zu@|u@_v@bv@dv@gv@hv@zv@|v@~v@fw@mw@nw@pw@qw@rw@tw@uw@vw@ww@xw@yw@zw@{w@|w@}w@_x@ax@cx@dx@ex@fx@gx@hx@ix@jx@kx@lx@mx@nx@ox@px@qx@rx@tx@|x@}x@~x@_y@`y@ay@by@cy@dy@ey@fy@gy@hy@iy@jy@ky@my@ny@oy@py@qy@ry@sy@ty@uy@vy@xy@zy@|y@~y@`z@bz@dz@ez@fz@gz@hz@jz@qz@rz@sz@tz@vz@wz@xz@yz@zz@{z@|z@}z@~z@_{@`{@a{@b{@c{@d{@e{@f{@g{@h{@i{@j{@k{@l{@m{@o{@s{@u{@v{@w{@x{@y{@z{@{{@|{@}{@~{@_|@`|@a|@b|@c|@d|@e|@f|@g|@h|@i|@j|@k|@l|@m|@n|@o|@p|@q|@r|@t|@z|@||@}|@`}@b}@d}@e}@g}@h}@l}@n}@o}@q}@t}@u}@w}@y}@{}@|}@~}@`~@a~@c~@e~@f~@h~@m~@o~@q~@r~@s~@v~@__Af_Ag_Ai_Ak_Am_An_Ap_Aq_As_Au_Av_Aw_Ax_Az_An`Ap`Ar`Az`A{`A|`A}`A~`A_aAaaAeaAfaAhaAmaAnaApaAsaAwaAxaAyaA{aA}aA~aA`bAbbAqbAtbAvbAwbAxbAybAzbA{bA~bA_cAacAccAdcAfcAgcAicAjcAkcAmcAucAycAzcA{cA`dAadAddAfdAhdAidAjdAkdAmdAodApdAqdAtdAvdAydA{dA|dA~dA_eA`eAbeAeeAkeAleAmeAreAseAteAveAxeAzeAafAbfAcfAdfAefAgfAhfAifAmfAnfAofAqfArfAsfAtfAufAvfAwfAxfA{fA|fAcgAdgAegAggAigAjgAkgAlgAmgAogAqgAtgAwgAxgAygAzgA}gA_hAchAdhAehAfhAghAmhAphArhAshAuhAvhAwhAyhA|hA}hA`iAhiAjiAliAniAqiAriAsiAwiAxiAziA}iA_jAajAcjAejAojApjAqjArjAtjAujAwjAxjAyjAzjA|jAekAfkAhkAikAkkArkAukAvkAykA{kA|kA~kA_lA`lAblAclAilAklAllAnlAolAplAqlArlAslAtlAulAvlAwlAylAzlA{lA|lA}lA~lA_mA`mAamAbmAcmAdmAemAgmAhmAimAjmAkmAlmAmmAnmAsmAxmA}mA_nA`nAbnAdnAfnAhnAinAlnAmnAnnAonAqnAunAvnAwnAynAznA{nA|nA}nA~nA_oAcoAeoAgoAjoAkoAmoAooApoAroAsoAtoAvoAwoAxoAyoAzoA{oA|oA}oA~oA_pAapAcpAdpAepAfpAgpAhpAipAkpAlpAnpAppArpAspAtpAvpAxpAypAzpA{pA|pA}pA~pA_qAaqAbqAcqAfqAgqAhqAiqAjqApqAqqArqAsqAuqAwqAyqAzqA{qA~qA_rA`rAarAdrAfrAhrAirAjrAkrAlrAmrAorAsrAtrAvrAwrAxrAyrAzrA{rA|rA~rA_sA`sAcsAdsAesAfsAgsAhsAisAjsAksAosApsAqsArsAssAtsAusAvsAwsAxsAysAzsA{sA|sA}sA~sA_tA`tAatAbtAdtAetAftAgtAhtAjtAktAltAmtAntAotAptAqtArtAstAttAutAvtAwtAxtAytAztA{tA}tA~tA_uAauAbuAcuAduAeuAfuAguAhuAluAmuAnuAouAquAruAsuAtuAuuAwuAxuAzuA{uA}uA~uA_vA`vAavAbvAdvAfvAivAkvAlvAmvAnvAovAqvAtvA|vA}vA~vA_wA`wAawAbwAcwAdwAewAfwAgwAhwAkwAmwAnwAowApwArwAswAtwAuwAvwAwwAxwAywAzwA{wA|wA}wA~wA_xA`xAaxAbxAcxAdxAexAfxAgxAhxAixAjxAkxAlxAmxAnxApxAqxArxAsxAtxAuxAvxAyxA{xA}xA_yAayAbyAcyAdyAeyAfyAgyAiyAlyAmyAnyAoyApyAryAtyAuyAvyAxyAyyAzyA|yA}yA~yA`zAazAbzAczAdzAezAfzAgzAhzAizAjzAlzAmzAnzAozApzAqzArzAszAuzAvzAwzAxzAyzAzzA{zA}zA~zA_{A`{Ab{Ac{Ae{Ag{Ah{Ai{Aj{Ak{Al{Am{An{Ao{Ap{Aq{Ar{As{At{Au{Av{Ax{Ay{A{{A|{A}{A~{A_|A`|Aa|Ab|Ac|Ad|Ae|Af|Ag|Ah|Ai|Aj|Ak|Al|An|Ao|Ap|Aq|Ar|As|At|Au|Av|Aw|Ax|Ay|Az|A{|A||A}|A~|A`}Aa}Ab}Ac}Ad}Ae}Af}Ag}Ah}Aj}Al}Am}An}Ao}Ap}Aq}Ar}As}At}Au}Av}Aw}Ax}Ay}Az}A{}A|}A}}A~}A_~A`~Aa~Ab~Ac~Ad~AmK????????????????b@?b@?aA??dE??????????????????@???~E?????@????????????@????????????G???wF??G??????G^xF????tD??vHsG????eB@?^???pB?lB??G??@????K???????K?X??????l@??ZG????@?????TK??K??????MuB???g@????????UU???K?_@???wMh@?G?Z^@?pASM??gCM???m@@?]gCG?tB??`M?M?M?G????_Fv@g@Uh@@?T?KM??iMiOkB??aC????gO??t@??p@?????}B?}AjBp@?_@??_IoH?JfM?n@]??U????????aPzB?@@????????????zP{P???lB??????cMn@_@rA?yP|P??_A?T?eB???fPcN??????qC?uB]?]jQqCm@hBpB?@??Z?????^?aAcReP@??m@??pCrCoQ?mQoC@T???eMT?A?B?C?D?E?F?G?H?I?J?K?L?Mw@BtCDvCF?N?O?P?Q?R?S}CCuCEwCGyCI?T?U?VND~CNx@Py@Wz@E_DHzCJ?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@?d@?e@cDFxCH{@XdDZfDf@?g@?h@?i@?j@?f@lDh@|@j@nDg@mDi@`@k@?l@WNx@m@?n@?o@?p@?q@?r@?s@WG`DJ|Ct@?u@b@v@?w@?x@?y@?z@?{@?|@?}@?~@?_A?`A?aA?bA?cA?dA?eAOfA?gA?hA?iA?jA?kA?lA?mA?nA?oAuDH{@K?t@?pAw@jAIqA?rA_EI{CXjD[}@h@|@sA?tA?uA?vA?wAOb@iDxA?yA?zA?{A?|A?}A?~AeEJvDu@wDx@xDz@~@|@zD_B?`B?aB?bB?cB?dB?eB?fB|DkA?gB?hB?iB?jB?kB?lB?mBc@K`Eu@CnB?oB?pB?qB?rB?sB?tB?uB?vB?wBbEkA?qA?xB?yBWzB?{B?|B?}B?~B?_Cc@XfEf@a@`C?aC?bC?cC?dC?eC?fC?gCYc@?hC?iC?jC?kC?lC?mC?nC?oC?pC?qC?rC?sC?tC?uCDqAc@vC?wC?xC?yCqDO?m@sDp@?zC?{C?|CBd@?}C?~CeAYeD[gEi@`@_DgD]Cy@yD{@?`D?aD?bD?cD?dD?eD?fD?gD?hD?iD?jDtEt@aEkD?kD?lDbAoBuEqBwEsByEuB?mD?nD?oD?pDPPy@qD?rDkAz@~@`DlAbDrFsD?tD?uD?vD?wD?xD?yD?zDD{D?|D?}D?~D?_E?`E?aE?bE?cE?dE?eE?fEyF{@pFaDqFcD?sD{FuD}FwD_GyD?gEQ|@hE`BjEbBlEdB?hEnEjAIgBpEiBrEkB?iE?jEeAkE?lE?mENnE?oE?pE?qE?rE?sE?tE?uE?vE?wE?xEQ`DlAyEqAzE?{E?|E?}E?~E?_F?`F?aF?bF?cF?dF?eF?fF?gF?hF?iF?jF?kF?lFQmF?nF?oF?pF?qF?rF?sF?tF?uF?vF?wF?xF?yF?zF?{F?|F?}F?~F?_G?`G?aG?bG?cG?dG?eG?fG?gG?hG?iG?jG?kGmAlG?mG?nG?oG?pGuG{EvGqG?rG?sG?tG?uG?vG?wG?xG?yG?zG?{G?|G?}G?~G?_H?`H?aHWbH?cH?dH_AiADlA?eH?fHwGnFxGpFzGrF|GtF~GgH?hH?iH?jH?kH?lH?mH?nH?oH?pH?qH?rH?sH?tH?uH?vH?wH?xH?yH?zH?{H?|H_H}H?~H?_I?`IFaI?bI?cI?dItAdInHeI?fIkHoFyGqF{GsF}GuF?gHlHgI?hI?iI?jI?kI?lI?mI?nI?oI?pI?qI{E{B|E}B`H|E?qGaHsGbHuGcHwGdHyGeH{GfH}G?rI?sI?tI?uIYvI?wI?xI?yIDzI?{InApBvErBxEtBcAmDvFoD?|I?}I?~I?_JY`JnFZkDg@pDj@oFj@}@aJgHcHrAhA{DjAIlAiHfHPm@rDo@XbJFQ?cJf@dJFeJ?fJ?gJBhCbFjCdFlCgAhJiAwC?iJ?jJ?kJ?lJEn@?mJ?nJ?oJ?pJpHwIqHyIuAqJ[rJ?sJiEaBkEcBmEhEpGkAoEhBqEjBEtJ|HiCcFkCeFmC?hJBuJqAaDhGsDjGvD~FxD`GzDbG|DdG~DfG`E?vJPwJ?xJ?yJ?zJ?{J?|J?}J?~J?_K?`KzAbDzFtD|FvD?aKhHjAvAmAf@bK?cK?dK?eKf@bImHdI[}@?_B?fK?gKBhK|AcDiGtDtIwDlGzDjI}DeG_Ed@aEe@cE?iK?jK?kK?lK?mK?nK?oK?pK?qK?rK?sK?tKgGbE?uK?vK?wKRsDgIwDxIjAI{DcG}DzI`EfJcE|IjK~IlK?xK?yKzAzK?{K?|K?}Kk@tDwIxDiIjAhJ|DkI_Ed@~KbA_LmJuDkGxDnJkA?{D`B~D{AaEe@uK_BwKB`L?aL?bLqJvDhIyDaGjAoJ}DiJaEe@cL_BdL?eLtHqBtFtBcAvB~HfL?gLEo@XhLQiL?jL?kL?lL?mL?nL?oL?pL?qL?rL?sL?tL?uL?vL?wLzHiAsAeHjHoA\jC}HmCfFoChFqCjFsChAuCmFrA?xL?yL?zLN{L?|L?}LmIxJnIzJpI|JrI~J?~L?`CaFbC?_M?`M?aMFbM?cM`IxIrHjAIzIsHdM?eM?fM?gMlIoA|JjL}JlL_KnLaKpLcBrLdKtLeKvLgKdHuIkA`AeHAqD?hMPiM?jMAcJRkM?lM?mM?nM?oM?pMEqMyAo@XrMAsM?tMbBrBuHuBdAnDaIsJbIbBnGhEeIgBrGjBsEiEOuM?vM?wM?xM?yM?zMzKsBuFvB?{M?|MaBwDgJkAsJ|DpJ`EjJiK}IkK_JmKaJoKbJqKdJsKS}M?~M?_NO`NuKlA}DnAFaN?bN?cN?dNtGoE?eN?fN?gN?hN?iN?jNnBeHaBaKnBmA~DoA`LtBzJnD?kN?lN?mN?nNaLxDrJ{DtJ_E{IbEoAiKdLlK`JnKj@oN?pNoLhA{HkA`AmAwKlMxKnMyKpMiBqN?rN?sN?tNxH[yHf@a@uN?vN?wNPxN?yN?zN?{N?|N?}N?~N?_O?`O?aOEbO?cOZdO?eO?fO?gO?hO?iO?jO?kO?lOvImO?nOnLfHyAmJ?oO?pO?qO?rO}AcIAsOJtOAuO?vOARkBwOiKkC?xO?yO?zO?{O?|O~K}O?~On@_P?`PHaP?bPsBcP?dP?cPwBcPhMdPwBePAfP?gP}Lo@hLhAvLlAiLoAsBdIFhP?iP?jP?kPrLyDwJkAbL}DyJbEsLjKlJmKmBpKcJrKeJtK?lP?mP?nPi@_B{KcBdIfBDoPwLf@a@i@`@f@tMj@xLg@UpPAWFqPaDU?rPqLuBdAwBvMvBbMoABsPjMzDyI~DuJbEmMkKeLnKj@tPxMjAxJ~D{AvJyLyNzL{N|LuP?vP?xNqBzN{L|N?uP?wP?xP?yPg@wNsMg@?aJ?zPC{PR|P?}P?~P?_QiBkL~JmL`KoLbKqLcK`Q?aQ?bQDcQ?dQ?eQ?fQ?gQ{MkAkM~DyMcEkJkKzMoKfLrK{BgM}MzN`NuPq@xN_C{N~BxNsN|NaNvP?hQ?iQ?jQ?kQElQjLbN?fPvBvO{Jp@?mQwAnQjBoQBpQVqQ?rQpN{N~BvP_NyN~M|NtNxNr@sQ?tQ?uQuNkQ?vQAtO[wQ?xQmAyQ?zQB{Q?|Q?}Q?~Q?_RkKyJoI{JqI}JsI~LmKaCfA_MnKaMxA`Rh@lJgMaR}BbR?cRuMTbDdRwN|N?sQ?eR?fR?gR?hR?iRrBjRjAkRdCuPbCzNqNxNr@uPq@vP}N{NxNxN_OvP`O|NyNyNcCuPrNyNfCvPbOuPq@hQ?lR?mRjA|CLnRtBbKJtMhOvOxBoRo@iPdMlCgApR?qRBrRaMnOiAsR?tR?uR?vRdNlLrKoLfNrL?`QhNbQjNdQ`CwR?xR?yR?uMoBpE?zR?{RoBeNkLgNlLiNmLhAyBeHlN{D`B|R?}RoNvJ|A~R?_S?`SrO|DcLaE~AdEuO}DlMcEmNlKuLoKnNsKkOmLeNpLtK`QnOjAIcQkNeQ?aS?bS?cS?dS?eS?fSCgS?hS?iShC~D|MoARdDsFjS?kS?lSRmS?nS?oS?pSv@_Ed@vJfBgE|BqS?rS?sS?tS?uS?vSHwS?xSl@yIuA{I?dMgByS?zS?{S\|S?}S?~S?_T?`T|B`BmGcBrMjAqGhBfIkB?aT?bT?cT?dT~LiO_MkOu@eT?fT?gTtOhTCiTbBjT?kTClT?mTyO`EvJnTiCnLsKqLgNaQiNjAwOdQ`CfQVnDs@vPcOoT?pT?qTxArTjCvJjCaE~AiKtLmKmBsThC|RsOsKSgMl@tTLuT?vT?wT?xTaCvQlCxNeCvPeOvPmCvPmCxNeCxNr@yT?zT?{T?|T?}T?~T?_UE`ULcNAaUBbUnPyNdOxNpPyNfCcU?dU?eUfOmRLfPQfU?gU?hUrPzN~NyNsPyNvPzNuPiU?jU?kUHlU?lU?mU?nU?oU?pU?qUvB`PJrUEsU?tU?uU?vUpOiAwAwUHxUlCvPbCyULzUs@wP?{U?|UtP{NaOyNcCsQzN}U?~U?_V?`V?aV?bVrBcV?dVmPkQ{NwNEeVJfVs@xN_C`O?hLvNgVHnJzBdItAeIxBgPAhVo@gEzOrS{OtS|OvS_@rDwPxNoPxNqBoT?aRHiVAjV?kV?lV?mVJ`PYnV?oVnCpVbPfTdP`S?hT}OjAoKqVdC`O_PaBcIdBoGfBDgB}KkBu@rV?sV?tV?uV_LvV?wV?xVk@yV?zVpLnAt@hAqOfHxOeD?jS?{VqP|VkCkN?}V[~V?_W?`W?aW?bW?cW?dWV{MbQzVcQoAkCoDlP}R{BeW|NzJlK}J?fW?gW?hWHiWV|Mp@jWo@kWFlW?mW?nWnCoVjOmCjKpCiFrCkFtClFjAcErA?oWgPoLlO`QdBpW?qW?rW?sWxP|N?tW?uW?vWhDwWHxW?yW?zWLqDA{WN|WiC}W?~W?_X?`X?aX?bX?cX?dX?eX?fX?gX?hX?iX?jXsQkX?lX}PmX?nXzEqA?oX?pX?qXi@rX?sX?tX?uX?vVaQvX?wX?xX?yX?zXt@{XD|X?}X?~XtQ_Y?`Y~PkA?zIpKeMqKgMpQnCgFpCqQsChAaY?bYjPbEoAdEpAfE?cY?dY?eY?fYCgYkQhY?iYfQ_WgQjYoC|IwH_JeQjS?kY?lY?mYk@nY?oY?pY?qY?rY?sY?tY_R{VrQpLcBuY?vY?wY?xY?yYkAzY?{Y?|Y\}Y?~Yi@_Z?`Z?aZ~Q`WhQbWiQbZyQzIzQfMlQhAyBmACcZaR{I~OeM{QvJVwBnAdZ`RqLhPaQu@eZuQsXvQuXpCwV?vXwQxXxQzX?fZ?gZ?hZ?iZ?jZ?kXv@kZqMlZ|QcEvOmKoMqKgLtK?eW?mZCnZNoZ?pZ?qZ?rZ?sZ?tZ?uZ?vZ?wZ?xZ?yZ?zZ?{Z?|Z?}ZhKjAvAeHbNh@oDf@`FaCfA|B}E~Z?_[?`[dQiAsAa[?b[\c[?eTcPgTbRdMgBfMhBvJdRrLmOgEnQsKSmZ_QbB|KfB`QhB`PaToOd[rCxMsCiKkPnKj@pKpMsKSeW?e[Of[gR`QdBuLfKwLfRkAvKfHhRjKnMnKiRqKeRgMiPoAfB|L?g[sCdE}Qh[z@i[?j[Dk[?l[?m[?n[?o[?p[
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????A??B??B?????C??D??C?????C??E??C?????C??F??C?????C??G??C?????C??H??C?????C??I??C?????C??J??C?????C??K??C?????C??L??C?????C??M??C?????C??N??C?????C??O??C?????C??P??C?????C??Q??C?????C??R??C?????C??S??C?????C??T??C?????C??U??C?????C??V??C?????C??W??C?????C??X??C?????C??Y??C?????C??Z??C?????C??[??C?????C??\??C?????C??]??C?????C??^??C?????C??_??C?????C??`??C?????C??a??C?????C??b??C?????c??d??pS?WC?e??f??@U?wL?g??h??PJ?sC?g??i??pr??K?j??k??oH?gN?C??l??C?????C??m??C?????C??n??C?????C??o??C?????C??p??C?????C??q??C?????C??r??C?????C??s??C?????C??t??C?????C??u??C?????C??v??C?????C??w??C?????C??x??C?????C??y??C?????C??z??C?????C??{??C?????C??|??C?????}??d??pA?Cs?~??d??P@?kf??@?@@?@V??F@A@?d??pH?_O?B@?C@?@@?k`?D@?d??@U?kA?E@?F@?`d?WC?E@?G@?pH?kG?H@?I@?`E?wZ?J@?K@?@A??t@J@?L@?pC?ot@M@?K@?`A?geBM@?K@?pQ?CeBM@?N@?@J??lBM@?O@?@?????e??f??PW?GM?P@?Q@?@?????R@?S@?B?????T@?U@?B?????A??V@?D?????A??W@?D?????A??X@?D?????A??Y@?D?????A??Z@?D?????A??[@?D?????C??\@?C?????A??]@?D?????A??^@?D?????C??_@?C?????c??d??`P?OC?`@?a@?P??_G?`@?a@?p@?CI?`@?b@????wG?g??i??@o?oJ?c@?d@?@A?SG?c@?d@?`C?gG?c@?e@?PC?wJ?f@?g@?pA?sb?M@?g@?PF?Wq?M@?h@?@?????E@?G@?@[?OH?i@?F@?@b??Q?j@?F@?`A?KC?j@?F@?@a?CE?j@?k@?@`?OG?l@?F@?@@?wB?l@?m@???????R@?n@?B?????A??o@?D?????A??p@?D?????A??q@?D?????A??r@?D?????A??s@?D?????A??t@?D?????A??u@?D??????@?@@?`E?GE@?@?v@?pc?WA@w@?x@?pE?KZ?y@?z@?PY?[d@{@?|@?@G?gUB{@?}@?`D?[WB~@??A?p@?g^?@A?AA?P@?ST?M@?AA?@?????R@?BA?B?????A??CA?D?????A??DA?D?????C??EA?C?????C??FA?C?????C??GA?C?????C??HA?C?????C??IA?C?????C??JA?C?????C??KA?C?????C??LA?C?????C??MA?C?????C??NA?C?????C??OA?C?????C??PA?C?????C??QA?C?????C??RA?C?????g??i??@A@sK?g??SA?PD??H?TA?UA?`S?OD?VA?WA?P@?_@?XA?WA?PD?kF??@?YA?PN?sS@w@?ZA?`^?[Y?w@?[A?pC?KJ?\A?]A?P@?w]?^A?_A?@B??~?^A?`A?`F?Ke?@A?aA?@A?CJ?M@?aA?@?????R@?bA?B?????C??cA?C?????C??dA?C?????C??eA?C?????C??fA?C?????C??gA?C?????C??hA?C?????C??iA?C?????j??k??pH?gN?j??jA?E??wS?C??kA?C?????lA?d??@B????TA?mA?p??WD?nA?UA?PG?GC?oA?UA?@B????pA?qA?PG?SD?rA?sA?@O?WE?tA?uA????CS@C??vA?C?????C??wA?C?????C??xA?C?????C??yA?C?????C??zA?C?????C??{A?C?????M@?AA???????|A?}A?C?????C??~A?B?????C???B?C?????C??@B?C?????C??AB?C?????pA?qA?pI?WD?g??BB?@W?GN?g??CB?pA?gO?e??F@?@B?WH?e??F@?PG?OI?DB?F@?pE?WQ?EB?F@?@?????R@?FB?B?????A??GB?D?????A??HB?D?????A??IB?D?????A??JB?D?????A??KB?D?????A??LB?D?????A??MB?D?????A??NB?D?????A??OB?D?????A??PB?D?????A??QB?D?????A??RB?D?????A??B??B?????l@?m@?@?????A??SB?D?????A??TB?D?????C??UB?C?????C??VB?C?????C??WB?C?????C??XB?C?????C??YB?C?????C??ZB?C?????C??[B?C?????C??\B?C?????C??]B?C?????C??^B?C?????C??_B?C?????C??`B?C?????C??aB?C?????C??bB?C?????nA?UA?EJ?OC?TA?mA?@C?cD?cB?dB?pA?{`?cB?eB?PM?GW?cB?fB?PB?_Y?gB?hB?`\??H?iB?jB?p??__?kB?jB?@H?oJ?lB?jB?p??{f?lB?mB?pZ?ci?lB?nB?PH?_n?lB?oB?@T?kt?pB?qB?P??sv?rB?qB?pl?CH?sB?tB?PN?WZ?uB?vB?@B?SG?wB?xB?@@?GJ?yB?d??@A?_X?zB?{B?pE?Om?|B?}B?_??w]?D@?d??pW?sA?~B??C?`??Sp?~B?@C?PF?cc?tA?AC?@l?gk@BC?AC?`??S??CC?DC?`J?{O?CC?EC?`@?cP?FC?GC?@A?kR?HC?IC?`VB_I?JC?KC?PA????LC?MC?`??w`?NC?OC?@E?Su?PC?QC?@Z?g^?NC?RC?@B?sI@NC?RC?@F?{L@SC?TC?@i?SS@SC?UC?pD?{u@SC?VC?@Q??x@WC?XC?@Q?WI?SC?YC?p??OP@SC?YC?PC?gP@ZC?hB?`@?WM@[C?hB?`@?wA?NC?hB?PG?C]?\C?]C?PD?oq?\C?^C?PP?Wt?_C?`C?pE??n?_C?aC?PD?kp?_C?bC?@n?KW?cC?dC?`a?sz?eC?YA?U|CSs?C??fC?C?????C??gC?C?????C??hC?C?????C??iC?C?????C??jC?C?????cB?fB?pE?gY?cB?kC?pA?KO?cB?lC?@B??P?mC?lC?@G?KB?nC?oC?PY?SD?pC?qC?`A?WE?pC?rC?`E?OM?pC?sC?P@??K?tC?uC?P@?GF?vC?wC?P@?KA?vC?wC?pF?[B?xC?yC?pG?OC?zC?yC?PB?{p@zC?{C?@D?[r@|C?hB?p@?[F?|C?}C?@X?OH?~C??D????o[?C??@D?C?????C??AD?C?????C??BD?C?????A??CD?D?????A??DD?D?????JC?KC?@G????ED?IC?pZ????FD?GD?P?????HD?ID?`@?GT?HD?JD?@@?OW?HD?KD?PA??X?LD?MD?pE?OF?LD?ND?PC?GL?LD?OD?PF?OM?PD?QD?`??WV?PD?QD?@@?cV?M@?RD?`B?KG@M@?SD?@?????TD?XC?@r@GF?UD?VD?pD?s`AUD?WD?`B?ouBUD?XD?`s?OyBHD?YD?pg?oE?HD?ZD?`??KM?HD?ZD?pa?OL?HD?ZD?PC?cM?HD?[D?@EBCR?_C?`C?`F??n?_C?\D?@A?{R?UD?]D?p??SSA^D?_D????SJAC??`D?C?????C??aD?C?????C??bD?C?????C??cD?C?????C??dD?C?????C??eD?C?????FD?GD?@D????TD?fD?@w?gT?TD?gD?pq?_L?hD?iD?`Y?_DESC?jD?pL??f?SC?kD?`a?Kq?lD?mD?P@?_j?lD?nD?P\??[?lD?oD?PE?ST?pD?MD?PD?_T@qD?MD?eG?gy?zC?{C?@I?cr@rD?yC?@K?GUAsD?yC?`b?gHBtD?uD????sS?g??h??@F?WC?e??d@?@A??G?EB?d@?@?????R@?vD?B?????A??wD?D?????A??xD?D?????C??yD?C?????C??zD?C?????C??{D?C?????C??|D?C?????g??h??E??CC?C??}D?C?????C??~D?C?????C???E?C?????C??@E?C?????C??AE?C?????C??BE?C?????C??CE?C?????w@?ZA?E??OX?C??DE?C?????C??EE?C?????C??FE?C?????C??GE?C?????C??HE?C?????C??IE?C?????C??JE?C?????C??KE?C?????A??LE?D?????E@?F@?`[?KC?E@?ME?@C?_F?C??NE?C?????g??i??`Z??J?A??OE?D?????C??PE?C?????C??QE?C?????C??RE?C?????C??SE?C?????C??TE?C?????C??UE?C?????C??VE?C?????C??WE?C?????C??XE?C?????C??YE?C?????e??F@?uS?wI?C??ZE?C?????c??d??@M?KC?[E?\E?`E?_G?`@?hB?E??_G?i@?F@?uN?sP?]E?^E?Q??[G?g??i??Pb?WJ?A??_E?D?????A??`E?D?????A??aE?D?????A??bE?D?????A??cE?D?????A??dE?D?????A??eE?D?????A??fE?D?????A??gE?D?????A??hE?D?????A??iE?D?????A??jE?D?????A??kE?D?????A??lE?D?????A??mE?D?????A??nE?D?????A??oE?D?????nA?UA?`D?wB?pE?qE?`??CB?rE?MD?`??oa?rE?sE?E??[b?A??tE?D??????@?v@?E??k?@g??i??Px?GK?g??uE?@R?cG?A??vE?B?????A??wE?D?????A??xE?D?????A??yE?D?????C??zE?C?????C??{E?C?????C??|E?C?????D@?d??`P?gA?}E?~E?pC?{D?}E??F?pE?SD?@F??F?P@?Gh?@F?AF?p@?oV?BF?AF?@D?_L?CF?DF?P@?GH?CF?DF?@Y?SG?CF?EF?PO@GO?FF?EF?pA?OC?FF?GF???????HF?IF?B?????C??JF?B?????C??KF?C?????C??LF?C?????A??MF?D?????A??NF?D?????A??OF?D?????C??PF?C?????C??QF?C?????C??RF?C?????C??SF?C?????C??TF?C?????C??UF?C?????C??VF?C?????C??WF?C?????C??XF?C?????A??YF?D?????A??ZF?D?????A??[F?D?????A??\F?D?????c??d??ON?KC?C??]F?C?????C??^F?C?????pA?qA?@@?KD?_F?`F?@B?w@?aF?qB?PD?gn@aF?uC?`A?cr?aF?bF?pB??N@cF?dF?@D?[A?C??eF?C?????C??fF?C?????C??gF?C?????C??hF?C?????A??iF?B?????A??jF?B?????A??kF?B?????C??lF?C?????C??mF?C?????c??d???J?CC?C??nF?B?????R@?oF?B?????A??pF?D?????A??qF?D?????A??rF?D?????e??f??EX?GM?C??sF?C?????C??tF?C?????C??uF?C?????C??vF?C?????C??wF?C?????C??xF?C?????C??yF?C?????C??zF?C?????C??{F?C?????C??|F?C?????|A?}F?C?????C??~F?B?????C???G?C?????C??@G?C?????A??AG?D?????A??BG?D?????}E??F?P@?KD?CG?DG?p@????}E?EG?p??WC?}E?FG??@?sF?C??GG?C?????C??HG?C?????A??IG?B?????C??JG?C?????C??KG?C?????C??LG?C?????C??MG?C?????C??NG?C?????C??OG?C?????C??PG?C?????C??QG?C?????C??RG?C?????C??SG?C?????C??TG?C?????C??UG?C?????A??VG?D?????A??WG?D?????A??XG?D?????A??YG?D?????A??ZG?D?????A??[G?D?????A??\G?D?????A??]G?D?????A??^G?D?????[E?\E?pA?WG?[E?_G?@?????C??`G?C?????C??aG?C?????C??bG?C?????C??cG?C?????C??dG?C?????C??eG?C?????C??fG?C?????C??gG?C?????C??hG?C?????XA?WA?pB?gF?XA?iG?e@?GE?A@?hB?q@?_H?jG?kG?aC?KY?B@?hB?a@?[`?A??lG?B?????c??d??_P?OC?C??mG?C?????C??nG?C?????C??oG?C?????C??pG?C?????C??qG?C?????C??rG?C?????C??sG?C?????C??tG?C?????C??uG?C?????C??vG?C?????C??wG?C?????C??xG?C?????C??yG?C?????A??zG?D?????A??{G?D?????A??|G?D?????A??}G?D?????C??~G?C?????C???H?C?????C??@H?C?????g??i??@g?cJ?A??AH?D?????C??BH?C?????C??CH?C?????C??DH?C?????C??EH?C?????C??FH?C?????C??GH?C??????@?@@??X?CF@pA?qA?@I?WD?pA?HH?@A?GE?IH?hB?eH?_D?JH?qC?a??KJ?FF?GF?@?????A??KH?B?????R@?EF?B?????A??LH?D?????A??MH?D?????A??NH?D?????A??OH?D?????A??PH?D?????C??QH?C?????C??RH?C?????C??SH?C?????C??TH?C?????C??UH?C?????C??VH?C?????C??WH?C?????C??XH?C?????g??i??pY??J?C??YH?B?????A??ZH?B?????C??[H?C?????C??\H?C?????C??]H?C?????C??^H?C?????E@?F@?pi?cC?E@?_H????sD?C??`H?C?????C??aH?C?????g??i??Pf?cJ?g??bH?`L?sL?c@?d@?AA?SG?c@?d@?QA?cG?c@?cH?AD?GI?C??dH?C?????eH?fH?B?????C??gH?C?????C??hH?C?????C??iH?C?????C??jH?C?????C??kH?C?????C??lH?C?????C??mH?C?????C??nH?C?????C??oH?C?????C??pH?C?????C??qH?C?????C??rH?C?????C??sH?C?????C??tH?C?????w@?ZA?ER?{X?w@?uH?q@?oK?g??i??@Y??J?C??vH?C?????C??wH?C?????C??xH?C?????C??yH?C?????A??zH?D?????A??{H?D?????A??|H?B?????C??}H?C?????C??~H?C?????A???I?D?????A??@I?D?????oA?UA?p@????j??AI?`C?{F?aF?BI?QB?SVAA??CI?D?????A??DI?D?????A??EI?D?????A??FI?D?????A??GI?D?????A??HI?D??????@?@@?pG?KE@~??II?`??Sh?^A?JI?E??cy?tA?uA?@C?KS@tA?KI?Ee?_e?tA?LI?AC?cW?pA?qA?E@?KD?_F?`F?AB?w@?aF?qB?aB?gn@aF?MI?q@?{ZCi@?F@?`K?kP?i@?NI?@A?[I?]E?OI?pD?[I?]E?PI?@@??L?QI?PI?P??{MA}??PI?PB?oM?C??RI?C?????C??SI?C?????A??TI?D?????A??UI?D?????A??VI?D?????TA?UA?PR?OD?WI?XI?p@????YI?ZI?P?????HD?[I?@B?__?M@?[I?@?????A??\I?D?????A??]I?D?????A??^I?D?????A??_I?D?????j??AI?PP?KG?`I?aI?p??kC?aF?BI?q??gSAbI?BI?AG?SL??@?@@?_E?GE@{@?|@?EG?gUB{@?}@?QB?[WB?@?@@?pJ?_E@?@?cI?@??kX?g??uE?E??kF?C??dI?C?????C??eI?C?????C??fI?C?????C??gI?C?????A??hI?D?????iI?jI?B?????C??kI?C?????C??lI?C?????C??mI?C?????C??nI?C?????C??oI?C?????C??pI?C?????C??qI?C?????C??rI?C?????C??sI?C?????C??tI?C?????C??uI?C?????C??vI?C?????C??wI?C?????g??i??PC@{I?C??xI?C?????C??yI?C?????C??zI?C?????D@?d??p@??A?{I?|I?@@?cD?C??}I?C?????C??~I?C?????C???J?C?????C??@J?C?????C??AJ?C?????C??BJ?C?????C??CJ?C?????C??DJ?C?????C??EJ?C?????C??FJ?C?????C??GJ?C?????C??HJ?C?????C??IJ?C?????C??JJ?C?????C??KJ?C?????C??LJ?C?????C??MJ?C?????C??NJ?C?????C??OJ?C?????C??PJ?C?????C??QJ?C?????C??RJ?C?????C??SJ?C?????C??TJ?C?????C??UJ?C?????C??VJ?C?????C??WJ?C?????C??XJ?C?????C??YJ?C?????C??ZJ?C?????C??[J?C?????C??\J?C?????C??]J?C?????C??^J?C?????C??_J?C?????C??`J?C?????C??aJ?C?????C??bJ?C?????g??h??QJ?sC?g??i??aZ??J?g??i??qY??J?A??cJ?D?????j??AI?`N?GG?aF?dJ?`@?_fAaF?dJ?@F?_hAaF?eJ?`A?[[CC??fJ?C?????C??gJ?C?????C??hJ?C?????g??BB?pI?wM?aF?iJ?aA?wy@tA?KI?P\?Se?C??jJ?C?????C??kJ?C?????E@?F@?PG?_B?lJ?hB?`C?{F?lJ?hB?@@?SL?lJ?hB?p}?KO?lJ?EF?p??_T?lJ?GF???????mJ?nJ?B?????A??oJ?D?????C??pJ?C?????C??qJ?C?????C??rJ?C?????C??sJ?C?????C??tJ?C?????C??uJ?C?????C??vJ?C?????C??wJ?C?????C??xJ?C?????A??yJ?D?????mJ?zJ?B?????C??{J?B?????c??d??PN?KC?`@?|J?@??kH?C??}J?C?????C??~J?C?????C???K?C?????C??@K?C?????C??AK?C?????C??BK?C?????C??CK?C?????C??DK?C?????C??EK?C?????BF?AF?`F?gL?FK?GK?p??{E?FK?GK?pF?gE?FK?HK?`Q?wD?IK?hB?@@?wB?JK?hB?`??GD?KK?hB?`??cB?LK?hB?`??KC?MK?hB?@E?{O?MK?NK?@C?wp?MK?NK?@?????mJ?OK?B?????C??PK?B?????C??QK?C?????C??RK?C?????C??SK?C?????C??TK?C?????C??UK?C?????A??VK?D?????A??WK?D?????A??XK?D?????E@?G@?`L?oG?H@?uA?`@?KN?YK?uA?PK?g}?C??ZK?C?????C??[K?C?????C??\K?C?????C??]K?C?????C??^K?C?????|A?_K?C?????R@?`K?B?????A??aK?D?????A??bK?D?????A??cK?D?????A??dK?D?????A??eK?D?????C??fK?B?????C??gK?C?????A??hK?D?????A??iK?D?????A??jK?D?????c??d??oS?WC??@?@@??V??F@C??kK?C?????C??lK?C?????lJ?hB??D?kL?tA?KI?@e?_e?tA?LI?@D?cW?YK?mK?`??kO?g??BB?pD?gM?nK?oK?A@?SL?pK?qK?a??SE?pK?}B?QD?[D?rK?sK?a@?SJ?tK?uK?q??gK?vK?wK?A@?g~@FF?EF?`E?WC?xK?_A?P??WC?yK?zK?p??gE?{K?MD?@C?SI?|K?}K?aH?[Z?A@?d??pB??O?tK?~K?aK?OC??L?@L?AJ?OJ?TA?UA?@??kC?c??d???M?KC?E@?G@?@B?_G?AL?BL?P??[@?CL?DL?`@?c??mJ?EL?B??????@?@@?_I?_E@w@?x@?QB??Z?j??AI?AF??G?|A?FL?C?????C??GL?C?????C??HL?C?????C??IL?C?????C??JL?C?????A??KL?D?????A??LL?D?????A??ML?D??????@?@@?oG?KE@C??NL?C?????C??OL?C?????C??PL?C?????C??QL?C?????C??RL?C?????C??SL?C?????C??TL?C?????C??UL?C?????C??VL?C?????C??WL?C?????C??XL?C?????C??YL?C?????C??ZL?C?????C??[L?C?????C??\L?C?????C??]L?C?????C??^L?C?????C??_L?C?????A??`L?D?????A??aL?D?????TA?UA?`H?{C?bI?bL?@??WT?A??cL?D?????e??f??pX?KM?C??dL?C?????A??eL?D?????C??fL?C?????R@?d@?B?????A??gL?D?????A??hL?D?????A??iL?D?????A??jL?D?????A??kL?D?????
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1665357897014;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "/usr/lib/libc.so.6", "libjvm.so", "thread_native_entry", "Thread::call_run", "JavaThread::run", "CompileBroker::compiler_thread_loop", "CompileBroker::invoke_compiler_on_method", "Compiler::compile_method", "Compilation::Compilation", "Compilation::compile_method", "Compilation::compile_java_method", "Compilation::emit_lir", "BlockList::iterate_forward", "non-virtual thunk to LIRGenerator::block_do", "C2Compiler::compile_method", "Compile::Compile", "Compile::Code_Gen", "PhaseChaitin::Register_Allocate", "PhaseChaitin::Select", "RegMask::clear_to_sets", "ciEnv::register_method", "nmethod::new_nmethod", "CodeBuffer::copy_relocations_to", "PhaseChaitin::Split", "Compilation::build_hir", "IR::IR", "IRScope::IRScope", "GraphBuilder::GraphBuilder", "BlockListBuilder::BlockListBuilder", "BlockListBuilder::set_leaders", "ciMethod::bci_block_start", "MethodLiveness::compute_liveness", "MethodLiveness::init_basic_blocks", "one.nio.server.SelectorThread", "run", "one.nio.net.Session", "process", "one.nio.http.HttpSession", "processRead", "processHttpBuffer", "one.nio.http.Request", "getHeader", "GraphBuilder::iterate_all_blocks", "GraphBuilder::iterate_bytecodes_for_block", "GraphBuilder::invoke", "GraphBuilder::try_inline", "GraphBuilder::try_inline_full", "ciMethod::ensure_method_data", "ProfileData::translate_from", "Compile::Optimize", "PhaseIdealLoop::optimize", "PhaseIterGVN::optimize", "PhaseIterGVN::transform_old", "LoadNode::Value", "MemNode::can_see_stored_value", "AddPNode::Ideal_base_and_offset", "LinearScan::do_linear_scan", "LinearScan::assign_reg_num", "LinearScan::color_lir_opr", "java.lang.Thread", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.kovalenko.dao.runnables.FlushRunnable", "ok.dht.kovalenko.dao.Serializer", "write", "writeEntry", "java.nio.HeapByteBuffer", "putInt", "jdk.internal.misc.ScopedMemoryAccess", "putIntUnaligned", "putIntUnalignedInternal", "jdk.internal.misc.Unsafe", "putIntParts", "putByte", "java.lang.System", "currentTimeMillis", "libc.so.6", "__clock_gettime", "vdso", "__vdso_clock_gettime", "entry_SYSCALL_64_after_hwframe", "do_syscall_64", "__x64_sys_clock_gettime", "posix_get_realtime_timespec", "ktime_get_real_ts64", "read_hpet", "LinearScan::build_intervals", "__x64_sys_futex", "futex_wake", "DirectiveSet::should_not_inline", "one.nio.net.NativeSelector$2", "next", "findNext", "one.nio.util.Utf8", "read", "toAsciiString", "sun.misc.Unsafe", "copyMemory", "copyMemory0", "sun.nio.ch.FileChannelImpl", "sun.nio.ch.IOUtil", "writeFromNativeBuffer", "sun.nio.ch.FileDispatcherImpl", "write0", "__write", "__x64_sys_write", "vfs_write", "generic_file_write_iter", "__generic_file_write_iter", "generic_perform_write", "copy_page_from_iter_atomic", "copy_user_generic_string", "getTask", "java.util.concurrent.LinkedBlockingQueue", "take", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject", "await", "java.util.concurrent.ForkJoinPool", "managedBlock", "unmanagedBlock", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode", "block", "java.util.concurrent.locks.LockSupport", "park", "__libc_malloc", "get_timespec64", "_copy_from_user", "ciEnv::ciEnv", "ciObjectFactory::get", "ciObjectFactory::get_metadata", "ciObjectFactory::create_new_metadata", "ciInstanceKlass::ciInstanceKlass", "AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ul, G1BarrierSet>, ", "ciBytecodeStream::get_method", "ciEnv::get_method_by_index", "ciEnv::get_method_by_index_impl", "LinkResolver::linktime_resolve_virtual_method_or_null", "LinkResolver::linktime_resolve_virtual_method", "Method::print_external_name", "Symbol::print_as_signature_external_parameters", "outputStream::put", "handleParsedRequest", "ok.dht.test.kovalenko.MyServer", "handleRequest", "ok.dht.kovalenko.dao.utils.PoolKeeper", "submit", "java.util.concurrent.AbstractExecutorService", "execute", "offer", "signalNotEmpty", "java.util.concurrent.locks.ReentrantLock", "unlock", "java.util.concurrent.locks.AbstractQueuedSynchronizer", "release", "signalNext", "unpark", "pthread_cond_signal", "Compilation::emit_code_body", "LIR_Assembler::emit_code", "LIR_Assembler::emit_op1", "LIR_Assembler::move_op", "ConvI2LNode::Value", "Type::hashcons", "Type::cmp", "trim", "GraphBuilder::push_scope", "ok.dht.test.kovalenko.MyServer$$Lambda$68.0x0000000800ccb748", "lambda$handleRequest$0", "one.nio.http.HttpServer", "RequestHandler1_handlePut", "ok.dht.test.kovalenko.MyService", "handlePut", "ok.dht.kovalenko.dao.LSMDao", "upsert", "java.util.concurrent.ConcurrentSkipListMap", "put", "InterpreterRuntime::frequency_counter_overflow", "InterpreterRuntime::frequency_counter_overflow_inner", "JavaThread::pd_last_frame", "CodeCache::find_blob", "LinearScan::add_use", "Interval::Interval", "libasyncProfiler.so", "LockTracer::UnsafeParkHook", "jvmti_GetClassSignature", "oopDesc::is_a", "PhaseChaitin::gather_lrg_masks", "RegMask::is_misaligned_pair", "sendResponse", "writeResponse", "one.nio.net.Session$ArrayQueueItem", "one.nio.net.NativeSocket", "send", "__x64_sys_sendto", "sock_sendmsg", "tcp_sendmsg", "tcp_sendmsg_locked", "__tcp_push_pending_frames", "tcp_write_xmit", "__tcp_transmit_skb", "__ip_queue_xmit", "ip_finish_output2", "__dev_queue_xmit", "dev_hard_start_xmit", "loopback_xmit", "fault_in_iov_iter_readable", "fault_in_readable", "IR::split_critical_edges", "BlockBegin::iterate_preorder", "CriticalEdgeFinder::block_do", "GangWorker::run", "GangWorker::loop", "G1EvacuateRegionsBaseTask::work", "G1EvacuateRegionsTask::scan_roots", "G1RootProcessor::evacuate_roots", "G1RootProcessor::process_java_roots", "ClassLoaderDataGraph::roots_cld_do", "G1CLDScanClosure::do_cld", "ClassLoaderData::oops_do", "G1ParCopyClosure<", "G1ParScanThreadState::trim_queue_to_threshold", "ch.qos.logback.classic.Logger", "error", "filterAndLog_0_Or3Plus", "buildLoggingEventAndAppend", "ch.qos.logback.classic.spi.LoggingEvent", "<init>", "java.lang.ClassLoader", "loadClass", "jdk.internal.loader.ClassLoaders$AppClassLoader", "jdk.internal.loader.BuiltinClassLoader", "loadClassOrNull", "findClassOnClassPathOrNull", "defineClass", "jdk.internal.loader.URLClassPath$JarLoader$2", "getBytes", "jdk.internal.loader.Resource", "java.util.zip.ZipFile$ZipFileInflaterInputStream", "close", "jdk.internal.ref.PhantomCleanable", "clean", "jdk.internal.ref.CleanerImpl$PhantomCleanableRef", "performCleanup", "java.util.zip.ZipFile$InflaterCleanupAction", "java.util.zip.ZipFile$CleanableResource", "releaseInflater", "java.util.ArrayDeque", "add", "java.util.concurrent.LinkedBlockingDeque", "remove", "removeFirstOccurrence", "equals", "ok.dht.kovalenko.dao.aliases.TypedBaseEntry", "java.lang.invoke.MethodHandleNatives", "linkCallSite", "linkCallSiteImpl", "java.lang.invoke.CallSite", "makeSite", "java.lang.invoke.BootstrapMethodInvoker", "invoke", "java.lang.invoke.LambdaForm$MH.0x0000000800cd0000", "invoke_MT", "java.lang.invoke.Invokers", "checkGenericType", "java.lang.invoke.MethodHandle", "asType", "java.lang.invoke.MethodHandleImpl$AsVarargsCollector", "asTypeUncached", "asCollector", "java.lang.invoke.MethodHandleImpl", "varargsArray", "makeCollector", "makeCollectorForm", "java.lang.invoke.MethodHandleImpl$ArrayAccessor", "<clinit>", "makeIntrinsic", "java.lang.invoke.MethodHandleImpl$IntrinsicMethodHandle", "java.lang.invoke.DelegatingMethodHandle", "java.lang.invoke.LambdaForm", "prepare", "compileToBytecode", "java.lang.invoke.InvokerBytecodeGenerator", "generateCustomizedCode", "generateCustomizedCodeBytes", "clinit", "jdk.internal.org.objectweb.asm.MethodWriter", "visitVarInsn", "jdk.internal.org.objectweb.asm.Frame", "LinearScan::allocate_registers", "IntervalWalker::walk_to", "LinearScanWalker::activate_current", "LinearScanWalker::alloc_free_reg", "LinearScanWalker::free_collect_inactive_fixed", "callAppenders", "appendLoopOnAppenders", "ch.qos.logback.core.spi.AppenderAttachableImpl", "ch.qos.logback.core.UnsynchronizedAppenderBase", "doAppend", "ch.qos.logback.core.OutputStreamAppender", "append", "subAppend", "writeOut", "ch.qos.logback.core.encoder.LayoutWrappingEncoder", "encode", "ch.qos.logback.classic.layout.TTLLLayout", "doLayout", "ch.qos.logback.core.util.CachingDateFormatter", "format", "java.time.format.DateTimeFormatter", "formatTo", "java.time.format.DateTimePrintContext", "adjust", "java.time.Instant", "isSupported", "CompileBroker::post_compile", "FormatStringEventLog<256ul>::log", "os::elapsedTime", "posix_get_monotonic_timespec", "ktime_get_ts64", "java.lang.invoke.LambdaForm$MH.0x0000000800cd2c00", "java.lang.invoke.LambdaForm$DMH.0x0000000800ccd400", "invokeStaticInit", "java.lang.invoke.DirectMethodHandle", "internalMemberNameEnsureInit", "ensureInitialized", "checkInitialized", "java.lang.ClassValue", "get", "getFromBackup", "getFromHashMap", "java.lang.invoke.DirectMethodHandle$EnsureInitialized", "computeValue", "ensureClassInitialized", "ensureClassInitialized0", "java.lang.runtime.ObjectMethods", "java.lang.invoke.MethodHandles$Lookup", "findStatic", "getDirectMethod", "getDirectMethodCommon", "make", "preparedLambdaForm", "makePreparedLambdaForm", "loadMethod", "makeHiddenClassDefiner", "java.lang.invoke.MethodHandles$Lookup$ClassFile", "newInstanceNoCheck", "Matcher::match", "Matcher::xform", "Matcher::match_tree", "Matcher::Label_Root", "State::DFA", "State::_sub_Op_ConL", "bootstrap", "makeEquals", "java.lang.invoke.MethodHandles", "guardWithTest", "makeGuardWithTest", "makeGuardWithTestForm", "java.lang.invoke.MethodType", "invokerType", "insertParameterTypes", "makeImpl", "java.lang.invoke.MethodType$ConcurrentWeakInternSet", "java.util.concurrent.ConcurrentHashMap", "java.time.format.DateTimeFormatterBuilder$CompositePrinterParser", "java.time.format.DateTimeFormatterBuilder$FractionPrinterParser", "java.time.format.DecimalStyle", "convertNumberToI18N", "__recv", "__x64_sys_recvfrom", "inet6_recvmsg", "JvmtiEnv::GetClassSignature", "InstanceKlass::signature_name", "Symbol::as_C_string", "resource_allocate_bytes", "GraphBuilder::access_field", "AddLNode::add_ring", "PhaseChaitin::post_allocate_copy_removal", "Matcher::find_shared", "PhaseOutput::fill_buffer", "loadINode::emit", "AbstractAssembler::AbstractAssembler", "LIR_Assembler::process_debug_info", "LIR_Assembler::record_non_safepoint_debug_info", "DebugInformationRecorder::describe_scope", "DebugInformationRecorder::find_sharable_decode_offset", "PhaseIdealLoop::build_and_optimize", "PhaseIdealLoop::build_loop_tree", "PhaseIdealLoop::build_loop_tree_impl", "PhaseIdealLoop::sort", "__fdget", "writeOffset", "IfTrueNode::Opcode", "ktime_get", "CallGenerator::for_inline", "InlineTree::check_can_parse", "ciMethod::get_flow_analysis", "ciTypeFlow::do_flow", "ciTypeFlow::flow_types", "ciTypeFlow::df_flow_types", "ciTypeFlow::flow_block", "ciTypeFlow::StateVector::apply_one_bytecode", "ciTypeFlow::StateVector::do_new", "ciBytecodeStream::get_klass", "Node::out_grow", "one.nio.net.NativeSelector", "select", "java.nio.channels.spi.AbstractInterruptibleChannel", "isOpen", "__local_bh_enable_ip", "do_softirq", "__softirqentry_text_start", "net_rx_action", "__napi_poll", "process_backlog", "__netif_receive_skb_one_core", "ip_local_deliver_finish", "ip_protocol_deliver_rcu", "tcp_v4_rcv", "tcp_v4_do_rcv", "tcp_rcv_established", "ip_output", "nf_hook_slow", "ipv4_confirm?[nf_conntrack]", "napi_consume_skb", "skb_release_head_state", "one.nio.http.PathMapper", "find", "java.util.HashMap", "getNode", "tcp_rearm_rto", "startParsingRequestBody", "jbyte_disjoint_arraycopy", "__ip_local_out", "nf_conntrack_in?[nf_conntrack]", "nf_conntrack_tcp_packet?[nf_conntrack]", "LIR_Assembler::emit_op2", "LIR_OprDesc::as_register", "RegionNode::Ideal", "ok.dht.kovalenko.dao.utils.FileUtils", "createPairedFiles", "createFile", "java.nio.file.Files", "newByteChannel", "sun.nio.fs.UnixFileSystemProvider", "sun.nio.fs.UnixChannelFactory", "newFileChannel", "open", "sun.nio.fs.UnixNativeDispatcher", "open0", "libnio.so", "Java_sun_nio_fs_UnixNativeDispatcher_open0", "jni_Throw", "Exceptions::_throw_oop", "ExceptionsEventLog::log", "wake_up_q", "try_to_wake_up", "_raw_spin_unlock_irqrestore", "WatcherThread::run", "PeriodicTask::real_time_tick", "StatSamplerTask::task", "ciTypeFlow::StateVector::do_invoke", "ciEnv::get_klass_by_index_impl", "ciObjectFactory::get_symbol", "vmSymbols::find_sid", "Matcher::Matcher", "PhaseTransform::PhaseTransform", "tcp_recvmsg", "tcp_recvmsg_locked", "tcp_rcv_space_adjust", "tcp_mstamp_refresh", "PhaseRemoveUseless::PhaseRemoveUseless", "Compile::identify_useful_nodes", "ok.dht.kovalenko.dao.base.ByteBufferDaoFactoryB", "fromString", "java.lang.String", "encodeUTF8", "java.lang.StringCoding", "hasNegatives", "PhaseCCP::analyze", "PhaseIterGVN::add_users_to_worklist", "PhaseChaitin::build_ifg_physical", "PhaseChaitin::interfere_with_live", "I2C/C2I adapters", "not_walkable_Java", "_new_array_nozero_Java", "OptoRuntime::new_array_nozero_C", "RegisterMap::RegisterMap", "jvmti_Deallocate", "cfree", "tcp_data_queue", "sock_def_readable", "__wake_up_sync_key", "PhaseCFG::do_global_code_motion", "PhaseCFG::global_code_motion", "PhaseCFG::schedule_local", "PhaseCFG::needed_for_next_call", "G1BatchedGangTask::work", "G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::do_work", "G1CollectionSet::par_iterate", "FreeCSetClosure::do_heap_region", "CompositeElapsedCounterSource::now", "os::elapsed_counter", "JNIEnv_::CallStaticObjectMethod", "jni_CallStaticObjectMethodV", "jni_invoke_static", "JavaCalls::call_helper", "ip_rcv", "ip_rcv_core", "ok.dht.kovalenko.dao.utils.FileUtils$$Lambda$69.0x0000000800cce210", "apply", "getDataFilename", "getFullFilename", "GraphBuilder::append_with_bci", "GraphBuilder::handle_exception", "/usr/lib/ld-linux-x86-64.so.2", "ParseGenerator::generate", "Parse::Parse", "Parse::do_all_blocks", "Parse::do_one_block", "Parse::do_one_bytecode", "Parse::do_new", "GraphKit::new_instance", "GraphKit::set_output_for_allocation", "PhaseGVN::transform_no_reclaim", "NodeHash::hash_find_insert", "Compile::remove_speculative_types", "Node_Array::grow", "asm_exc_page_fault", "exc_page_fault", "do_user_addr_fault", "handle_mm_fault", "vma_alloc_folio", "__folio_alloc", "__alloc_pages", "get_page_from_freelist", "rmqueue_pcplist.constprop.0", "epollWait", "IdealLoopTree::loop_predication", "PhaseIdealLoop::loop_predication_impl", "PathFrequency::to", "GrowableArrayWithAllocator<float, GrowableArray<float> >::grow", "PhaseAggressiveCoalesce::insert_copies", "RegMask::is_UP", "PhaseIFG::SquareUp", "IndexSet::alloc_block_containing", "PhaseChaitin::elide_copy", "newTaskFor", "java.util.concurrent.Executors", "callable", "Interpreter", "PhaseIFG::re_insert", "IndexSetIterator::advance_and_next", "PhaseIdealLoop::build_loop_late", "LoadINode::Opcode", "Matcher::ReduceInst", "Matcher::ReduceInst_Interior", "State::MachOperGenerator", "PhaseLive::compute", "PhaseLive::add_liveout", "PhaseOutput::Output", "PhaseOutput::BuildOopMaps", "OopFlow::compute_reach", "MachProjNode::bottom_type", "tcp_send_ack", "__alloc_skb", "kmem_cache_alloc_node", "syscall_enter_from_user_mode", "PhaseIdealLoop::build_loop_late_post_work", "PhaseOutput::install", "nmethod::nmethod", "__netif_receive_skb_core.constprop.0", "Parse::do_call", "PredictedCallGenerator::generate", "Compile::call_generator", "ciMethod::call_profile_at_bci", "ciMethodData::data_from", "GraphBuilder::make_constant", "emptyResponseForCode", "one.nio.http.Response", "java.lang.StringBuilder", "unknown", "__x64_sys_openat", "do_filp_open", "path_openat", "link_path_walk.part.0.constprop.0", "inode_permission", "GraphKit::subtype_check_receiver", "TypeKlassPtr::as_instance_type", "TypeOopPtr::make_from_klass_common", "TypeInstPtr::make", "HaltNode::bottom_type", "MemBarNode::hash", "Node::add_req", "MachNode::cisc_RegMask", "jni_GetObjectClass", "call_stub", "Parse::do_field_access", "Parse::do_get_xxx", "Compile::alias_type", "TypeOopPtr::TypeOopPtr", "writeMeta", "LinearScan::compute_local_live_sets", "ResourceBitMap::ResourceBitMap", "parseRequest", "isAsciiString", "PhaseOutput::Process_OopMap_Node", "ld-linux-x86-64.so.2", "__tls_get_addr", "PhaseIdealLoop::get_late_ctrl_with_anti_dep", "TypeOopPtr::is_known_instance", "CodeBuffer::finalize_oop_references", "Parse::do_put_xxx", "GraphKit::access_store_at", "BarrierSetC2::store_at", "ModRefBarrierSetC2::store_at_resolved", "G1BarrierSetC2::post_barrier", "AddPNode::Identity", "Dict::Insert", "TypePtr::xmeet", "TypeInstPtr::xmeet_helper", "PhaseCFG::schedule_pinned_nodes", "IndexSet::free_block", "enqueue", "LIR_Assembler::emit_slow_case_stubs", "CounterOverflowStub::emit_code", "LIR_Assembler::add_call_info", "CodeEmitInfo::record_debug_info", "d_lookup", "__d_lookup", "unknown_Java", "G1ParScanThreadStateSet::state_for_worker", "G1ParScanThreadState::G1ParScanThreadState", "release_sock", "__release_sock", "getParameter", "indexOf", "shmem_create", "shmem_get_inode", "new_inode", "alloc_inode", "shmem_alloc_inode", "kmem_cache_alloc_lru", "lock", "acquire", "doPut", "cpr", "coder", "beginBlocking", "begin", "blockedOn", "java.lang.System$2", "PhaseIdealLoop::Dominators", "NTarjan::DFS", "skb_copy_datagram_iter", "__check_object_size", "is_vmalloc_addr", "java.lang.invoke.Invokers$Holder", "linkToTargetMethod", "java.lang.invoke.DirectMethodHandle$Holder", "newInvokeSpecial", "allocateInstance", "shmem_write_begin", "shmem_getpage_gfp.constprop.0", "shmem_alloc_and_acct_folio", "shmem_alloc_folio", "one.nio.util.URLEncoder", "decode", "java.lang.StringLatin1", "runStateAtLeast", "ciMethod::method_data", "ciMethodData::load_data", "MethodData::next_data", "NonSafepointEmitter::emit_non_safepoint", "ip_local_deliver", "libonenio.210fea54.so", "recv@plt", "PhaseCFG::schedule_late", "PhaseCFG::insert_anti_dependences", "MachNode::adr_type", "TypeInstPtr::add_offset", "Parse::do_ifnull", "Parse::adjust_map_after_if", "GraphKit::add_empty_predicates", "GraphKit::add_empty_predicate_impl", "GraphKit::uncommon_trap", "GraphKit::make_runtime_call", "Node::set_req", "PhaseCCP::do_transform", "PhaseChaitin::merge_multidefs", "GraphKit::record_profiled_arguments_for_speculation", "TypeFunc::make", "TypeTuple::make_domain", "java.util.AbstractCollection", "isEmpty", "Method::verified_code_entry", "Parse::build_exits", "GraphKit::clone_map", "SafePointNode::size_of", "IdealLoopTree::iteration_split", "IdealLoopTree::iteration_split_impl", "PhaseIdealLoop::insert_pre_post_loops", "PhaseIdealLoop::insert_post_loop", "PhaseIdealLoop::clone_loop", "Node::clone", "PhaseChaitin::add_input_to_liveout", "ConnectionGraph::do_analysis", "ConnectionGraph::compute_escape", "ConnectionGraph::complete_connection_graph", "elapsedTimer::stop", "Matcher::find_shared_post_visit", "Node::is_CFG", "Parse::init_blocks", "PhaseChaitin::mark_ssa", "InlineTree::ok_to_inline", "InlineTree::print_inlining", "GraphKit::access_load_at", "BarrierSetC2::load_at", "G1BarrierSetC2::load_at_resolved", "BarrierSetC2::load_at_resolved", "GraphKit::make_load", "LoadNode::make", "LoadNode::Ideal", "MemNode::find_previous_store", "RootNode::bottom_type", "IndexSet::IndexSet", "CmpLNode::Opcode", "PhaseIFG::Compute_Effective_Degree", "PhaseIdealLoop::build_loop_early", "PhaseCoalesce::coalesce_driver", "PhaseAggressiveCoalesce::coalesce", "PhaseCoalesce::combine_these_two", "PhaseIFG::Union", "import_single_range", "substring", "isLatin1", "TypeArrayKlass::allocate_common", "MemAllocator::allocate", "G1CollectedHeap::mem_allocate", "equalsIgnoreCase", "PhaseCCP::transform_once", "InstanceKlass::initialize", "java.io.RandomAccessFile", "libjava.so", "JNU_GetStringPlatformChars", "tcp_ack", "ciTypeFlow::Block::successors", "ciTypeFlow::block_at", "ciMethodBlocks::block_containing", "MultiNode::is_CFG", "loadNKlassNode::rule", "PhaseOutput::shorten_branches", "PhaseBlockLayout::PhaseBlockLayout", "PhaseBlockLayout::find_edges", "ShouldNotReachHereNode::is_block_proj", "futex_wake_mark", "JNU_NewObjectByName", "jni_NewObjectV", "hasNext", "Parse::do_monitor_enter", "GraphKit::kill_dead_locals", "ciMethod::liveness_at_bci", "MethodLiveness::BasicBlock::compute_gen_kill_single", "PhaseIdealLoop::split_if_with_blocks", "PhaseIdealLoop::split_if_with_blocks_post", "PhaseIdealLoop::try_sink_out_of_loop", "MachProjNode::ideal_reg", "ConcurrentGCThread::run", "sun.nio.fs.UnixException", "rethrowAsIOException", "translateToIOException", "java.nio.file.FileAlreadyExistsException", "java.nio.file.FileSystemException", "java.io.IOException", "java.lang.Exception", "java.lang.Throwable", "fillInStackTrace", "Java_java_lang_Throwable_fillInStackTrace", "JVM_FillInStackTrace", "java_lang_Throwable::fill_in_stack_trace", "frame::sender", "frame::frame", "PhaseConservativeCoalesce::coalesce", "IndexSet::lrg_union", "futex_wait", "futex_wait_queue", "schedule", "java.nio.ByteBuffer", "OptoRuntime::new_array_C", "MemAllocator::Allocation::notify_allocation_jvmti_sampler", "JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector", "JvmtiObjectAllocEventCollector::generate_call_for_allocated", "JvmtiExport::post_sampled_object_alloc", "ObjectSampler::SampledObjectAlloc", "epoll_wait", "__x64_sys_epoll_wait", "ep_poll", "schedule_hrtimeout_range_clock", "__schedule", "finish_task_switch.isra.0", "Unsafe_Unpark", "ThreadsListHandle::ThreadsListHandle", "__netif_rx", "netif_rx_internal", "enqueue_to_backlog", "JvmtiEnv::Deallocate", "os::free", "compareTo", "one.nio.server.Server", "incRequestsProcessed", "java.util.concurrent.atomic.LongAdder", "increment", "java.util.concurrent.atomic.Striped64", "casBase", "java.lang.invoke.VarHandleGuards", "guard_LJJ_Z", "java.lang.invoke.VarHandle", "checkExactAccessMode", "sun.nio.fs.NativeBuffer", "sun.nio.fs.NativeBuffers", "releaseNativeBuffer", "java.lang.ThreadLocal", "java.lang.ThreadLocal$ThreadLocalMap", "getEntry", "guard_LLL_Z", "java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite", "compareAndSet", "ok.dht.kovalenko.dao.utils.MergeIteratorUtils", "getTombstoneValue", "ok.dht.kovalenko.dao.base.Entry", "isTombstone", "fileOpen", "Profiler::recordSample", "JvmtiEnv::GetStackTrace", "JvmtiEnvBase::get_stack_trace", "JavaThread::last_java_vframe", "vframe::new_vframe", "tcp_stream_alloc_skb", "__kmalloc_node_track_caller", "kmem_cache_free", "VMThread::run", "VMThread::inner_execute", "VMThread::evaluate_operation", "VM_Operation::evaluate", "VM_G1CollectForAllocation::doit", "G1CollectedHeap::do_collection_pause_at_safepoint", "G1CollectedHeap::do_collection_pause_at_safepoint_helper", "G1CollectedHeap::post_evacuate_collection_set", "G1CollectedHeap::process_discovered_references", "ReferenceProcessor::process_discovered_references", "ReferenceProcessor::process_soft_weak_final_refs", "ReferenceProcessor::run_task", "G1STWRefProcProxyTask::work", "RefProcPhase2Task::rp_work", "RefProcSubPhasesWorkerTimeTracker::RefProcSubPhasesWorkerTimeTracker", "ciMethod::ciMethod", "ciSignature::ciSignature", "ciInstanceKlass::protection_domain", "put_timespec64", "_copy_to_user", "replace", "cubictcp_acked", "Mutex::lock_without_safepoint_check", "tcp_wfree", "JvmtiAgentThread::start_function_wrapper", "__x64_sys_read", "vfs_read", "seq_read_iter", "show_stat", "get_cpu_iowait_time_us",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(' + value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
