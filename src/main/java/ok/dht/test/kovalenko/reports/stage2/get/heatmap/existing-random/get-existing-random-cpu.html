<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BKjj@A^kAtDvFrGyNvVeW|_@wd@hsB????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????@????????????????????????????????????????????????????GG?@H@I@@?@O?@HH????G@G?G?@`???G????????@?G?G?@O?GIG????OG?I?O@OWG?Y????GG?IAH@???G@?????@G@??@G@??????????????@QQO??AQY`P?@????AIQP?????H??H??GBP???A???HHYY`WIG`RHBZY?QR```Zp`XX[JPpXZYR`PRPPZ[JYHYPIXhAP@QIO@PRHBB?I`HXP`PSIJHGHIHRIQHTHIOZGIIZSHJIWPIQWRIHQHQHYRDHXAAYHHOORAP`BOPQHXPQYHHJ?WQ@O@HOPZHIP`@AGH[HHBIAH@JQI@ZGXOPKIKIQIJAPKIHWPHQPQQXGYHGAHG`IA@H@GXOGBXA@ZGGQ?@@H?OH?BHA@J@GAOGIPHH@AGHHBQGHPGJHAIQ@?IH?HO@?XJ@`@GGOP@@PH@IBGGCH?OQG@JA?PGHG@OPPGGI@AH?QOG@POHBOGIO??HG?PG?AH@?WHQH?@GO`GIAOP@@POX?OA?H?p?@G?AJHOPGOBO@I?B[HHQAW@GPGBHOHGO@GOHAJ?AQOAQG?AQG@J@?HG?G?PHAGP?IHGKI@GXGG@@@GQ??OG@G?O@I?GI?H@?HI@PGQIHH?H@O?HPAPJ?AH??HI?HB@?Q?OIOA@WA@Z@WR?OH@G@P?HPGPIGH?B@GHHGGO?HGY@?@P?HPA@@A@@`?@GP@BGGIH?IPH?P?PHGJGOHGJ@?HGGPG@H@?OAAH?@H@?O@@WHGO?HO?QGOGG@GIGHOHHHI?AAG?G@@OIO@GG@GG?Q@OHHGBH@HG@AA@P?BHGAKG@@?X@JQG@@@@IGGO@GIJ@GW?GP??Z@@JG?I?@GH?P?GGH@OGOP@OH@GOAH@??IB@AQP@HQ@@@GI?I@@HG@AHWI@AH?XA?OQGGZ@@GHIHG@HG?IHOHA?P@WJG@G??GHHOOQA@H@?@P@?@HI@H@@P?BGH@@A@BOGGOIIB?P???J`Q[JQ`HY?@HHHOHH?J@O@HGAH@?O@YA@BGGIP@@@Y@HHG?XB@OIOGI@@PG?BG@H`OAJP?BZ?IXG?AO@JG?HG@@XHAIG@JG?YO?@W?BI?AWG?RG@JH?HI?GI?@MG?AhG?PW?IG?HXGHHG?HOPHO@HP?IGOPA?PHHWOA@HP@HH@H?XGH@@HHPA?G@@RGHI?WIG?PGHG@?@DH??`W?@PG?QGGJX@?OOHIGJ@P@Q@GI?@BQAI@G@@WP@A?AOWOOH?AIAAHG?H@POPI@GI@???HP?GOABGGIAH@OP?OOAGP??H@?G@?WR?HPOAWHA@G@AB?@HHO?P?@PGPAHGW?HG@?IG@G?GI@IIOOI@B?W?H@HWAHHQA?O?GHGH@@?HHHP??WOOGHIA??SGGHPP?HOG@@I?HZ?@AGG@H@HG?AQGGOPIG@@PGGGJ@@B?IPWARGGOH?PWOAPR?W@PB?W@P@JGH?W@HH@R??HQAIAHQ@H@HH?IAPAJGPAGBQP@P@GGHB?G@@B@@?H@A@PHOPAIOGP@IHX?OHPHHYGG@GA@O?JAGWckAckAk~A|}AmaBugBgpBzlBrfBonB{nBajBbuBkvByyB`bC|vAlxBspAzvA{iBgmA`zAhrBxhBaiBroBorB}zB`~AdpBhkAa|An_BpbB}cBjfBggB|hBbpBixB{xB_yBfbCsbCybC{`BhaBnaBblBhlBfpBoqBfrBcsBs{Bv`CmrAyrAjsAmsAgwApoByrBrsBuuBbvBkxBoyB__C|aCesAuuAsvAacBneB|uB}uB|wBhyBleCxfCbpArqAysA_tAheBviBxiB}jBznB`tBdwBxyB_~Bf_Cy_CvaCdbCdcCihCvhCkoAhtAwyA|yA}|Ah~AreB|iBsmBlnBloBsoBaqBhqBkqBerBbsBdsBjzBa|Bb}Bo~B_`CuaC~bCkiCvkAhlAwmAfnAhrAosAywAdyAlzAyzA`{Au|Ar}As}A`_Bf`BjbBrhBijBjjBwmBrnB`oBnoB{oBxpBhtBotBfvBpvBawBvxBwxBxxBtzBy{Bd|Bj|Ba}Bd}Bj~BqcCpfC`gCzhC|kC_lCglA`nAxoAkqAgsAmtAeuAguA`vAyvA`wA_yAayAvyAnzAg{Ak{At{A_}A}}AkcB_dBmdB}dBcfBwhB~hBwiBbjBojBkkBxlB~lBkmBtmBdnBsnB}nBgoB_pB}pBxqB`rB_sBgtBmtBwtB_uBduBfuBzuB~uBevBsvBwvB{vB`wBmxBnxBqxBqyBryB~yBwzBb{Be{Bn{Bw{Bb|B|}Bq~Bs~Bm_Cv_Ci`CfcC~cCrdCudCeeCveCdfChfCkfCcgClgC`hCdhCfhC_iCokCeoCxoCvqCdkAokApkA~kAdlAslAulAcmA{mA|mAhoA~oAmpAppAcqAgqAgrAasAbtAetAptAstAttAwtAytAouAbvAlwAuwA`xAlxAqyAezAhzAizAkzApzAtzA~zAm{Ar{As{Av{A{{Ag|Ar|Aa}Al}Ac~Ae~Ap~Ar~Ao_Bh`BkaB`bBfbBgbBmbBfcBocBvcBqeBdfBefBlfBsfBvgB}gBahBdhBohBuhBgiBniBriBsiB`jBqjBsjBxjBekB|kB}kB_lBmmBomBvmBzmB`nBanBgnBinBknBvnB~nBfoBhoBwoBrpBvpBvqB~qBkrBlrBqrBvrBfsBgsBmsBosBpsB_tBatBdtBqtBauBkuBouBquBdvBewBjwBuwBvwBcxBoxBrxByxBfyBmyBazBnzBvzB~zBd{Bm{B{{B~{Bw|B||B}|Bj}Bp}Bq}By}Bz}Bb~Be~Bw~Bx~Bz~Bb_Cj_Cp_Cs_Ce`Cj`Ck`Co`Cp`CdaCiaCnaCpaCsaCbbCnbCobCgcCpdCfeCneCpeCteCefCifCnfCvfC}fCqgCchCohCwhCyhC~hC`iCajCejC{jChkCjkCukCwkCtmCanChnClqCuqC`sCnsCfkAikAkkAlkAmkAnkAqkAxkAykA{kA|kA`lAalAblAclAilAklAllAmlAnlAolAplAqlArlAtlAbmAdmAemAimAjmAkmAlmAqmAtmAumAymAzmA~mAbnAhnAjnAnnAsnAunA|nAaoAboAnoAzoA{oA|oA}oAapAfpAhpAipAjpAupAwpAxpAzpAeqAfqAhqAiqAvqAyqAzqA{qA}qA`rAbrAdrAjrAkrAorAssAvsAwsA{sA|sA}sAjtAktAotAqtArtAutAvtAxtA{tA}tAauAcuAduAfuAhuAkuAluAmuAquAruAsuA_vAdvAevAfvAgvAjvAkvAlvAvvAwvAxvA~vA_wAawAjwAnwAswAwwAoxArxAuxAwxAxxAzxA~xAhyAiyAjyAkyAlyAmyAnyAryAsyAyyA{yAazAfzAmzAszAuzA{zA|zAi{Ao{Ap{Aq{Ax{Ay{Az{A`|Ac|Ad|Ae|Af|Aj|Ak|Ap|Ay|Az|Ab}Ad}Ae}Ao}At}A~}Ag~Ai~Aj~An~As~Ax~A|~A~~A__Bb_Bd_Be_Bg_Bi_Bk_Bq_Bu_Bv_Bw_Bx_By_B{_Bi`Bj`Bn`Bv`B~`B_aB`aBaaBbaBcaBdaBfaBiaBjaBqaBtaBvaBxaByaB{aB}aBbbBcbBdbBebBhbBibBkbBlbBrbBsbBtbBvbB{bB|bB}bBccBdcBmcBrcBucBwcB{cBadBbdBcdBddBkdBpdBrdBtdBvdBxdB`eBaeBfeBpeBxeB}eB_fB`fBafBbfBkfBmfBtfBufBvfB{fBbgBmgBngBwgBxgB`hBkhBnhBthBvhByhB{hB}hB_iB`iBdiBeiBfiBiiBliBpiB~iB_jBdjBejBfjBgjBljBnjBpjBtjBujBvjByjB|jBgkBhkBikBjkBnkBpkBqkB`lBclBelBflBnlBplBulB{lB}lB`mBgmBlmBpmBqmBymB|mB~mB_nBbnBfnBnnBtnBwnB|nBboBdoBeoBjoBtoBvoBxoBzoB}oBapBcpBhpBjpBlpBmpBnpBopBppBspBwpBypB{pB|pBbqBcqBdqBeqBfqBgqBiqBjqBlqBmqBnqBpqBsqBtqBuqBwqByqBzqB{qB}qB_rBbrBnrBrrBtrBurBwrBxrBzrB|rB`sBesBisBksBlsBssBusBvsBwsBxsBysB{sB|sBctBetBftBitBltBntBptBrtBztB{tB}tB~tB`uBhuBnuBsuBvuBwuBxuByuB{uB_vBgvBnvBuvByvBzvB}vB~vB_wBbwBhwBiwBkwBmwBowBqwBtwBxwBzwB`xBaxBuxBzxB}xB`yBbyBdyBgyBiyBkyBlyBnyBtyBvyBwyB{yB|yB_zBizBmzBpzBqzBrzBuzByzB{zB_{B`{Bg{Bh{Bi{Bl{Bp{Bq{Br{Bt{Bu{Bv{B|{B_|Bg|Bk|Bm|Bn|Bo|Bq|Bs|Bt|Bu|By|Bz|B~|B_}Bf}Bi}Bl}Bm}Bo}Br}Bs}Bu}Bv}Bw}B~}Bc~Bd~Bf~Bi~Bl~Br~Bt~Bu~B|~B`_Cd_Cg_Ci_Ck_Co_Cr_Cu_Cz_C{_C|_C``Cb`Cg`Cq`Cs`Ct`Cx`Cz`C{`C_aC`aCcaCeaCjaCkaClaCqaCraCxaC{aC~aCcbCebCgbCibCjbCmbCpbCrbCubCzbChcCjcCkcClcCncCscC{cC|cC_dCadCedCfdCgdChdCidCtdCvdCwdCydC{dC}dC_eCceCheCjeCoeCqeCueC{eC}eC_fCafCcfCgfCufCwfCyfCzfC{fC~fC_gCagCegCggCigCkgCngCtgCugCwgCzgC|gCrhCthC}hCaiCbiCdiCeiCniCqiC|iC}iC`jCbjCcjChjCljCzjC}jC_kC`kCakCgkClkCnkCqkCrkCxkCzkC{kCjlColCamC|mC}mC~mC_nCdnCgnCknClnCqnCtnCunCwnCynCgoCjoCmoCnoCqoCzoC}oCbpCdpCfpChpCjpCupCypC{pCaqCiqCkqCyqC~qCjrCmsCpsCysCdtCftCstC}tCauCmuCuuCtvCekAgkAjkArkAskAtkAukAwkAzkA}kA_lAelAflAjlAvlAwlAxlAylAzlA{lA|lA}lA~lA_mA`mAamAfmAhmAmmAnmAomApmArmAsmAvmAxmA}mA_nAanAcnAdnAenAgnAinAknAlnAmnAonApnAqnArnAtnAvnAwnAxnAynAznA{nA}nA~nA_oA`oAcoAdoAeoAfoAgoAioAjoAloAmoAooApoAqoAroAsoAtoAuoAvoAwoAyoA_pA`pAcpAdpAepAgpAkpAlpAnpAopAqpArpAtpAvpAypA{pA|pA}pA~pA_qA`qAaqAbqAdqAjqAlqAmqAnqAoqApqAqqAsqAtqAuqAwqAxqA|qA~qA_rAarAcrAerAfrAirAlrAnrAprAqrArrAsrAtrAurAvrAwrAxrAzrA{rA|rA}rA~rA_sA`sAbsAcsAdsAfsAhsAisAksAlsAnsApsAqsArsAtsAusAxsAzsA~sA`tAatActAdtAftAgtAitAltAntAztA|tA~tA_uA`uAbuAiuAjuAnuApuAtuAvuAwuAxuAyuAzuA{uA|uA}uA~uAavAcvAhvAivAmvAnvAovApvAqvArvAtvAuvA{vA}vAbwAcwAdwAewAfwAhwAiwAkwAmwAowApwAqwArwAtwAvwAxwAzwA{wA|wA}wA~wA_xAaxAbxAcxAdxAexAfxAgxAhxAixAjxAkxAmxAnxApxAqxAsxAtxAvxAyxA{xA|xA}xA`yAbyAcyAeyAfyAgyAoyApyAtyAuyAxyAzyA}yA~yA_zAbzAczAdzAgzAjzAozAqzArzAvzAwzAxzAzzA}zA_{Aa{Ab{Ac{Ad{Ae{Af{Ah{Aj{Al{An{Au{Aw{A|{A}{A~{A_|Ab|Ah|Ai|Al|Am|An|Ao|Aq|As|At|Av|Aw|Ax|A{|A||A~|A`}Ac}Af}Ag}Ah}Ai}Aj}Ak}Am}An}Ap}Aq}Au}Av}Aw}Ax}Ay}Az}A{}A_~Aa~Ab~Ad~Af~Al~Am~Ao~Aq~At~Au~Av~Aw~Ay~Az~A{~A}~Aa_Bc_Bf_Bh_Bj_Bl_Bm_Bp_Br_Bs_Bt_Bz_B|_B}_B~_B_`B``Ba`Bb`Bc`Bd`Be`Bg`Bk`Bl`Bm`Bo`Bp`Bq`Br`Bs`Bt`Bu`Bw`Bx`By`Bz`B|`B}`BeaBgaBlaBoaBpaBraBsaBuaBwaBzaB|aB~aB_bBabBnbBobBqbBubBwbBxbBybBzbB~bB_cB`cBbcBecBgcBhcBicBjcBlcBncBpcBqcBscBtcBxcBycBzcB|cB~cB`dBedBfdBgdBhdBidBjdBldBndBodBqdBsdBudBwdBydBzdB{dB|dB~dB_eBbeBceBdeBeeBgeBieBjeBkeBleBmeBoeBseBteBueBveBweByeBzeB{eB|eB~eBffBgfBhfBifBnfBofBpfBqfBwfBxfByfBzfB|fB}fB~fB_gB`gBagBcgBdgBegBfgBhgBigBjgBkgBlgBogBpgBqgBrgBsgBtgBygBzgB{gB|gB~gB_hBbhBchBehBfhBghBhhBihBjhBlhBmhBphBqhBshBzhBbiBciBhiBjiBkiBmiBoiBqiBtiBuiByiBziB}iBcjBhjBkjBmjBrjBwjBzjB{jB~jB_kB`kBakBbkBckBdkBfkBlkBmkBokBrkBskBtkBukBvkBwkBxkBykBzkB{kB~kBalBdlBglBilBjlBklBllBmlBolBqlBrlBslBtlBvlBwlBylB|lB_mBamBbmBcmBdmBemBfmBhmBimBjmBnmBrmBumBxmB{mB}mBcnBenBhnBjnBmnBpnBqnBunBxnBynB_oBaoBcoBioBkoBmoBooBqoBuoByoB|oB~oB`pBepBipBkpBqpBtpBupBzpB~pB_qB`qBqqBrqB|qBarBcrBdrBgrBirBjrBmrBprBsrB{rB}rB~rBasBhsBjsBnsBqsBtsBzsB}sB~sBbtBjtBktBstBttButBvtBxtBytB|tBcuBeuBguBiuBjuBluBmuBpuBruBtuB`vBavBcvBhvBivBjvBlvBmvBovBqvBrvBtvBvvBxvB|vBcwBfwBgwBlwBnwBpwBrwBswBwwBywB{wB}wB~wB_xBbxBdxBexBfxBgxBhxBjxBpxBsxBtxB|xB~xBayBcyBeyBjyBpyBsyBuyBzyB}yB`zBbzBczBdzBezBfzBgzBhzBkzBlzBozBszBxzBzzB|zBa{Bc{Bf{Bj{Bk{Bo{Bx{Bz{B}{B`|Bc|Be|Bf|Bh|Bi|Bl|Bp|Br|Bv|Bx|B{|B`}Bc}Be}Bg}Bh}Bk}Bn}Bt}Bx}B{}B}}B`~Ba~Bg~Bh~Bk~Bm~Bn~Bp~Bv~By~B{~B}~B~~Ba_Cc_Ce_Ch_Cl_Cn_Cq_Ct_Cw_Cx_C}_C~_Ca`Cc`Cd`Cf`Ch`Cl`Cm`Cn`Cr`Cu`Cw`Cy`C|`C}`C~`CaaCbaCfaCgaChaCmaCoaCtaCwaCyaCzaC}aC_bCabChbCkbClbCqbCtbCvbCwbCxbC{bC|bC}bC_cC`cCacCbcCccCecCicCmcCocCpcCrcCtcCucCvcCwcCxcCycCzcC}cC`dCbdCcdCddCjdCkdCldCmdCndCodCqdCsdCxdCzdC|dC~dC`eCaeCbeCdeCgeCieCkeCmeCreCseCweCxeCyeCzeC|eC~eC`fCbfCffCjfClfCmfCofCqfCrfCsfCtfC|fCbgCdgCfgChgCjgCmgCogCpgCrgCsgCvgCxgCygC{gC}gC~gC_hCahCbhCehCghChhCjhCkhClhCmhCnhCphCqhCshCuhCxhC{hC|hCciCfiCgiChiCiiCjiCliCmiCoiCpiCriCsiCtiCuiCviCwiCxiCyiCziC{iC~iC_jCdjCfjCgjCijCjjCkjCmjCnjCojCpjCqjCrjCsjCtjCujCvjCwjCxjCyjC|jC~jCbkCckCdkCekCfkCikCkkCmkCpkCskCtkCvkCykC}kC~kC`lCalCblCclCdlCelCflCglChlCilCklCllCmlCnlCplCqlCrlCslCtlCulCvlCwlCxlCylCzlC{lC|lC}lC~lC_mC`mCbmCcmCdmCemCfmCgmChmCimCjmCkmClmCmmCnmComCpmCqmCrmCsmCumCvmCwmCxmCymCzmC{mC`nCbnCcnCenCfnCinCjnCmnCnnConCpnCrnCsnCvnCxnCznC{nC|nC}nC~nC_oC`oCaoCboCcoCdoCfoChoCioCkoCloCooCpoCroCsoCtoCuoCvoCwoCyoC{oC|oC~oC_pC`pCapCcpCepCgpCipCkpClpCmpCnpCopCppCqpCrpCspCtpCvpCwpCxpCzpC|pC}pC~pC_qC`qCbqCcqCdqCeqCfqCgqChqCjqCmqCnqCoqCpqCqqCrqCsqCtqCwqCxqCzqC{qC|qC}qC_rC`rCarCbrCcrCdrCerCfrCgrChrCirCkrClrCmrCnrCorCprCqrCrrCsrCtrCurCvrCwrCxrCyrCzrC{rC|rC}rC~rC_sCasCbsCcsCdsCesCfsCgsChsCisCjsCksClsCosCqsCrsCssCtsCusCvsCwsCxsCzsC{sC|sC}sC~sC_tC`tCatCbtCctCetCgtChtCitCjtCktCltCmtCntCotCptCqtCrtCttCutCvtCwtCxtCytCztC{tC|tC~tC_uC`uCbuCcuCduCeuCfuCguChuCiuCjuCkuCluCnuCouCpuCquCruCsuCtuCvuCwuCxuCyuCzuC{uC|uC}uC~uC_vC`vCavCbvCcvCdvCevCfvCgvChvCivCjvCkvClvCmvCnvCovCpvCqvCrvCsvCuvCvvCwvCxvCyvCzvC{vC|vC}vC~vC_wC`wCawCbwCcwCdwCewCfwCrxA????????????]?????????????????{O?????????_C????????????????}M????mD?????????????????????fB??????????????????????sA??sQfH???????????????yG?????_E???????hB??fB?????????T]?????A??AhH@???lQ@??@iB?]~DqH???iB~P?????hB???A@cR?@?????A_C?????BjC?_E???????@?dCAA}QaE?B?mR?????T|G??~D??????]_S?xH?~H?bU???A??aO???sU??AbRgC@gH@gC?dCbS????xHiC??T?hB~HB{U??fB|U??F}HA?_C??@??]?CB@@?????@??ABcV?iB?AB??VhE@B]A?aI@?vDtH@AyH@@B?B?@eI_@?C@@]@yHIA?kC???_VA??@A?nI?A~D???@@?vD?`E?A?hBA@?AAkEB??@@FvAC?eCB?@A???B?AkCp@@?d@?_@T_@nD@B??A@?@@AB??@@?eVAAd@lIA@?A?@?|G??A???@AIC?E@IBB?????B@C@?AA@@??iV@jC`EA?b@??@vD?mB???@?_@@??@@?A?AA@??pBD??hO??????B?@q@@????A?C?vE?C?tEn@?@pBA??A_@@A?@AkE@??fV????B@BA@b@A?@AIdV?A?|@??@D???B?DhEA??B@sBAA?A??A??@@?xAB@?@?EA@B?aIA@?p@dC??@?}HABAA?AA@@aJAA?@CB????BuWA@?iJ@?o@}JBwC`A?~EACbJA???sB?@@V??jIAABC@???@BB??DdX?A?~TAqYA?@?eCaF@@sEK??A??@?BBA?@FxYsB?@?nBC?E@F?ABB@?@E@??I??zA?_AC?F@`AB?mE?AA@?A@kE?Bt@A{ID??B@~@?@B??BhJ??A?A~Y??BA?e@@??@@CFe@??xC?{I?@??A?CBuC???AAB@?YmX?FEDCf[B?AD@BA???gECAzE?A?????~C]yCBoBACY??O???\?qB@C?BC?G?B@CZK?CA]?@A?wXYc@lAxAOlA@?Y???HDFmA?B?EU??q@?@bAZ?A?Z@Ad\@ACA??aA??AiFB?A??o@As@_T?A??A@@K?AA??A?@DA?BB??A?@K?sKAsB?AhF?@DBeF??C?]ExA_F?BvJ?pBARhJ@f@p@A`\@xJ?A?@A?m\_@@?AA??`AAnBD??aJzC?CB?B?ACF_Y?@r@???{AB?@FB@?K@ABqBoBB~@~@_Dy\aKpK`L?AAuBAp[????yE?cAd@g@??@Y????@_@LLzA_JA?cF?mB?A??BaA@E@BV??BjAHBxI@?ROmAAuK?oKCd@F?FAA??qEg@fEaAlXC_ABvJAhEBpKbAs@B?????AH??a[@A?BC??AcL?X{A?BFBK?z[ABF??ABJE{X_F?ACB_BsL?u@?B?c@??A`A?}C@BjL@?Du@s@?kApYtF@A??t@??CXB?@????CCEnBlB@xZh@??c@?K@vA?BvC|YA@@|K?aAB?AA?g[AOBArB_@@mAB{F?@dL?A?Ot@AyJ{F??aB@??A?BA??o@B|FhZA@?lLAD@aA@B@B@??}AdLB@AbW{K?|F?Z?EaAVAkL@rJ_L?H@uKV@@L?@qL???A?@AbAmFaZAeDo@aBC{YCB?B_@@??AGnAj^`DCC@@BFAxEA?t@j@mADc\??~@fFXwFwCABBByF?r]?zB?@cF@?u@Au@A??A_Bc@?cAuEEA{B@zAAR??UyA??A??@AAyX_BJ?lA@kAC?\{KCcA?vW?xAMuA?CAyA?oA?BIBhD?j@X?E??EFAA?B@Cs@?AMAJV?bDq@lBHC???@iD?@?jA@i@?~@BJXzA@@?sF~R??MA`BlB@j@kF?mAn]?BxC@yBXoBn^BC@I@@BAoAA@b@??CcACA?gFB??MCCj_@mAB?EkJe@A@lEkACo@F@yA?CBj@B~C??dAH??@?BE}Fd]F?@E}Ah@AAMoAb@zC@@k@vEsECCJA?pBA??A`G?@?L?hF?h@B???A{J?yCCA?mAM??d@??Bk@C}YDr@aACv@?uCrKY@Xx^|BBA?@dZg@??lE??i\@eD`D?BB@cGlA?GI}E?B?pCf`@t]@?A@K@uEA{AaG?`^Aw`@B|BxEoA_AFD??@@BmD??A?@?@?A??gMkL?cA?b@?D_a@A@ObAh@wBA@t`@?BCEA_GAiJ@?BC{AAMErArB?j`@`D?@B@Ev@`A?C@?BBw[EmEI?rAsCYCDBEsCi_@iDcX?mBBjBkGAYB???yT???_CzDC?bB?@?vR_RB?jAjCC??iBnI?aT?yU??j@iC?hHiC_E??_@ClM@bBlDcG?`MRB??f]OO?CU_Ama@??ACyKbD?|\@?}BaBwKcGt@??@?kAB?iD?vAB{`@v^B??OcB?eM?@AA?}KjA{J?CxC?AtHB@V?AA{L`GAdM}U?KA?e]FAsKB@@nM@cAd@Al[?@A?kAmMcMoAAI}Bb^C``@B}CfDiFBF@e`@aBmEZ?B\gY?k@??@HjM@rB?@h@|BO@AzCB\@Aj@?oMAK?ZbGX@BCOuA?@?{\A@?iFt@A?AB_MDA?wB}LBO|BA?ACgGx_@U?qAA~F_D~@ABCeDxACBzAu@E@C?MvAYr@B_BBtKu]@Ab@rJzEsE@?{a@jB??xXU?qBoBCB?dF@BcBh@iDBg@lBBBeD~FhD?EBiYCt@X{A@aFfMg@fD@CAg\?jAlDfFB}B?L@_BB@mFMK?????qFBCZrBxCB??u[b@A?jL@AwL?ABBcb@p@wC|BfMk@aFAB?yB_M?wI@DB?yKu@?Xaa@ua@zABaB@iGl^A?kA?mM@B?@@?d[sLbBI@?E}BbA@lABC{Bj@@??wCgG@A|Cha@?O?`A_`@A|`@E?@@_KA?Bsa@AgFvLlD??cM@CA?bAkJyZfGpCxFDoMyA?@@BBH|@AyJpCEBUVB@k@??B@pM?AvBACbE?AwBA@CBvB?C?aM?za@@?cDBDb]XABaY@F@~JsFA??o@}AiG@@CUBaB?DAv@jMM?A@cBq@{BpMA`BoBC?EKk@cB@D?AACBZ~@j@kAnA}Fs@V?FALj@?LjG?B?CdA_Gv@BAzYAI?jb@~J}KDfa@D_L?XAp@yFu@hLKApb@yF?AAC??d_@}AfF`A~F_DjA?jAoL@ob@t\bBB@@A@MBvLACU@`Bu@cA?yA?lA@@AL??Afb@DA@o`@?MO@`BD|@A@rM?pBw_@@BU@lBab@AsC_BY@A@Bt@k@A`Gj@B?Uh@LcB@jGCB@UB?c@??wK?o@M@fKC?wBA{B?nMA?s@`DqCxAba@lM?@?CD??A@A@Bq@A?pCFq`@?hL@oApZ}AARcDhb@@@?nb@cD~C?b@gGA@?B@hDCv`@C?g`@@t[@?e@?qLCBaMzBYA?~C?qM??t@EM`MDib@?jFDBA`B@BxFIgE@@KwIu@A{Lh@`LuEC??JBmB|FAdb@tKA?gF?BAB}BzC@h\b@EE}LA?rMAhDDeMdMBg@@McJD?BA@@qM@B|^AlEA@v@vb@?Zk@@aA}AEaG?wB?@@Ik@?Bi`@?A_Fz_@wLUBoAlL?@rB?jGYBBaG?A?`Bq@@@tb@sF@la@?@?Fx`@c@hFbAsB_KA??ACAo@{_@?h@cB?JiGbBhIR@oJBAZbA}FCb@?{A@@oFuCh@@{Bs[bByCcAbJcJ????OAvACwb@BoJ@??~Ao@q^k@wFB?xF@l]w\B}@?@B?bD@wFK?C?MqFkF@eG?ABElDra@qFuA?yCu`@B@`Aq_@?A?B?C?D?EkGBtMF?G?H?I?J?K?L?M?N?O?P?QuMC?FvMHxMJlGR?S~BF{MIyMKmGT?U?V?W?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@?d@?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@?o@?p@?q@?r@?s@?t@?u@?v@?w@?x@?y@?z@?{@cN_@dNa@fNc@hNe@jNg@pGi@qG|@?}@?~@?_A~MGwMInGL?`A?aA?bAS`@eNb@gNd@iNf@kNh@lNj@?cA?dA?eA`Ca@pNd@xNg@sNj@?fA?gAtNH|MKmG`AvNhAaCiA?jA?kA?lAaCInGmA?nA?oA?pAnDb@wNe@rNh@tGcAyNqA?rA?sA?tA?uA}NJlGLzMvA?wA?xA?yA~Nc@qNf@sGi@qGzA?{A?|A`OK{NaA?}AuGLuNaA?~AdBM?vA?_B?`B?aB?bB?cB?dB?eB?fBdBT_NVaNXoGgB?hB?iBbNY?gB?jB?kBbOd@zNh@tGlB?mB?nB?oB?pB?qB?rB?sB?tBdB`A?uB?vBpAe@_Oi@?wBxGf@sGxB?yB?zB?{B?|B?}BwGaA?~BP_C?`C?aC?bC?cC?dC?eCnNz@?fC?gC?hC?iC?jC?kC?lCPg@pGmC?nC?oC?pC?qC?rCSsC?tC?uC?vCaCwC?xC?yC?zC?{CoDU`NWvGgBfOiBvG|C?}C?~C?_D?`DxOVdOY?|CzO~CuOxC?aD?bD?cD?dDpDh@?xBmOzBiOoB?eD?fD?gD?hD?iD?jD?kD?lDw@xB_PmD?nD?oD?pD?qD?rD?sD?tDdBuD?vDmD]x@yB?wD?xD?yD?zDbCaD}OcD?{DbCyCvO|D?}D?~D?_E?`Ey@aE?bE|NcE?dE?eE?fEw@gE?hE?iE?jE?kE?lEy@mE?nE?oEz@|DcCpE?qEz@zCwOrE?sEPtE?uE?vE?wE?xEy@yE?zEbC{E?|E?}E?~E?_F?`F?{E_H}EjP_FaH{ElP~E`HaF?bF?cF?dF?eF?fF?gF?hF?iFhP|EiP~E`H`FkP|ErP_FmP|E?jF?kF?lF?mF?nF?oFpDpF?qF?rF?sF?tF?uF?vF?wFpOxF?yF?zF?{F?|F?}F?~F?_GqP}EbH`F?`G?aG?bG?cG?dG?eG?fG?gG?hG?iG?jG?kG?lG?mG?nG?oG?pG?qG?rG?sG?tG?uG?vG?wG?xGy@yG?zG~G{C?{G{P~EsD{EcH_FaH|G?}G?~G?_H?`HuGR}G}D?aH?bHQcH?dHNeHaCfHcOvA?gH?hH?iH?jHy@bD~OEz@kH?lH`PbE{@mHNnH?oH?pH?qH?rH?sH?tHQuH?vHoDwH?xHjQyH?zHoD{H?|H?}H?~H?_I?`IPaI?bI?cIrAhEcPdIpDeIwGuB?fI?gI?hI?iI?jI|OWyOhBgOXeOhBrQY?kINlIfQ_F?mI?nI?oI?pIgAsG?qI?rI?sI?tI?uI?vI?wI?xI?yI?zI?{I?|IxD`F?|GsP}EbH}I?~Iz@_JdCoH?`J?aJ{@bJrDcJkQcD?dJ?eJ?fJQgJ?hJiQdH?iJy@jJjH|G|Q~EgQ|EtD`F`R_FtP}EuD|GmH`F{Q{EwD`FaR|ElH|GfC`G?kJN{G~G|DcClJ?mJ?nJNoJNpJ?qJ?rJ?sJ?tJrDuJTvHdHvJ?wJ?xJ?yJ{@zJgH{J?|J?}J?~JpH}D?_KgB`K?aKeBbK?cK?dK?eK?fK?gK?hK?iK?jKhCrFyPtF?kK?lK?mK?nK?oKTpKQqK?rKTsKeCqI?tK?uK?vK?wK?xK?yK?zK?{KkH{E{D|GmHaFnPcFoPeF?|KN}K?~K}D_L?`L?aLQdJ{@bL?cL?dL?eL|D]z@fLgBgLThJiCkBQhLz@iLSjLPkL?lL?mL?nL?oL?pL?qL?rL?sL?tLmQiEdPkE?uLrHcKgReK?vLQwLgAxLmNx@{@aH|DyLzD|DcCzL?{LrD|LsA}LeA~LQ_MeB`M{RaMrHbM?cM?dM?eM?fM?gM?hMNrEQzGeAiMNaKx@jMzDkMeBlM?mM?nMToM?pMhBvHzRdKhRfKsHqMxDrMyDsMStMfHoJjCuMkCvMkCw@rGy@oNfCqOhCx@wM?xM?yMqDzMlCxMfSxD?zMuHsFzPkKkRmKvH{MiHbI?lM`S|M?}Mw@i@?~MwRlLxR_N?`N?aNrR|ElH{E{D{EsR{EpS|EtDaF?bN?cN?dN?eN?fN|DgNtR}K?hN?iN?jN?kN^rI?lN?mN?nN?oN?pN?qNTrN^tKnRsN?tN?uN?vNpHwNPxN?yNaSeKiRgKdBzN?zNaP{NgSyMqD|NN}NmS}EnH|GfC{EoS|EnS|E{S}EuD{E{D`GeHbG|PdGl@xD?|NN~NS_OgBwL_I~MqAtC?`O?aOsAnE?bO?cOz@dO?eO?fOuPmFwPgO?hO{G_D?iO?jOz@kO?|DQvHn@lO?mO?nO?oO?pO?qO?rO?sOrOiCsOkC?tO?uO?vO?wO{@pE?xOn@`O?yO?zO?{O?|O?}OjH`GeH~OQ_PqQXoG`PwS~EsD|GfC|GfCiG?aP?bPuSuKoRwKqRyK?cP?dPjSnK?eP?fP?gPNsEqHhP?iP?jP?kPPlP?mP?nPx@oP?pP?qP?rP?sPeCtGcQvGeQjKcStPgBuP?vPeAwD?wPbIxP?yP?zPtT_FhQ|GvT{EwD}I?{PbC|PfR}PfB`JgBdJT~P?_Q[cM?`Q{HaQ`CbQ?cQ?dQ?eQPfQ?gQ?hQ?iQTjQhAkQy@lQ?mQ?nQ_U`FyS|E|S~EuT{EqS}EuDoQ?pQ?qQ?rQvSfKsHhK`@sQ?tQ?uQnDvQ{@wQ?xQhAyQ?zQ?{Q?|Q?}QN~Q?~Q?_R?`R?aRmCsItQuIvQwIxQyIzQ|IeAzBnO|BjOqBlObR?cR?dR?eR?fR?gR{@{JlSmLyRhR?iRx@jRgAkR?lRSmRQnRsAoRsAyAsApReAqRdE|GaU|EoH{EiU~EsDiGaQkG?rRfTjOmI{EcHsR?tR?uR?vR?wRkSxR|TuGdQwGhAyR?zRN{RjUgKN|R?}R?~R?_S?`S?aSgT|DcCbS?cS?dSTeS|Rw@rGtPm@|N`EfS?gSxDhS?iS?jS?kSyDlS`@yOpT{O?mS?nS^oS`InNtSpSgCqJdRqS}GrSy@sS?tS?uSSvS_IwS?xS?yS?zSrA{S?|S?}SzTpP?~S?_T?`T?aT?bTxUvGmClN`IcT?dTlCeT?fT?gT?hTSiTa@xD?jTm@kT?lT?mT?nToIzOqT|O?oTcIEsT`GgCpT?qTbVmN?cTtI{OrToTcIsO?rTcUcQdUeQWsT?tTd@fTgEhTa@uTVwG~UxS?vTWwT?xT?yTRzTP{T?|T?}T?~T?_U?`U?aUl@wPmCbU?cUbImOhToOjTqOvIhCzGjCtOtOnTvOgIdU?eU?fU?gUrUlR?hUlV|OjVrOdIiU?jUcEkU?lUdE`G~ScG}PeG_QgG?mU{GkBPnU?oU?pU?qU?rU?sUlIhUbTeOcTlFvPnF?gOeTtU_WgO`WmFdThO?tUaWhO`QjGbQdEbPuU?vU?wU?xUkBySpImNsSoN?pS?yU~QzEVzUmU{BoOpBkOrB?bR?{Uc@hKdE{EzS}EnH{E_HjFyD{JnQfI?|U?}UgW~UfBpH?_VgU`VyVoTvIaVn@bVIxG[cV}IzS|IoU{VqU}VsUkBdVx@eV~BfV?gV?hV?iV?jV?kV?lV?mV?nV?oV?pVoC~S`V`TaVbT?qV?rVuHsV?tV?uV?vViAzQ?wVwAxVmCyV?zViI{V?|V}D}VeB~V?_W?`W?aW?bWzIcWcE`Q{HdW?eW?fW?gWpAhW?iW?jW?kW?lWIjK?mWpAnWhWrO?oW?pWvAgTgAqWmVxTxIrWRjKpEsW?tW?uWa@vWGsO?wW?xW?yW?zW~InN?{WfJ|W?}W?~W?_X?`XGaXgAbX?cX?dX?eXx@fX?gX~IcT?hXHiUzViXc@qMWjXsVnOiTpOkTrOdIhCuVkCnCkX?lX?mX}RnXaEoX?pXm@qXgVmTlCrXwWyT?sXuIcT?tXp@iKsChTnE|B?uXpUdReEvX?wX?xX?yX?zXzGkCnCuO?{XnJ|X?}X?~XrC_YS`Ya@aYlUtI?bY?cYl@dY?eYSfY?gY?hY^iYn@jY?kY?lY?mY?nY?oY?pY?qYHkBeArY\sYtEsP?tYHuY`@vYiStFjRlKlRnKtVrOmJiCmTtO?kXaXmX?wY?xYcW|BnUrBeWcRqUeR?yYtWeM?dWkWgV?zY?{Ym@|Yw@}Y?~YD_Z?`Ze@aZWbZzHcZ?dZ?eZqCcUiHfZ?gZ?hZeEyY?iZtApO_XsOlTjCyIkXHwWrEyW?jZnXbYoXkZ`CwFWkTnBlZhS|YnYcYmBmWxWtWRmZp@EbEnZ?oZ?pZtAqZqXkYsXmYuXoYqBrZoEwVoYyMqD|YnBgXw@mC?sZ?tZ?uZ?vZ?wZiWpU|VrU?xZ?yZ?zZ?{Z\|Z\tXeBuEfPwE?}ZqElRs@~YS~ZW_[`@`[tYsZuYuZwYwZoEa[iI}Q?b[tBc[q@jKw@d[|Ie[?f[?g[?h[?i[Pj[?k[?l[ImZjYqOjEjCrYlYtXnYvXpY?m[w@n[}@xWjJo[{Ep[?q[?r[bXoX?oXiZs[?t[tIu[?v[?w[nE_TsIaTfEqV~WoO~XsOkYkCnCx[nWtV?y[?z[?{[?|[?}[zXtYuBuWd@~[pEfW`@_\?`\?a\d@b\fArOiAc\_AuV^d\bKpOuJwWrEkBrAe\hAf\lJcX}Wg\cYpBdWbRfXeRqEh\e@i\`@j\?k\sYnY|EqYm@sTJl\m@wTnVyThCm\?n\{CfR?o\wAp\bEyPwJoZyYqUjWh\\dThAvKpRxKwHq\fIpOuJhC`XtO`YlXvCwYbYr\eIs\sZqBoUcRqJfR?t\~@u\?_Z}Iv\zZrU~VlR_Ay[?w\_ZtZvYvZ^x\uBy\?z\?{\r@|\_[rBdYdReEfRkI}\?~\?_]?`]?a]JyW?b]Rc]GEc@Eq@xGzHjEePd]pXeYiAe]jBf]fAf\Gg]gKsUf@h]GlRe[bR{Ci]Hj]?k]~BD?l]}JhUrZqOjEiCpJkXvEwY~ZwO?s\fJiWgJkWqAm]dKwKwTcP?n]rXlYgZoYqBo]_DhUuAp]?q]eAr]?s]?t]sIu]`Z|QjBb[}@v]f@w]?x]bZmWc@iKm@y]}ClRkKcRqJz]g@{]?|]`F}]?~]`C_^?`^?a^Lb^RxG}Eq[?c^lJd^fZmYxJpY?e^l@f^hIg^wEfM|HhMtB}Mx[nY|Em[Ph^?i^oE{Q[j^eFk^?l^Jm^oCn^q[`T`Jo^?p^WqXp@c]|@jUuInN?q^?r^?s^?t^kKu^f@b]\v^fAw^qZ`\?x^bFk\tZoYG|\s@y^GuYbFz^G{^pA|^?}^{Ek[?~^?__@e\lYmKpY[`_@{[gM?a_@HxWtC{Wf@b_@rKiX`Fc_@?d_@n@e_@tCf_@[g_@Lx]pFh_@?i_@?j_@?k_@?l_@?m_@rAn_@?o_@?p_@?q_@Lo[?r_@fYhV?s_@?t_@?u_@tEv_@Hb^lKjW?w_@?x_@uChXzJxDiKkE?y_@Wz_@eJ{_@?|_@yWxWjJw]tA}_@VEr@~_@nFf_@dHqFxPsVoWy[mZ{[?k^nFq^a\s^?_`@?``@?a`@jFs]_\aTfEo^}@yWgAb`@nFoN_Jc`@?d`@n\i_@o\k_@q\m_@c]t]aKbT?o^aDe`@m[xKwHcPn[kYf\pYdKf`@?g`@?h`@?i`@zK|[GoW?j`@^k`@xKkW~K`Tk\mYK}MK{UJb]zIeUwVgUg]yKxTn]o[mYoK]Sl`@|CpZ~Km`@u\r_@jZ`T`JqVv[dRhKn`@l@aYk]nY|Eo]i[rOkBo`@dFp`@g@q`@bLcP?r`@?s`@?t`@?u`@?v`@_]r^b\_`@a]a`@}Ew`@gJw_@?x`@|[oYxKw_@qKt]uFn]m]nYGy`@p]oYx]kYh]z`@tCq^`]{`@?|`@|A}`@?~`@y]lYmK_a@tBiRfK`a@vFjWx\aa@Wba@qCca@xBda@j]lW[ea@?fa@?ga@tCoNcFtTzBpY?rZeZrOmJEGha@vFia@~Eja@|Aka@xElThVnTuZxTwAla@x@ma@{]mYbDna@vKoa@?pa@?qa@?ra@q]sOkZtO?sa@jFta@mWaTmLhCeKuOl@uTd^nYxBua@iLw_@?aa@kFhUtAva@cLu][wa@?xa@?ya@?za@i^oY?_a@d@u\tBkZ~A_a@}@l\\{a@cKr[REa@f^dApYiE|a@?}a@?~a@w]`T?u]tAtQ?_b@b[z[nZk^}\rF?sV~\z[dD|NcZ`b@fAwP~]pS?c`@?ab@dA_a@qW_WrWaWdJc[zJwPgAbb@rI|S?cb@?db@`@eb@Hc]i@e^oIfb@Jgb@rLhb@?ib@s^}[_^sOf^sa@aLfUxV}M[jb@tJhZhKgRo]eR?vXgXxXiXzXkXtO}ZmXnJkb@?lb@?mb@|@aXnLiCpJsa@?nb@i@m[|JvEgP}Z?ob@yGfCeSiCj[lX`_@wEtFaTi@qYn@pb@s]t`@?qb@Prb@?sb@?tb@qKoB?ub@w^`WsWbWPvb@?wb@?xb@?yb@{Ee]jBzb@?{b@s@|b@[}b@?~b@?_c@zFwb@g_@yb@sJ`c@?ac@Lr_@e@bc@uFr`@f_@cc@?dc@`FgWdDjTrCzVpW|Vn_@s`@eLcc@~ApYfAx\bFec@W|NrFpSrL{[[fc@k_@za@p_@t`@?cc@Jgc@|Aj_@p\l_@?hc@Jic@iEjc@?kc@?lc@?mc@?nc@?oc@?pc@f@jZv@m[i@]~^jCyIqc@r[}QgKxZnAo]{^gUW|YLfHa@rc@fLs^|@sc@l@vWlAgZhYeRjIn`@}Ctc@ImWfAjRa@wPy_@b[uBlRl@uc@lKia@~Evc@zLkCnCsa@r@wc@v@o]uLaWdJ}Mj\Ev@e^pAxc@?yc@t^sVu^{[e_@s`@eLzc@J{c@gDfRkIo\n@|c@gD}c@m^_ZqA~c@nK|]gD_d@gL`d@k^fa@}]}M}@ic@dDwTvZsXdDzM_Aad@?bd@?cd@?dd@i@ed@nAm[e@rW`@fd@lCgd@c`@tVlZz[a^r[?ja@hChd@vBc^oCqP{TsPdAid@jK{V?jd@_GyZz\wWmYw]uLkd@?ld@?md@eXuXzB_a@o^v_@?nd@g@kB~LtOg^nb@yLod@xLc`@_Apd@jDkXm_@ac@lFqd@jK}Q?f]Zb]hArd@?sd@~Ltd@r`@sd@?ud@?vd@e@sXoFa\HrT?wd@?xd@?yd@?zd@e^{d@?|d@?}d@?~d@lWnV?_e@?`e@|Cae@GwWrCbe@kBce@H{]Sde@?ee@~Aid@eGvc@i@o]r\o_@s\fe@rFge@?he@p`@f]uFdP{ZqOjEie@dGpd@cDfHyLu`@wEje@a@uc@eUgQfUke@?le@?me@?ne@?oe@?pe@?qe@wZt\i@rZwJre@gDvX}^yXjXiClYlXvC{X^se@dGy[zKk^[te@Rue@|]xa@?ve@Lwe@s`@xd@?xe@m@z_@g@ye@?ze@fL{e@iMyd@r_@k^aL}W{W_XtJ|e@h_@}QyEtTjDuOoT}e@xG~e@iAk[?_f@o_@|Qf@o[gIzQkU|Qf@x]jDsa@mLwWrEgc@aEiPxB`f@hAaf@?bf@?cf@yQzI?ic@wU|EuU|EoHdf@?ef@?pEmI|GtU}ExS{EvU_F`U{EwDaFrSff@?gf@?hf@?if@?jf@pPnI?kf@?lf@uRmf@qIaS`Tnf@zU}D?of@?pf@}Dqf@Qrf@iBsf@Qtf@?uf@pF}^yBxGkH|Gja@~EhU|Eia@}E}S|EtDrMka@]kVvf@qIrJeRpH}Twf@^xf@b_@}Za_@y@dSgCz^nb@cKyf@a`@bWxLyUiMxe@~ArTc_@bTfDg`@i]zf@?{f@zF|f@?}f@zW}Wda@`X}@xGc^yThC~f@GpWiLkWJxGkDwVn`@d`@?_g@oC`g@kBvTiE|ToV~TqV`UtAag@pa@~W|W`Xt_@kc@u_@bg@?cg@?dg@ta@}TpV_UrVaUl\hM`Kv[iAdUvVcR`[eg@dFfg@h^_Toa@h`@?zf@iAp[?w`@w@gg@nAe^mFlTy[v_@qAhg@sJdZyEp]?ig@vKs_@v\jg@?kg@?lg@?mg@f@mWtLng@eGja@JmZtLib@xBy_@aDog@oLp]U`Z~_@r[?vc@bKpg@fGlX~`@kb@fAwFaD~^|L_`@kD{QuBE}[|QpLx`@bMnd@bGgR?}\?qg@?rg@?sg@?tg@?ug@hGvg@?wg@k`@cd@?xg@?yg@?zg@e@{g@|Lt^`@|g@{CyY\}g@?~g@ya@q[r@_h@Lb_@GmZgL~`@wA`h@|Ha_@i@EyBpWyAah@RrTr@k]~AqYr@bh@f@zWy^hCeKkXvCxYcEch@fWdh@oQiIpQeh@tFu]~a@fh@c[uZ?gh@`a@z[r^aT|Kp^vBr[rIhh@d`@t`@s_@dc@Zih@hMwXhXyX}`@kCv]aa@dGad@eb@jh@Kc[a@kh@iAlh@va@_XkDmh@dAo]~[l^qCnh@tBoh@|Jph@{CE~Bqh@?rh@?sh@?th@?uh@?vh@?wh@?xh@?yh@|Cfh@?zh@xB{h@bb@``@fGmXrC|h@nK}h@pItIuQvIwQ~h@?_i@ea@eReYiZ^`i@?ai@bLq\fIag@gMhe@}_@eYwa@lc@?bg@xa@dg@aDbi@vB__@nEci@?di@?ei@?fi@?gi@?hi@|a@eZ`@ii@|@EeJ}Mkb@{[oZ}[wAji@sMbg@y`@p_@vFki@pAli@z`@lK}XpO|ZiC__@]pEmi@Gwc@|Ani@sMmc@v_@oc@|_@hUh[oi@fDpi@hMb^l_@xb@{Fyb@kDa[zEb[nAEhGzf@|@qi@zLye@z]r^?{e@pFri@?si@zFti@qAui@?vi@ca@zd@`b@mX`Kwi@JmWq@mWmb@`XbGn`@qb@mKvHpOrb@qYh`@ga@?c[i@c]|Xxi@_b@nd@yBmZlFi^HaVa@dYhGyi@?zi@qa@rWlb@cc@wA{i@nL|i@jDmXn@}i@ga@{VzBkBdArTWzMbMq]dAkBkM{X?|XeF|[}@c]oF~i@pLaa@iK_j@nAc]kM`j@gb@u^ub@wYk[s\na@o^rFpNlFaj@?bj@?cj@?dj@|Aej@sb@|Qxb@{Vv@qYGkBp@mZ|Afj@Gj]b`@yc@p^}a@l`@ld@m`@`X}a@t_@uAgj@?hj@m@zMwEdWHij@uAtTl@kh@?jj@
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????A??B??B?????C??D??C?????C??E??C?????C??F??C?????A??B??B?????C??G??C?????C??H??C?????C??I??C?????C??J??C?????C??K??C?????C??L??C?????C??M??C?????C??N??C?????C??O??C?????C??P??C?????C??Q??C?????C??R??C?????C??S??C?????C??T??C?????C??U??C?????C??V??C?????C??W??C?????C??X??C?????C??Y??C?????C??Z??C?????C??[??C?????C??\??C?????C??]??C?????A??^??B?????_??`??pA?Cs?a??`??P@?kf?b??c??@V??F@d??`??pH?_O?e??f??@@?k`?g??`??@B????h??i??p??CD?j??k??PG?GC?l??k??`@????m??n??`D?cC?o??p??`C?gC?q??p??P??{D?q??r??PF?OG?q??s??pM?{C?t??u??pF?SU?t??u??`B?gQ?v??w??PD?KJ?x??w??P@?GH?x??w??p_?WG?y??u??@B?gH?y??z??Pa?CH?{??|??PD?oL?}??z??p??OI?~??z??PH?OC?~???@?@D?cD?C??@@?C?????C??A@?C?????C??B@?C?????C??C@?C?????C??D@?C?????q??s??pQ?CD?y??E@?@L?_?@y??F@?pW?SB@G@?H@????wA?C??I@?C?????C??J@?C?????C??K@?C?????q??s??@C?kC?L@?M@?p??WC?L@?N@??@?sF?q??s??@c?gD?O@?P@?oD??F?C??Q@?C?????C??R@?C?????C??S@?C?????A??T@?B?????A??U@?B?????C??V@?C?????C??W@?C?????C??X@?C?????C??Y@?C?????L@?N@????sF?C??Z@?C?????C??[@?C?????C??\@?C?????C??]@?C?????C??^@?C?????C??_@?C?????C??`@?C?????C??a@?C?????q??s??P`?SD?b@?c@?@C?KS@b@?d@??e?_e?C??e@?C?????C??f@?C?????C??g@?C?????C??h@?C?????C??i@?C?????C??j@?C?????C??k@?C?????C??l@?C?????C??m@?C?????C??n@?C?????C??o@?C?????C??p@?C?????C??q@?C?????C??r@?C?????s@?t@?B?????q??s??`^?WD?u@?z??PC?G@?v@?w@?`@?kA?v@?x@?`??KE?y@?z@?pA?Oj?y@?z@?PB?Ki?{@?|@?`@?kr@{@?}@?PC?[s@~@?|@?E??{]BC???A?C?????C??@A?C?????q??r??OF?OG?q??p??@J?GE?AA?p??@L?o@?AA?BA?@I?OC?v@?w@?`C?oA?v@?CA?`??kE?y@?z@?ED?Oj?C??DA?C?????m??n??_N?sC?C??EA?C?????C??FA?C?????C??GA?C?????C??HA?C?????C??IA?C?????C??JA?C?????C??KA?C?????LA?MA?C?????LA?NA?C?????LA?OA?C?????C??PA?B?????C??QA?C?????C??RA?C?????q??p??pF?CE?SA?TA?`@?gyAUA?VA?`G?CuAUA?WA?@F?gvAb@?XA?pB?k~?b@?YA??S?s\?b??c??`E?GE@b??ZA?pc?WA@[A?\A?@H?SZ?[A?]A????[L?C??^A?C?????C??_A?C?????C??`A?C?????C??aA?C?????C??bA?C?????C??cA?C?????C??dA?C?????C??eA?C?????C??fA?C?????C??gA?C?????C??hA?C?????C??iA?C?????C??jA?C?????C??kA?C?????y@?z@?@D?Oj?C??lA?C?????C??mA?C?????C??nA?C?????C??oA?C?????C??pA?C?????C??qA?C?????C??rA?C?????v@?w@?@B?oA?u@?sA?P??_@?C??tA?C?????C??uA?C?????C??vA?C?????C??wA?C?????C??xA?C?????yA?`??oS?WC?C??zA?C?????C??{A?C?????AA?BA?`L?SC?|A?}A?PK?gn@~A??B?PC?_A?y@?p??PC?oS?C??@B?C?????C??AB?C?????C??BB?C?????C??CB?C?????C??DB?C?????C??EB?C?????C??FB?C?????C??GB?C?????C??HB?C?????C??IB?C?????C??JB?C?????C??KB?C?????q??p??pB?CE?LB?MB?@K??LASA?z??p@?[yAUA?z??`F?gsANB?OB?pA?kYAb@?PB????kv?C??QB?C?????C??RB?C?????C??SB?C?????C??TB?C?????C??UB?C?????C??VB?C?????C??WB?C?????m??n??PO?sC?XB?YB?PF?oM?ZB?[B?`E?cN?\B?]B?`W?WJA^B?_B?uN??X?C??`B?C?????C??aB?C?????C??bB?C?????C??cB?C?????C??dB?C?????C??eB?C?????C??fB?C?????C??gB?C?????C??hB?C?????C??iB?C?????C??jB?C?????C??kB?C?????C??lB?C?????C??mB?C?????C??nB?C?????C??oB?C?????C??pB?C?????C??qB?C?????C??rB?C?????C??sB?C?????C??tB?C?????C??uB?C?????C??vB?C?????o??p??P@?_C?wB?p??`C?KI?xB?p??p??G@?yB?zB?P@?k?@{B?z??p@?KH@|B?z?????wA@A??}B?B?????A??~B?B?????C???C?C?????C??@C?C?????C??AC?C?????C??BC?C?????C??CC?C?????C??DC?C?????C??EC?C?????C??FC?C?????C??GC?C?????C??HC?C?????C??IC?C?????C??JC?C?????C??KC?C?????C??LC?C?????C??MC?C?????C??NC?C?????C??OC?C?????C??PC?C?????C??QC?C?????C??RC?C?????C??SC?C?????C??TC?C?????C??UC?C?????C??VC?C?????C??WC?C?????C??XC?C?????yA?`??pS?WC?YC?ZC?@U?wL?XB?[C?@F?WC?YC?\C?@A??G?]C?\C?@?????^C?_C?B?????C??`C?C?????C??aC?C?????C??bC?C?????C??cC?C?????C??dC?C?????C??eC?C?????C??fC?C?????C??gC?C?????C??hC?C?????C??iC?C?????C??jC?C?????C??kC?C?????C??lC?C?????C??mC?C?????C??nC?C?????C??oC?C?????C??pC?C?????C??qC?C?????C??rC?C?????C??sC?C?????C??tC?C?????C??uC?C?????C??vC?C?????C??wC?C?????C??xC?C?????C??yC?C?????C??zC?C?????C??{C?C?????C??|C?C?????C??}C?C?????C??~C?C?????C???D?C?????C??@D?C?????C??AD?C?????C??BD?C?????C??CD?C?????C??DD?C?????C??ED?C?????C??FD?C?????C??GD?C?????C??HD?C?????m??n??`N?sC?ID?JD?p@?KE?ID?z??O??OD?UA?z??_F?gsAo??p??uD?oC?C??KD?C?????C??LD?C?????C??MD?C?????C??ND?C?????C??OD?C?????C??PD?C?????C??QD?C?????C??RD?C?????C??SD?C?????C??TD?C?????C??UD?C?????XB?[C?PJ?sC?XB?VD?Pf?cJ?XB?WD?`L?sL?XD?\C?@A?SG?XD?\C?`C?gG?XD?YD?`E??K?ZD?[D?@D????\D?]D?@A????^D?_D?@B?__?~@?_D?@?????C??`D?B?????C??aD?C?????C??bD?C?????C??cD?C?????C??dD?C?????C??eD?C?????C??fD?C?????C??gD?C?????C??hD?C?????C??iD?C?????C??jD?C?????C??kD?C?????C??lD?C?????C??mD?C?????C??nD?C?????C??oD?C?????C??pD?C?????C??qD?C?????C??rD?C?????C??sD?C?????C??tD?C?????C??uD?C?????C??vD?C?????C??wD?C?????C??xD?C?????C??yD?C?????C??zD?C?????wB?p??P@?CI?xB?p??`F?O@?b@?p??`???Q@b@?{D?E??k`?C??|D?C?????C??}D?C?????C??~D?C?????C???E?C?????C??@E?C?????C??AE?C?????C??BE?C?????C??CE?C?????XB?YB?@W?GN?XB?DE?pA?gO?YC?EE?@B?WH?YC?EE?PG?OI?FE?EE?pE?WQ?]C?EE?@?????^C?GE?B?????C??HE?B?????C??IE?C?????|B?z??pB?CB@JE?KE?@@?GS?LE?KE?PA?cH?ME?NE?pB?gy?ME?NE????wf?C??OE?C?????C??PE?C?????C??QE?C?????C??RE?C?????XB?VD?@A@sK?XB?SE?PD??H?h??k??@S?{C?TE?UE?P@?_@?VE?UE?PD?kF?b??WE?PN?sS@[A?XE?uG?cX?YE?z??a@?WG?C??ZE?C?????C??[E?C?????C??\E?C?????C??]E?C?????C??^E?C?????C??_E?C?????C??`E?C?????C??aE?C?????C??bE?C?????C??cE?C?????C??dE?C?????C??eE?C?????C??fE?C?????C??gE?C?????b??c??o_?cF@m??n??pM?sC?hE?iE?@B?cA?|A?p??P@?gr?|A?p??pH??q?|A?jE?pM?Oy?{@?kE?@B?SH?{@?lE?@G?[I?~@?kE?PA??q?~@?mE?p??{r?~@?nE?eD?O\?b@?PB?uH?Cw?FE?EE?EG?[Q?C??oE?C?????YC?ZC?@??GL?C??pE?C?????C??qE?C?????C??rE?C?????C??sE?C?????C??tE?C?????AA?BA?q@?sB?C??uE?C?????XB?YB?@??SM?C??vE?C?????XB?DE?`??cO?ID?iE?`V?OJ?wE?xE?`D?sE?XD?EE?QB?kC?XD?EE?QF?kD?\B?yE?AB?k]@^B?yE?QD?GB?AA?BA?AT?sC?AA?p??@K?o@?C??zE?C?????ID?z??`J?_D?{E?|E?@C?S[?YC?EE?E??WH?C??}E?C?????C??~E?C??????F?@F?B?????C??AF?C?????C??BF?C?????b??c??_I?_E@C??CF?C?????A??DF?B?????AA?p??pC?[@?EF?FF?p??[@?EF?GF?`B?K@?~A??B?AZ?KB?ME?NE?ep??j?^B?HF?p@?Co?A??IF?B?????q??r??A??GG?|A?p??E@?kp?JF?KF?A@?kX?LF?KF?Q@?_U?C??MF?C?????C??NF?C?????C??OF?C?????C??PF?C?????C??QF?C?????C??RF?C?????C??SF?C?????C??TF?C?????C??UF?C?????C??VF?C?????XB?WD?aL?sL?XD?\C?AA?SG?XD?\C?aC?gG?XD?YD?aE??K?ZD?[D?aB????WF?XF?A???f?C??YF?C?????h??k??uQ?{C?ZF?[F?q@????\F?]D?Q?????^D?_D?AB?__?C??]F?C?????m??n??UO?sC?A??^F?B?????C??_F?C?????C??`F?C?????~A??B?AD?_A?C??aF?C?????C??bF?C?????b??c??OL?cE@[A?\A?pE?KZ?cF?dF????_c@C??eF?C?????C??fF?C?????C??gF?C?????C??hF?C?????C??iF?C?????C??jF?C?????C??kF?C?????C??lF?C?????C??mF?C?????C??nF?C?????[A?\A?PB??Z?JE?oF?@@?OV?LE?oF?pD?CI?ME?pF?PD?wz?ME?NE?pU@kk?qF?rF?`B?KL?~@?rF?@?????LA?sF?C?????C??tF?C?????C??uF?C?????C??vF?C?????C??wF?C?????C??xF?C?????cF?dF?PY?[d@yF?zF?@G?gUByF?{F?`D?[WB|F?}F?p@?g^?qF?rF?O@?ST?C??~F?C?????C???G?C?????C??@G?C?????C??AG?C?????C??BG?C?????[A?XE?`^?[Y?[A?CG?`@?{I?ME?NE?`\@?l?DG?EG?@A?s\?~@?FG?E???RAC??GG?C?????C??HG?C?????C??IG?C?????C??JG?C?????m??n??p??[C?ZB?KG?@F??G?\B?LG?aV??MAAA?p??@Q?w@?AA?MG?@A?kD?v@?NG?pC??A?v@?OG?a??[E?y@?p??A@?oS?C??PG?C?????C??QG?C?????C??RG?C?????|A?}A?@??Kn@JE?oF?A@?OV?LE?oF?qB??I?SG?TG?QE?OM?C??UG?C?????C??VG?C?????C??WG?C?????C??XG?C?????C??YG?C?????wE?xE?aD?sE?XD?EE?aL?sD?d??`??@P??P?d??ZG?a@?SM?[G?\G?aK?cG?]G?^G?AF?GJ?m??n??pA?_C?hE?_G?pB?w@?|A?`G?@@?SZ?|A?`G?EA?_X?C??aG?C?????h??k??ES?{C?C??bG?C?????C??cG?C?????C??dG?C?????C??eG?C?????C??fG?C?????C??gG?C?????C??hG?C?????cF?dF?`d?Ge@ME?NE?`^??i?SG?iG?UB?GN?e??f??aA?o`?C??jG?C?????C??kG?C?????h??k??p??_C?ZB?KG?PP?KG?lG?mG?`A?oC?\B?nG?q??gSA\B?nG?QB?SVAC??oG?C?????C??pG?C?????C??qG?C?????C??rG?C?????{@?}@?pD?cs@C??sG?C?????C??tG?C?????C??uG?C?????C??vG?C?????C??wG?C?????|A?jE?@??Gx?A??xG?B?????AA?p??@??W@?YC?ZC?pX?KM??F?yG?B?????b??c???X?CF@C??zG?C?????C??{G?C?????C??|G?C?????AA?BA?AD?GC?C??}G?C?????C??~G?C?????C???H?C?????C??@H?C?????C??AH?C?????C??BH?B?????ID?z??UF?_D?h??k??@B?cC?\B?CH?QB?O\@C??DH?C?????C??EH?C?????C??FH?C?????C??GH?C?????C??HH?C?????C??IH?C?????C??JH?C?????C??KH?C?????C??LH?C?????C??MH?C?????C??NH?C?????C??OH?C?????C??PH?C?????C??QH?C?????C??RH?C?????C??SH?C?????C??TH?C?????C??UH?C?????|F?}F?U??g^?|F?VH?Q@?W^?XB?VD?@o?oJ?ZD?[D?AD????C??WH?C?????C??XH?C?????C??YH?C?????C??ZH?C?????C??[H?C?????b??c??oG?KE@q??r??QC?KG?b@?p??a???Q@b@?{D?qn?cb?b@?\H?Q??cW?LB?MB?AK??LASA?z??q@?[yAUA?z??a??WsAv@?NG?`F?CA?v@?CA?a??kE?y@?z@?qA?Oj?y@?z@?QB?Ki?{@?|@?a@?kr@XD?\C?QA?cG?XD?]H?a@?GI?EF?FF?q??[@?EF?GF?qA?K@?^H?_H?Q??cC?^H?_H?Q??[V?b??c???V??F@~A??B?AV?KB?~A??B?QY?KB?y@?p??QC?oS?{@?`H?A@?W\?{@?aH?qB?G]?qF?rF?P@?ST?C??bH?C?????C??cH?C?????C??dH?C?????~A??B?AB?_A?eH?p??QB?cI?|A?}A?@O?wn@b@?{D?ah?[b?~A??B?qN?gA?{@?fH?aB?cM?{@?gH?qF?oN?C??hH?B?????m??n??QO?sC?XB?YB?AW?GN?XB?DE?qA?gO?YC?EE?AB?WH?YC?EE?QG?OI?FE?EE?qE?WQ?]C?EE?A?????XB?WD?aH?oL?XD?LG?Q@?wN?ZB?KG?`N?GG?\B?iH?`@?_fA\B?iH?P??GhA\B?jH?@??[[@kH?lH?B?????C??mH?B?????C??nH?C?????wE?xE?a??oE?XD?jH?aF??B?C??oH?C?????m??n??qA?_C?hE?_G?qB?w@?|A?`G?A@?SZ?|A?`G?AA?_X?eH?z??AB?wC?|A?z??QH?CQ?C??pH?C?????C??qH?C?????C??rH?C?????C??sH?C?????C??tH?C?????\D?]D?QB?????F?uH?B?????C??vH?C?????C??wH?C?????C??xH?C?????C??yH?C?????C??zH?C?????C??{H?C?????C??|H?B?????[A?\A?@G?KZ?ID?iE?pZ?KJ?b@?{D?Qg?Sb?AA?p??`F?_@?C??}H?C?????C??~H?C?????C???I?C?????C??@I?C?????C??AI?C?????C??BI?C?????C??CI?C?????C??DI?C?????C??EI?C?????C??FI?C?????C??GI?C?????{@?}@?qD?cs@HI?II?A??se?yB?zB?Q@?k?@{B?z??q@?KH@|B?z??AE?KB@A??JI?B?????lG?mG?@??kC?XD?jH?QE??B?XB?WD?AT?wL?ZB?z??aK?SD?\B?nG?Q??SVA\B?KI?aA?[[CC??LI?C?????XB?YB?pD?gM?MI?NI?@@?SL?OI?PI?`??SE?OI?H@?@R?oD?QI?RI?`@??G?\B?iH?p??_fAXD?EE?aH?oD?yA?`??@M?KC?SI?TI?aE?_G?UI?z??qJ?kG?j??k??pB?wB?ZB?VI?AC?SF?\B?iH?QI?_hA^B?HF?AD?Co?\B?z??a@?gZCC??WI?C?????j??k??@??oB?C??XI?B??????F?YI?B?????YC?ZC?qX?KM?ZI?fH?QC?oF?SI?TI?pA?WG?SI?[I?@??????F?\I?B?????|A?}A?PH?_n@LA?]I?C?????C??^I?B?????C??_I?C?????C??`I?C?????XD?YD?A??sJ?ZB?VI?@C?SF?\B?iH?PI?_hA^B?HF?@D?Co?\B?z??`@?gZCA??aI?B??????F?bI?B?????YC?ZC?AU?wL?XB?[C?AF?WC?YC?\C?AD?GG?YC?cI?a??cF?AA?p??PG?_@?EF?dI?q??k@?XD?]H?AP?wI?C??eI?C?????~A??B?a[?GB?C??fI?C?????C??gI?C?????C??hI?C?????C??iI?C?????C??jI?C?????C??kI?C?????~A??B?QC?_A?EF?FF?a@?[@?ZI?fH?aN??G?XD?]H?qA?GI?y@?z@?@C?Wj?C??lI?C?????C??mI?C?????C??nI?C?????C??oI?C?????LA?pI?C?????C??qI?C?????C??rI?C?????C??sI?C??????F?tI?B?????ZB?z??aH?KD?b??c??_E?GE@|A?}A?@Q?wn@XD?\C?PA?cG?XD?]H?pA?GI?|A?}A?P??Kn@uI?vI?Q??gQ?b??c??u_?cF@a??wI?a??[h?ME?xI?a??{}?XB?VD?@`?KJ?[A?\A?PN?gZ?JE?wI?P@?w]?ME?xI?@B??~?ME?yI?`F?Ke?qF?zI?@A?CJ?~@?zI?@?????C??{I?B?????C??|I?C?????AA?BA?q??sB?XD?]H?q??CI?uI?}I?A@?kn?C??~I?B?????cF?dF?AN??d@C???J?C?????C??@J?C?????C??AJ?C?????C??BJ?C?????C??CJ?C?????~A??B?aS??B?q??p??`A?CE?NB?DJ?AE?sqA|A?_H?Q??gb@uI?_H?q@??^?ZI?fH?qZ?SG?~A??B?q@?[A?UA?z??pQ?{sANB?EJ?p??wVANB?FJ?@??KVAID?JD?@??KE?C??GJ?C?????C??HJ?C?????C??IJ?C?????C??JJ?C?????A??KJ?B?????EF?dI?p??k@?C??LJ?C?????LE?oF?qD?CI?ME?pF?AA?wz?SG?iG?aA?GN?ME?NE?E??wf?C??MJ?C?????SA?TA?a@?gyAUA?VA?aG?CuAUA?WA?AF?gvAb@?XA?qB?k~?b@?YA?QY?K]?|A?z??AA??Q?uI?z??qH?SN?|A?NJ?a??kO?|A?NJ?a??c^@XD?]H?qF?WI?^B?_B?PC?gW?b??c??EV??F@~A??B?QW?KB?cF?dF?AK?{c@lG?mG?p??kC?^B?nG?AG?SL?A??OJ?B?????q??p??`L?SE?hE?_G?AB?w@?\B?PJ?QD?gn@\B?QJ?aA?cr?\B?RJ?AE?CN@SJ?TJ?aB?G\Bm??n??q??[C?ZB?KG?AF??G?\B?LG?QU?oLAC??UJ?C?????q??p??@??{D?C??VJ?C?????ZB?KG?aN?GG?\B?iH?q??_fA\B?jH?a@?[[@C??WJ?C?????C??XJ?C?????yF?{F?aD?[WB|F?}F?Q??g^?|F?VH?Q??W^?C??YJ?C?????|B?z??qB?CB@JE?KE?A@?GS?LE?KE?Q??_H?SG?TG?qB?GM?ZJ?[J?a??gC?EF?GF?aB?K@?cF?dF?aI?wc@cF?\J?AC?[^@ME?]J?QD?Kd?EF?GF?Q???@?ZB?KG?AH?CG?XB?VD?PC@{I?LB?MB?AJ??LAh??k??@??_C?YC?cI?Q@?cF?C??^J?C?????ZI?fH?QD?sF?cF?dF?@E?kc@cF?_J?`N?_]@C??`J?C?????xB?p??PC?K@?|B?TA?pC?GC@C??aJ?C?????XD?jH?qA?wA?[A?XE?@K?kX?C??bJ?C?????C??cJ?C?????C??dJ?C?????EF?GF?q@?K@?b@?\H?AD?cW?JE?KE?A??GS?XB?VD?@??kH?C??eJ?C?????C??fJ?C?????C??gJ?C??????F?hJ?B?????C??iJ?C?????C??jJ?C?????C??kJ?C?????C??lJ?C?????C??mJ?C?????C??nJ?C?????C??oJ?C?????b@?PB?AV??x?ZB?KG?aC?{F?^B?nG?aA?wK??F?pJ?B?????C??qJ?C?????C??rJ?C?????C??sJ?B?????C??tJ?C?????C??uJ?C?????b??ZA?qc?WA@[A?CG?pC?KJ?C??vJ?C?????eH?p??q@?cI?uI?wJ?Q??Wm?AA?BA?AI?OC?v@?w@?a@?kA?v@?x@?a??KE?y@?z@?A@?Ki?C??xJ?C?????C??yJ?C?????C??zJ?C?????~A??B?aJ?kA?C??{J?C?????C??|J?C?????C??}J?C?????UI?z??qC?cG?SI?~J?Q??g@?d??`??pB??O?[G??K?aK?OC?@K?^G?AJ?OJ?C??AK?C?????\B?jH?Q??[[@XB?[C?a@?GC??F?BK?B?????|A?}A?PQ?wn@uI?}I?Q??kn?m??n??qM?sC?hE?iE?Q??_A?ID?iE?pL?wI?SG?TG?q@?CM?ME?CK?QA?oa?C??DK?C?????v@?NG?`@?{@?{@?}@?QC?[s@~@?|@?AA?{]BXD?YD?QC?wJ?EK?kE?qA?sb?~@?kE?QA??q?~@?mE?q??{r?C??FK?C?????XD?]H?AR?{I?qF?GK?@??WR?ME?]J?QC?Kd?NB?DJ?AB?sqAcF?_J?`B?{\@A??^F?B?????j??k??`D?wB?HK?IK?Q@?CB?\B?LG?aA?CLA\B?jH?A@?[[@ID?iE?`F?kI?^B?yE?QE?GB?C??JK?C?????UI?z??AJ?kG?UI?KK?AG?{G?[A?\A?@D?GZ?XD?YD?Q??sJ?ID?iE?@D?kI?HK?IK?a??CB?LK?p??a??oa?LK?MK?qD?_b?LK?NK?QA?GT?\B?OK?qE?WQA^B?OK?AG?SK?LB?MB?aE?{KAPK?z??q@?_CAQK?z??aB?gAAQK?VA?q@?SBAC??RK?C?????C??SK?C?????C??TK?C?????C??UK?B?????y@?p??qA?oS?^B?HF?AC?Co?SJ?VK?qK?{mBb@?PB?AR?[w?~A??B?aP?{A?A??WK?B?????LA?sF?C?????ME?NE?pe?Wi?C??XK?C?????~@?mE?QC?Cs?~@?YK?qB?Kc?~@?ZK?Q??wa?YC?ZC?A??GL?\D?]D?aE????\B?z??Q??cZC\B?LG?qJ?cLATE?UE?Q@?_@?VE?UE?QD?kF?b??WE?QN?sS@[A?XE?AK?kX?C??[K?C?????XB?VD?pj?kJ?b??c??oJ?_E@y@?z@?Q@?Oj?C??\K?C?????b@?{D?qu??c?|B?TA?qF?OC@C??]K?C?????[A?CG?PB?CJ?cF?^K?`F?K[@cF?_K?`H?wY@ME?`K?pA?Oc?DG?aK?AA?[\?\B?iH?a@?_fASJ?VK?Q@?omBC??bK?C?????C??cK?C?????~@?mE?QA??s?~@?YK?AB?Kc?LK?MK?qN?gb?\B?dK?AJ?Wq@?F?eK?B?????fK?}A?a??[C?SJ?VK?aM?{mB~A??B?QU?GB?XD?LG?aD?wN?b@?PB?A\?Wx?ID?iE?`P?GJ?wE?xE?P@?gD?wE?xE?@C?{D?C??gK?C?????\B?iH?Q??GhA\B?hK?q??{ZCLK?MK?aI?cb?XD?jH?qM?wA?AA?p??`D?[@?C??iK?C?????C??jK?C?????C??kK?C?????C??lK?C?????C??mK?C?????C??nK?C?????v@?w@?aC?oA?b@?PB?aP?Ww?ME?NE?Ph?_i?ID?iE?`b?_J?wE?xE?Q@?gD?wE?xE?a??wD?wE?oK?qA?wI?XD?]H?QF?SI?XB?YB?QF?oM?ZB?[B?aE?cN?\B?]B?aW?WJASG?iG?AD?KN?\B?PJ?aC?gn@\B?z??qA?kZCYC?ZC?A@?GL?UA?z??qQ?{sANB?EJ?AB?wVAcF?dF?aB?gc@yF?zF?@??WUBC??pK?C?????LE?KE?QA?cH?ME?NE?a??cy?ID?iE?PV?OJ?C??qK?C?????C??rK?C?????C??sK?C?????C??tK?C?????C??uK?C?????[A?\A?`L?_Z?ME?`K?@H?_c?m??n??aN?sC?ID?JD?q@?KE?ID?z??AL?cD?y@?z@?@A?Oj?m??n??aD?cC?o??p??qE?oC?vK?wK?Q??c??xK?yK?Q??S??^B?nG?Q??kK?^B?zK?q@?WB?NB?DJ?QD?sqAID?iE?@Y?OJ?wE?xE?a??[F?wE?oK?Q@?wI?NB?EJ?@B?wVANB?{K?@??cVAZI?fH?A_?gG?ME?`K?@F?[c?ME?|K?QA?Gb?cF?_J?`J?W]@ID?iE?P\?WJ?C??}K?C?????^B?OK?QE?SK?C??~K?C?????XB?YB?qD?gM?MI?NI?A@?SL?OI?PI?a??SE?OI?H@?AR?oD?QI?RI?a@??G?[G??L?qK?oK?@L?AL?A???N?C??BL?C?????|A?}A?@M?sn@C??CL?C?????C??DL?B?????|A?}A?PB?Sn@\B?hK?q@?{ZC?F?EL?B?????j??k??`??oB?j??FL?A@?cF?ME?`K?@I?cc?C??GL?C?????[A?\A?pD?KZ?C??HL?C?????b??ZA?a@?w?@C??IL?C?????\B?dK?AA?Wq@|B?z??aI?WB@JE?wI?Q@?w]?ME?xI?AB??~?ME?yI?aD?Ge??F?JL?B?????cF?dF?A??_c@EF?FF?A??[@?xB?p??@??C@?C??KL?C?????\B?KI?q??[[COI?H@?pE?_D?LL?ML?`@?_K?[G?NL?PI?sE?uI?wJ?QA?Wm?ME?`K?@@?Kc?|B?z??aH?OB@hE?iE?A@?_A?h??k??@J?oC?OL?PL?aB?gy?C??QL?C?????OL?RL?qF?O~?SL?dK?Q??KL@yA?`??`P?OC?UI?TA?Q??_G?UI?TA?q@?CI?UI?KK?qA?wG?C??TL?C?????C??UL?C?????C??VL?C?????C??WL?C?????C??XL?C?????C??YL?C?????SG?iG?QE?WN?ZB?z??AO?[D?b@?{D?Qj?_b?b??c??pG?KE@a??KE?a??Sh?QK?VA?aH?cBAZD?[D?aA????WF?ZL?Q??G`?LA?[L?C?????XD?EE?qp?gD?|A?`G?@A?_X?eH?z??@B?wC?|A?z??@A??Q?uI?z??PJ?WN?|A?vI?`??kO?|A?vI?`??o]@uI?vI?pJ?wR?ME?pF?qA?wz?XB?VD?PX?{I?ID?iE?@??cI?C??\L?C?????wE?xE?AC?{D?C??]L?C?????UI?TA?aA?CI?C??^L?C?????C??_L?C?????~@?kE?QF?Wq?C??`L?C?????C??aL?C?????l??k??@?????\B?LG?qP?kLAb@?PB?QD?{v?h??k??pQ?{C?ZF?[F?p@????\F?]D?P?????C??bL?C?????C??cL?C?????C??dL?C?????C??eL?C?????C??fL?C?????C??gL?C?????C??hL?C?????C??iL?C?????C??jL?C?????C??kL?C?????C??lL?C?????C??mL?C?????C??nL?C?????C??oL?C?????C??pL?C?????C??qL?C?????C??rL?C?????C??sL?C?????C??tL?C?????C??uL?C?????XB?VD?p`?KJ?\B?jH?A??[[@[A?XE?AR?{X?[A?`K?aA?oK?o??p??Q@?_C?wB?p??Q@?CI?xB?p??PB?G@?vL?z??A??oA?v@?NG?@??{@?ME?NE?@??wf?OI?H@?qE?_D?LL?ML?a@?_K?[G?NL?QI?sE?C??wL?C?????|B?TA?AH?SC@q??p??p@?CE?b??ZA?qB?C@@uI?wJ?a@?Wm?C??xL?C?????C??yL?C?????C??zL?C?????C??{L?C?????ME?NE?qB?gy?\B?LG?qL?gLAME?NE?@G@Gk?C??|L?C?????C??}L?C?????C??~L?C?????C???M?C?????C??@M?C?????[A?XE?a^?[Y?[A?CG?qC?KJ?ME?yI?aF?Ke?qF?zI?AA?CJ?~@?zI?A?????ZI?fH?AL?{F?cF?dF?Ph?Se@XD?]H?AK?cI?EK?z@?Q@?OI?C??AM?C?????XD?jH?AC?{A?EK?BM?A??kO?C??CM?C?????wE?xE?Q@?oE?C??DM?C?????C??EM?C?????SG?iG?Q??GN?b@?XA?Qi?O@@SA?z??a??[yAC??FM?C?????ME?yI?aB?Ce?|A?}A?`F?[n@ZB?KG?aI?GG?lG?mG?pB?sC?XD?LG?aB?{N?A??GM?B?????ZB?[B?@B?_N?C??HM?C?????C??IM?C?????C??JM?C?????C??KM?C?????C??LM?C?????C??MM?C?????C??NM?C?????C??OM?C?????C??PM?C?????ME?QM?Q??O`?b@?PB?qH?Cw?ZB?z??qO?[D?C??RM?C?????\D?]D?`E????\B?z??pA?kZCXB?VD?po?oJ?ZB?SM?Q@?[P?\B?LG?AS?oLAv@?CA?qA?oE?TM?UM?aG?_O?TM?z??AC?oL?y@?z??QB??L?^H?z??AA?KE?|A?z??aA?_Q?cF?dF?AZ?od@XD?jH?aB?{A?\B?iH?AA?KhAj??k??pA?wB?SI?TI?qB?WG?LK?MK?Q??[b?C??VM?C?????VE?UE?qB?gF?C??WM?C?????HK?IK?pE?[B?C??XM?C?????o??p??aD?oC?b??ZA?aJ?[@@b??YM?q??wW?|F?}F?aA?g^?DG?ZM?aA?O\?[A?XE?AS??Y?[M?\M?AA?[J?XD?jH?q??sA?LA?]M?C?????[A?\A?PC?GZ?ME?]J?a@?Kd?NB?OB?@??gYAC??^M?C?????hE?iE?AB?cA?|A?p??Q@?gr?|A?p??qH??q?|A?jE?aY?sy?LK?MK?QL?cb?LK?MK?aB?[b?eH?p??aA?cI?eH?_M?Q@?kH?C??`M?C?????
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1665329775466;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "/usr/lib/libc.so.6", "libjvm.so", "thread_native_entry", "Thread::call_run", "WatcherThread::run", "JavaThread::run", "CompileBroker::compiler_thread_loop", "CompileBroker::invoke_compiler_on_method", "Compiler::compile_method", "Compilation::Compilation", "Compilation::compile_method", "Compilation::compile_java_method", "Compilation::emit_code_body", "LIR_Assembler::emit_slow_case_stubs", "CounterOverflowStub::emit_code", "LIR_Assembler::add_call_info", "CodeEmitInfo::record_debug_info", "Dependencies::assert_evol_method", "GrowableArrayWithAllocator<int, GrowableArray<int> >::grow", "Compilation::build_hir", "IR::IR", "IRScope::IRScope", "GraphBuilder::GraphBuilder", "GraphBuilder::iterate_all_blocks", "GraphBuilder::iterate_bytecodes_for_block", "BlockBegin::try_merge", "ValueStack::ValueStack", "resource_allocate_bytes", "/usr/lib/ld-linux-x86-64.so.2", "java.lang.Thread", "run", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.test.kovalenko.MyServer$$Lambda$66.0x0000000800c8a830", "ok.dht.test.kovalenko.MyServer", "lambda$handleRequest$0", "one.nio.http.HttpServer", "handleRequest", "RequestHandler0_handleGet", "ok.dht.test.kovalenko.MyService", "handleGet", "ok.dht.kovalenko.dao.LSMDao", "get", "ok.dht.kovalenko.dao.aliases.MappedFileDiskSSTableStorage", "updateTables", "mapForRead", "java.nio.channels.FileChannel", "open", "sun.nio.fs.UnixFileSystemProvider", "newFileChannel", "sun.nio.fs.UnixChannelFactory", "sun.nio.ch.FileChannelImpl", "<init>", "java.lang.ref.Cleaner", "register", "jdk.internal.ref.CleanerImpl$PhantomCleanableRef", "jdk.internal.ref.PhantomCleanable", "insert", "Runtime1::monitorenter", "SharedRuntime::monitor_enter_helper", "ObjectSynchronizer::enter", "ObjectMonitor::enter", "ObjectMonitor::TrySpin", "map", "mapInternal", "sun.nio.ch.NativeThreadSet", "add", "Compilation::emit_lir", "LinearScan::do_linear_scan", "LinearScan::compute_local_live_sets", "ok.dht.kovalenko.dao.utils.FileUtils", "getDataFilename", "getFullFilename", "java.nio.channels.spi.AbstractInterruptibleChannel", "close", "BitMap::set_from", "ciEnv::ciEnv", "ciObjectFactory::ciObjectFactory", "not_walkable_Java", "Interpreter", "ciEnv::register_method", "nmethod::new_nmethod", "nmethod::nmethod", "CodeBuffer::copy_code_to", "InterpreterRuntime::frequency_counter_overflow", "InterpreterRuntime::frequency_counter_overflow_inner", "CompilationPolicy::event", "CompilationPolicy::method_invocation_event", "LIR_Assembler::emit_code", "LIR_Assembler::process_debug_info", "LIR_Assembler::record_non_safepoint_debug_info", "DebugInformationRecorder::describe_scope", "java.util.concurrent.ConcurrentSkipListMap", "put", "doPut", "LinearScan::sort_intervals_before_allocation", "LinearScan::build_intervals", "LIR_OpAllocObj::emit_code", "LIR_Assembler::emit_alloc_obj", "C1_MacroAssembler::allocate_object", "MacroAssembler::tlab_allocate", "BarrierSetAssembler::tlab_allocate", "Assembler::movq", "Assembler::emit_operand_helper", "Assembler::emit_data", "GraphBuilder::invoke", "GraphBuilder::try_inline", "GraphBuilder::try_inline_full", "ciBytecodeStream::has_appendix", "ld-linux-x86-64.so.2", "__tls_get_addr", "ok.dht.kovalenko.dao.dto.MappedPairedFiles", "ok.dht.kovalenko.dao.Serializer", "readKey", "readDataFileOffset", "java.nio.DirectByteBuffer", "getInt", "jdk.internal.misc.ScopedMemoryAccess", "getIntUnaligned", "getIntUnalignedInternal", "jdk.internal.misc.Unsafe", "BlockList::iterate_forward", "LIRGenerator::do_BlockBegin", "ok.dht.kovalenko.dao.aliases.MappedFileDiskSSTable", "entryIndex", "readByteBuffer", "LinearScan::resolve_data_flow", "InterpreterRuntime::resolve_from_cache", "InterpreterRuntime::resolve_invoke", "LinkResolver::resolve_invoke", "LinkResolver::resolve_static_call", "InstanceKlass::initialize_impl", "InstanceKlass::link_class_impl", "JvmtiExport::post_monitor_contended_entered", "libasyncProfiler.so", "LockTracer::MonitorContendedEntered", "LockTracer::recordContendedLock", "Profiler::recordSample", "jvmti_GetStackTrace", "JvmtiEnv::GetStackTrace", "interpretedVFrame::method", "java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapValueIterator", "next", "java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapIter", "advance", "descend", "findNear", "findPredecessor", "getTask", "java.util.concurrent.LinkedBlockingQueue", "take", "dequeue", "C2Compiler::compile_method", "Compile::Compile", "Compile::Optimize", "PhaseIdealLoop::optimize", "PhaseIdealLoop::build_and_optimize", "GraphBuilder::access_field", "ciBytecodeStream::get_field", "ciEnv::get_field_by_index", "ciField::ciField", "ciField::initialize_from", "Compile::Code_Gen", "PhaseCFG::do_global_code_motion", "PhaseCFG::global_code_motion", "PhaseCFG::implicit_null_check", "SharedRuntime::handle_wrong_method", "SharedRuntime::reresolve_call_site", "SharedRuntime::find_callee_method", "SharedRuntime::find_callee_info_helper", "Bytecode_invoke::static_target", "LinkResolver::resolve_method_statically", "LinkResolver::resolve_method", "dataFile", "SharedRuntime::resolve_opt_virtual_call_C", "SharedRuntime::resolve_helper", "SharedRuntime::resolve_sub_helper", "SharedRuntime::resolve_sub_helper_internal", "DirectNativeCallWrapper::instruction_address", "one.nio.server.SelectorThread", "FrameMap::FrameMap", "FrameMap::java_calling_convention", "java.nio.ByteBuffer", "compareTo", "java.nio.BufferMismatch", "mismatch", "PhaseCFG::schedule_early", "PhaseIterGVN::optimize", "PhaseIterGVN::transform_old", "PhaseIterGVN::subsume_node", "PhaseIterGVN::remove_globally_dead_node", "Node::replace_edge", "PhaseOutput::Output", "PhaseOutput::BuildOopMaps", "ciObjectFactory::get", "ciObjectFactory::get_metadata", "ciObjectFactory::create_new_metadata", "ciInstanceKlass::ciInstanceKlass", "java.util.concurrent.ConcurrentSkipListMap$Values", "iterator", "java.util.concurrent.ConcurrentSkipListMap$SubMap", "hiNode", "findLast", "PhaseOutput::fill_buffer", "PhaseOutput::Process_OopMap_Node", "MachCallNode::returns_pointer", "IfNode::Ideal", "IfNode::search_identical", "PhaseIdealLoop::build_loop_tree", "Node::is_CFG", "one.nio.http.HttpSession", "sendResponse", "one.nio.http.Request", "getHeader", "java.lang.String", "regionMatches", "java.lang.StringLatin1", "regionMatchesCI", "Matcher::match", "ConNode::Opcode", "ParseGenerator::generate", "Parse::Parse", "Parse::do_all_blocks", "Parse::do_one_block", "Parse::do_one_bytecode", "Parse::do_call", "Parse::do_field_access", "Parse::do_put_xxx", "GraphKit::access_store_at", "BarrierSetC2::store_at", "ModRefBarrierSetC2::store_at_resolved", "G1BarrierSetC2::post_barrier", "IdealKit::load", "LoadNode::make", "Arena::Amalloc_D", "Parse::do_exits", "AllocateNode::compute_MemBar_redundancy", "ciMethod::get_bcea", "BCEscapeAnalyzer::BCEscapeAnalyzer", "BCEscapeAnalyzer::compute_escape_info", "BCEscapeAnalyzer::initialize", "ok.dht.kovalenko.dao.LSMDao$MemoryStorage", "ok.dht.kovalenko.dao.aliases.MemorySSTableStorage", "java.util.concurrent.LinkedBlockingDeque", "descendingIterator", "java.util.concurrent.LinkedBlockingDeque$DescendingItr", "java.util.concurrent.LinkedBlockingDeque$AbstractItr", "unknown_Java", "I2C/C2I adapters", "LinearScan::allocate_registers", "IntervalWalker::walk_to", "LinearScanWalker::activate_current", "LinearScanWalker::split_and_spill_interval", "LinearScanWalker::split_before_usage", "Interval::split", "Interval::new_split_child", "Interval::Interval", "Compile::call_generator", "InlineTree::ok_to_inline", "ciMethod::get_flow_analysis", "ciTypeFlow::do_flow", "ciTypeFlow::flow_types", "ciTypeFlow::df_flow_types", "ciTypeFlow::flow_block", "ciTypeFlow::StateVector::apply_one_bytecode", "ciTypeFlow::StateVector::do_invoke", "ciBytecodeStream::get_method", "ciEnv::get_method_by_index", "ciEnv::get_method_by_index_impl", "LinkResolver::linktime_resolve_virtual_method_or_null", "LinkResolver::linktime_resolve_virtual_method", "LinkResolver::check_method_loader_constraints", "SystemDictionary::check_signature_loaders", "SystemDictionary::add_loader_constraint", "Dictionary::find_class", "one.nio.net.Session", "process", "processRead", "read", "one.nio.net.NativeSocket", "libonenio.210fea54.so", "Java_one_nio_net_NativeSocket_read", "HandleMark::pop_and_restore", "PhaseChaitin::Register_Allocate", "PhaseChaitin::Split", "ProjNode::is_CFG", "PredictedCallGenerator::generate", "GraphKit::type_check_receiver", "GraphKit::load_object_klass", "LoadKlassNode::make", "LoadNKlassNode::Value", "AddPNode::Identity", "TypeLong::make", "PhaseCoalesce::coalesce_driver", "PhaseConservativeCoalesce::coalesce", "PhaseIdealLoop::Dominators", "JNIHandleBlock::allocate_block", "LIR_Assembler::emit_op1", "LIR_Assembler::mem2reg", "LIR_Assembler::add_debug_info_for_null_check_here", "GrowableArrayWithAllocator<CodeStub*, GrowableArray<CodeStub*> >::grow", "PhaseCCP::analyze", "Node::find_out_with", "StoreNode::Identity", "PhaseIdealLoop::build_loop_late", "PhaseIdealLoop::build_loop_late_post_work", "PhaseIdealLoop::get_late_ctrl_with_anti_dep", "Compile::can_alias", "Compile::find_alias_type", "Compile::flatten_alias_type", "ciInstanceKlass::get_canonical_holder", "PhaseChaitin::Simplify", "IndexSetIterator::advance_and_next", "GlobalValueNumbering::GlobalValueNumbering", "ValueMap::find_insert", "LIR_Assembler::emit_profile_call", "Label::patch_instructions", "IR::compute_use_counts", "BlockList::iterate_backward", "non-virtual thunk to UseCountComputer::block_do", "StateSplit::state_values_do", "ValueStack::values_do", "Local::as_Local", "one.nio.http.Response", "ok", "non-virtual thunk to LIRGenerator::block_do", "LIRGenerator::do_ProfileInvoke", "LIRGenerator::state_for", "ciMethod::liveness_at_bci", "MethodLiveness::get_liveness_at", "as_ValueType", "Node::pinned", "GraphKit::load_array_length", "PhaseGVN::transform_no_reclaim", "TypeAryPtr::add_offset", "TypeAryPtr::make", "processHttpBuffer", "parseRequest", "one.nio.util.Utf8", "toAsciiString", "java.lang.invoke.LambdaForm$MH.0x0000000800c8c400", "invokeExact_MT", "java.lang.invoke.LambdaForm$DMH.0x0000000800c8d400", "newInvokeSpecial", "java.lang.invoke.DirectMethodHandle", "allocateInstance", "Unsafe_AllocateInstance", "InstanceKlass::check_valid_for_instantiation", "Parse::do_if", "GraphKit::clean_stack", "Compile::remove_speculative_types", "PhaseIdealLoop::compute_lca_of_uses", "PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal", "RegionNode::Ideal", "Matcher::find_shared", "PhaseLive::compute", "PhaseLive::add_liveout", "IndexSet::alloc_block_containing", "PhaseChaitin::build_ifg_physical", "PhaseChaitin::interfere_with_live", "PhaseCFG::is_uncommon", "PhasePeephole::do_transform", "InlineTree::find_subtree_from_root", "PhiNode::Ideal", "RegionNode::is_unreachable_region", "RegionNode::is_unreachable_from_root", "CProjNode::is_CFG", "PhaseIdealLoop::split_if_with_blocks", "PhaseIdealLoop::split_if_with_blocks_post", "PhaseIdealLoop::try_sink_out_of_loop", "PhaseIdealLoop::ctrl_of_all_uses_out_of_loop", "CallStaticJavaNode::uncommon_trap_request", "Matcher::xform", "doGet", "Node::Opcode", "PhiNode::Value", "TypeInt::filter_helper", "Type::hashcons", "Dict::Insert", "Type::cleanup_speculative", "PhaseCFG::schedule_late", "PhiNode::pinned", "writeResponse", "write", "one.nio.net.Session$ArrayQueueItem", "Java_one_nio_net_NativeSocket_write", "jni_GetByteArrayRegion", "check_bounds", "java.util.concurrent.locks.ReentrantLock", "lock", "java.util.concurrent.locks.ReentrantLock$Sync", "java.util.concurrent.locks.AbstractQueuedSynchronizer", "acquire", "PhaseChaitin::adjust_high_pressure_index", "PhaseChaitin::Select", "PhaseChaitin::bias_color", "IndexSet::IndexSet", "handleParsedRequest", "ok.dht.kovalenko.dao.utils.PoolKeeper", "submit", "java.util.concurrent.AbstractExecutorService", "execute", "offer", "java.util.concurrent.LinkedBlockingQueue$Node", "IdealKit::end_if", "IdealLoopTree::iteration_split", "IdealLoopTree::adjust_loop_exit_prob", "PhaseCFG::insert_anti_dependences", "Node_Array::grow", "Arena::Arealloc", "StoreNode::Ideal", "MemNode::Ideal_common", "MemNode::adr_type", "TypeInstPtr::add_offset", "PhaseCCP::do_transform", "PhaseCFG::schedule_pinned_nodes", "PhaseChaitin::merge_multidefs", "PhaseIterGVN::PhaseIterGVN", "ok.dht.kovalenko.dao.base.ByteBufferDaoFactoryB", "toBytes", "getArray", "copyMemory", "copyMemoryInternal", "copyMemoryChecks", "checkSize", "PhaseChaitin::gather_lrg_masks", "TypeLong::hash", "ConstraintCastNode::Identity", "TypeNode::bottom_type", "IfNode::Opcode", "cmpOpOper::ccode", "PhaseChaitin::post_allocate_copy_removal", "AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<594020ul, G1BarrierSet>, ", "one.nio.util.ByteArrayBuilder", "append", "charAt", "Type::remove_speculative", "java.lang.StringBuilder", "toString", "PhaseChaitin::remove_bound_register_from_interfering_live_ranges", "RegMask::Size", "libc.so.6", "send", "Parse::do_ifnull", "DecodeNNode::Opcode", "RegMask::is_misaligned_pair", "monitorexit Runtime1 stub", "ok.dht.kovalenko.dao.comparators.ByteBufferComparator", "lessThan", "compare", "newString", "jbyte_disjoint_arraycopy", "java.util.Objects", "checkFromIndexSize", "jdk.internal.util.Preconditions", "Parse::do_get_xxx", "GraphKit::make_constant_from_field", "Type::make_constant_from_field", "Type::make_from_constant", "TypeOopPtr::make_from_constant", "Type::cmp", "IdealLoopTree::iteration_split_impl", "PhaseIdealLoop::partial_peel", "PhaseIdealLoop::clone_loop", "NodeHash::hash_delete", "java.lang.invoke.Invokers", "checkCustomized", "PhaseChaitin::lower_pressure", "java.lang.invoke.Invokers$Holder", "linkToTargetMethod", "java.lang.invoke.DirectMethodHandle$Holder", "CMoveNode::Value", "unknown", "ciMethod::ensure_method_data", "Metadata::is_method", "IdealLoopTree::reassociate_invariants", "PhaseIdealLoop::build_loop_early", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject", "await", "DebugInformationRecorder::create_scope_values", "LocationValue::write_on", "ConnectionGraph::do_analysis", "ConnectionGraph::compute_escape", "ConnectionGraph::process_call_arguments", "BCEscapeAnalyzer::iterate_blocks", "BCEscapeAnalyzer::iterate_one_block", "ciObjectFactory::get_symbol", "vmSymbols::find_sid", "PhaseMacroExpand::expand_macro_nodes", "lockInterruptibly", "acquireInterruptibly", "java.util.concurrent.locks.LockSupport", "park", "LockTracer::UnsafeParkHook", "JvmtiEnvBase::get_stack_trace", "JavaThread::last_java_vframe", "JavaThread::pd_last_frame", "CodeCache::find_blob", "split_if", "java.util.concurrent.ForkJoinPool", "managedBlock", "unmanagedBlock", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode", "block", "CompileTask::print_inlining_ul", "MachProjNode::bottom_type", "GraphBuilder::if_zero", "ciBytecodeStream::has_local_signature", "ConstantPool::has_local_signature_at_if_loaded", "signalNotEmpty", "java.util.concurrent.locks.AbstractQueuedSynchronizer$Node", "clearStatus", "putIntOpaque", "Matcher::match_tree", "Matcher::ReduceInst", "Matcher::ReduceInst_Interior", "State::MachOperGenerator", "getParameter", "startsWith", "entryAt", "readEntry", "readByte", "ObjectSynchronizer::quick_enter", "PhaseCFG::schedule_local", "PhaseCFG::select", "java.util.concurrent.locks.ReentrantLock$NonfairSync", "initialTryLock", "Node::raise_bottom_type", "Compile::remove_useless_nodes", "NodeHash::hash_find_insert", "MachNode::rematerialize", "MachNode::ideal_reg", "set", "java.lang.invoke.VarHandleGuards", "guard_LII_Z", "java.lang.invoke.VarHandleInts$FieldInstanceReadWrite", "compareAndSet", "fromString", "wrap", "PhaseChaitin::add_input_to_liveout", "PhaseBlockLayout::PhaseBlockLayout", "PhaseBlockLayout::reorder_traces", "Trace::fixup_blocks", "LibraryIntrinsic::generate", "LibraryCallKit::try_to_inline", "LibraryCallKit::inline_unsafe_copyMemory", "Node::set_req", "tryAcquire", "LoadNode::Identity", "AllocateNode::Ideal_allocation", "one.nio.util.URLEncoder", "decode", "indexOf", "IdealLoopTree::loop_predication", "PhaseIdealLoop::loop_predication_impl", "IdealLoopTree::compute_profile_trip_cnt", "IdealLoopTree::compute_profile_trip_cnt_helper", "OptoRuntime::new_instance_C", "InstanceKlass::allocate_instance", "MemAllocator::allocate", "MemAllocator::allocate_inside_tlab_slow", "G1CollectedHeap::allocate_new_tlab", "unsafe_arraycopy", "__clock_gettime", "PhaseIFG::SquareUp", "JVMState::same_calls_as", "NonSafepointEmitter::emit_non_safepoint", "ciEnv::get_klass_by_index_impl", "Parse::do_exceptions", "Parse::throw_to_exit", "GraphKit::combine_exception_states", "PhiNode::slice_memory", "__tls_get_addr@plt", "isEmpty", "MemBarVolatileNode::Opcode", "SuperWord::transform_loop", "SuperWord::SLP_extract", "SuperWord::find_adjacent_refs", "SuperWord::are_adjacent_refs", "SuperWord::in_bb", "PhaseIdealLoop::get_ctrl", "LoadNode::Value", "MemNode::can_see_stored_value", "AddPNode::Ideal_base_and_offset", "PhaseChaitin::raise_pressure", "PhaseChaitin::elide_copy", "PhaseChaitin::yank_if_dead_recurse", "GraphKit::null_check_common", "GraphKit::uncommon_trap", "GraphKit::make_runtime_call", "GraphKit::set_predefined_input_for_runtime_call", "MergeMemNode::Ideal", "isReleasable", "PhaseIdealLoop::compute_early_ctrl", "ReturnNode::hash", "PhaseCFG::PhaseCFG", "PhaseCFG::build_cfg", "Node::clone", "cpr", "isAsciiString", "java.nio.MappedByteBuffer", "rewind", "getByte", "getByteInternal", "PhaseIdealLoop::split_if_with_blocks_pre", "PhaseIdealLoop::has_local_phi_input", "JavaFrameAnchor::make_walkable", "java.nio.HeapByteBuffer", "vectorizedMismatch", "vectorizedMismatchInternal", "jni_SetByteArrayRegion", "substring", "length", "vdso", "__vdso_clock_gettime", "jvmti_GetClassSignature", "JvmtiEnv::GetClassSignature", "ciTypeFlow::StateVector::do_putstatic", "BCEscapeAnalyzer::invoke", "ciMethod::ciMethod", "ciSignature::ciSignature", "ciEnv::get_klass_by_name_impl", "ciObjectFactory::get_unloaded_klass", "__recv", "CardTableBarrierSet::on_slowpath_allocation_exit", "LIRGenerator::do_Goto", "LIRGenerator::move_to_phi", "PhiResolver::create_node", "PhaseIdealLoop::is_dominator", "checkCastPPNode::rule", "jni_GetObjectClass", "GangWorker::run", "GangWorker::loop", "G1EvacuateRegionsBaseTask::work", "G1RemSet::scan_collection_set_regions", "G1CollectionSet::iterate_incremental_part_from", "G1ScanCollectionSetRegionClosure::do_heap_region", "G1CodeRootSet::nmethods_do", "G1CodeBlobClosure::do_code_blob", "nmethod::oops_do_process_weak", "nmethod::fix_oop_relocations", "metadata_Relocation::unpack_data", "java.lang.ref.Reference", "reachabilityFence", "call_stub", "isLatin1", "Node_Backward_Iterator::next", "one.nio.server.Server", "incRequestsProcessed", "java.util.concurrent.atomic.LongAdder", "increment", "java.util.concurrent.atomic.Striped64$Cell", "cas", "one.nio.net.NativeSelector", "select", "one.nio.net.NativeSelector$2", "getPath", "ResourceArea::rollback_to", "jvmti_Deallocate", "cfree", "jdk.internal.util.ArraysSupport", "epollWait", "epoll_wait", "JNIEnv_::CallStaticObjectMethod", "jni_CallStaticObjectMethodV", "jni_invoke_static", "CompilationPolicy::compile_if_required", "jlong_disjoint_arraycopy", "__libc_malloc", "listen", "greaterThan", "InstanceKlass::signature_name", "vframe::java_sender", "compiledVFrame::sender", "vframe::sender", "MultiNode::is_CFG", "Matcher::Label_Root", "ThreadLocalNode::ideal_reg", "MemAllocator::Allocation::notify_allocation_jvmti_sampler", "JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector", "JvmtiObjectAllocEventCollector::generate_call_for_allocated", "JvmtiExport::post_sampled_object_alloc", "ObjectSampler::SampledObjectAlloc", "vframe::new_vframe", "Arena::grow", "ChunkPool::allocate", "pthread_self", "java.nio.Buffer", "position", "unlock", "release", "signalNext", "unpark", "Unsafe_Unpark", "ThreadsListHandle::ThreadsListHandle", "scope", "Unsafe_Park", "frame::real_sender", "frame::sender", "AllocTracer::send_allocation_in_new_tlab", "G1PrepareEvacuationTask::work", "HeapRegionManager::par_iterate", "values", "inBounds", "tooLow", "OptoRuntime::new_array_C", "TypeArrayKlass::allocate_common", "ObjectSampler::is_created", "StackOverflow::reguard_stack_if_needed", "jshort_disjoint_arraycopy", "SafepointMechanism::process_if_requested_with_exit_check", "oopDesc::address_field", "limit", "jbyte_arraycopy", "getBytes", "encode", "encodeUTF8", "java.util.Arrays", "copyOf", "ThreadsListHandle::cv_internal_thread_to_JavaThread", "os::stack_shadow_pages_available", "State::DFA", "State::_sub_Op_AddP", "Chunk::next_chop", "java.util.concurrent.locks.AbstractOwnableSynchronizer", "setExclusiveOwnerThread", "canReacquire", "isEnqueued", "os::javaTimeMillis", "enableWait", "JNI_ArgumentPusherVaArg::~JNI_ArgumentPusherVaArg", "G1Allocator::attempt_allocation", "frame::frame", "CodeHeap::find_blob_unsafe", "G1NUMA::index_of_current_thread", "JavaThread::check_special_condition_for_native_trans", "SafepointMechanism::process", "SafepointSynchronize::block", "pthread_cond_wait", "G1CollectedHeap::attempt_allocation_slow", "G1AllocRegion::new_alloc_region_and_allocate", "G1CollectedHeap::new_mutator_alloc_region", "G1CollectedHeap::new_region", "HeapRegionManager::allocate_free_region", "methodHandle::~methodHandle", "AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ul, G1BarrierSet>, ", "_pthread_cleanup_push", "os::current_stack_pointer", "JfrAllocationTracer::JfrAllocationTracer", "jvmti_GetCurrentThread", "JavaThread::threadObj", "StatSamplerTask::task", "ThreadsListHandle::~ThreadsListHandle", "checkIndex", "oopDesc::metadata_field", "JavaCalls::call_helper", "JavaCallWrapper::JavaCallWrapper", "ThreadLocalAllocBuffer::retire_before_allocation", "JvmtiEnv::GetCurrentThread", "AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<2646116ul, G1BarrierSet>, ", "access$100", "guard_LLL_Z", "java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite", "JavaThread::is_Java_thread", "pthread_mutex_lock", "compareAndSetState", "JNI_ArgumentPusher::JNI_ArgumentPusher", "sun.misc.Unsafe", "SharedRuntime::on_slowpath_allocation_exit", "getBlocker", "one.nio.http.PathMapper", "find", "JNIHandleBlock::release_block", "findNext", "java.util.HashMap", "getNode", "hash", "hashCode", "java.util.concurrent.ConcurrentSkipListMap$ValueIterator", "java.util.concurrent.ConcurrentSkipListMap$Iter", "AbstractInterpreter::size_top_interpreter_activation", "G1EvacuateRegionsTask::evacuate_live_objects", "G1ParEvacuateFollowersClosure::do_void", "SpinPause", "copyOfRange", "jint_disjoint_arraycopy", "java_lang_Thread::set_thread_status", "checkPrimitivePointer", "checkPrimitiveArray", "JvmtiEnv::Deallocate", "ThreadLocalAllocBuffer::fill", "Handle::Handle", "signal", "doSignal", "enqueue", "setPrevRelaxed", "Thread::is_Named_thread", "java_lang_Thread::thread", "equals", "pthread_cond_signal", "java.lang.Long", "JvmtiEnvBase::is_valid", "coder", "Symbol::as_C_string", "G1EvacuateRegionsTask::scan_roots", "G1RemSet::scan_heap_roots", "G1ScanHRForRegionClosure::scan_heap_roots", "G1BlockOffsetTablePart::forward_to_block_containing_addr_slow", "Method::jmethod_id", "ensureCapacity", "JavaCalls::call", "compiledVFrame::compiledVFrame", "CompiledMethod::scope_desc_at", "ScopeDesc::decode_body", "InstanceKlass::get_jmethod_id", "SharedRuntime::complete_monitor_locking_C", "ok.dht.kovalenko.dao.base.Entry", "isTombstone", "ok.dht.kovalenko.dao.aliases.TypedBaseEntry", "value", "canEncode", "tooHigh", "casTail", "JNI_ArgumentPusherVaArg::do_type", "InstanceKlass::initialize", "guard_LJJ_Z", "java.lang.invoke.VarHandleLongs$FieldInstanceReadWrite", "weakCompareAndSetRelease", "javaVFrame::is_java_frame", "oopDesc::is_a", "clock_gettime@plt", "pthread_mutex_trylock", "findHandlerByHost", "os::os_exception_wrapper", "JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector", "ThreadLocalAllocBuffer::set_back_allocation_end", "pthread_mutex_unlock", "Parker::unpark", "java.util.concurrent.atomic.Striped64", "getProbe", "guard_L_I", "java.util.ImmutableCollections$SetN", "contains", "HandleMark::initialize", "probe", "java.lang.Integer", "G1RootProcessor::evacuate_roots", "G1RootProcessor::process_java_roots", "Threads::possibly_parallel_oops_do", "JavaThread::oops_do_frames", "G1NmethodProcessor::do_regular_processing", "nmethod::oops_do", "checkExactType", "Buffer::putVar64", "void AccessInternal::arraycopy_conjoint<signed char>", "HandleMark::~HandleMark", "PreserveExceptionMark::PreserveExceptionMark", "ThreadShadow::clear_pending_exception", "InstanceKlass::allocate_objArray", "nmethod::is_zombie", "GraphKit::subtype_check_receiver", "GraphKit::gen_subtype_check", "GraphKit::access_load_at", "BarrierSetC2::load_at", "G1BarrierSetC2::load_at_resolved", "BarrierSetC2::load_at_resolved", "GraphKit::make_load", "LoadNode::Ideal", "MemNode::find_previous_store", "TypeInstPtr::make", "PhaseIdealLoop::get_early_ctrl", "URShiftLNode::Ideal", "Node::Node", "PhaseCFG::hoist_to_cheaper_block", "PhaseChaitin::build_ifg_virtual", "decodeHeapOop_not_nullNode::rule", "PhaseIFG::init", "IndexSet::initialize", "PhaseIdealLoop::remix_address_expressions", "loadConINode::ideal_Opcode", "java.lang.Object", "CollectedHeap::fill_with_dummy_object", "G1ParScanThreadState::steal_and_trim_queue", "G1ParScanThreadState::trim_queue_to_threshold", "void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>", "void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>", "MutatorAllocRegion::retire", "G1CollectedHeap::retire_mutator_alloc_region", "G1CollectionSet::add_eden_region", "G1Policy::predict_region_non_copy_time_ms", "AbsSeq::davg", "JavaThreadParkedState::JavaThreadParkedState", "getLong", "Parker::park", "LIRGenerator::do_Invoke", "BitMap::set_union", "SignatureIterator::set_fingerprint", "jshort_arraycopy", "VMThread::run", "VMThread::inner_execute", "VMThread::evaluate_operation", "VM_Operation::evaluate", "VM_G1CollectForAllocation::doit", "G1CollectedHeap::do_collection_pause_at_safepoint", "G1CollectedHeap::do_collection_pause_at_safepoint_helper", "G1CollectedHeap::trace_heap", "GCHeapSummaryEventSender::visit", "getState", "JNIHandles::make_local", "addHeader", "java.nio.DirectByteBufferR", "slice", "WatcherThread::sleep", "JvmtiEnvBase::jvmtiMalloc", "OptoRuntime::new_array_nozero_C", "workerCountOf", "getAndUnsetStatus", "java.util.concurrent.atomic.AtomicInteger", "getAndIncrement", "Dictionary::lookup", "CompiledMethod::is_compiled", "ix", "JvmtiEnvBase::phase",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(' + value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
