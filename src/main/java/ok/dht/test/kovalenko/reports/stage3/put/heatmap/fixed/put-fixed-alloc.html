<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BOta@AFbA}AkDyHoLrN`WpXvXm\f^z_@c`@r`B????????????????????????????????????????????????????????????????A????????????????G@??@??G??@G????@@???????G?????G??@@G??@?????@????G?@?@?@??G??????G?A?G??@?G??H??????@?????G???????@?@?????G?G@???A?G@???????@?@??G?G?G?@?HGO@H??@?G?@@???H?????@@?@G???G???O@GG@??????G??@??OG?GG?O?GG@A@?????@??@?G???@???@?H??G?G??@????@@??O@??????@@@???????H??G?H?G??@??????????@@??H@@?G@A???@GPGG@??H?OO?I@@G@G?HG?@??@@PI??@?G@W??XO@?I?BHGG??Z??A?@IG?G@?H???O??G@IH???GAW?I@A@H?QOP?G?@G??PA?IGGGJ?@?GBG????GP@O??G??@AA?A@??H?G??H@?O?@??`GA?@G?AOP??GH??@??H?@@?GGA@G?H@@?G?G@G??GG??O?O??@?@@?@??G@G??@@OGG?G?H??@GHB??HIH?GG?GHGQ?O?G?@GG?GO??G@??OI?GJ@?GH@?GG@?@?????AAG@?W@G@HPHGOH?HGG@??GH?G?@?G???????@???G???G@??OAG?H?R?GO?@?G??O?HH?@Q?@G???@????H?X?HGG??OAOGG@@?@@G?@A@?HG@?@?GH@?GH@?GOG@@??O@G???AG@G??I????GGG@G??G?@@?B?H?G?@?@HJ?@?@??O?@?@???@@W@??@?G?A?@?G@@?G@H?HAH?@???@?GHG?AO@@?G?@@??HIA?G?@@G@@?@??@B@HG@OI??GHO??GG@?G@H???G?@??@WOI@???@?QGG???GG?AIGW??@@GOG??P?H??P@OO??G?GGG??H@?HCG?G@HA??@??H@?@G@HH?@G???A?G?H@@??G@@???AO???GA@G@PG@@WH@?H@?G?QXKGG?@???PBG@??@??H?G@?X@AA@@???AGGP@G?@GG@?IG?G@H?Q???@GG?@I@PG?@GG??@G???QHGH???H?GGG?P??@?H??@@?H@?@@@HO???H?@GOGY?O??@A@G?GG?G@GHG@??@?OH@@G??@??G@?GO?PH@??G?@BGO?GA@@@OH@?GGP@??HGG?GGG?W@?@@G?@W@A@?????HGIG@B@@?B@GH?H@?I?OGGH?IH??@?G?G?IQ?????H?G??HG?@O?GH?O??O?HGO?OG??G@I@?GOOI@???@I??G?@?@@@?A?GO?HG@?IGG?GG?AHPGG?@H?W?B@@O??@@QPO`@?@IG?G@??????PO?@?@HH@?G?OG@GI@G@@O@AHP???@@PGPH?O?G?H?GGO?XG?HGGAO@H@@H@G?@??AGGHAOG?AGOWI?@GH??AO?@GG?Q@???@O??G@?GGH?@P?@HG??@GG??GGO???J@OG?HHGPGG@?@??@G@GI?I??@??I?HGGGGHAG@??OXGxyAxyA}yAp}A{~AtdByqBovCc}A{cBuaBybBn}A|wBbdB_rBxoBdtBpuCewCa|CkbBrdBofBljBozCzzClbBh~Bj_Cm`CpdC_tC`qBzqBsvB~yCr{Cz}AeoBroBnsBitBuuBhyBlzBx|B{lCatCjbDldBulBwnBhqBrsBiuBbvBcvBvwBxwBo{By~Bz_CcaCdbCqkCa{CbzA`}AzbBcdB|dBwhB|jBtkBhrBhuBpyBt{By}Bj~Bt`C{aC}dCbfC_mC{rCqtCs{Ay|Ap_B~`BigBrgB{hBokBonB|nB`oB{oBnrByrBzxBczByzBh}B_~BdaCvcC}fCmkCtpCdvC~|CycDmeD`gDbiDh{Ap|Ar|A||Ad_Bc`B~aBkcBneBqiBuiBajBxmBgnBlnB}nByoBspBkrB`uBtuB{uBdvBcwBnyB_zBpzBrzBi{B`~Bp~Bt~Bv~B|_Cg`Ck`Cr`CbbCkcCbdCqeCveCogC|hCciCfiCekCwkCrlCvlCfnC`oCxpCpqC_sCqsCetC|uCiwC}xCpzCt_Dh`DyaDpbDxgDplDczAhzA`{Ak{Ap{A`|Ac|Ae|Al|Au|Aw|A{|Aj}Au}Aa~Ae~Ah~Am~Ao~Aq~A|~A}~A~~A__Bc_Bi_Br_B``Bd`Bf`Bi`B|`BhaBjaB|aB`bBdbB|bB`cBdcBecBgcBhdBpdBvdBaeBheBjeBteBifBlfBrfBtfBufB{fB|fB~fBxgB|gBghBjhBkhBphB}hBciBkiBxiByiBijBxjBkkBpkBklBllBnlBqlBrlBzlB}lB_mBhmBsmBzmB}mBdnBxnBooBipBmpBqpBgqBmqBwqBqrBrrB}rB`sBcsBdsBmtB_uBluBquBruBwuByuB`vBfvBivBkvBmvBqvBewBfwBhwBjwBpwBqwBkxBmxB}xBcyBdyBiyBk{Bs{Bz{Bb|Bi|Bj|Bu|Bc}Bj}Bg~Bw~Bz~Bf_Ci_Cp_Cn`Cq`C{`C~`CgaCpaCfbCxbCybC~bCjcCncCpcCycCufCegCigCkgCchChhClhCnhCyhC}hC`iCiiCliCtiCxiCojCqjCujCwjCckC_lCclCplCbmCemCkmC|mC_nCanClnCqnCxnCcoCvpCwpCypCitCstC~tCyuCevCuvCvvC`wCywCeyC_zC{zC~zCo{Cq{C`|Cg|Cn|C`}Cb}C~}Cp~Cu~Ci_Dj_Dn_Dp`Dw`Dz`D~aDgcDicDncDvcDwcD{cD_dDhdD`eDaeDeeDoeDxeD`fDbfDhfDkfD~fD_gDigDogDtgDpiDqiDrpDvpD~yA`zAazAdzAezAfzAgzAjzAmzAnzAb{Ac{Ad{Ae{Af{Ag{Ai{Aj{Al{Am{An{Ao{Aq{Ar{Au{Av{Aw{Ay{A}{A_|Aa|Ad|Ag|Ak|Am|An|Ao|Aq|As|At|Av|Ax|Az|A}|A~|A_}Ab}Ad}Af}Ag}Ai}Al}Am}Ao}Aq}As}Aw}Ax}Ay}A{}A~}A_~A`~Ac~Ad~Ag~Ai~Aj~Ak~Al~An~Ar~As~At~Aw~Ax~Ay~Az~A`_Ba_Bb_Bf_Bg_Bh_Bj_Bk_Bm_Bq_Bs_Bt_Bu_Bv_Bw_Bx_By_B{_B|_B}_B~_B_`Ba`Be`Bg`Bh`Bk`Bm`Bn`Bo`Bp`Br`Bs`Bt`Bu`Bv`Bw`Bx`By`Bz`B{`B}`B_aB`aBdaBgaBiaBlaBmaBnaBoaBpaBqaBraBsaBtaBvaBxaBzaB{aB}aB_bBabBbbBcbBgbBibBjbBnbBobBpbBsbBtbBvbBwbBxbB}bB~bBacBbcBccBhcBicBjcBmcBncBpcBscBtcBvcBwcBxcBzcB|cB~cB_dB`dBadBedBfdBjdBndBodBsdBxdBydBzdB{dB}dB~dB_eB`eBbeBdeBeeBfeBgeBmeBoeBqeBreBseBueBweByeB{eB}eB`fBbfBcfBefBffBgfBhfBjfBkfBmfBnfBpfBsfBvfBwfBxfByfBzfB}fB_gBagBbgBcgBggBhgBkgBmgBngBogBqgBsgBugBwgBygB{gB~gB`hBahBbhBchBehBhhBihBmhBnhBohBqhBshBthBuhB`iBaiBbiBeiBhiBjiBniBsiBziB}iB`jBcjBdjBejBfjBgjBhjBjjBmjBojBpjBqjBrjBtjBwjByjBzjB{jB}jB_kB`kBakBbkBekBfkBikBjkBskBvkBwkBxkBykBzkB|kB}kB~kB_lB`lBalBclBelBflBhlBilBjlBmlBolBplBslBtlBvlBxlBylB{lB|lB~lBbmBdmBfmBimBkmBlmBmmBomBtmBvmBwmB{mB|mB~mB`nBanBfnBhnBknBpnBtnBunBvnBznB{nB_oBcoBdoBfoBhoBioBkoBloBmoBnoBqoBuoBvoB|oB}oB~oB`pBepBjpBkpBlpBtpBvpBwpBxpBzpB{pB|pB}pB_qBbqBcqBdqBeqBfqBjqBkqBlqBnqBpqBqqBsqBtqBuqBxqB}qB~qBbrBcrBerBgrBjrBlrBorBtrBurBvrBwrBxrBzrB|rB_sBasBbsBesBfsBgsBhsBisBjsBksBmsBosBqsBusBvsBwsBxsBzsB{sB|sB}sBatBbtBctBftBgtBktBltBntBotBptBqtBstBttButBxtBztB{tB}tB~tBauBbuBcuBduBeuBfuBguBkuBnuBouBxuBzuB|uB_vBavBevBhvBnvBovBpvBrvBtvBwvByvB{vB}vB~vB_wB`wBawBgwBkwBowBswBuwBywB{wB}wB_xB`xBdxBfxBgxBhxBixBlxBoxBqxBtxBvxByxB{xB|xB~xB`yBayBfyBgyBkyBoyBuyBvyBwyByyB{yB|yB}yB~yB`zBezBgzBizBjzBkzBnzBozBqzBszBtzBuzBwzB|zB}zB~zB`{Bb{Bd{Be{Bf{Bh{Bm{Bn{Bq{Br{Bv{Bx{B{{B|{B}{B~{B`|Ba|Bc|Bd|Be|Bf|Bg|Bl|Bo|Br|Bv|By|B{|B||B}|B_}Ba}Bb}Be}Bf}Bg}Bk}Bm}Bp}Bq}Bs}Bt}Bu}Bv}Bw}Bx}Bz}B|}B}}B~}Bb~Bd~Bf~Bk~Bm~Bo~Br~B|~B__Cb_Cg_Ck_Cm_Co_Cq_Cr_Ct_Cu_Cv_Cx_C}_C``Cb`Cc`Ce`Ci`Cj`Co`Cp`Cu`Cw`Cy`Cz`C`aCaaCbaCfaCiaCjaCkaClaCmaCnaCoaCqaCsaCuaCwaCxaCyaCzaC|aC~aC_bC`bCcbCgbChbCibCkbClbCvbCwbC|bC_cC`cCbcCccCecCgcChcClcCmcCqcCscCtcCucCwcCxcC{cC|cC}cC~cC`dCddCedCfdCgdChdCidCldCmdCodCrdCudCvdCxdCydCzdC{dC|dC_eCaeCbeCceCdeCeeCfeCgeCheCieCjeCkeCleCmeCneCoeCreCseCxeCzeC}eC~eC`fCafCcfCdfCffCgfCifClfCnfCofCpfCqfCtfCvfCxfCzfC{fC|fC_gCagCcgCggCjgClgCmgCngCqgCsgCugCwgCygC{gC}gC`hCdhCehCfhCghCihCkhCmhCohCqhCrhCshCthCuhCwhCxhCzhC{hC~hC_iCaiCbiCdiCeiCgiCjiCoiCpiCriCsiCuiCwiCziC{iC|iC}iC~iC`jCbjCdjCfjCgjChjCjjCljCrjCtjCxjCzjC{jC|jC}jC_kC`kChkCjkCkkCokCpkCrkCskCtkCukCvkCxkCykCzkC|kC`lCalCblCflChlCilCjlCllCnlCqlCslCwlCylCzlC}lC~lC`mCamCcmCdmCfmChmCimCmmComCqmCsmCumCvmCwmCxmC{mC~mC`nCcnCdnCenChnCinCpnCtnCunCynCznC{nC|nC}nC~nCboCdoCeoCfoCgoCioCjoCloCmoCnoCooCqoCroCsoCwoCzoC|oC~oC_pC`pCbpCcpCdpCfpChpCjpCkpCmpCppCqpCupC{pC}pC~pCdqCeqCgqCiqCjqCkqClqCmqCoqCqqCsqCtqCvqCwqCxqCyqC{qC|qC}qC~qC_rC`rCbrCcrCdrCerCfrCjrCkrClrCmrCnrCorCqrCsrCtrCurCwrCxrCyrCzrC|rC~rC`sCasCcsCdsCfsChsCjsClsCmsCnsCosCrsCtsC}sC~sC`tCbtCctCdtCgtCktCltCmtCntCotCrtCttCutCxtCytC}tCduCeuChuCiuCjuCkuCluCnuCquCruCtuCuuC`vCavCgvChvCivCjvCkvClvCmvCnvCpvCsvCxvCyvCzvC|vC}vC~vCbwCcwCfwChwClwCnwCowCpwCqwCrwCuwCvwCwwCzwC|wC_xCaxCbxCdxCpxCrxCwxCyxC|xC_yCcyCfyCgyChyCiyCkyCmyCoyCpyCqyCryCsyCuyCvyCwyCxyC{yC}yCazCfzCizCkzCqzCrzCtzCvzCxzCyzC}zC`{Cb{Cd{Ce{Cf{Ci{Ck{Cm{Cp{Ct{Cu{Cv{Cz{C|{C~{Cb|Cj|Ck|Cm|Co|Cq|Cu|Cz|C{|C||C}|C_}Ca}Cd}Ce}Cf}Ch}Ci}Cj}Ck}Cl}Cm}Cp}Ct}Cy}Ce~Ch~Ci~Ck~Cm~Co~Cq~Cr~Ct~Cw~Cx~Cy~C{~C`_Da_Df_Dg_Dk_Dm_Do_Ds_Dx_Dy_D{_D}_D~_D``Da`Dd`Df`Dj`Dl`Dm`Dn`Do`Dq`Dt`Du`Dx`D|`D~`D_aDaaDcaDdaDfaDoaDpaDqaDraDsaDxaD|aD}aDcbDdbDhbDibDkbDmbDrbDsbDubDybD_cD`cDacDbcDdcDhcDjcDmcDocDqcDscDzcD}cD~cDadDddDfdDgdDidDjdDldDqdDsdDxdDzdDbeDdeDgeDieDkeDneDpeDreDseDteDueDveD}eD_fDafDdfDefDjfDmfDofDpfDqfDvfDxfDyfDzfD}fDfgDhgDjgDlgDpgDqgDsgDugDvgDygD{gD}gD~gDahDbhDchDdhDihDlhDnhDqhDthDyhD{hD|hD~hDaiDgiDjiDliDviDyiD|iDhjDjjDljDnjDpjDqjDujDwjDyjD|jD~jD_kDckDekDfkDjkDmkDokDykD}kDalDclDflDglDjlDmlDolDslDtlDwlD{lD}lDamDdmDimDmmDpmDqmDumDwmDxmDymDanDdnDfnDhnDinDlnDpnDxnDznD{nD_oDfoDgoDloDnoDroDvoDxoD_pD`pDopDspDtpDypD`qDjqD|qD}qDfrDirDnrDvrD~rDyyAzyA{yA|yA_zAizAkzAlzAozApzAqzArzAszAtzAuzAvzAwzAxzAyzAzzA{zA|zA}zA~zA_{Aa{At{Ax{Az{A{{A|{A~{Ab|Af|Ah|Ai|Aj|Aa}Ae}Ah}Ak}Ar}At}Av}A|}A}}Ab~Af~Ap~Au~Av~Ae_Bl_Bn_Bo_Bz_Bb`Bj`Bl`Bq`BaaBbaBcaBeaBfaBkaBwaByaBebBfbBhbBmbBqbBrbBubB{bB_cBfcBlcBocBqcBrcBucBycB}cBddBgdBidBkdBmdBqdBudBwdBceBieBkeBleBpeBveBxeBzeB|eB~eB_fBafBdfBqfB`gBdgBegBfgBjgBlgBpgBtgBvgBzgB}gB_hBdhBfhBlhBrhBvhBxhByhBzhB|hB~hB_iBdiBfiBgiBiiBliBmiBoiBpiBriBtiBviBwiB{iB|iB~iB_jBbjBkjBnjBsjBujBvjB~jBckBdkBgkBhkBlkBmkBnkBqkBrkBukB{kBblBdlBglBwlB`mBamBcmBemBgmBjmBnmBpmBqmBrmBumBymB_nBbnBcnBenBinBjnBmnBnnBqnBrnBsnBynB~nBaoBboBgoBjoBpoBsoBtoBwoBzoB_pBapBbpBcpBdpBfpBgpBhpBnpBopBppBrpBupBypB~pBaqBiqBoqBrqBvqB{qB|qB`rBarBdrBfrBirBmrBprBsrB{rB~rBlsBpsBssBtsBysB~sB_tB`tBetBhtBjtBrtBvtBwtBytB|tBjuBmuBpuBsuBvuB}uB~uBgvBjvBlvBuvBvvBxvBzvB|vBbwBdwBiwBlwBmwBnwBrwBtwBwwBzwB~wBaxBbxBcxBexBjxBnxBpxBrxBsxBuxBwxBxxB_yBbyBeyBjyBlyBmyBqyBryBsyBtyBxyBzyBazBbzBdzBfzBhzBmzBvzBxzBzzB{zB_{Ba{Bc{Bg{Bj{Bl{Bp{Bu{Bw{By{B_|Bh|Bk|Bm|Bn|Bp|Bq|Bs|Bt|Bw|Bz|B~|B`}Bd}Bi}Bl}Bn}Bo}Br}B{}Ba~Bc~Be~Bi~Bl~Bn~Bq~Bs~Bu~Bx~B{~B}~B~~B`_Ca_Cc_Cd_Ce_Ch_Cl_Cn_Cs_Cw_Cy_C{_C~_C_`Ca`Cd`Cf`Ch`Cl`Cs`Cv`Cx`C|`C}`C_aCeaChaCraCtaCvaC}aCabCebCjbCmbCnbCobCpbCqbCrbCsbCtbCubCzbC{bC}bCacCdcCfcCicCocCrcCzcC_dCadCcdCjdCkdCndCqdCsdCtdCwdC~dC`eCpeCteCueCweCyeC{eC|eC_fCefChfCjfCkfCmfCrfCsfCwfCyfC~fC`gCbgCdgCfgChgCpgCrgCtgCvgCxgCzgC|gC~gC_hCahCbhCjhCphCvhChiCkiCmiCniCqiCviCyiC_jCajCcjCejCijCkjCmjCnjCpjCsjCvjCyjC~jCakCbkCdkCfkCgkCikClkCnkC{kC}kC~kCdlCelCglCklCmlColCtlCulCxlC|lCgmCjmClmCnmCpmCrmCtmCymCzmC}mCbnCgnCjnCknCmnCnnConCrnCsnCvnCwnC_oCaoChoCkoCpoCtoCuoCvoCxoCyoC{oC}oCapCepCgpCipClpCnpCopCrpCspCzpC|pC_qC`qCaqCbqCcqCfqChqCnqCrqCuqCzqCarCgrChrCirCprCrrCvrC}rCbsCesCgsCisCksCpsCssCusCvsCwsCxsCysCzsC{sC|sCftChtCjtCptCvtCwtCztC{tC|tC_uC`uCauCbuCcuCfuCguCmuCouCsuCvuCwuCxuCzuC{uC}uC~uC_vCbvCcvCfvCqvCrvCtvCwvC{vC_wCawCdwCgwCjwCkwCmwCswCtwCxwC{wC}wC~wC`xCcxCexCfxCgxChxCixCjxCkxClxCmxCnxCoxCqxCsxCtxCuxCvxCxxCzxC{xC~xC`yCayCbyCdyCjyClyCnyCtyCyyCzyC|yC`zCbzCczCdzCezCgzChzCjzClzCmzCnzCszCuzCwzC|zC_{Cc{Cg{Ch{Cj{Cl{Cn{Cs{Cw{Cx{Cy{C{{C}{C_|Cc|Cd|Ce|Cf|Ch|Ci|Cl|Cp|Cr|Cs|Ct|Cv|Cw|Cx|Cy|Cc}Cg}Cn}Co}Cq}Cr}Cs}Cu}Cv}Cw}Cx}Cz}C{}C|}C}}C_~C`~Ca~Cb~Cc~Cd~Cf~Cg~Cj~Cl~Cn~Cs~Cv~Cz~C|~C}~C~~C__Db_Dc_Dd_De_Dh_Dl_Dp_Dq_Dr_Du_Dv_Dw_Dz_D|_D_`Db`Dc`De`Dg`Di`Dk`Dr`Ds`Dv`Dy`D{`D}`D`aDbaDeaDgaDhaDiaDjaDkaDlaDmaDnaDtaDuaDvaDwaDzaD{aD_bD`bDabDbbDebDfbDgbDlbDnbDobDqbDtbDvbDwbDxbDzbD{bD|bD}bD~bDccDecDfcDkcDlcDpcDrcDtcDucDxcD|cD`dDbdDcdDedDkdDmdDndDodDpdDrdDtdDudDvdDwdDydD{dD|dD}dD~dD_eDceDfeDheDjeDleDqeDweDyeDzeD{eD|eD~eDcfDffDgfDifDlfDnfDrfDsfDtfDufDwfD{fD|fDagDbgDcgDdgDegDggDkgDmgDngDrgDwgDzgD|gD_hD`hDehDfhDghDhhDjhDkhDmhDohDphDrhDshDuhDvhDwhDxhDzhD}hD_iD`iDciDdiDeiDfiDhiDiiDkiDmiDniDoiDriDsiDtiDuiDwiDxiDziD{iD}iD~iD_jD`jDajDbjDcjDdjDejDfjDgjDijDkjDmjDojDrjDsjDtjDvjDxjDzjD{jD}jD`kDakDbkDdkDgkDhkDikDkkDlkDnkDpkDqkDrkDskDtkDukDvkDwkDxkDzkD{kD|kD~kD_lD`lDblDdlDelDhlDilDklDllDnlDqlDrlDulDvlDxlDylDzlD|lD~lD_mD`mDbmDcmDemDfmDgmDhmDjmDkmDlmDnmDomDrmDsmDtmDvmDzmD{mD|mD}mD~mD_nD`nDbnDcnDenDgnDjnDknDmnDnnDonDqnDrnDsnDtnDunDvnDwnDynD|nD}nD~nD`oDaoDboDcoDdoDeoDhoDioDjoDkoDmoDooDpoDqoDsoDtoDuoDwoDyoDzoD{oD|oD}oD~oDapDbpDcpDdpDepDfpDgpDhpDipDjpDkpDlpDmpDnpDppDqpDupDwpDxpDzpD{pD|pD}pD~pD_qDaqDbqDcqDdqDeqDfqDgqDhqDiqDkqDlqDmqDnqDoqDpqDqqDrqDsqDtqDuqDvqDwqDxqDyqDzqD{qD~qD_rD`rDarDbrDcrDdrDerDgrDhrDjrDkrDlrDmrDorDprDqrDrrDsrDtrDurDwrDxrDyrDzrD{rD|rD}rD_sD`sDasDbsDcsDdsDesDfsDgsDhsDisDjsDksDlsDmsDnsDosDpsDqsDrsDssDtsDusDvsDwsDxsDysDzsD{sD|sD}sD~sD_tD`tDatDbtDctDdtDetDftDgtDhtDitDjtDktDltDmtDntDotDptDtg@??@?@????F@?A@????H?B?@@?S?????G??A??@??TUU?L@?@sF??S????B??IH|BnS??B?@????????F@???G??@sFd@H?B??A?@??~AH????H??TLUgAA@q@?@?@??????sZ?e@DpTgG?BbB?@????@D??rEnG?@jC?G|BVoH_W???@?gGUjG?DjAT@?mCT??KeC?r@???@q@A??hC?VB???????A??BKVN?rE??{Ar@????@y@S?Z???L?{@?mA?}@B??bB?@??l@?@K|]?g@Ar@?vCw`@?L?VHiC?AV?l@?I??yHKjBFL?D@???nQ@l@?g@NS?w^oAnAiI@hHL?B@HFKa@?y@G??[THd@??zC??mA??hB????hB?L??_D?lCpWK@??A?kH?@`D???cDT??????v@eDZuC?e@????Z??rAuIHwIl@GvC??v@[KrAFaDLI`JrAyHTA?cI[I_AIa@DFaCaDtX?HuC??fCgAF??tGhB_DgA?y@?mB?cB?gA?tHbJqGbJL?hBjC?AfJB@d@nCD@y@d@iCjA@v@GrA?SF{Ia@eB?cB|@?gAK?w_@??e@hDcB?dZN?r@?oH?S?~AkDmCmB?|@eDDjCnAZeDy@?md@q@oA@{@}Isf@L?tGAD?Z?cB?[BHwIjD^A_D??_B_B}@bI@??VhJS?@KT@?L?@{@?????}AjG?zC?{A^VhI???@S?}A??NB??mAgIg^`DpA~A@?@cD?nByJ?hC?@oU?~A?N?FbBGPVll@??Q?Q?`AD?U^W???lCb@r@^vC?|@?^tHv@???bd@?a@?Qq@tAvd@n@G?va@fJZAWsAG??pA?F?uI?v@ik@_AyC?T?eB@gKtC?aC[b@?mC??|@ZX?`J?{F??oAI??r@?B|\A@?WD_AuCpAIPyCNsA?tCGF???{H?hC?@I{AG?oA?|J??eB?q@a@?hG??Ae@@oAW?c@??XnAkHn@Dd@LmK|@g@eBdDUaC?Ae@pH}@`DVqJ{VP????GB}@??B??XH@}@^@`A??tDsA???A?o@???g@ad@fl@???K?hIy@INro@pBc@sn@A`A?DjAb@Qep@?F?rA????am@X?je@??{A?pA?[?IQ?uo@tKX@?zK}KBtDlKfKxm@mB?rn@vi@@?_LA?PbBa@vKkb@X_AhD???uKja@tk@o@?lC?pBc@APzm@zCD?@?B??GDv@?nKWc@{KqGn@hHkm@pD?sAU?yK@nAA??_Aon@do@lp@?pHqd@eCb@??{HrD?{@NQ[{FRfCfL?jq@P?sBN?_B???gIvK?PpF?|@hJ?f]GW?@rk@K?mB@o@jDRsBnr@n@n@wp@sr@SrDpDn@?g@??{@IF?rB?sA_L}A[{r@W?mK?jAnD?ScI?tp@Wsm@BFqB??b@tK?n@tq@??nB`AUZFfC?Q?nC@?GnAI???ce@yKKVqBX??gL_r@?gm@??XRR?qB?uf@?PUtARg@@oWN??gf@|K?`Ano@^??Pdt@kDoB}AiL{Ib@hGtDjBrK??P@iC?q@Bft@?^X?g`@kDqp@|J}Id@INeCwe@a@gK?oB??tA?rDzKjDd@}@zs@?aD?dm@hDtA?@?Aa@Kbm@??ZsBnBPWjBmAgLfLIl@zq@pAqBrKR_ABW[?@??Qc@iL??cs@pBo@`ADDe@??RIoBlq@Ae@b@|BfK?tAT?tCpBcDQG?iIus@@X?vt@o@Rsa@?@?LkLkt@jBR?_BoBaL?H?RQuKl@R~r@rBHaL@BnKcLct@nGNpD?kL???@KnDqJ?DyC{@b@?dD?lKnC?yJg@@?|Ko@nBdn@jLnDcL?F}KvD??{K?^?pFvDtt@xp@?dDo@rBUmAc@rBl@sBvDc@jA?jLQc@?wk@D?bIH??A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@?d@?e@?f@?g@lLGmLh@?i@?j@?k@?l@?m@?n@?o@?p@?q@?r@?s@?t@?u@?v@?w@?x@?y@yDH?h@vLj@xLl@zLn@tBz@?{@?|@?}@?~@vAh@dMk@yLm@{Lo@|Lq@zD_A?`A?aA?bA?cA?dA?eA?fA?gAvAIaAKoLMqLOxDhA?iA?jA?kA?lA?mA?nA?oA?pA?qA?rA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~A?_B?`B?aB?bB?cB?dB?eB?fB?gB?hB?iBhMi@wLk@iMn@tBjB?kB?lB?mB?nBbAzAzM|AbNj@eMm@|DjBdEoB?pB?qB?rB?sB?tBfN{AmMJwDLpLNrLP?hAuBjAvBlAsMnAtMpAuMrAvMtAwBuB?vB?wB?xBfEKnMNgEQsLyBuBzB?{B?|B?}BvA~B?_C?`C?aC?bC?cC?dC?eC?fC?gC?hC?iC?jC?kC?lCgNk@cNo@?jBdEmC?nC?oC?pC?qC?rC?sC?tCkE_CmEaCzNcC|NeCxBuC?vCbAwC?xC?yCJhB?zCkE{C?|ClE`CnE}C?~C?_D?`D?aD?bD?cD?dD?eD?fD?gD?hD?iD?jD?kD?lD?mD?nD?oD?pD?qD?rD?sD?tD?~B?uD?vD?wD?xD?yD?zD?{DuNLmNOxDQvNiAqMkA?|D?}D?~D?_E?`E?aE?bE?cE?dE?eE?fE?gE?hEgO`CnEbC{NdCoEfC?uCkOyA?iE?jE?kE?lE?mE?nE?oE?pEaOl@fMo@jMr@?_A}DqE?rE?sE?tEfPMoMPnNiAwElAqNoAaEuE?vE?wE{M~A|MxE?yE?zEpEwBtNEbQ_B}MaB~McB?{EYNgEhAoNkArMmA`EoAaEqAwAsAbEuA?|E?}E?~E?_F?`FcA`B?aF?bF{Em@|Dp@}Lr@{P`A?qE|PsEgQOpMiA_QmAiQpArNsA_FcF?dF?eFoQn@tBp@pQfF?gF`FhF?iFmQEwQo@bOkB?oBiNqBeEjF?kF?lFxAmFoOnFrQP~PjApNmAtQqA~EtAwBoF?pFYqF~QgBaNrFrPaCiOdCoEsF?tFaAuF?vF?wF?xF?yF?zF_E{F?|F?}F?~F?_G?`G?aG?bGdAjBhNpBjNrB?jF?cG?dG?eGvAfG?gG?hG?iG?jG?kGeA~ByBlG?mG?nG?oG?pG?qG?rG?sG?tG?uG{EvG?wGpElCp@hA}ElA`QpAuQtAwBvAxMxAbAiE?xGzByG?zG?{G?|G?}GpRgGqRiGsRkGtR_CmE~G?_H?`HeAIaAaHvBbH?cH`EdH?eH?fH?gH?hH?iH?jH?kHcFbCsPeCxBlH?mH?nH?oHp@QgPjAvB|DxE~DiP`EkPbEmPdEoPpHiF{GcS}G{RiAsQnAhEqAbFqH?rH?sHwSjA_RnAxSrAiEuA?oFYtH?uH?vHiFwH?xHoScCjOfCtPvChFjEaSzGbS|G?yHmSkHdAp@xQgFzQiFpO|CyBaC?}CqO_D?zH?{H?|H?}H?~HeFkB|QpBfFjFaF_IChB?`ItFq@zDs@_Mu@aMw@bMy@eT_ChO}CgTzHhT|HjTaI?bIfAlBdNnBlN|AfAmC?cI?dI?eI?fI?gIvFr@~Lt@`Mv@{DhIzAR?yB}E|DxEiI?jI?kI?lI|AmImT`CsE~CtEzHnTnIcRJ?oI?pI?qI?rI_CsI?tI?uI?vI~ByBwN{ByN}ByOlD{OnD}OpD_PrDaPtDvEuDyAwI?xI?yI?zIjF{I?|I?}I?~I?_J?`J`TdCbRtFdRvFeAxFgRzFhSkA?aJ?bJ?cJzSkAhQnAhEuE?dJ?eJ|TiAwE|DyFjIsTfJ?gJgUeCxBgC?hJjEwB~FfCaTyAyEjEzBlEzEnEyPpEfAoB}QrB?iJ?jJ?kJ?lJ?mJ?nJ?oJ?pJ?qJcTjHmUlA|RqAbFuAwMrJhFsJ`SkE?tJ?uJ?vJ?wJ?xJ?yJ?zJ?{J?|J?}J~FsF_CuFeRwFfRyFhRJwD{FdF}F?~J?_KeA`K?aK|AbK}FjArS}D?iIzFcKtTaCuFdK?eKdAz@gM|@?fK?gKmVkAhP}DnVjI?hK?iK?jK?kKgVtFhUwFiVzFiR|FjR~JlVwF?`K?lK?mK?nKsV|DyFoK?pK~UmA`RrAqFvA_SyA?qK?rK?sKuUpBfFiJ?tK?uKzV}DtVkI?vK?wK|VnA{SsA_FvAkGiE_GlEzExK?yK?zK~DcAlMeA?{K?|K?}KoTmBeNyA?~K`WoAjQrAqFuBpUxBfE_L?`LbC~DsSaElPcEnPaL?bL?cL?dL?eL?fL}Bs@?gL?hL`BpA}RuA`VyA?iLbCjL|AkL}UkHxFcI?lL?mL?nLqErCeOtC?oLf@qA_VvAkGzAYpL?qL~VqBeEsBkNyA?rL?sL~BtLwAuLxN|BbCiIzFkI?vL?wLvWrAiEqHySsHuVJ?uFhVxFjUJjV|F`C_KfGlK?xL?yLxAzLqE{L?|LwWrBvUjJxU}L?~L?_M?`M?aM?bM_@sB?cM?dM?eM?fM?gM?hM?iMpSoH{WuF|WyFdGK?{FkV~J?jM?kM?lMzW}BhAgC}NmM?nM?oM?pMoGjI?qM?rM?sMiW_EjPaEjWdE?tMpPgE_@jFaFuMwAvM?wMmGt@rTw@lTE{BxM?yM?zMdCdIqT{M?|M?}M?~M?_N?`NzRiBdShGrRjGgFwFvE_CkF_HfSwFnLJ?aHiScHmFeHkSgH?aN?bN?cN?dN?eN?fNpGsAbEgNsGhN?iNp@jN|AkN`@lNlYtA~RmN?nN?oN?pN?qNhAuCuPiEvPkE?yG~SxH?rN?sN?tN?uN?{I|F}IeU_Jt@uA?vN?wNcAxN|E{EOvA?rJaVxGzBtJbVvJcVxJbGzJeV|J{BaB|EdB_NfBJiBuGeI?{M|X}M~X_N`YkCsNxB}TmD|OoD~OqD`PsDbP~BcPvDdPxD?yN?zN?{N?|N?}N?~N?_O`@hC?`OeQxBdCaO?bO?cOaYiGjFwFvG`C?~GlFdO?eOf@uEnUeJoV}C?fO?gO?hOuXwKh@rJ}YkE`GuJaGwJdVyJcG{JfV}JwZyAfW|A|GbOwYsN?iO?jO`U~BgCkObUyI?lO?mO?nOxAoO?pO?qO?rOuWEnXvFiUyFdG_L`[wFvVJ~W}FeGsO?tOeAuO?vO?wOsGlMh@xOi@yO?zOcH_CwFdKO{OvQeFf@|OMhK?}O?~Oh@wAyMyAyExGrUmExPoEzPhEvX`EtScEkW_P?`P?aPiAkF?bPyXwMi@vEaQ}ByRwGrZEcAcP?dP?eP?fP?gP|FhP?iPO|E`F~ElQ`FxWrA?uLMjP?kPkXgM?lP?mP?nP?oP?pP?qP?rP?sPw@iE?sJ_GtJzGwJaHtP?uP?vP?wP?xP?yPsYvClOxCnOgBj[xAbArLzZcO}BfFyQ}E?hF{Q`Fb\yAa[xF}WKpX|F`CzP?{PaZ}Jw@iL_@iJwUkJyUmJ{UoJ|UqJzA|Pf[{B{[sJ|[uJxZxJbGtP}[vP~[xPkAtK`@}PgWErHyFoX{FdF~PmYiNp@_QaBmFJ`QhAaQ?bQ?cQ?dQrY`FMkI?eQ?fQ?gQ?hQ_HdKOcF?pHvS|Go\zFwV}FeG_K_XmKMqM?iQu\jQ?kQu[uLk@lQ?mQs@cMiXeMmHhM?nQqHgFdT`FiAcGoReGOuBi@oQ?pQpV{@?qQ?rQ?sQ`\yAqUkEwPmE?xKcWzK`@tQ~NjCtZjGbY~ByB~GlF`HgSJdYkA?bHjSnA?dHnFuQ?vQ?wQ?xQ?yQ?zQ?{Q?|Q?}QkC~Q?_Rz\Jb[~FkR`G?`R?aRj@iEaWmEh]yKi]kGeS`C~GbRCcRz@iEtYyGy\}GqHdR?eR?fR}PtEsH|@qVgKi\xG~YuJj\yJyZ|J_]dMjXfMrGhM?gRjElCk@eQ?hR?iR_@jR?kRx]wF}G~G?lR?dOoYpFg\kMrX{B_@mR?nRh^|Bq\bQr\dQt\E_H~CtE`DsObD?oRjHx@cMExHKe\}F{\wFiGpRmOyCJqRu@iC_OkC`OiBpCrRmXE_@sR?tRzHeM`]gRc^iBdAuR?vR?wR?xR~]kEg]nEtUhE~BS?yRlU}BqC{FqXsOc[wF?uOd[wOh\|BlA`O}\{BgBzR?{R?|Rz@wCs^gB}]fKrVEd]vBgZEw]xGrF{GhZnD~TqDjZtDaUvD?}R?~R?_S?`S?aSkAjJdX~LfX`MhXbMu^tRj@wC_IzCrCbS?cSb]E}B_A}DaA`BdSz]eR{]sElHaEwXtMxXhElAeS?fS?gS~H|F`ChSp\gB?iStFjS?kS?lS}^kEuYzGbT}Gs[}EkQ_Fe^~Bj]_HcYIkUbHm]dH?mSCnSqCoS?pSvFqSaBnLtWsCfOEh@mN?rSpYpNbHtN?sSCtSs_@mLsWqCdOsCiAuS`BvSuBwS?xSpCyS?zS~^oDiZrDcHuDyA}R?{S?|S?}S?~Sm\uKbZbBcE{Ek@_T?`Ty]jErFwH_T}GoCpHd_@kJ?aT?bTx_@nLu_@tCeZ{M?cTi_@fRYdT?eT?fT?gT?hT?iT?jT?kT?lT?mT?nT?oT?pTwC}Fr^`K?qT?rT?sTe[kM?hN|YbBcEdBcZgBxClEbWyKp_@_CkFlRf^eOj_@bEuStTiAuTd^kRiBnNv_@qNv`@`C~G_Hq_@Jk]bHdIeHyGaNgYcNiYeNkYhEYvTyW{Bh`@kE`GlDaGwThYdNjYfNh[zOkC`CsEfO`HhOp[dPq[fP?xT?yT?zT?{T?|Tx`@cEl[}T_a@rAv[{Bf@~T?_UxCyGjI~J?sOy^uO?`UCaU`IwBfAbU?cU?dU?eUrWoC?mFJkLmI~G?bRiBfU?gU?hU?iU?jU?kU?lU?mU?nUoItJzOvJ?wTba@eNj@~Ky`@oNqYqN~@oU?pU|_@iA?zBpa@xB]qU?rU]zP?sU?tUdBuU?vU?wU?xU?yUyDzU?{U?|U?}UfU`J{BaFcA~U?_VsCyGo_@~Et[E]sOoa@vOkIhNqA_HnIaHeYnAn]eH|`@`V?hIfBaV?bV`@hJna@zGv^fMa^iM~DcV?dV?eVo`@oT|^gKka@dE?tTa]}Ec\iF]fV?gVtb@`HuHaHub@dH?hV?iV`a@|Bj`@qCz_@tCu`@mEk[pEs@jV?kVl`@|M}XlVbHiO{ZsD{GuDyAkOdHlOeHnO}ZpOfHrOac@wFwGaHqIeHyGhH?mV?nV?oVkc@Ir_@cHmFpVu@mM?qV?rV?sVz@qK}VsK]_KfGtV?uVbXqC?{LcXiBwa@gUxa@iUza@kU|a@mU~a@kC`@vVsCtJzGwTbb@fNj@zA}C{P?wV?xV?yVgBfQ?zV?{Vs`@cBfQEu@|V|c@hEdb@pNxIwV_d@yVdClLt_@qCcc@E_`@pD_UsDhc@vD`_@{Sb`@}Sd`@x@_c@hFd\EcC}V?~V?_W?`W?aW?bWnc@J{`@cHxGfHoFhHmc@cWv\hQzXu@kTx@}CsUib@vP?dW?eW?fW?gW?hWdd@qN~IaHlc@iWo]wQvHjW?kW?lW\mWeFnW?oW?pW{c@uJ_^zJ~c@xV{d@vJ_ZyJ`^}JaJwJaHzJmGgL~CqWzI{Ew[kPmHlPnHrW?sWYtW\uWrCvRx^xRfBiQ?zR?vW?wW?xWsClEsUoEf`@`TkBaL?yW?zWaJwT~d@hLzIdBt`@iB~@{W?|W?}W?~WM_Xle@}Wzb@gMlXnQxd@kAl]cHxGuQyd@xQq]zQs]|Qu]sD{G_C?~QwH`X?aX?bXoZ}NqZ_Oi@cXCdX~@lJzUeX?fX?gX?hXbDiX?jXsc@wFiGlKyVnK{e@jX}d@xJ`Z{J_e@kCw@wC|e@`KxVxLaXoC?zLk`@Ep@kXwAlX}e@yJ?tPk\wP_\yP}CmX?nX?oXtInMsXpM?pX?qX?rX?sXu@eSk_@gS]hS\iSx@lFCnFlI`HyY~Iw@qKoIlEfe@pErI{LgHpHlGdA?tXs@uXgJzJ|d@yV?vX?wX?xX?yXxI{Jpe@hMb^vB~CzXlb@{Umb@}U}c@{An^_DrOaDuE{XcGwVid@iFlB_P?|X?}X_JoWgd@qD__@~BgCwDePyN?~XcU|IdU~IqAbRpCpQie@eB`NgBg[yAqWeFm_@kSyb@vBdA_Y?`Y|HwBjf@fSl_@wBrIrC|CzBec@kVof@rKkJwVhf@oMp@aY\bYhe@cN~`@fNgDwCiJcYdBdY?eYjb@wU?fY?gYYhY}_@xSqe@bHdIhVbc@rA?vMxf@|Unb@_Js@tBbA~Kh@iY?jY?kYClYzHmY?nY{XyMrd@v@{Dx@jg@xVfIuNxY|I~f@_Jrg@cHnd@gHfY`Vxb@tEx@bPhW`L|g@w@zg@nY~C}MfZ`NMoY?pY{f@rD``@vDkZyN|f@jGgF{Inf@_J{_@}BsIxKmJ`Do^{X~@}LeX_MgXaMs@qYl^cQs\qNx@_IC`IrJx@vg@yAg_@`AkMEnJ}Tye@mJ?eXze@gXk@rYlh@y@gDzAyIgQlHsYpb@_Vx@uMz@zAfBrM_h@nAvb@uQdJyQr]{Qt]}QkCtY?uY?vY?`Xue@bXve@~Nyf@`FkJ{JjJtXug@}UcCnBwg@|Aeh@aDuEoRjHhIz@~Km@tVtc@oCaf@qChi@uVvIrCm@wY{g@zMcAxEcQzEmg@dNca@hEci@_Ju@`Oi[}BfIsSOvN{YiBt@xY?yY?zY?{Y?|Y?}Y?~YxH_LsJlV_b@lDaa@cNng@hEag@fBw\eKbh@sD|I}Ra_@_Sb_@aSmIlGuRnGvRpGwRrGxRuGgJtPef@xPhb@ErJhIoi@`Jxh@sMcd@cNfDgRei@bDp^~OuG_Z?`ZqAlRnIK?aZ?bZ?cZ?dZ?eZ?fZdi@yAfDiMaj@vBYgZlByWge@Eld@aWai@|JkBtMx\zGcg@`Yeg@xBeIpSlD{Xdf@uPdBdW?hZ?iZ?jZvJzJrb@_FqAkZClZ_JmZ?nZzi@gBpGuLlDoRfi@tEmi@yEdQkC`i@Euj@zE_@oZCpZvj@kCjI~Fv]aG?qZ~@rZm@lK`XyLvI{Lyh@dHnFfHoFaN}`@dNuJlCed@xVx@sZCtZgi@|AiHiK?uZ?vZ?wZ?xZ?yZjJeAdW|Kgg@sCkf@mLua@gBbk@tCMzZ?{Zm@qTq`@|Z\}Zqg@iAgb@{B|i@uPdBwPm`@sEs@~Z?_[oj@`F{C`[dg@jChAlH?a[u@b[?c[?d[~i@tEhAe[?f[m^qNob@bFiH}Oq^y@qCg[?h[?i[uh@Eke@|Wme@~W{i@tDaIwDoJ~X}f@}IzY`Jsd@tUgk@j[?k[f@l[cf@`LlDcDtOeDuOgDwOm[?n[wJmKMo[?p[ae@fMrGlPnHnPy[pPz[q[?r[?s[?t[?u[?v[?w[?x[pI{Ghg@{BMy[cFz[?{[?|[eH}[?~[C_\oh@eXph@hXig@sKwd@`FmDeHwb@hIsi@yYvOhDxOjDk@fJqA`\Ca\ee@mEdc@hEbf@rAla@|B]b\?c\?d\Je\lBf\?g\?h\ih@dQ|CwSlA|Vda@sDeJ`Cea@gOvZsMmh@aAyj@_GlRaGnReFiBrSz`@`Fsk@}Whk@tEek@rT?|Z{CePr[xT?i\?j\tJdObl@fX?k\?l\nk@f[ok@`Fi@dJ?m\Cn\k@vKdk@Ekg@pMiD~Kuk@~BgC}Ra`@|Sc`@~StIqVpc@sVsj@{Bkl@g\jk@E|Go\?p\fc@|AiBq\?r\?s\}g@yV~JsTkIlM_j@wK_l@|Gx@t\?u\?v\?w\{j@yV`Kx\?y\?z\?{\lJ|\dh@yKkBtTem@}Gt@gNz^}B}JxKaK{Jil@c\jl@gB?e\t@}\C~\rHsI?_]?`]?a]e`@cBcl@Efd@mLy_@rChm@y\im@{\vf@|Jxk@vPtd@eWud@gWiDiLah@pYta@mFxl@gXwf@kCkk@`Y|HlCwJxL`f@zLtl@`GmRbGoDuQzh@zQse@}Q}h@uY?b]c_@zKog@xCa\zChj@nHqSEwh@{A}k@p[j@qKbj@`Znj@{J_Kc]pIwHnYoCEkNfDnQ{Cd]?e]Ef]cm@wOlAb[mk@d[}JnElBbLlWdLnWfLrc@rKpi@kCh@g]?q\?h]?i]{Jj]fBk]?l]{^vWde@xWin@vB|CjAqIhV?m]Cn]cJo]~m@_[mJzHuTtFaAoIvTqIxTtFaAsIzTuIm@p]cn@mFJq]cb@|Aqb@zGuJwBaKwV?r]?s]oDfHod@t]?u]lm@yK|l@uDyAv]al@oCE_\t@w]yIjQpJlC{m@oHlJwXtf@yXmDhVsg@uLuAwCpJwBiKwHqm@nLvh@rAtg@wMsInEz@iLgD~Kzf@pWsHqQe]sQnJ`Pm[EgBhRzk@dD?x]?y]?z]lIdOmf@|I~g@`Jpn@xB~e@wBiK{GoCdF~l@rVqc@eFi`@zGjK{]?|]dKwP?j[lg@mLEbYwn@E]jMcJwRqj@zMmm@|Jji@oCii@rCli@kMr`@iNqD}]?~]?_^`m@h\_g@oCEcRlk@c[?`^~I_LOa^?b^?c^qf@zGma@_Upl@tD}GaCuFfO`Hd^?e^?f^?g^?h^?i^?j^?k^?l^?m^?n^?o^?p^{JmH{n@oEzJzBuAzAml@qNoDiWdJjWzd@q^j^hNwC~PjKgHlSmV?r^bo@|G}m@rKun@vD?v]vn@mFJ_\hn@lCgl@lXvm@yLki@sCxCtJ`b@wTzo@{BoGoKkj@}JeIs^?t^ak@}K`n@mFJkNzj@iBj@iLMu^gc@jOch@kOic@mO|ZoC?oO~ZqO_[sCkAv^?w^?x^n`@y^?z^]{^}o@kMk^}BtJ`HuHKcj@bZej@dZgj@|^?}^yo@pEho@xRap@oCko@sCyn@xBzc@pFrh@Ejo@zLjp@}BzA~^\__@sKiBeKlCoCfEqPhE`g@pFtm@hX|k@nKlo@hNsDhHpd@zVpf@mEco@eFqDeD?`_@?a_@i@b_@?c_@vc@hUya@jU{a@lU}a@nUao@E~@aTmDpVeKwBwKt]`IlCaRoCErFkKuLqKwDoJzNnZ|NpZ~Ndp@t^up@iNsh@{AsDd_@?e_@gp@sD|IkOdHzIvk@~If@f_@Cg_@zl@eJtn@zKMh_@?i_@_Kp\bi@eFcKdBjn@{HiTnI_CoIkn@rIyTtI{TvI`e@Eeo@{G`c@gVqDx]?j_@oe@~Wo[kC~o@}GhKwBfk@vPl\yPwKmV?k_@mq@xB`l@bTMcK}p@rAOl_@tj@~O|n@|Aqn@r]xKfDti@m_@ui@}YqK}R}l@}Shd@y@{l@|AhKlCio@}JsDaN?`V}HTtLV?n_@?o_@?p_@dKuUpg@xU~p@u]sb@q_@nn@gB?r_@|p@bTgHfEwl@fPfa@yTha@{Tne@|Wop@hEhh@zJ~b@EpKs_@aBt_@fH|L_f@xCoq@uL{b@dV|b@nTp`@pTpj@xRrf@pHvY}Gpk@h[qk@cJ|m@|Acp@pKbKdFfm@u\?u_@dL{Jsl@Ei^nRfh@~Le_@aMkBeE_@v_@wi@`LxFnCxApCzn@xHlGw_@Cx_@cK{E`@y_@rp@qCuc@|Lqq@s]om@_]pm@a]lAmMoc@rVen@kMeLiBbDfQwm@vQp]xQre@{Q|h@sDeJtY~h@vYqi@oCEtSeLEbDhRlf@oCEnF}HyRyp@iUwc@lU{p@kCeq@|H?nIfq@pIwTrIgq@uIkKvMrj@iBiq@j_@ir@}GpKb^qo@ExJuZ|j@wZ~j@yZ?z_@aB{_@J|_@h@}_@?~_@\_`@h_@rAhl@}BzJwSyr@vZ}j@xZ_k@}Kpr@wQvHyQ{h@|Qte@tDvG~QwHrHvl@~Wnq@wPfA``@?a`@?b`@}n@rQuDdFvr@nIwr@qIln@J?sImn@vI|o@`Ft^jCoo@mFJcRbL`Vjj@zW`j@dNpq@hIjm@zKkp@hN`LzY?m_@rq@~Y?c`@?d`@?e`@n_@lSzAf`@~Eg`@?h`@tr@jUzp@mUyc@wBuA~K_o@eOwj@oCEpZpp@zLdl@gD{k@n[n\vBzr@mL?{_@fp@}Bck@mFJiS~\mQqa@cUra@eUas@hIes@d`@fs@kSxe@oCEdX_m@|Bw@~Kel@oCEa\xr@wM~q@eV}b@pTiJqXif@sXk@i`@?j`@_n@xHxi@kCdq@kVhLvMso@~BfT}CuZgOrl@wK~Hk`@yq@l`@kAm`@ri@n`@vJtP}i@yPuAiL`@o`@ms@wB_s@Em@pR_IqRps@tE~k@gMx[mP?rWhs@kUxc@nUth@{B`p@`L`k@{KeW}Kqs@nTxg@jYyg@oCElYcr@v\nm@oCE~\ts@_CwFp`@\q`@~n@iRsKExn@xXfb@pUhq@|Gor@hNys@xBgn@cLmWeL~_@zSws@Eff@nXj@r`@?s`@i@t`@?u`@aq@e_@ol@cNOv`@?w`@kAx`@gs@rAhr@oCcOqCxJjKbs@eNmp@wFwGKnp@cZfj@eZ?|^bt@Ers@j`@oKd[`t@`Cql@hOrm@eFdr@|Jbp@|Bnl@xSqh@}BMy`@yi@vJab@cNfo@j[jd@~Vw@zAxj@wBt@qH_q@xDlZzN`q@}Nuq@UuLn_@wq@p_@ss@|Axo@nHsq@~R?z`@?{`@?|`@cC}`@kd@_Wet@u`@gt@dNiDzArt@Vvq@o_@xq@sCnh@iBdLwVfn@c[po@iBym@yCJzCyl@cQjh@`Fkh@oCE`Iwt@`^lr@rCum@jC`Kr\wC~`@C_a@f\eFfg@gSut@eNxt@dQ|s@lUur@wBuDpHit@I_EaZdj@cZjt@|^mj@cJzt@kCan@pFbq@tDaIkOhp@nOjc@qOip@tCm@`a@?aa@f_@ba@qQtE`h@rA`s@gB?cR_u@cRhLuL}FzByk@rA?lXsp@mLE__@vs@e]El`@kq@wBht@w`@oK`^`u@lXc]dGbg@lSOoFot@`Tvp@nE}q@}WbLca@~KcW`d@{V~s@oTmt@aCto@gO|t@mUis@xB`Bda@\ea@os@dUiAfa@?ga@au@oHds@iN{t@qNni@eNjr@oCEx_@}s@|Kkr@nH|q@xTga@zTia@|Tmo@ha@?ia@?ja@?ka@?la@pt@yNmZ{N_i@_OuDfElj@pH{q@gEst@oHn[wEgr@kMuArLgo@mFJbY_t@w\}t@aa@ks@qCmr@iBul@oNeb@`FsJ~M_Y`Nyt@iBgu@lM|SuH}SzG?wHar@i[_p@sKgBiXcq@i_@ij@rAbu@gQlt@E~J|Zer@hNdu@oH{s@lPbe@sWbn@e]rCma@br@eF{o@{Avo@g^wo@i^?na@?oa@?pa@at@yXcu@}Knt@}J|r@xQqr@|Q}r@~BlEtYrr@rHxK`_@xs@eF~Kr^`r@zGiu@xHhu@pNbKpHeu@zNqt@~N`LgDls@gJOqa@fr@_Mgh@bM`o@}I~t@uLf@ra@Csa@ns@gBfu@gEjs@|A?ta@
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????B??C??PY?CF?D??E??`??w@?D??E??`@?_B?F??G??@D?[A?H??A??A?????I??C??pA?Cs?J??C??P@?kf?K??L??@V??F@M??C??PM?sm@N??O??@R?w^?P??Q??PY?wF@R??S??@A????T??U??P??ST?T??V??@X?_X?W??X??`??OV?W??V??@C?oV?W??Y??PO?k\?W??Z??pX?[T?[??\??PL?sD?]??^??`B?GE?_??`??pE?k`?_??a??pR?{b?b??c??`J?{O?b??d??`@?cP?e??f??@A?kR?g??h??Pf?WE?i??j??`E????k??l??PD????m??n??`C????o??p??@v?WU?o??q??`Z@{`?o??r??@J?gf?s??t??@T?cBDu??v??p@?oD?w??v??pG?_\?w??x??PW??_?y??z??`f?_f?y??{??pA?OT?y??A??A?????|??C??pH?_O?}??~??@@?k`??@?C??@B????@@?A@?p??oB?@@?B@?p??CD?D??C@?PG?GC?D@?C@?`@????E@?B@?`@?[E?F@?G@?`C?S@?F@?H@?pN?KC?F@?I@?p@?sC?J@?K@?P@?k??L@?M@?@A?cB?N@?G??p??_D?O@?G??p??[E?O@?G??pD?cF?P@?Q@?@C?kU?R@?G??`@??C?F@?G@?@t?wA?F??S@?@W?GN?F??T@?`??cO?U@?V@?PM?CJ?W@?A??A?????J@?K@?pC?k??O@?I@?pF?cN?N@?X@?@Y?{I?Y@?C??pnACu?Z@?[@?@C?WO?Z@?[@?@E?SP?\@?]@?`E?[Y?^@?_@?@??w|?`@?A??A?????W??Y??pQ?o\?N??B@?p??OQAN??a@?`L?Wz?N??b@?`M?Wy?c@?S??@C????W??d@?@@?o\?W??e@?@j?OX?f@?S??@B????W??g@?P??_\?h@?i@?Pz?SO?N??j@?p??SOAN??k@?`[?KI@l@?S??@A????h@?m@?PN?KP?n@?o@?`q?WR?n@?p@?`E?WE?q@?r@?p@?gC?s@?t@?@B?OL?s@?u@?`C?wM?v@?G??P??sG?w@?A??A?????x@?C??pS?WC?y@?z@?@U?wL?F??{@?PJ?sC?F??|@?Pf?cJ?F??}@?`L?sL?~@??A?@A?SG?~@??A?`C?gG?~@?@A?`E??K?AA?j??@D????BA?CA?@A????DA?EA?@B?__?FA?EA?@?????GA?A??A?????F@?G@?pe?KA?F@?HA?PS?[D?IA?JA?PC?WB?KA?r@?pI?kL?LA?G??pI?KB?IA?JA?PE?SB?MA?NA?`@?SG?OA?NA?@@?[d?OA?NA?pA?{d?OA?NA?PG?Cf?PA?G??pY?GF?n@?o@?`r?[R?QA?RA?@C?S[?SA?TA?@C?Co?UA?VA?PI?wmB[??\??@U?GE?N??a@?PB?Cz?WA?XA?P??WA?WA?XA?@??SD?WA?A??A?????YA?C??`B?WM?ZA?C??P??SH?[A?C??`G?sK?\A?C??@@????]A?^A?`p?cM?_A?`A?pH?oh?aA?bA?PD?Oe?_A?B@?p@?se?_A?B@?@W?Gj?cA?dA?@d?wF?cA?eA?@s?GS?cA?fA?`R?kO?GA?gA?`@?_fAGA?gA?PI?_hASA?TA?p@?Co?IA?JA?P@?WB?IA?hA?`??KC?i??iA?P@????jA?h??PD????m??n??pA????kA?lA?PN?SY?kA?mA?pC?w]?FA?nA?pK?{T@cA?dA?@f?{F?cA?oA?pK?wS?s@?u@?PH??N?i??iA?PA????pA?CA?P?????qA?A??A?????ZA?C??P@?[H?rA?sA?`g?kT?]A?^A?@L?WL?]A?tA?@R?kW?uA?vA?`A?So?wA?vA?PR?ga?xA?C??@@????yA?zA?pS?s_?{A?|A?`[?sW?Z@?}A?@A?kH?Z@?}A?pH?cI?Z@?~A?PK?CL??B?@B?`E?cO@?B?AB?PH?CF?BB?AB?`A??b?CB?A??A?????Y@?C??puCWy?DB?EB?`J?[]@FB?bA?@A????Y@?GB?p??Wy?Y@?HB?@D?K|?IB?B@?P@?sN?JB?KB?`C?sz?LB?MB?@@?Wo?NB?OB?`@??O?NB?OB?`T?{Q?PB?C??`G?SJ?QB?C??@@????LB??A?ptBct?RB?SB?P@?s`?RB?SB?PC?[c?TB?UB?@??gP?VB?A??A?????WB?S??@C????[??XB?@@?GE?[??YB?pz?CH?N??ZB?p??_FAN??[B?PE?Wh?N??\B?PR?oi?]B?S??@A????[??^B?P??GH?W??_B?@C?sR?PA?`B?PH?SQ?q@?aB?P@?oB?DB?G??`A?oH?bB?A??A?????s@?u@?`I??N?cB?EB?`Q?sW@qA?bA?@E????s@?dB?p]?GO?eB?fB?P??oA@gB?hB?`F?oI?DB?iB?@A?CV?UA?fB?`@?cXBN@?X@?`Y??J?P@?jB?@@?SZ?P@?jB?@??_X?R@?A??A?????h@?i@?@L?[M?yA?G??``?GE?_A?kB?`@?{g?F??|@?pr??K?lB?mB?pH?gN?lB?nB?@L?CT?~@?@A?P??sJ?n@?o@?`v?cR?GA?oB?PD?gn@GA?pB?@H?{r?GA?qB?p@?Oz?UA?fB?P??C\BF??}@?pM?wL?lB?A??A?????n@?o@?@V?OQ?q@?aB?@??oB?DB?A??A?????J@?K@?`B?k??rB?sB?@A?WB?GA?pB?`A?cr?GA?tB?@E?CN@OA?NA?@e?wg?T??X??`C?SQ?T??uB?pA?ST?m??CA?P?????vB?A??A?????n@?o@?@G?oP?QA?A??A?????T??V??`[?cX?wB?A??A?????_A?B@?@i?[j?N??sA?p@?KEAxB?Q??PU?Gg?yB?zB?pE?ob?{B?|B?`E?sH?}B?C??`??G]?xB?Q??Pc?sg?N??~B?@O?We?vB?S??@A????T???C?PL?CU?W??@C?@H?cJ?h@?@C?PE?SV?AC?S??P?????BC?CC?@??ki?DC?EC?p@?sA@FC?G??@C?kS?T??X??PA?OQ?GC?G??P@?kJ?HC?A??A?????IC?C??@@????JC?KC?`@?oW?LC?KC?Pb?{^?MC?NC?PV?[m?NB?OB?`@?GP?NB?OB?`V?CR?OC?C??`@A[l??B?SB?P@?gB??B?SB?P@?[G?JC?SB?`T?sR?JC?PC?@Y?wT??B?QC?@@?{K@RC?iB?pD??g?SC?TC?`??wC?SC?mA?@?????UC?A??A?????D??C@?pB?wB?lB?VC?@C?SF?w@?EB?@F?GO@s@?dB?`^?GO?w@?WC?@@?W`?w@?WC?@u?or?w@?XC?@??sn?YC?A??A?????OC?C??@~?wj?h@?ZC?Px?Wd?N??[C?`E?CfA\C?Q??@L?{w?]C?S??@C????W??^C?@@?c\?_C?S??@A????W??`C?PK?{Z?h@?aC?PL??S?n@?bC?`L?[S?cC?AB?@F?oE?dC?AB?pV?{B?DB?UB?@??Kz?eC?A??A?????cA?dA?@Z?cF?cA?fC?pP?oJ?QA?G??p??gE?gC?G??@B?_D?q@?aB?pD?wB?h@?m@?Pe?cP?h@?hC?P??w_?iC?A??A?????T??V??pN?_W?OA?jC?pC?GK@v@?kC?@A?{N?w@?WC?`B?Cp?w@?lC?@A?co?Y@?C??@u@Ks?wA?vA?PU?ka?mC?nC?`??WW?mC?sA?pK?KT?FC?nC?@B?oV?FC?oC?@A?{U?T??uB?@D?WT?pC?A??A?????FC?oC?p??wU?qC?rC?p??wi?IA?hA?p@?KC?IA?sC?`A?[C?tC?uC?P@?_w?tC?G??PA?{e?vC?A??A?????P@?Q@?PA?kU?[??YB?`x??H?[??wC?`@?CI?h@?G??@t?gK?]A?G??`@?kB?xC?A??A?????FC?nC?@D?oV?yC?Q??@L?cs?N??zC?PM?{t?{C?bA?PA????|C?}C?pB?GG@xB?Q??`Y?Wg?~C?S??PB????T???D?P??KU?@D?A??A?????LB??A?`QC?x?LB?AD?PB@[y?CB?BD?@M?gg?RB?vA?p^?{a?{B?|B?PC?kH?K??|B?PN?sS@CD?DD?pC?ku?ED?FD?@^@sX?ED?GD?@@?_S?HD?A??A?????wB?S??@B????T??ID?pE?oZ?WA?JD?@??GB?yA?G??PQ?sD?_A?A??A?????]A?G??pR?oJ?KD?A??A?????cA?eA?@M?sQ?OA?NA?pb?[g?T??G??pP?WI?OA?LD?@@?gJ@MD?ND?pJ?sA?OD?TC?`F??]?OD?PD?`C?c]?QD?RD?`@?Ci?QD?SD?pK?sj?QD?TD?PK?Sl?n@?p@?PT??F?UD?EB?P@?C`@s@?dB?@L?WN?VD?EB?`F?kC?WD?bA?@C????s@?XD?`B?_N?YD?ZD?@B????n@?[D?`??CF?s@?\D?P@?GD?]D?^D?p@?[m?_D?^D?P@?SC?`D?A??A?????h@?@C?@I?_V?yA?aD?@r?WY?bD?C??@D????yA?cD?@C?_Y?xA?A??A?????h@?G??pO?[D?]A?tA?PM?_W?dD?A??A?????U@?V@?`N?CJ?W@?G??`@?GA?h@?G??@l?[K?{A?eD?pG?wN?Z@?eD?pD?{G?fD?A??A?????yA?cD?PQ?SZ?gD?hD?@I?gF?wA?A??A?????[??wC?@??CI?h@?A??A?????s@?u@?PO?[O?iD?jD?pA?[[@UD?A??A?????T??G??`m?SJ?W??A??A?????]A?G??PM?{I?kD?A??A?????gB?hB?pG?oI?eB?t@?`G?K@@RC?A??A?????^@?_@?P@?w|?`@?G??`A?S}?lD?A??A?????s@?u@?@??sM?P??Q??pb?GG@mD?A??A?????PA?`B?`G?SQ?]??nD?P??GL?]??oD?@@?cN?pD?G??`??wD?pD?G??PA?cD?qD?A??A?????L@?M@?@??cB?N@?A??A?????s@?u@?`D?{M?[??YB?`y??H?]B?A??A?????IA?sC?P@?[C?i??iA?`@????k??rD?`B????Y@?C??pl?[p?T??V??`S?CX?T??sD?pH?kM?s@?u@?pA?wM?v@?A??A?????[??\??@X?KE?N??k@?PB?GH@]A?G??@P??J?tD?A??A?????gD?hD?`K?gF?wA?G??PG?S`?uD?h??PD????kA?lA?`U?gY?kA?TA?`@?KW?MD?ND?@I?sA?vD?wD?pE?wLAxD?yD?P@?kS?zD?yD?P??CF?OD?{D?PC?WH?OD?A??A?????PA?G??p}?cG?PA?|D?@@?wQ?}D?~D?`x?cL??E?@E?P@?wR??E?AE?PF?_o?BE?C??P??gL?BE?C??`L?gM?yA?aD?`y?O^?N??CE?p??SPAN??DE?PB?Gv?cA?fA?p_??P?cB?EE?PM?wI@cB?FE?P`?wj?GE?A??A?????h@?G??PK?GD?HE?G??pH?Sf?IE?G??P@?WA?PA?`B?pD?OQ?T??uB?@C?WT?N??k@?@F?SH@P??A??A?????F??}@?@T?wL?lB?G??@O?[D?JE?A??A?????tC?G??pC?{e?vC?dA?@Z?[EBvC?KE?PK?KHBvC?LE?@_?sKBvC?ME?pz?wPBvC?NE?`p??[BcC?AB?PB?gE?cC?{D?pP?KE?DB?kC?@D?K\?DB?kC?p@?W[?DB?OE?p@?ON?DB?OE?@L?{M?h@?m@?PD?_O?N??DE?@F?Sv?yC?A??A?????W??Y??PK??\?_C?A??A?????cA?eA?@p?CS?n@?p@?pV?[F?n@?PE?@[?OK?QA?QE?`??KJ?gC?QE?PD?Wc?gC?RE?@G?OM?Y@?C??PBASs?SE?B@?@@?WB?TE?C??@@????JC?UE?@b?OW?n@?o@?@i??R?VE?RA?`D?w]?F??|@?@o?oJ?RB?SB?pJ?_c?]A?WE?@M?k[?XE?DD?`??K|?XE?YE?`??Cu?XE?ZE?@@?kT?XE?[E?@??GR?\E?A??A?????cA?fA?@I?KO?IA?sC?PB?[C?]E?^E?@??CR?KA?A??A?????N??[C?PC?CfAM??A??A?????]A?tA?@P?_W?dD?G??P??wG?_E?G??PA?OA?`E?C??@@????LB?aE?pR?gj?LB??A?PW?Wp?bE?vA?`??S_?CB?NC?@B?ke?LB?NC?`S?cl?cE?h??PG????dE?h??pD????m??n??PB????kA?eE?p@?k\?yA?aD?Pv?w]?|C?fE?PU?oF@gE?C??@B????|C?hE?@B?wF@N??CE?`???H?n@?p@?PN?gE?yA?G??`b?KE?]A?AB?`X?OZ?n@?o@?pi??R?h@?i@?@u??O?{A?eD?pJ?{N?{A?iE?@B?kJ?]??nD?pC?WL?jE?kE?`??cT?jE?pB?PA?OQ?T??uB?p@?ST?F??|@?@A@sK?F??lE?PD??H?@@?C@?`Q?oB?mE?nE?P@?[@?oE?nE?PD?kF?pE?DD?`F?cX?qE?A??A?????h@?G??pg?WK?PA?rE?PQ?[W?sE?C??@A????PA?tE?`@?WW?uE?G??pB?SM?vE?wE?P??[M@vE?xE?`??cP@vE?xE?@e@CU@vE?yE?@t?{]@zE?A??A?????s@?\D?`A?GD?{E?|E?P@?[g?}E?~E?@U?gM??F?@F?P@?WH?AF?\??@?????BF?A??A?????yA?aD?p_?gX?s@?CF?P@?CE?W??Z??pa?kT?cA?eA?pn??S?W??@C?PJ?gJ?W??Y??`P?k\?c@?A??A?????cA?dA?@`?oF?cA?DF?@Y?gN?QA?QE?`??WN?gC?QE?p@?Gq?]A?G??`H?gI?NB?EF?@B?_X?NB?G??P@?gL?FF?A??A?????HE?G??`L?[f?NB?G??PI?sM?YA?A??A?????]A?G??PE?[I?XE?G??`@?Oo?BE?C??`K?gM?yA?G??P[??E?cA?G??P@?KB?F??T@?pA?gO?y@?GF?P??WH?HF?A??A?????cA?eA?PQ?{Q?h@?aC?`f?gS?N??IF?p??WGAN??JF?PE?{l?N??KF?PQ?Sn?LF?bA?@A????h@?MF?P??gS?h@?NF?PF??a?OF?NC?`J?cG?PF?NC?pJ?gG?QF?C??Pv?kF?RF?nC?pc?O\?DC?EC?@??oA@FC?A??A?????h@?ZC?pv?Wd?SF?A??A?????rB?sB?pA?WB?O@?TF?P@?WH?O@?TF?@@?kH?BE?C??@Q?gM?NB?EF?@@?_X?[A?A??A?????OA?NA?@E?Cf?PA?A??A?????h@?ZC?pK@wd?OA?NA?pq?_h?N??UF?`@?{PA{A?|A?@V?kW?yA?cD?pa?o[?VF?A??A?????cA?G??PA?KB?OA?NA?p_?[g?T??A??A?????F@?G@?P_?CA?E@?WF?@H?_F?E@?XF?@A?_C?U@?G??PF?_D?]??^??Pp?oF?NB?EF?PA?_X?[A?G??P@?{J?YF?A??A?????LB??A?`gACs??B?ZF?pe?OJ@[F?QE?PK?GB@?B?\F?PJ?OK@eB?t@?@??oq?E@?WF?@@?SF?]F?^F?@B?w@?W??g@?PC?g\?cA?fA?PS?kO?GA?nB?pA?o[BSA?nB?@P?Sd?yA?aD?@u?w]?_F?A??A?????F@?H@?PE?GC?`F?UB?@??[|?aF?A??A?????W??`C?PL?{Z?bF?A??A?????cF?S??@B????T??dF?PK?WY?F@?I@?`??sC?n@?PE?p^?SK?JC?UE?p`?OW?IC?A??A?????T??X??@??OQ?W??g@?pA?c\?N??a@?@F?Oz?\C?A??A?????cA?G??@C?[B?cB?A??A??????B?ZF?Pl?gJ@[F?eF?PD?w@@fF?\??@?????qC?eF?p??CQ?]A?G??PD?[I?XE?A??A?????MD?ND?@??cA?^@?A??A?????vC?dA?PT?OEBT??V??PK?[W?gF?t@?P@?cA?gF?G??PC?sA?hF?G??@E?KB?iF?jF?`??Op?kF?lF?PC??D@iF?jF?p??{K?iF?jF?PW?_t?iF?mF?p??{u?iF?jF?pK?Cy?iF?nF?pE?oS?iF?uC?pH?{X?iF?A??A?????yA?cD?pe??]?{A?oF?P@?SE?pF?kC?PF?gD?PA?`B?`A?KQ?T??X??PF?WQ?T??V??`Z?cX?s@?XD?@E?cN?oE?nE?pB?gF?oE?qF?`@?GE?|??G??p@?_H?rF?sF?@B?KY?}??A??A?????jE?kE?`@?gT?h@?i@?pH?[M?yA?A??A?????|C?hE?p@?wF@{C?A??A?????IA?JA?@F?_B?N??\??pA?_@AN??tF?`F?st@uF?A??A?????n@?PE?`W?GK?vF?ZD?`A????wF?xF?`B?cC?yF?ZD?@A????qC?zF?@@?oO?{F?ZD?P@????|F?}F?`???D?~F?ZD?@@????qC??G?@D??K?MD?ND?PH?sA?@G?A??A?????yA?aD?@i?CY?AG?A??A?????s@?CF?@D?CE?BG?|E?P@?[`??F?@F?`B?WH?}E?CG?PA?K^?}E?DG?pD?Ka?EG?FG?@??OM?GG?A??A?????K??L??`E?GE@K??HG?@`?SA@CD?IG?pA?[w?ED?FD?PT?KV?F??|@?Px?GK?F??JG?pL?_G?cC?{D?PD?oD?HE?G??pD?Of?MC?A??A?????Z@?[@?PB?WO?iF?KG?@??KP?LG?MG?@S?{_?yA?aD?`Y?WX?mC?A??A?????W??`C?@O?C[?W??NG?`B?G]?PA?G??Pl?wF?q@?G??P@?cA?vC?LE?Pf??LBdC?AB?PX?{B?PF?G??`B?{C?QF?A??A?????W??`C?`M??[?cB?EE?`q?OK@OG?S??@@????cA?PG?@??CP?yA?cD?PD?_Y?gD?G??@G?GC?cA?eA?PN?wQ?]D?^D?P??[m?eB?QG?p@?go?RG?A??A?????NB?G??PF?oM?rA?A??A?????cA?fA?Pb?CP?LA?G??`L?OB?SG?TG?`A??G?SG?A??A?????x@?C??@M?KC?UG?~D?@D?_G?VG?A??A?????PF?G??`D?{C??F?@F?@D?WH?WG?\??P??SM?WG?\??PC?{M?XG?t@?@??KF?XG?A??A?????h@?aC?Pd?cS?YG?bA?@A????h@?ZG?`??cS?h@?[G?PA?_Q?\G?A??A?????F@?HA?@T?[D?]G?^G?@??k@?U@?A??A?????vC?KE?@Z?oHBuE?G??@F?cM?_G?A??A?????T??V??PY?_X?cF?A??A?????[A?G??PA?{J?YF?G??P@?WQ?`G?A??A?????]??nD?`@?KL?pD?aG?@@?wG?MD?ND?`M?wA?^@?kC?`??WT?^@?ZE?P@?GH?bG?A??A?????h@?G??Pb?GK?h@?hC?`A?w_?h@?hC?@G?K`?XE?kC?`??{|?yA?G??pR?sD?cG?A??A?????OD?PD?PO?K^?dG?TC?P@?sA?eG?TC?@?????fG?A??A?????NB?EF?@??_X?NB?A??A?????W??Y??PS?s\?N??k@?`e?[I@s@?CF?pB?CE?{E?gG?P@??M?EG?A??A?????Y@?C??@iCwx?{E?EB?p??Od?hG?iG?P@?_C?jG?A??A?????\@?]@?`B?CY?PA?G??ps?CG?Y@?C??`eCwx?kG?lG?pB?g@@{E?mG?P@?WI?nG?A??A?????vC?KE?ph?GIB{A?|A?@N?[W?jE?kE?pB?gT?GA?G??`L?OX?]A?WE?@P??\?F@?G@?p??O@?lB?oG?`N?GG?W??Y??PM?[\?f@?A??A?????{E?EB?`@?Od?jG?@F?p??sI?pG?@F?p??WH?nG?FG?@??gI?qG?A??A?????T??V??p\?[Z?n@?p@?`M?kE?{A?rG?PI?oT?qC?sG?P??GJ?tG?A??A?????}D?~D?@u?cL?BE?A??A?????h@?G??@J?GD?HE?A??A?????PA?G??Po??G?]A?G??pV?wJ?N??\B?P??{h?QF?C??pg?WF?RF?SB?P@?kW?RF?SB?`h?sY?yA?cD?@c?o[?h@?m@?`F??P?h@?@B?@K?_L??B?@B?pF?gO@HE?AB?`V?Cg??B?vA?P@?GG?JC?vA?@P?kQ?LC?A??A?????tC?uC?@??_w?tC?A??A?????bF?S??@A????W??uG?P@??[?h@?vG?PF?WT?yA?wG?py?oL?N??xG?`@?GGAN??[B?`F?[h?T??V??P^?S[?BF?\??P??{J?BF?\??pA?GK?SG?t@?@??CF?h@?ZC?@N@?e?yG?A??A?????]G?^G?`D?k@?U@?G??pA?WD?OA?NA?@f?wg?zG?A??A?????FC?G??P@?gS?MD?ND?@J?sA?T??uB?`??ST?R??A??A?????Z@?eD?`M?CH?Z@?{G?PH?sL?\@?|G?pC??X?}G?~G?`??[R?^@?~G?P@?_u?h@?G??pm?cK?n@?A??A?????pF?kC?@E?gD??H?A??A?????PA?G??Pk?wF?q@?A??A?????@@?C@?PG?SB?cA?fC?pO?oJ?cA?fA?p]??P?GA?@H?PB?{RBSA?@H?PX?S[?cA?dA?@X?_F?cA?AH?pG?kI?BH?S??@A????W??CH?`@?G]?W??DH?`U??c?EH?\??@?????WG?A??A?????h@?i@?`|?OQ?BB?AB?@D??b?CB?G??`A?Od?h@?G??pq?gK?]A?A??A?????vE?yE?@R?c[@FH?|G?@A?SO?GH?|G?pC?_o@GH?HH?`a?oo?b??IH?p??{W?y??{??`X?SU?JH?kC?@B?KV@KH?A??A?????h@?G??PZ??K?]A?^A?@N@KO?]A?LH?@P?wS?RB?KC?`P?ob?LB?NC?pL?Gl?LB?MH?pJ?gm?NH?A??A?????h@?ZC?PJ@wd?OH?A??A?????yA?aD?pp?WY?PH?iA?@B????QH?CA?P?????bD?A??A?????]??nD?PB?SL?jE?RH?PA?GY?jE?A??A?????oE?qF?@??GE?|??A??A?????SH?TC?@?????TH?A??A?????Y@?C??pgCwx?UH?A??A?????]E?^E?P@?CR?KA?G??PE?cB?n@?PE?PA?wJ?VH?UB?@??_i@WH?A??A?????T??uB?PE?[U?N??XH?p??kSAN??YH?@F?gA@ZH?A??A?????VH?UB?P@?_i@WH?G??PC?ci@[H?UB?@??oR@\H?A??A?????kG?lG?@@?c@@h@?m@?@C?_O?]H?A??A?????^H?S??@A????yA?_H?PT?kK?`H?A??A?????RF?SB?pg?sY?KA?G??PD?cB?@@?C@?PP?oB?i??iA?p@?????@?A??A?????n@?p@?pX?oF?aH?UB?@??{P@bH?A??A?????cA?fC?@N?kJ?HE?G??`J?Wf?OC?A??A?????W??NG?PA?G]?BH?A??A?????E@?XF?@??_C?yA?cD?@P?SZ?cH?A??A?????dH?QG?@??kU?eH?A??A?????dC?AB?PT?{B?PF?A??A?????LB??A?PvBCu?h@?m@?@??WO?Z@?}A?`k?wJ?\@?kC?`W?_W?fH?A??A?????n@?bC?@I?WS?RF?A??A?????Z@?}A?p`?cJ?Z@?gH?P??ON?hH?iH?@??sV?SA?@H?pj??\?n@?o@?PU?OQ?n@?jH?`R??N?kH?RA?@B?_[?_E?G??P@?OA?IE?A??A?????Y@?C??@`Bcv?lH?~D?pF?sG?lH?mH?`I?CG?nH?oH?@r?[G?nH?pH?PZ?KK?lH?qH?PY?KR?dH?kC?@A?sL?cB?WC?PA?Ge?cB?rH?@M?Sf?cB?[E?@??su@sH?A??A?????h@?[G?`C?_Q?PF?G??`A?{C?T??dF?`??sX?T??tH?PB?ON?h@?G??@M?SD?T??G??po?SJ?W??G??PD?oD?uH?A??A?????gF?t@?@??cA?gF?A??A?????yA?aD?@\?_X?N??[B?@H?_h?xB?A??A?????W??Z??``?kT?vH?A??A?????Z@?~A?@??wK?bE?A??A?????yA?G??PZ??E?cA?A??A?????cC?AB?PC?kE?dC?A??A?????h@?i@?P{?SO?wH?A??A?????h@?G??`D?cC?xH?A??A?????\@?kC?@Z?_W?PF?G??PF??D?n@?o@?@y?gR?bE?AB?`??G`?yH?iA?p@????zH?h??pX????m??n??`A????|C?fE?@T?oF@gE?A??A?????n@?jH?PS??N?{H?h??@c????N??YH?PB?[A@OA?NA?Pg?wg?Z@?[@?pj?KQ?|H?A??A?????cA?eA?@q?CS?Y@?C??`kC{x?}H?CA?P?????~H?A??A?????n@?p@?@C?OE?wF??I?p@?cC?vF?A??A?????IA?JA?PA?WB?@I?EC?@??_h?cC?A??A?????Y@?C??P|Bgw?AI?UB?@@?CU?dH?UB?p@?wI?W??Z??@f?CU?BI?S??@A????W??CI?@E?oU?]A?G??PJ?sI?RB?A??A?????T???C?pM?CU?~C?A??A?????T??G??P@?[D?VE?RA?@B?o]?cA?eA?PO?wQ?]A?tA?`K?OV?DI?A??A?????s@?u@?@N?[O?s@?A??A?????yA?G??pU?wD?uA?A??A?????n@?o@?`H?oP?QA?G??`??[F?T??G??PD?gE?h@?G??PG?wC?[F?QE?`J?GB@R@?EI?@??sG?FI?A??A?????LA?G??PQ?WB?W??@C?@I?cJ?GI?A??A?????yA?cD?P??_Y?gD?A??A?????]F?^F?pB?w@?cC?{D?@??gD?W??g@?`@?_\?]C?A??A?????T??X??@@?OQ?GC?A??A?????Z@?gH?p@?SN?cB?\??`??oa?cB?HI?pD?_b?cB?I@?PA?GT?fD?II?P??cE?E@?WF?@B?WF?nH?pH?@R??K?kH?JI?pD?cB@kH?A??A?????n@?o@?Pw?cR?h@?i@?@y?OO?l@?A??A?????
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1666009740712;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "one.nio.server.AcceptorThread", "run", "one.nio.http.HttpServer", "createSession", "one.nio.http.HttpSession", "<init>", "byte[]", "java.lang.Thread", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "java.util.concurrent.CompletableFuture$AsyncSupply", "java.util.concurrent.CompletableFuture", "postComplete", "java.util.concurrent.CompletableFuture$UniCompose", "tryFire", "jdk.internal.net.http.MultiExchange$$Lambda$209.0x0000000800d8aca8", "apply", "jdk.internal.net.http.MultiExchange", "lambda$responseAsync0$2", "responseAsyncImpl", "jdk.internal.net.http.Exchange", "responseAsync", "responseAsyncImpl0", "establishExchange", "jdk.internal.net.http.ExchangeImpl", "get", "jdk.internal.net.http.Http2ClientImpl", "getConnectionFor", "jdk.internal.net.http.Http2Connection", "keyFor", "keyString", "java.lang.invoke.MethodHandleNatives", "linkCallSite", "linkCallSiteImpl", "java.lang.invoke.CallSite", "makeSite", "java.lang.invoke.BootstrapMethodInvoker", "invoke", "java.lang.invoke.Invokers$Holder", "invokeExact_MT", "java.lang.invoke.DelegatingMethodHandle$Holder", "delegate", "java.lang.invoke.DirectMethodHandle$Holder", "invokeStatic", "java.lang.invoke.StringConcatFactory", "makeConcatWithConstants", "generateMHInlineCopy", "prepender", "java.lang.invoke.MethodHandles", "insertArguments", "java.lang.invoke.BoundMethodHandle", "bindArgumentL", "java.lang.invoke.LambdaFormEditor", "bindArgumentType", "java.lang.invoke.MethodType", "dropParameterTypes", "makeImpl", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.test.kovalenko.shards.MyServerBase$$Lambda$200.0x0000000800d876a8", "ok.dht.test.kovalenko.shards.MyServerBase", "lambda$handleRequest$0", "handle", "handleRequest", "RequestHandler0_handle", "ok.dht.test.kovalenko.shards.MyServiceBase", "ok.dht.test.kovalenko.LoadBalancer", "balance", "curServiceUrl", "hash", "ok.dht.test.kovalenko.utils.HashUtils", "getMurmur128Hash", "com.google.common.hash.Murmur3_128HashFunction", "newHasher", "com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher", "com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher", "java.nio.ByteBuffer", "allocate", "java.nio.HeapByteBuffer", "sendResponse", "writeResponse", "one.nio.http.Response", "toBytes", "one.nio.util.ByteArrayBuilder", "makeHash", "jdk.internal.net.http.HttpClientImpl$SelectorManager", "jdk.internal.net.http.ConnectionPool", "purgeExpiredConnectionsAndReturnNextDeadline", "jdk.internal.net.http.ConnectionPool$ExpiryList", "purgeUntil", "java.util.LinkedList", "descendingIterator", "java.util.LinkedList$DescendingIterator", "uniHandleStage", "uniHandle", "jdk.internal.net.http.Exchange$$Lambda$243.0x0000000800da1db8", "lambda$responseAsyncImpl0$10", "checkFor407", "jdk.internal.net.http.Exchange$$Lambda$217.0x0000000800d94458", "lambda$responseAsyncImpl0$9", "jdk.internal.net.http.Http1Exchange", "sendHeadersAsync", "thenCompose", "uniComposeStage", "jdk.internal.net.http.Http1Exchange$$Lambda$256.0x0000000800da7840", "lambda$sendHeadersAsync$4", "jdk.internal.net.http.Http1Request", "headers", "collectHeaders0", "jdk.internal.net.http.common.HttpHeadersBuilder", "build", "java.net.http.HttpHeaders", "of", "headersOf", "java.util.TreeSet", "java.util.TreeMap", "one.nio.server.SelectorThread", "one.nio.net.Session", "process", "processRead", "processHttpBuffer", "parseRequest", "one.nio.util.Utf8", "read", "toAsciiString", "java.lang.invoke.LambdaForm$MH.0x0000000800d88000", "java.lang.invoke.LambdaForm$DMH.0x0000000800d89800", "newInvokeSpecial", "java.lang.invoke.DirectMethodHandle", "allocateInstance", "jdk.internal.misc.Unsafe", "java.lang.String", "proxyRequest", "ok.dht.test.kovalenko.ServiceClient", "putJavaNet", "jdk.internal.net.http.HttpRequestBuilderImpl", "jdk.internal.net.http.ImmutableHttpRequest", "jdk.internal.net.http.HttpClientFacade", "sendAsync", "jdk.internal.net.http.HttpClientImpl", "jdk.internal.net.http.HttpRequestImpl", "java.lang.StringBuilder", "toString", "java.lang.StringLatin1", "newString", "java.util.Arrays", "copyOfRange", "jdk.internal.net.http.common.MinimalFuture", "newIncompleteFuture", "jdk.internal.net.http.common.SequentialScheduler$SchedulableTask", "jdk.internal.net.http.common.SequentialScheduler$CompleteRestartableTask", "jdk.internal.net.http.common.SequentialScheduler$LockingRestartableTask", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$238.0x0000000800da1000", "jdk.internal.net.http.Http1AsyncReceiver", "flush", "jdk.internal.net.http.Http1Response$HeadersReader", "tryAsyncReceive", "jdk.internal.net.http.Http1Response$Receiver", "accept", "jdk.internal.net.http.Http1HeaderParser", "parse", "resumeOrSecondCR", "addHeaderFromString", "substring", "requestForKeyJavaNet", "linkToTargetMethod", "java.lang.invoke.LambdaForm$MH.0x0000000800c0c000", "java.lang.StringConcatHelper", "simpleConcat", "newArray", "allocateUninitializedArray", "resumeOrEndHeaders", "java.lang.invoke.LambdaForm$DMH.0x0000000800d89400", "java.net.http.HttpHeaders$$Lambda$203.0x0000000800d81768", "jdk.internal.net.http.common.SequentialScheduler$TryEndDeferredCompleter", "complete", "handlePendingDelegate", "jdk.internal.net.http.Http1Response$BodyReader", "onSubscribe", "jdk.internal.net.http.ResponseContent$FixedLengthBodyParser", "jdk.internal.net.http.Http1Response$$Lambda$292.0x0000000800dafa50", "jdk.internal.net.http.Http1Response", "onFinished", "jdk.internal.net.http.HttpConnection", "closeOrReturnToCache", "returnToPool", "registerCleanupTrigger", "jdk.internal.net.http.SocketTube", "connectFlows", "subscribe", "jdk.internal.net.http.SocketTube$InternalReadPublisher", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadSubscription", "java.util.ArrayList", "forEach", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$264.0x0000000800da5b30", "lambda$run$3", "handleEvent", "jdk.internal.net.http.SocketTube$SocketFlowEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadEvent", "signalEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription", "signalReadable", "jdk.internal.net.http.common.SequentialScheduler", "runOrSchedule", "jdk.internal.net.http.SocketTube$SocketFlowTask", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$230.0x0000000800d99000", "jdk.internal.net.http.Http1AsyncReceiver$Http1TubeSubscriber", "onNext", "java.util.ImmutableCollections$AbstractImmutableList", "iterator", "java.util.ImmutableCollections$ListItr", "jdk.internal.net.http.ExchangeImpl$$Lambda$220.0x0000000800d97650", "lambda$get$0", "createExchangeImpl", "thenApply", "uniApplyStage", "uniApplyNow", "jdk.internal.net.http.ExchangeImpl$$Lambda$239.0x0000000800da14b0", "lambda$createExchangeImpl$2", "h2Upgrade", "setH2Upgrade", "setHeader", "java.lang.Object[]", "java.util.HashMap", "lambda$headersOf$1", "java.util.List", "copyOf", "java.util.ImmutableCollections", "listCopy", "toArray", "wrap", "start", "one.nio.http.Request", "getHeader", "trim", "getBytes", "encode", "encodeASCII", "com.google.common.hash.AbstractHasher", "putString", "encodeUTF8", "responseAsync0", "jdk.internal.net.http.MultiExchange$$Lambda$210.0x0000000800d8b128", "jdk.internal.net.http.MultiExchange$$Lambda$260.0x0000000800da5248", "java.util.concurrent.CompletableFuture$UniApply", "java.util.concurrent.CompletableFuture$UniCompletion", "claim", "jdk.internal.net.http.HttpClientImpl$DelegatingExecutor", "execute", "java.util.concurrent.CompletableFuture$Completion", "postFire", "lambda$responseAsync0$4", "readBodyAsync", "java.net.http.HttpResponse$BodyHandlers$$Lambda$204.0x0000000800d823a8", "java.net.http.HttpResponse$BodyHandlers", "lambda$ofByteArray$12", "java.net.http.HttpResponse$BodySubscribers", "ofByteArray", "jdk.internal.net.http.ResponseSubscribers$ByteArraySubscriber", "jdk.internal.net.http.MultiExchange$CancelableRef", "java.lang.ref.WeakReference", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$270.0x0000000800da8f30", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber", "requestMore", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$WriteSubscription", "jdk.internal.net.http.Http1Exchange$Http1Publisher$Http1WriteSubscription", "request", "jdk.internal.net.http.Http1Exchange$Http1Publisher$WriteTask", "tryFlushCurrent", "writeAvailable", "java.util.ImmutableCollections$List12", "java.lang.reflect.Array", "newInstance", "java.nio.ByteBuffer[]", "getPath", "put", "addEntry", "java.util.TreeMap$Entry", "getOutgoing", "completeAsync", "java.util.concurrent.CompletableFuture$UniHandle", "jdk.internal.net.http.Exchange$$Lambda$258.0x0000000800da7cd0", "lambda$responseAsyncImpl0$8", "jdk.internal.net.http.Exchange$$Lambda$216.0x0000000800d94210", "sendRequestBody", "sendBodyAsync", "continueRequest", "jdk.internal.net.http.RequestPublishers$ByteArrayPublisher", "jdk.internal.net.http.PullPublisher", "java.util.ArrayList$Itr", "readStatusLineFeed", "java.lang.AbstractStringBuilder", "appendToOutgoing", "jdk.internal.net.http.Http1Exchange$DataPair", "registerTimer", "add", "addEntryToEmptyMap", "jdk.internal.net.http.Http1Response$Http1BodySubscriber", "onComplete", "join", "jdk.internal.net.http.MultiExchange$$Lambda$211.0x0000000800d8b370", "jdk.internal.net.http.common.Utils", "remaining", "requestJavaNet", "java.net.URI", "create", "java.net.URI$Parser", "createHttp1Exchange", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$237.0x0000000800da0dd8", "java.util.concurrent.CompletableFuture$UniWhenComplete", "uniWhenComplete", "jdk.internal.net.http.ResponseSubscribers$$Lambda$299.0x0000000800db0698", "jdk.internal.net.http.ResponseSubscribers", "lambda$getBodyAsync$2", "jdk.internal.net.http.MultiExchange$$Lambda$302.0x0000000800db0d40", "lambda$responseAsync0$3", "jdk.internal.net.http.HttpResponseImpl", "handlePending", "signalOnSubscribe", "java.util.concurrent.SynchronousQueue", "offer", "java.util.concurrent.SynchronousQueue$TransferStack", "transfer", "snode", "java.util.concurrent.SynchronousQueue$TransferStack$SNode", "lambda$responseAsyncImpl$7", "completedFuture", "java.util.concurrent.atomic.AtomicReference", "filterChain", "jdk.internal.net.http.FilterFactory", "getFilterChain", "java.lang.reflect.Constructor", "newInstanceWithCaller", "java.lang.reflect.AccessibleObject", "checkAccess", "verifyAccess", "slowVerifyAccess", "java.util.Collections$UnmodifiableMap", "java.lang.Iterable", "java.net.http.HttpHeaders$$Lambda$272.0x0000000800da9158", "lambda$headersOf$0", "jdk.internal.net.http.Http1Request$$Lambda$274.0x0000000800da95e8", "test", "lambda$collectHeaders0$1", "firstValue", "java.util.Collection", "stream", "java.util.stream.StreamSupport", "java.util.stream.ReferencePipeline$Head", "readBody", "jdk.internal.net.http.Http1Response$$Lambda$291.0x0000000800daf400", "lambda$readBody$3", "jdk.internal.net.http.Http1AsyncReceiver$Http1AsyncDelegateSubscription", "getConnection", "jdk.internal.net.http.ConnectionPool$CacheKey", "jdk.internal.net.http.ResponseContent", "getBodyParser", "java.util.Collections", "unmodifiableMap", "java.util.concurrent.atomic.AtomicLong", "java.util.LinkedList$ListItr", "java.util.concurrent.CompletableFuture$UniRelay", "getSettingsString", "getClientSettings", "jdk.internal.net.http.frame.SettingsFrame", "int[]", "reinvoke_L", "requestFilters", "java.util.concurrent.atomic.AtomicBoolean", "java.lang.invoke.LambdaForm$MH.0x0000000800c90000", "java.lang.Class", "getConstructor", "jdk.internal.reflect.ReflectionFactory", "copyConstructor", "java.lang.reflect.ReflectAccess", "copy", "retrieveProxy", "sun.net.spi.DefaultProxySelector", "select", "java.security.AccessController", "doPrivileged", "executePrivileged", "sun.net.spi.DefaultProxySelector$3", "whenComplete", "uniWhenCompleteStage", "computeIfAbsent", "resize", "java.util.HashMap$Node[]", "jdk.internal.net.http.Http1Exchange$Http1Publisher", "jdk.internal.net.http.common.Demand", "java.lang.String[]", "parseHierarchical", "parseAuthority", "parseServer", "parseHostname", "grow", "collectHeaders1", "append", "ensureCapacityInternal", "jdk.internal.net.http.AsyncTriggerEvent", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$234.0x0000000800d99d50", "startSubscription", "java.lang.Long", "asyncReceive", "java.util.concurrent.ConcurrentLinkedDeque", "offerLast", "linkLast", "newNode", "java.util.concurrent.ConcurrentLinkedDeque$Node", "java.net.http.HttpRequest", "newBuilder", "jdk.internal.net.http.AbstractSubscription", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$232.0x0000000800d99460", "handleSubscribeEvent", "jdk.internal.net.http.ConnectionPool$CleanupTrigger", "java.lang.invoke.LambdaForm$MH.0x0000000800d11000", "java.lang.invoke.LambdaForm$MH.0x0000000800c0d000", "newArrayWithSuffix", "getBodyAsync", "jdk.internal.net.http.ResponseSubscribers$$Lambda$298.0x0000000800db0470", "lambda$getBodyAsync$3", "checkOpen", "java.util.Base64$Encoder", "encodeToString", "handleParsedRequest", "ok.dht.test.kovalenko.dao.utils.PoolKeeper", "submit", "java.util.concurrent.AbstractExecutorService", "java.util.concurrent.LinkedBlockingQueue", "java.util.concurrent.LinkedBlockingQueue$Node", "getAddress", "jdk.internal.net.http.HttpRequestImpl$$Lambda$223.0x0000000800d9db98", "lambda$getAddress$5", "java.net.InetSocketAddress", "java.net.InetAddress", "getByName", "getAllByName", "getAllByName0", "java.net.InetAddress[]", "java.util.stream.ReferencePipeline", "findFirst", "java.util.stream.AbstractPipeline", "evaluate", "java.util.stream.FindOps$FindOp", "evaluateSequential", "java.util.stream.FindOps$FindSink$OfRef$$Lambda$14.0x80000001d", "java.util.stream.FindOps$FindSink$OfRef", "firstValueAsLong", "readResumeHeader", "lockingScheduler", "java.util.concurrent.atomic.AtomicInteger", "write", "one.nio.net.Session$ArrayQueueItem", "thenAccept", "uniAcceptStage", "uniAcceptNow", "jdk.internal.net.http.Http1Exchange$$Lambda$279.0x0000000800daae30", "lambda$sendBodyAsync$8", "requestMoreBody", "jdk.internal.net.http.Http1Exchange$Http1BodySubscriber", "jdk.internal.net.http.PullPublisher$Subscription", "jdk.internal.net.http.PullPublisher$Subscription$PullTask", "jdk.internal.net.http.Http1Request$FixedContentSubscriber", "jdk.internal.net.http.Http1Exchange$$Lambda$275.0x0000000800da9c58", "putBytes", "whenCompleteAsync", "jdk.internal.net.http.Http1Response$$Lambda$295.0x0000000800dadcb8", "handlePut", "emptyResponseForCode", "java.util.concurrent.locks.ReentrantLock", "readAvailable", "jdk.internal.net.http.SocketTube$SliceBufferSource", "listOf", "ok.dht.test.kovalenko.dao.base.ByteBufferDaoFactoryB", "fromString", "jdk.internal.net.http.Http1Response$$Lambda$297.0x0000000800db0238", "java.util.HashMap$KeySet", "java.util.HashMap$KeyIterator", "jdk.internal.net.http.Exchange$$Lambda$282.0x0000000800dab4b8", "jdk.internal.net.http.MultiExchange$$Lambda$259.0x0000000800da5000", "lambda$responseAsyncImpl$6", "getBuffer", "jdk.internal.net.http.PlainHttpConnection$$Lambda$228.0x0000000800d9ab90", "jdk.internal.net.http.ResponseTimerEvent", "jdk.internal.net.http.TimeoutEvent", "java.time.Instant", "plus", "java.time.Duration", "addTo", "plusSeconds", "ofEpochSecond", "addTrailingOperation", "jdk.internal.net.http.HttpConnection$TrailingOperations", "newTaskFor", "java.util.concurrent.Executors", "callable", "waitingGet", "java.util.concurrent.CompletableFuture$Signaller", "java.util.function.BiPredicate$$Lambda$271.0x0000000800d3a800", "java.util.function.BiPredicate", "lambda$and$0", "jdk.internal.net.http.common.Utils$$Lambda$163.0x0000000800d0e930", "lambda$static$12", "java.util.function.Predicate$$Lambda$153.0x0000000800cab850", "java.util.function.Predicate", "lambda$negate$1", "jdk.internal.net.http.common.Utils$$Lambda$152.0x0000000800d0baa0", "lambda$static$5", "java.lang.Class[]", "jdk.internal.net.http.Http1Response$ClientRefCountTracker", "java.util.stream.LongPipeline", "wrapAndCopyInto", "wrapSink", "java.util.stream.ReferencePipeline$5", "opWrapSink", "java.util.stream.ReferencePipeline$5$1", "getTask", "poll", "startParsingRequestBody", "now", "java.time.Clock", "currentInstant", "wrapForUpgrade", "jdk.internal.net.http.Http1HeaderParser$$Lambda$285.0x0000000800dabd98", "lambda$addHeaderFromString$0", "spliterator", "java.util.AbstractList$RandomAccessSpliterator", "java.util.Optional", "ofNullable", "one.nio.net.NativeSelector", "one.nio.net.NativeSelector$2", "java.util.stream.FindOps$FindSink$OfLong", "java.util.OptionalLong", "jdk.internal.net.http.Http1Exchange$$Lambda$277.0x0000000800daa9c0", "lambda$sendBodyAsync$7", "cancelIfFailed", "jdk.internal.net.http.Http1Exchange$$Lambda$278.0x0000000800daabf8", "ok.dht.test.kovalenko.utils.HttpUtils", "toOneNio", "java.net.InetSocketAddress$InetSocketAddressHolder", "java.util.concurrent.locks.ReentrantLock$NonfairSync", "toByteArray", "java.util.LinkedList$Node", "jdk.internal.net.http.Http1Response$$Lambda$245.0x0000000800da34a8", "jdk.internal.reflect.DelegatingConstructorAccessorImpl", "jdk.internal.reflect.GeneratedConstructorAccessor8", "jdk.internal.net.http.RedirectFilter", "mapToLong", "java.util.stream.ForEachOps", "makeRef", "java.util.stream.ForEachOps$ForEachOp$OfRef", "jdk.internal.net.http.HttpClientImpl$SelectorAttachment", "events", "filter", "java.util.stream.ReferencePipeline$2", "getParameter", "java.util.stream.ForEachOps$ForEachOp", "java.util.stream.ReferencePipeline$2$1", "contextRestricted", "CONTEXT_RESTRICTED", "jdk.internal.net.http.common.Utils$$Lambda$273.0x0000000800da9390", "lambda$sendRequestBody$7", "getResponseAsync", "readHeadersAsync", "thenApplyAsync", "jdk.internal.net.http.Http1Exchange$$Lambda$280.0x0000000800dab068", "jdk.internal.net.http.HttpClientImpl$$Lambda$213.0x0000000800d8b7d8", "findConnection", "remove", "java.util.AbstractList", "listIterator", "jdk.internal.net.http.HttpConnection$TrailingOperations$$Lambda$296.0x0000000800db0000", "toLowerCase", "readResumeStatusLine", "jdk.internal.net.http.Exchange$$Lambda$284.0x0000000800dab948", "lambda$wrapForUpgrade$11", "checkForUpgradeAsync", "java.util.stream.FindOps$FindSink$OfLong$$Lambda$288.0x0000000800d3e078", "java.util.concurrent.ConcurrentSkipListSet", "java.util.concurrent.ConcurrentSkipListMap", "doRemove", "findMethodHandleType", "java.lang.invoke.MethodType$ConcurrentWeakInternSet", "java.lang.invoke.MethodType$ConcurrentWeakInternSet$WeakEntry", "checkRequestMore", "resumeReadEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$269.0x0000000800da8cf8", "jdk.internal.net.http.Http1Exchange$$Lambda$281.0x0000000800dab290", "java.lang.invoke.LambdaForm$MH.0x0000000800dad000", "java.lang.invoke.LambdaForm$DMH.0x0000000800dac800", "withoutPadding", "jdk.internal.reflect.GeneratedConstructorAccessor7", "jdk.internal.net.http.AuthenticationFilter", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$262.0x0000000800da56d0", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1", "exceptionallyCompose", "uniComposeExceptionallyStage", "java.util.concurrent.CompletableFuture$UniComposeExceptionally", "java.util.TreeMap$EntrySet", "java.util.TreeMap$EntryIterator", "jdk.internal.net.http.Http1Exchange$$Lambda$267.0x0000000800da8430", "jdk.internal.net.http.Http1Response$$Lambda$283.0x0000000800dab700", "lambda$readHeadersAsync$0", "jdk.internal.net.http.Response", "java.util.ImmutableCollections$MapN$1", "java.util.ImmutableCollections$MapN$MapNIterator", "jdk.internal.net.http.Http1Response$$Lambda$293.0x0000000800dafc78", "java.util.HashSet", "java.util.HashMap$KeySpliterator", "jdk.internal.net.http.ConnectionPool$ExpiryEntry", "putConnection", "jdk.internal.net.http.PlainHttpConnection", "cacheKey", "hostString", "java.lang.Integer", "sun.nio.ch.SelectorImpl", "lockAndDoSelect", "sun.nio.ch.EPollSelectorImpl", "doSelect", "processEvents", "processReadyEvents", "putVal", "java.util.HashMap$Node", "responseFilters", "jdk.internal.net.http.Exchange$ConnectionAborter", "jdk.internal.net.http.Exchange$$Lambda$241.0x0000000800da1938", "jdk.internal.net.http.Http1Exchange$$Lambda$257.0x0000000800da7a88", "java.lang.Object", "java.lang.invoke.LambdaForm$MH.0x0000000800d98000", "java.lang.invoke.LambdaForm$MH.0x0000000800d93800", "java.lang.invoke.LambdaForm$MH.0x0000000800c0fc00", "jdk.internal.net.http.ConnectionPool$$Lambda$304.0x0000000800db1fb0", "java.lang.invoke.LambdaForm$DMH.0x0000000800c9c000", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$263.0x0000000800da5908", "and", "java.net.http.HttpRequest$BodyPublishers", "sun.nio.ch.Util$2", "jdk.internal.net.http.Exchange$$Lambda$242.0x0000000800da1b70", "lambda$establishExchange$3", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$248.0x0000000800da6238", "asReadOnlyBuffer", "java.nio.HeapByteBufferR", "jdk.internal.net.http.Exchange$$Lambda$301.0x0000000800db0b08", "getNode", "hashCode", "valueOf",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(' + value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
