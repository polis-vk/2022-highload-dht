<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BY_a@Ai@p@mAjCgDtEuEvE~EvFfIyItK}NbOpQbRcUnUhYyY{YkZg^muC????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????@@????????G?G?????G???G????@?@???G???G???????G?G??G?????G@???????????@???G@?O???G???@??GAOG????G?H??A@O???GO???O????Q???O@???A@???HG??G????G?G?@????A???@???A??G?G?@?G??GG???@??G@????G????????@?@?@?G@???G@?GGG?????@???G??A?G????@?G?G?O??????@@?@G??GGG????????????I@???????@???@???????GGG?@??G?G??????@H?G??G???@@???G?G??G??@???@??H?@????@???G??@???????G??@?@G??G??@??@??@?????G????????????@G?????OG@@????????G?????????G??@@??@?OG??????G?????????@@??????G??????GO????????@???O?A???????????G??@?W@??@????????OO???????????@???G????O?????@?????I@???@?@??G??????O??@?G?G????HA???@I???@HG??G?I??HGH??????@@??????H??@???G??@A?@??????H?@??G??@???G?@??H??????@????@??????G?G@??????@??G???@????G?@@@?GG?????@??@G??GB????@???@??G???G????G@???A?????KGG?A@G?@?????????@????@????@??@??@???W???????????@GO??????????P@????@@?@????@??@??@A????????G??@@???????P?????G????G@???????@??@??G??G????O?????????A?@????????G??@???@?????GG?????GG??????????@??????OG??????@?@??????G???@G@?@??????G?G@????G??G????G@?@???@????G@???@??????P?G????@????O?G???GG??????@??????@?????@B???@??H???W????G??????G???@??????@HG????@?????A?????????A????H?????AG?@?????@????@?????G@??????@?G??@?????G?????@??GG?@????????OG????G????????@G??????G??G?G?????????@G?????????@??@?@@G@?????????G????G?@???????O???????@???G@A@????????G????@@?????G??@A???H?????A?@?@????@??@?G@????????????@??G???@????????????GGA???@???@?@???G???@@??????G?G?A??G?G?G?G????????H?@????@A??A??????G?????G????????GA??G?G?O??G@???@G?????O?G?@?@??????@?@?@??@??GG?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????G}{@}{@btAy{ApsActAtwAo}@k|@~|@qcA~fAnuAn|@e}@auAt{Ae|Ar|@n}@vdAdeAuiA}jA_kAgkAymA}tA_uAcxAgxAuzA``BgkBc|@d}@l~@n~@n`Ar`Ay`AbbAlbAubAwbAacA_dAaeAseAveApfAqfA`hAjhAqiAwiAcjAkkA}kAilApmA_pAopAasAjsAlsAovAqvAawAcwAjwAi{Ar|Ap}Ar`BblBulBmnBeoBopB`sBa|@d|@g|@m|@z|@{|@s}@v}@x}@f~@l_An_At_A``Ag`Aj`Ap`Ax`AfaAoaAibAzbAccAjcAncApcAhdAudAceAmeAhfAufAwfAdgAegAigA}gAehAohAuhAzhA|hA_iAeiAfiA|iAijAjjAyjAckAwkAnmAsmA{mAbnAenAhnA|nA}nAjoAqoAsoA~oAbpAupAbqApqAtqA~qAetAgtAeuApuAruAtuA|uA`vAgvAlvAvvAdwAfwAqwAvwArxAzxAdyAlyAnyAfzA|zAj{Az{Ag|Ah|Aa}Ai}Ak}Ac`BbaBxaB_dB|eB}gBihB~hBaiB_kB~lB`mBlmB~{@b|@e|@f|@h|@j|@l|@o|@p|@q|@s|@t|@u|@v|@w|@y|@}|@`}@a}@b}@c}@f}@k}@p}@q}@r}@t}@u}@w}@y}@z}@|}@~}@`~@b~@c~@e~@g~@h~@i~@j~@k~@q~@s~@t~@u~@v~@w~@x~@z~@|~@}~@~~@a_Ac_Ag_Ai_Ak_Am_Ap_Aq_Ar_Av_Aw_Ay_Az_A{_A|_A}_A~_A_`Aa`Ab`Ac`Ad`Af`Ah`Ai`Ak`Al`Am`Ao`Aq`As`A{`A|`A~`A_aAdaAgaAhaAkaApaAqaAraAsaAtaAuaAwaA}aA_bAabAcbAebAfbAgbAhbAmbAnbAobApbAqbArbAsbAtbAvbA|bA}bA~bA_cA`cAbcAdcAecAfcAhcAicAkcAscAtcAucAvcAxcAycAzcA{cA|cAadAbdAcdAedAgdAldAqdAsdAtdAxdA{dA|dA~dAbeAfeAjeAleAqeAzeA|eA}eA~eA`fAffAgfAlfAofAyfAzfA{fA|fA}fA_gAagAbgAcgAggAhgAjgAkgAlgAmgAngAogApgAqgA{gA_hAahAbhAchAdhAfhAghAhhAihAlhAnhAqhArhAshAthAvhAwhAxhAyhA{hA}hA~hA`iAaiAbiAciAdiAhiAiiAjiAkiAliAmiAniAoiAtiAyiAziA{iA}iA~iAbjAmjAojAqjArjAtjAvjAwjAxjAzjA{jAakAbkAdkAekAfkAhkAlkAukAxkA{kAflAhlAplArlAslAtlAulAvlA}lA_mA`mAbmAcmAdmAemAfmAgmAhmAjmAlmAmmAomAqmAtmAvmAwmAxmA}mA~mA_nAcnAdnAgnAlnAonApnArnAsnAvnAxnAynAznA{nAaoAooAtoAuoAvoAwoAzoAapAfpAhpAjpAkpAlpAppArpAspAtpAwpAypA{pA|pA}pA~pA_qA`qAfqAgqAhqAiqAkqAlqAmqAnqAoqAqqArqAsqAvqAyqA{qA|qA_rA`rAarAfrAhrAjrAlrAmrAnrAorAprAurAxrAyrAzrA{rA|rA}rA_sA`sAbsAdsAesAgsAhsAisAksAmsAnsAosAqsArsAssAtsAusAxsA{sA|sA}sA_tAftAitAktAltAntAotAptAstAouAquAuuAwuAxuAyuAzuA{uA~uA_vAavAbvAcvAevAfvAhvAivAjvAmvAsvAtvAyvA{vA}vA_wA`wAewAgwAhwAowAuwAywAzwA|wA}wA_xAfxAixAkxAmxAoxAwxAxxA{xA|xA}xA_yAbyAhyAjyAkyAmyApyAsyAuyAwyAxyAyyAzyA}yA~yA_zA`zAbzAdzAgzAizAjzAkzAmzAozAqzArzAszAwzAzzA}zA~zA_{Aa{Ad{Ae{Af{Ag{Ah{Ak{Al{Am{A|{A}{A~{A`|Af|Aj|An|Aq|At|Aw|Ax|Az|A_}A`}Ab}Ac}Ad}Ae}Af}Aj}Al}An}Aq}As}At}Av}Az}A|}A~}Ah~Ak~An~Ap~At~Av~Az~A|~A~~Ar_Bt_Bx_Bz_B|_B~_Ba`Be`Bg`Bh`Bj`Bl`Bn`Bq`Bv`B{`B_aBdaBfaBhaBiaBlaBnaBraB}aB_bBfbBjbBnbBqbBubBwbBxbBzbB_cBacBdcBicBjcBkcBncBpcBrcBtcBvcBycBcdBedBgdBhdBjdBrdBtdBudBwdBydBzdB|dB}dB~dB_eBbeBdeBfeBleBneBpeBreBseBteBveByeB_fB`fBgfBifBkfBnfBxfBfgBkgBlgBngBpgBzgBlhBvhB|hBiiBkiBliBoiB{iB|iBajBhjBjjBujByjB|jBikBjkBkkBlkBnkBpkBtkB{kB}kBclBelBmlBolBzlB}lB_mBcmBemBhmBwmB|mBbnBdnBnnBonBqnBsnBvnBaoBcoBhoBioBnoByoBbpBepBipBqpBspB|pB~pBgqBoqByqB{qBfrBkrBorBvrBusB}sBqtB|tBiuBkuBpuBsuByuBmvBuvBiwBlwBnwB_|@`|@i|@x|@||@_}@g}@h}@i}@j}@l}@m}@{}@}}@_~@a~@d~@m~@o~@p~@r~@y~@{~@__A`_Ab_Ad_Ae_Af_Ah_Aj_Ao_As_Au_Ax_Ae`At`Au`Av`Aw`Az`A}`A`aAaaAbaAcaAeaAiaAjaAlaAmaAnaAvaAxaAyaAzaA{aA|aA~aA`bAdbAjbAkbAxbAybA{bAgcAlcAmcAocArcAwcA}cA~cA`dAddAfdAidAjdAkdAmdAndAodApdArdAwdAydAzdA}dA_eA`eAeeAgeAheAieAkeAneAoeApeAreAteAueAweAxeAyeA{eA_fAafAbfAcfAdfAefAifAjfAkfAmfAnfArfAsfAtfAvfAxfA`gAfgArgAsgAtgAugAvgAwgAxgAygAzgA|gA~gAkhAmhAphAgiApiAriAsiAviAxiA_jA`jAajAdjAejAfjAgjAhjAkjAljAnjApjAsjAujA|jA~jA`kAikAjkAmkAnkAokApkAqkArkAskAtkAvkAykAzkA|kA~kA_lA`lAalAblAclAdlAelAglAjlAklAllAmlAnlAolAqlAwlAxlAylAzlA{lA|lA~lAamAimAkmArmAumAzmA|mA`nAanAfnAinAjnAknAmnAnnAqnAtnAunAwnA~nA_oA`oAboAcoAdoAeoAfoAgoAhoAioAkoAloAmoAnoApoAroAxoAyoA{oA|oA}oA`pAcpAdpAepAgpAipAmpAnpAqpAvpAxpAzpAaqAcqAdqAeqAjqAuqAwqAxqAzqA}qAbrAcrAdrAerAgrAirAkrAqrArrAsrAtrAvrAwrA~rAcsAfsAvsAwsAysAzsA~sA`tAatAdtAhtAjtAmtAqtArtAttAutAvtAwtAxtAytAztA{tA|tA~tA`uAbuAcuAduAfuAguAhuAiuAjuAkuAluAmuAsuAvuA}uAdvAkvAnvApvArvAuvAwvAxvAzvA|vA~vAbwAiwAkwAlwAmwAnwApwArwAswAwwAxwA{wA~wA`xAaxAbxAdxAexAhxAjxAlxAnxApxAqxAsxAtxAuxAvxAyxA~xA`yAayAcyAeyAfyAgyAiyAoyAqyAryAtyAvyA{yA|yAazAczAezAhzAlzAnzApzAtzAvzAxzAyzA{zA`{Ab{Ac{An{Ao{Ap{Aq{Ar{As{Au{Av{Aw{Ax{A{{A_|Aa|Ab|Ac|Ad|Ai|Ak|Al|Am|Ao|Ap|As|Au|Av|Ay|A{|A||A}|A~|Ag}Ah}Am}Ao}Ar}Au}Aw}Ax}Ay}A{}A}}A_~A`~Aa~Ab~Ac~Ad~Ae~Af~Ag~Ai~Aj~Al~Am~Ao~Aq~Ar~As~Au~Aw~Ax~Ay~A{~A}~A__B`_Ba_Bb_Bc_Bd_Be_Bf_Bg_Bh_Bi_Bj_Bk_Bl_Bm_Bn_Bo_Bp_Bq_Bs_Bu_Bv_Bw_By_B{_B}_B_`Bb`Bd`Bf`Bi`Bk`Bm`Bo`Bp`Bs`Bt`Bu`Bw`Bx`By`Bz`B|`B}`B~`B`aBaaBcaBeaBgaBjaBkaBmaBoaBpaBqaBsaBtaBuaBvaBwaByaBzaB{aB|aB~aB`bBabBbbBcbBdbBebBgbBhbBibBkbBlbBmbBobBpbBrbBsbBtbBvbBybB{bB|bB}bB~bB`cBbcBccBecBfcBgcBhcBlcBmcBocBqcBscBucBwcBxcBzcB{cB|cB}cB~cB`dBadBbdBddBfdBidBkdBldBmdBndBodBpdBqdBsdBvdBxdB{dB`eBaeBceBeeBgeBheBieBjeBkeBmeBoeBqeBueBweBxeBzeB{eB}eB~eBafBbfBcfBdfBefBffBhfBjfBlfBmfBofBpfBqfBrfBsfBtfBufBvfBwfByfBzfB{fB|fB}fB~fB_gB`gBagBbgBcgBdgBegBggBhgBigBjgBmgBogBqgBrgBsgBtgBugBvgBwgBxgBygB{gB|gB~gB_hB`hBahBbhBchBdhBehBfhBghBhhBjhBkhBmhBnhBohBphBqhBrhBshBthBuhBwhBxhByhBzhB{hB}hB_iB`iBbiBciBdiBeiBfiBgiBhiBjiBmiBniBpiBqiBriBsiBtiBuiBviBwiBxiByiBziB}iB~iB_jB`jBbjBcjBdjBejBfjBgjBijBkjBljBmjBnjBojBpjBqjBrjBsjBtjBvjBwjBxjBzjB{jB}jB~jB`kBakBbkBckBdkBekBfkBhkBmkBokBqkBrkBskBukBvkBwkBxkBykBzkB|kB~kB_lB`lBalBdlBflBglBhlBilBjlBklBllBnlBplBqlBrlBslBtlBvlBwlBxlBylB{lB|lBamBbmBdmBfmBgmBimBjmBkmBmmBnmBomBpmBqmBrmBsmBtmBumBvmBxmBymBzmB{mB}mB~mB_nB`nBanBcnBenBfnBgnBhnBinBjnBknBlnBpnBrnBtnBunBwnBxnBynBznB{nB|nB}nB~nB_oB`oBboBdoBfoBgoBjoBkoBloBmoBooBpoBqoBroBsoBtoBuoBvoBwoBxoBzoB{oB|oB}oB~oB_pB`pBapBcpBdpBfpBgpBhpBjpBkpBlpBmpBnpBppBrpBtpBupBvpBwpBxpBypBzpB{pB}pB_qB`qBaqBbqBcqBdqBeqBfqBhqBiqBjqBkqBlqBmqBnqBpqBqqBrqBsqBtqBuqBvqBwqBxqBzqB|qB}qB~qB_rB`rBarBbrBcrBdrBerBgrBhrBirBjrBlrBmrBnrBprBqrBrrBsrBtrBurBwrBxrByrBzrB{rB|rB}rB~rB_sBasBbsBcsBdsBesBfsBgsBhsBisBjsBksBlsBmsBnsBosBpsBqsBrsBssBtsBvsBwsBxsBysBzsB{sB|sB~sB_tB`tBatBbtBctBdtBetBftBgtBhtBitBjtBktBltBmtBntBotBptBrtBstBttButBvtBwtBxtBytBztB{tB}tB~tB_uB`uBauBbuBcuBduBeuBfuBguBhuBjuBluBmuBnuBouBquBruBtuBuuBvuBwuBxuBzuB{uB|uB}uB~uB_vB`vBavBbvBcvBdvBevBfvBgvBhvBivBjvBkvBlvBnvBovBpvBqvBrvBsvBtvBvvBwvBxvByvBzvB{vB|vB}vB~vB_wB`wBawBbwBcwBdwBewBfwBgwBhwBjwBkwBmwBowBpwBqwBrwBswBtwBuwBvwBwwBxwBywBzwB{wB|wB}wB~wB_xB`xBaxBbxBcxBdxBexBfxBgxBhxBixBjxBkxBlxBmxBnxBoxBpxBqxBrxBsxBtxBuxBvxBwxBxxByxBzxBpN???????????????sE|A?????????????f@f@?fB???????????????????jB??p@?????U??????`F?`I???}L?W????kB??????jB??}B??fB?`K????????W????UBxKUgC?kB?????????}@?mC?mC?rPXcP{I???QxO???o@W???????I??????J??v@??????B??|A?qRDD???????????A?tS???nEA???????????????yKI?v@D??aR????cU??_J???B^?????B?}BaS????wC????vM}TBo@??AA??I~T????dVuSXQ??O?????OxB|Q??rG?A????BI????o@?O`A??A??????dWAA????D?yH??yC?O?????}O?@dB???w@BwI|@X????s@?p@hBO???JoW????I|@B???wC????yS??bD???}UiX??Q????}@?ArW??bD?wX?XJ??}X?|@?????????fUA??A?jAlDJ????yC?~VJiAA?DD?uO?hB?U?DaY??yDC???WyDD???rRz@?B????iY??gLv@?p@zN?vTqUzL?D?bYlD?f@?J?uU?????w@}@I?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?TFU?V?W?X?Y?Z?[?\?]?^?_@?`@~DB?a@?b@?c@?d@?e@?f@?g@?h@?i@?j@sAk@?l@?m@?n@?o@?p@GC?q@Pr@?s@?t@?u@?v@?w@?x@?y@?z@?{@?|@?}@?~@?_A?`A?aA?bA?cAEq@vEs@uAdA?eA?fA?gA?hA?iA?jA?kA?lA?mA?nA?oAEpA?qA?rA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~A?_B?`B?aBsA^tEbB?cB?dBEeB?fB?gB?hB?iB?jBKD_EF?kB?lB?mB?nB?oBhFqAiFsAkFuAmFwA?pB?qB?rB?sB?tB?uB?vB?wB?xBaFN?U?r@wEt@?dAxAyBfFjAb@zB?{B?|B?}B?~B?_C?`C?aC?bC?cC?dC?eC?fC?gC?hC?iC?jC?kC?lC?mC{ArAjFtAlFvAnFpB?nC?oC?pC?qCuFfBvFhBwFjBxFE`@kByFmB{FoBeGUgGs@bFeA?yB}AkA?zBkG|BlG~BnG`CoGbC?rC?sC?tC?uC?vC?wC?xC?yC?zC?{Cc@|C?}C?~Ca@g@sGsA|FvAuGqB_GsBaGuBcGwByGr@hGdAiGiAgFkAzG{B~A}BmG_Cd@aC_BcCe@_D?`D?aD?bD?cD?dD?eD?fD?gD?hD?iD?jD?kD?lDoAmD?nD?oD?pD?qD?rDdHtAtGwA?sD?tD?uDzHuA}FsD|HuDvGgB?vD?wDGa@oEc@qEe@g@xD?yDQzD?{D?|D?}D?~D?_E?`E?aE?bEaI{DbI}DdI_EfIcE?dE?eEl@|DcI~DeI`E?cE?fE?gE?hEjI}DgI`EiBiE?jE?kE}HvAeHrB`GtBbGvB?lEcBs@uAu@yEw@zEy@{EmE?nE?oE?pEGqE?rE?sEc@nA?tE?uEmIwA{HtD?vE?wE?xE?yE?zE?{E?|ERt@xEv@vAx@wA}E?~E?_F?`F?aFcBbFHcF?dF?eF?fFSpB~FrBnIuBhHxBlBdAxAfAdFhA}AgF?hF?iF?jF?kF?lF?mFlI~DkIaE?nF?oFmB_EhIdE?pF?qF?rF`J`EiBfE?sF?tF`BkC?uF?vF?wF?xF?yF?zF?{F?|F?}FHb@pEd@rEf@L~F?_G?`G|IeAcFgAeFiAh@aG?bG?cG?dG?eG?fG?gG?hG?iG?jG?kG?lG?mG?nG?oG?pG?qG?rG?sG?tG?uGdBhDrHjDtHlDvHnDwHpD?vG?wGaBxG?yG?zG?{G?|G?}G?~G?_HyIqBfHtBoIlEED?`H?aHzAG?bH?cH?dH?eH?fH?gH?hHcEN?iH?jH?kH?lHwBiH?mHrAnH?oH?pH?qH~J~GSxAoFrH?sH?tH?uH?vH?wH?xHg@~FjJ`G?yHgJc@~Hf@LzH?{H_KrBzIvB{ByA?|H?}H?~H?_I?`I?aI?bI?cI?dI?eI?fI?gI?hI?iI?jI?kI?lI?mISsD?nI?oI?pI?qI?rI?sI?tIgBhBaBQoAE`@uI?vI?wI?xI?yI?zIbJyFdJ{FfJ}FH{IT|I?}I?~I?_J?`J?aJ?bJ?cJ?dJV}IjL_J`CeJt@fJRgJ?hJ?iJ?jJ?kJ?lJ?mJ?nJ?oJuB`HaKE`@GcKcHvBeH?pJ?qJ?rJ?sJ?tJ{BuJ?vJ?wJ?xJ?yJ?zJ?{JR|J?}J?~J?_K?`K?aK?bKVcK?dK?eKsBfK?gK?xGtBzG|J|GzB_HlBu@pIx@wAz@|E|@}E~@~E`A_FbAbH}CcHf@LyD_LhK?iK?jK?kK?lK?mK?nKvJD?mDk@oK?pK?qK?rKzJyG{J{G}J}Gs@sKu@rHqKtHsKvHuKxH_IyDoL~IkL`JlLbJnLdJ?tKjMsHrKuHtKwHvKf@qBfA}IiAh@uKlM_J`CaJmLcJuIwE?vK?wK?xK?yK?zK?{K|L~Ca@|K?}K?~Ku@|HzK~H|K`I}KbI?_L?`LqByBbBzB{G}BkH`C~GcCnH`DpHbDqHdD?aLy@`K?bL_HsC`HcL?dL?eL?fL?gL?hL?iL?jLHkL?lL?mL?nL?oLt@d@hJpLuBEaCHaEJbEqL?rL?sL?tL?uL?vLkCFpAHlCwL?xLHyLeNG`EIqAK?qLbNzL?{L?|LTsBgHvBzMiAh@zB{M~B}GaCmHdCqG}L?~Lc@_M~LiK_MkKaMmKcMkDuHDeMnD?`M?aM?bMu@zApF|ArF~A?cM?dM?eM?fM?gM?hM?iM?jM?kM?lMuJmM?nM?oMcLiByAQdLF?pM?qM?rM?sM?tM?uM?vM?wM?xM?yM~BtDtL}JuL_K?zM?{MgNtBqLaHbKbHdKdH?|M?}M?~M?_N?`N?aN?bN?cN?dNVeN?fNhNjAjG{BjH~BjNbCpGdC?gNhChNiCaLy@zM?iN?jN{@HlCKnCkN?lN?mN?nN?oN?pNdCtHcCwHpMg@?xD?qN?rN?sN?tNm@uN?vN?wN?xN?yNgEN?zNzBsK?{N`Ne@g@|NlOfNeC`JnMcJ_CzIiLzF?}N?~N?_OgOEaCbHsCeHfKgHhKMFiHxBkHkKMF`OGaOdPf@@g@?~FoBwFiP{F?bOeCcOGdO?eO?fOsOIfNLwBOrAQeES~@gO~ImFwM}H{K_I|BhO?iO?jO?kO?lO?mOsIrE?nOuMf@LoOC|N?pOC~F{@qO?rO?sO?tO?uO?vO?wO?xO?yO?zO?{O?|O?}OfPaJsMdJCxDM_GpB~OCh@lNjK`MlKbMnKdMmDk@_P?`P?aP?bP?cP?dP?eP?fPqPeOxPbJsBiDsHkDoNmDk@oDeBvGyJiByAxGxL{GiM~G?sKfOuB`BgP@|K?hPmOkAiH|B|G_ClHbCpOiP?jP?kP?lPsPJaNkNtOmNvOoNkPFpAbHsC|M?mP?nP?oP?pP_QbP?qP?rP?sP?tP?uPjQvBdGxByPqN|OsN?vPcQcJCwPmQKnCxP?yPuQdJY|FdAzPtI{PuCkCw@|F{NjBwGF}NqM_OsMqCuMbOwMrC|P`DsPtQ}PfCxE?~P?_QnB`QaDqL?aQ?bQhCcQj@dQ?eQ~OvN_PxNaPTFzN_AfQoQGrLdHhOmPbAoPcAgQ?hQzPkKmNnK|PnD?_P~PaPzCqP?iQ?jQ?kQ?lQEmQ?nQ~BnI?oQ?pQHqQcDH?rQqAsQ?tQ?uQ?vQqQnP?wQ?xQ?yQ?zQxI_Fn@{Q?|Q?}Q?~Q?_R?`R@rFMaRvQ}F?bR?cR?dR?eR?fRaAzBiNgRd@hR?iRdAwBaDLtPPKRfETPjR?kR?lR?mR?nR?oR?pR?qR?rR?sRmR`F?{QnR}QoR_RxCrFbRlK{PkDeQnDcR`P_DcP`QeP{CtRfCvKtMxK?uRq@vR?wR?xR?yR?zR?{R?|RjDvRiSxRkSzReA}R?~R?_S?`S?aS?bSq@cEiIpFaJcSNdS?eShDxBqMgAkJjAb@aGrBfS?gS?hS?iScAjS?kS?lS?mSdAlEHnS@~FjP~N?oS?pS]{QbS~QpR`RhRrQiRtQfDqSlPhHyBjH?rSyOuHoMxHwK_GpByHvSJ?sQjRuQkRmPbAsSsFaBtF_@hSwRjSyRlS{RmSwR}SzReA|R?vRnSyRnD|R~SxRoS{RaTwR_T{RcTxRoDvRbTzReAvReT{RdTyRnDvRgA|RfTzR`TvRgAvRgAtS?uS?vSNwS?xS?yS?zS?{S?|SNfE?}S?~S?_TNiE?`T?aT?bTcDbHpQmPbAwQlRcT?dT?eTCzHEuK[~P?fT?gT?hTwP~HxMaI~KcI?iT|SxRoD|RhT{RjD|RsT|RtTvRgTvRuTwRpDvRiTwRpDjT?kT?lT?mT?nTq@aE?oT?pT?qT?rT?sT?tTNuT?vT?wT?xT@pLMyTmTcHvB|MgDwQnTdT?zT?{T?|T?}T?~T?_U?`U?aUYg@{OqN?bU?cUhLxFcJzFeJ|FCyDwR{BnO_ClQcC~MaDi@cDj@eDvLgKwLyGbCdU?eUwTdHeKpJsLrJx@tJcSmKnNlDr@_P?fU?gQxSvHkMf@L|N?gUm@hUnBlC?iU]jU?kU?lUuRpLbUxGiQdUhAeHwSMnPjHjKlHyBmHmKoHoKqH_AmU?nUdCoUSpU?qU?rU?sU?tU`A~KjTxSkTzSlTuU?vU?wU_U|BkQ`C}MdC?xU?yU?zU?{U?|U?}U?~U?_V{Lv@vA`V?aV[bV?cVrIdVyRMFeV?fVdQjDdDoD|CwGhMzGyL}Gz@{Nm@oAsUkDiDoD|CgVvChVpNbMpLhJ?iV~RoR_SqRnU}B|MaC_BjV?kVxTlVyT}TzT_U{TaU]mV?nVM`GgSwKgCuRVoV?pVmMaJoT{HeUwHzO~FkDhAbBaGrBcGnJeGpJgGrJiGtJqV?rV?sV?tV?uVyU~BoOcCe@eC?vVY|KtCxFrUNdEPzRS~@UhEWjEY?wVKxV?yV?zVfLxI@hPsD{VtD_C`U|V?}Vy@~V?_W?`W?aWZ|Fl@bW?cW?dW?eW?fW?gW?hW?iWnVcWoVeWqVgW?jWsVdWpVfWrVhWuVeWtVhWmDoS~UpV_VbJ`VxHa@rFiUfHgKhHfAkHoPNiKjH?kWaViAlJbGmJdGoJfGqJhGsJlWjV_KeOiN?mWdOuDiV`CoUgNrOcDj@aLkV_WlVnWt@oW|VjApSbG?fS?pW_RwN`PiHEqWeVOuPR?eV?rW?sW?tWqIoE?uWrDkUgUdR?vW?wW?xW?yW?zW?{WaH|W?}W?~W?_X?`X?aX?bX?cX_WaCkN_DoHaDaUdD?dX?hK?eX?fX?gX?hX?iX?jX?kXtA_@?lXsDmXgRnQ@zH^~O@|FxQQ|NkB?nX?oXKq@PpX?qX?rX?sX?tX_CuX?vX?wX?xX?yXwVf@iJzXC~O`WkA?aGqSgS?{X?|X?}X?~X_NtC?_Y?`YeDaY?bY?cY?dYuCeY?fYdUnKdD_PdRbPrQrP?gYwQ}F?hYfWiY?jY?kY?lY?mY?nYjWDzAkB?oYvDQuEN?pYb@qY?rY~AsY?tY?uY?vY?wY?xY?yYjCzY?{Y@|YhD}YkWaGbVdG}VgGcVlWuD~VmWkDiD_PxDcP?~Y?_Z?`Z?aZnWExGbZvUlDr@oDeBqDmUcZ?dZ?eZ?fZ?gZ?hZ?iZ?jZ?kZ?lZn@mV|UmZcWPfVTFnZxWQvPTPViEXkEZ?oZ?pZ?qZ?rZ?sZ?tZuWFyQrM`OtMaOvMcOxM?uZ?vZsQtP?}PsWbGaWgS?wZ?xZvNgM?yZ?zZ?{Z?|Z?}Z?~ZqN{AqF}A?_[?`[qDa[?b[pU_V^~FyWR{RNfGVzDYlE[mE]tAm@?bB?c[?d[zSsQ{SvQgDoPcAaPzCcPfSfP?e[Zf[wDg@|TbU[g[?h[vI{EvV_JrMbJMpLmD_OgX`JgPdJ\rLcNi[?j[xVgHmPN{VkHzViHlKP?nHnKpHpK}GlWk[eWbC?jVzUl[?m[?n[?o[?p[?q[?r[?s[?t[tWlDr@oK?u[?v[?w[cXSgVVzDx[tDgRxRiRsRy[?z[?{[aX|ArNcMtNeM`XhMpC|[?}[?~[?_\?`\_@kBhUyGbC|G_Aa\_@pM~NrMzWuM{QxM}Wb\fRkQ?c\?d\{@bH?e\Tf\?g\?h\?i\?j\qDzIpP|FtCk\?l\hX|F}DcCe@m\~Cn\{DaJmXDoCoKfMqKgMiBhQyGrX}Gs@~O{Ao\?p\?q\?r\?s\kOt\?u\yNoMGv\\kNnQnNwOpNiA_GTw\?x\?y\?z\?{\hA|MiO~M?|\iWjX}D}\x@mFkA~\hA_]?`]?a]?b]x@c]B`JpTfT?d]?e]?f]tBg]?h]?i]?j]?k]?l]?m]@oOZn]{UnV?mZxC`GEo]^xD|DsL?p]?q]qXzGtU~G}Cr]qT_I|BaIrTs]?t]lAu]uD}OhPk\Y~FxXbJmAv]?w]?x]?y]Rz]?{]?|]?}]vX}FyXmD}P`PeSdPaQfP?tR|X}MjO|\@~]~X_^?`^?a^fAb^CzXnXT|RkR}RmRxUpR`SyDeXtQfDvQfXpP_DqP`DgYmAd]_Yf]`Yc^?d^jA~OkCe^sXqMzQtM{WwMrCuZ?b\uXc\?f^?g^?h^aAi^pX}AbXj^vDyGzX~G}C{H_@k^{XlN~Cl^?m^?n^rDo^?p^?q^?r^Gs^cY`IyMcI?t^?u^?v^?w^eYnDdSaPeRrP~WuPZx^[y^?z^mV}FvWDoCoD?{^?|^\}^?~^mB__@?`_@?a_@?b_@?c_@?d_@?e_@?f_@?g_@?h_@?i_@?j_@?k_@gBvDjCl_@?m_@cCn_@?o_@eP~]]aFkAlBzFp_@_XfSrShSsSpPfYeP{Cq_@wWlZn@aFeDoI`LqIaLsIbLyD\aQ}QaDi@cQ~QeQbQlSdYcJaAuKlYmDfQpDxHr_@kDs_@d@t_@bWxN`RNbP}GpYnDwJvGgQjB?u_@?v_@?w_@jYrMtXvM|Wx_@?y_@?z_@?{_@jXhHyVlHkUPlXoHlU}Gz@mUhYuQ?qSjUNkXlHfA|_@|D}_@dNuL?~_@kY_PxDqP{DeJiA~O_@uIeLwIoB_`@?``@kAoYpWq@FpYqWrY?a`@wDeYnA~AsNdMuNfMwNhMpCb`@xNnM`AhPnA_[?c`@?d`@qYyN~@zNsYsMqCe`@rYoDwUtO?f`@?g`@?h`@?i`@?j`@?y[oX{[tY`PnYfPmYk`@?l`@?m`@vYpDxJgVvCf`@wYh`@xYj`@tRdRvRn`@lAo`@?p`@?q`@?r`@?s`@nAt`@lAdCqOaDi@hNiCdX?u`@gWfXhWv`@?w`@uYoXKmQ?uKoYdJgYNdXWhVx`@?y`@?z`@mAgT?{`@?|`@jAxDl@}`@?~`@?_a@
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??`B?WM?H??C??P??SH?I??C??`G?sK?J??C??@@????K??L??`p?cM?M??N??pH?oh?O??P??PD?Oe?M??Q??p@?se?M??Q??@i?[j?R??S??p@?KEAR??T??@R?w^?U??V??PU?Gg?W??X??pE?ob?Y??Z??`E?sH?[??C??`??G]?U??V??Pc?sg?R??\??@O?We?]??V??PY?wF@^??_??@A????`??a??PL?CU?b??c??@H?cJ?d??c??@I?_V?e??f??p_?gX?g??h??@D?CE?i??j??P@?[`?k??l??@U?gM?m??n??aB?WH?k??o??QA?K^?k??p??AG?Ga?E??F??`E?GE@E??q??@`?SA@r??s??pA?[w?t??u??pA@CX?v??w??@D?oN?x??y??@?????z??{??C?????|??}??B?????~??C??@iCwx??@?@@?`@?Od?A@?n??q??sI?B@?n??q??WH?k??o??QB?K^?k??C@?AG?s^?D@?E@?qf?wi@A??F@?B?????G@?C??PM?sm@H@?_??@A????`??I@?P??ST?`??J@?@X?_X?b??K@?a??OV?b??J@?AC?oV?b??L@?QO?k\?b??M@?qX?[T?N@?O@?QL?sD?P@?Q@?aB?GE?R@?S@?qE?k`?R@?T@?qR?{b?U@?V@?q@????W@?X@?A^????Y@?X@?AF????Z@?[@?QC????\@?]@?q??sQ?\@?]@?AB?kP?^@?_@?QP?O_?b??K@?`??OV?b??J@?@C?oV?b??L@?PO?k\?b??M@?pX?[T?N@?O@?@U?GE?R??Q??p??OQAR??`@?`L?Wz?R??a@?`M?Wy?b@?_??@?????c@?C??pF?SI?d@?F??PL?Wd@d@?e@?@r?gf@f@?C??pH?_O?g@?h@?@@?k`?i@?C??@B????j@?k@?p??oB?j@?Q??p??CD?l@?m@?PG?GC?n@?m@?`@????o@?Q??`@?[E?p@?q@?PY?o@?p@?r@?pN?WD?s@?t@?PD??B?u@?v@?`@?SG?w@?v@?@@?[d?w@?v@?pA?{d?w@?v@?PG?Cf?x@?y@?Po??G?g??z@?`A?GD??@?j??P@?[g?k??C@?QK?C_?k??{@?AG?{_??@?|@?aC?CG?}@?C??@@????~@??A?`@?oW?@A??A?Pb?{^?AA?BA?PV?[m?CA?DA?`@?GP?CA?DA?`V?CR?EA?C??@~?wj?d??FA?@B?[b?GA?HA?@I?cx?GA?IA?`F?[W?GA?JA?E??G`?p@?q@?pR?g@?o@?KA?PB?oE?LA?O@?`C?cC?MA?O@?pF?KE?NA?OA?`@?gyAPA?QA?aG?CuAPA?RA?AF?gvASA?TA?qB?k~?SA?UA?QY?K]?b??L@?pQ?o\?VA?_??@C????b??WA?@@?o\?b??XA?@j?OX?YA?_??@B????b??ZA?P??_\?d??[A?Pz?SO?R??\A?p??SOAR??]A?`[?KI@^A?_??@A????d??_A?PN?KP?`A?aA?`q?WR?`A?bA?pV?[F?`A?cA?PA?wJ?dA?eA?P@?_i@fA?y@?PC?ci@gA?eA?@??oR@A??hA?B?????A??iA?B?????|??jA?C?????|??kA?C?????o@?KA?QB?oE?LA?O@?Q@?[C?lA?O@?aC?sH?mA?O@?AJ?[@?|??nA?C?????|??oA?C?????|??pA?C?????|??qA?C?????|??rA?C?????|??sA?C?????|??tA?C?????z??uA?C?????z??vA?C?????z??wA?C?????d@?F??pN?[d@d@?xA?`a@wj@v??yA?P@?gX?`A?bA?`E?WE?zA?{A?p@?gC?g??|A?@B?OL?g??}A?`I??N?~A?@@?@F?GO@?B?P??@E????g??@B?AL?WN?AB?@@?aF?kC?~??C??PBASs?BB?Q??@@?WB?CB?C??@@????DB?EB?pR?gj?CA?DA?`@??O?CA?DA?`T?{Q?FB?C??`G?SJ?GB?C??@@????DB?HB?PW?Wp?DB?IB?PB@[y?JB?KB?AM?gg?LB?MB?AE?Wa?p@?q@?@t?wA?NB?OB?PF?oM?PB?QB?aJ?_N?AA?BA?QV?[m?CA?DA?a@?GP?z??RB?C?????|??SB?C?????|??TB?C?????|??UB?C?????|??VB?C?????|??WB?C?????|??XB?C?????|??YB?C?????|??ZB?C?????|??[B?C?????|??\B?C?????|??]B?C?????|??^B?C?????|??_B?C?????|??`B?C?????|??aB?C?????|??bB?C?????|??cB?C?????|??dB?C?????|??eB?C?????SA?TA?Qi?O@@R@?S@?q@?[`?fB?gB?QG?wy@fB?hB?aW?WJAiB?jB?AU?OX?E??F??pG?KE@D??kB?`??Sh?lB?mB?`??cy?nB?C??PN?KC?nB?C??_P?OC?nB?C??pS?WC?oB?pB?@U?wL?NB?qB?PJ?sC?NB?rB?@o?oJ?sB?HB?AA?SG?sB?HB?QA?cG?sB?tB?aG?WI?P@?Q@?qG?SE?~??C??@`Bcv?uB?vB?pF?sG?uB?wB?`I?CG?xB?yB?AW?WF?`??I@?@??ST?E??q?????k?@|??zB?C?????|??{B?C?????|??|B?C?????R??a@?@B?ox?W??X??qE?ob?Y??Z??aE?sH?[??C??a??G]?}B?V??aR?Gx?R??\??AO?We?R??T??aU??_?|??~B?C?????|???C?C?????|??@C?C?????|??AC?C?????A??F@?B?????|??BC?C?????|??CC?C?????|??DC?C?????~??C??pnACu?EC?FC?PB?WO?GC?HC?@??KP?IC?JC?P@?G^?KC?LC?@?????|??MC?B?????NC?OC?B?????PC?QC?B?????|??RC?B?????|??SC?C?????|??TC?C?????b@?_??@C????N@?UC?@@?GE?N@?VC?pz?CH?R??WC?p??_FAR??XC?PE?Wh?R??YC?PR?oi?ZC?_??@A????N@?[C?P??GH?b??\C?@C?sR?x@?]C?`G?SQ?P@?^C?P??GL?P@?_C?pC?kN?P@?`C?`??oL?aC?bC?q@?S^?cC?dC?Q@?wR?cC?eC?QF?_o?fC?C??AA????aC?gC?a??W^?hC?iC?q@?WF?jC?kC?Q@?wC@lC?O@?q^?Gz?JB?KB?@M?gg?LB?MB?p^?{a?Y??Z??PC?kH?E??Z??PN?sS@r??mC?pC?ku?t??u??Pj@WY?nC?oC?pF?[O?v??pC?@A?CJ?x??pC?@?????NC?qC?B?????H??C??P@?[H?rC?S??`g?kT?K??L??@L?WL?K??sC?@R?kW?tC?MB?`A?So?uC?MB?PU?ka?vC?wC?`??WW?vC?S??pK?KT?xC?wC?@D?oV?yC?V??@L?cs?R??zC?PM?{t?{C?P??PA????|C?}C?pB?GG@R??zC?pB?Wt?d@?Z??pD?_eAd@?~C?`M?OHAd@??D?`E?SGAd@?@D?ph?Kc@s@?t@?@E?CB?R??O@?pA?_@AR??AD?PW?gu@d@?BD?@G?gUBd@?CD?`D?[WBDD?ED?PC?_s@v??y??`B?KL?|??FD?C?????|??GD?B?????A??HD?B?????s@?t@?P@??B?s@?ID?p@?KC?s@?JD?`A?[C?KD?LD?P@?_w?KD?y@?pC?{e?MD?ND?@Z?[EBMD?OD?PK?KHBMD?PD?@_?sKBMD?QD?pJ@cQB^@?RD?AD@cn?~??C??puCWy?SD?@@?aJ?[]@TD?P??AA????~??UD?q??Wy?~??VD?AD?K|?WD?Q??Q@?sN?XD?YD?qA?oz?w@?ZD?aE?c_?NB?OB?@W?GN?NB?[D?pA?gO?oB?\D?@B?WH?oB?\D?PG?OI?]D?\D?pE?WQ?^D?\D?@?????_D?`D?B?????EA?C??`w?sj?d??aD?A@?g`?GA?bD?Q??WC@GA?cD?aF?ku?~??C??@rBKw?w@?dD?pE?_L@E??q???`?SA@MA?O@?@J?OE?eD?O@?pC?[@?fD?gD?p??[@?fD?hD?`B?K@?iD?jD?PK?gn@kD?lD?qN?gA?mD?nD?aB?cM?mD?oD?qF?oN?pD?nD?q\?oF?kD?lD?Q\?GB?t??u??Px?_W?`??J@?`S?CX?`??qD?@L?oM?rD?BA?PY?[I?sD?O@?@@?cV?tD?eA?Q??wM?uD?vD?a??[R?wD?vD?qA?_u?xD?y@?qG?Kv?wD?yD?QK?Oc?vC?wC?a??WW?vC?S??qK?KT?xC?wC?AD?oV?R??S??q@?KEAR??T??AR?w^?p@?r@?qN?WD?s@?t@?Q@??B?s@?ID?q@?KC?s@?JD?aA?[C?KD?LD?Q@?_w?KD?y@?qC?{e?MD?ND?qW?WEB`??J@?pN?_W?w@?zD?pC?GK@{D?|D?@A?{N?~A?}D?@@?W`?~A?}D?`B?Cp?~A?~D?q??_o?~A?hD?AB?Ca@eD?O@?qC?[@?fD?gD?q??[@?fD?hD?aB?K@??E?C??@@????~@?@E?@b?OW?SD?@@?`J?[]@TD?P??@A????~??UD?p??Wy?~??VD?@D?K|?WD?Q??P@?sN?XD?YD?`C?sz?DB?AE?@@?Wo?DB?HB?ptBct?LB?BE?P@?s`?LB?BE?pJ?_c?K??CE?@P??\?|??DE?B?????~??C??Px?gp?A??EE?B?????NB?qB?@F?WC?oB?HB?@A??G?^D?HB?@?????_D?FE?B?????|??GE?B?????|??HE?C?????|??IE?B?????|??JE?C?????|??KE?C?????MD?PD?QF?oJBMD?e@?qK?SBBg??@B?`^?GO?~A?~D?@A?co?|??LE?C?????|??ME?C?????|??NE?C?????|??OE?C?????|??PE?C?????|??QE?C?????|??RE?C?????|??SE?C?????E??q??pc?WA@TE?UE?UB??Z?VE?WE?A@?OV?XE?WE?A??wH?B??YE?aC?O?@NC?ZE?B?????M??Q??@W?Gj?[E?ND?@d?wF?[E?\E?QQ?{Q?[E?]E?q]??P?fB?^E?QB?{RBiB?^E?QX?S[?M??Q??q@?se?M??Q??AW?Gj?E??q??_J?[@@[E?\E?@s?GS?[E?]E?p_??P?_E?`E?PM?wI@`A?cA?@@?wJ?aE?bE?AC?c^@d@?F??oN?[d@DB?HB?PvBCu?DB?cE?AL?gm?dE?eE?qM?GN@x@?y@?p}?cG?x@?fE?@@?wQ?gE?vB?`x?cL?cC?dC?P@?wR?cC?eC?PF?_o?hE?C??P??gL?hE?C??pQ?gM?hC?O@?aA?{D?iE?kC?aD?gz?jC?kC?a??GE@lC?O@?Q??_y?fB?jE?qE?WQAiB?jE?QH?OK?EA?C??`@A[l?dE?BE?P@?gB?dE?BE?P@?[G?~@?BE?`T?sR?~@?kE?@Y?wT?dE?lE?PG?OL@mE?\D?P@?Gg?nE?\D?@J?Kb?oE?\D?PA?cH?oE?\D?@??_I?~A?}D?@u?or?~A?pE?A??sn?uC?MB?PR?ga?qE?C??A@????e??rE?qS?s_?sE?tE?a[?sW?EC?uE?AA?kH?EC?uE?q`?cJ?EC?vE?q@?SN?_E?O@?a??oa?_E?wE?A_?Cc?eD?O@?@L?o@?eD?xE?`L?SC?`A?bA?PT??F?aE?@@?P@?C`@~A?pE?qG?Go?~A?yE?q~?ObA[E?ND?@X?_F?[E?zE?pG?kI?{E?|E?a??WN?}E?|E?q@?Gq?}E?~E?AG?OM??F?@F?Q??C\B|??AF?B?????|??BF?C?????|??CF?C?????|??DF?C?????d@?e@?Po?[f@EF?FF?PB?wH@GF?HF?`A?SV?[??IF?`??K]?yC?V??`R?os?DD?V??pB?_r@NC?JF?B?????|??KF?B?????nB?C??@M?KC?LF?vB?pA?WG?LF?MF?@?????A??NF?B?????E??F???U?wE@A??OF?B?????iD?jD?@??Kn@E??F??u_?cF@D??PF?a??[h?lB?QF?a??{}?RF?V??PM?kC@MD?ND?`M?GEBMD?SF?`A?KDBMD?TF?`@?[CBMD?e@?pB?{ABfB?UF?@B?k]@iB?UF?@??{A?lB?mB?@??cy?|??VF?C?????|??WF?C?????K??L??@N@KO?K??XF?@P?wS?LB??A?`P?ob?JB?BA?@B?ke?DB?BA?`S?cl?YF?V@?P@????ZF?X@?`L????[F?X@?@F????Z@?[@?PC????\@?]@?p???T?\@?]@?@B?wR?\F?_@?@b?Ob?A??]F?B?????^F?_F?B?????DB?HB?`gACs?dE?`F?PK?GH@nE?HB?@Z?CY?oE?HB?@A?KO?oE?HB?@U?_Q?oE?aF?@`?gS?bF?HB?@@?{A?bF?cF?@?????A??dF?B?????NC?eF?B?????`A?bA?P^?KG?{E?|E?`??WN?}E?|E?pA?Kq?}E?fF?@??sg@qE?C??@@????e??rE?pS?s_?sE?tE?@V?kW?sE?gF?pB?kJ?oE?HB?pP?SQ?hF?iF?qB?[M?jF?O@?AC?SI?kF?lF?aH?[Z?kF?mF?qG?k[?|??nF?C?????|??oF?C?????[E?ND?PA?SF?[E?pF?qA?kG?SA?TA?aH?C?@qF?rF?@??kH?oE?\D?@l?[K?kF?mF?aL?w[?NB?rB?@A@sK?NB?sF?QD??H?|??tF?C?????[E?ND?@f?{F?[E?uF?pK?wS?_E?@@?`Q?sW@g??@B?a^?GO?~A?}D?A@?W`?|??vF?C?????nE?HB?AZ?CY?oE?HB?AA?KO?hF?iF?pB?[M?jF?O@?@C?SI?kF?lF?`H?[Z?kF?mF?pG?k[?G@?C??PH?_m@wF?O@?@?????NB?[D?a??cO?~??C??PzCgy?E??q??pe?WA@tC?N??`A?wm?tC?Q??p@??l?tC?Q??`S?Wp?uC?P??P@?C`?uC?P??`K@{d?sE?tE?`[?sW?EC?uE?@A?kH?EC?uE?`k?wJ?xF?|D?pU?SW?xB?yB?Ar?[G?xB?yF?QZ?KK?uB?zF?aQ?sQ?{F?|F?a@?wI?nE?|F?q@?gW@nE?}F?Ah?WW@|??~F?C?????~??C??pL@sq??G?@G?@H?S?@AG?|D?@A?sL?_E?}D?PA?Ge?_E?BG?@??Gf?d??[A?`|?OQ?R??]A?@h?[I@R??CG?qH?Cd?DG?_??@B????`??EG?`??sX?`??FG?pK?_N?rD?GG?@@?KN?rD?HG?PA?_U?IG?O@?p@?GX?IG?JG?P??{Q?KG?jE?@?????|??LG?B?????|??MG?C?????NG?OG?B?????NC?PG?B?????|??QG?C?????|??RG?C?????|??SG?C?????|??TG?C?????|??UG?C?????|??VG?C?????|??WG?C?????|??XG?C?????|??YG?C?????|??ZG?C?????|??[G?C?????|??\G?C?????|??]G?C?????|??^G?C?????|??_G?C?????|??`G?C?????N@?VC?`x??H?N@?aG?`@?CI?d??y@?@l?[K?sE?bG?pJ?{N?nE?HB?AI@GZ?VE?PF?Q@?w]?lB?QF?AB??~?lB?cG?aD?Ge?E??q??oc?WA@LF?MF?A?????_D?dG?B?????uC?P??`N@?e?{C?P??@?????sE?tE?@N?[W?|??eG?C?????|??fG?C?????|??gG?C?????|??hG?C?????|??iG?C?????|??jG?C?????|??kG?C?????|??lG?C?????|??mG?C?????|??nG?C?????|??oG?C?????|??pG?C?????|??qG?C?????|??rG?C?????|??sG?C?????EC?uE?pH?cI?EC?tG?PK?CL?dE?uG?@??_O@NB?sF?PD??H?j@?m@?PG?SB?PB?`C?QP?KG?MD?QD?@??cNB|??vG?C?????|??wG?C?????|??xG?C?????|??yG?C?????|??zG?C?????|??{G?C?????|??|G?C?????|??}G?C?????|??~G?C?????|???H?C?????|??@H?C?????|??AH?C?????|??BH?C?????|??CH?C?????|??DH?C?????|??EH?C?????dE?uG?pF?gO@FH?GH?a??G`?dE?MB?Q@?GG?~@?MB?A^?{Q?w@?HH?Q@??_?~??@G?qB?om?xB?IH?aC?kN?JH?KH?A@??B?|??LH?C?????~??C??`cAgt?nC?oC?qF?[O?v??pC?AA?CJ?dE?`F?QK?GH@NC?MH?B?????d@?e@?@??[e@|??NH?C?????xB?yB?@r?[G?xB?yF?PZ?KK?uB?zF?PY?KR?|??OH?C?????nB?C???M?KC?R??AD?@a?Sv@p@?q@?`C?S@?p@?PH?PE?GC?QH?eA?AA?[|?RH?y@?q@?Gd@SH?y@?qQ?Cb@|??TH?C?????|??UH?C?????|??VH?C?????`A?bA?pX?oF?`A?cA?@F?wJ?fA?OA?Q??_i@fA?OA?AA?{i@WH?OA?Q??s]@WH?OA?Q??G^@XH?YH?QI?{[@~A?ZH?QN??ZAb??M@?Af?CU?R??\A?q??SOANB?rB?pr??K?PB?QB?aE?cN?iB?jB?qQ?GX?U??V??`Y?Wg?[H?_??AA????FH?MB?`??S_?DB?BA?qL?Gl?rD?BA?P??WH?d??_A?`F??P?d??uG?@K?_L?\H?GH?aV?Cg?xB?yB?@W?WF?]H?^H?@?????eD?O@?PG?_@?fD?_H?p??k@?P@?^C?pC?WL?`H?aH?`??cT?`H?bH?`C?SQ?`H?cH?`X?sZ?`H?dH?Qd??Z?`A?cA?@c?_K?e??f??@r?WY?eH?C??@D????e??fH?qY?_[?K??GH?aE?cY?|??gH?C?????`A?aA?`b?wQ?zA?hH?pD?wB?~A?}D?`I?kp?iH?hD?PA?k~@iH?hD?aG?W?AiB?jH?AD?oH?|??kH?C?????|??lH?C?????|??mH?C?????|??nH?C?????|??oH?C?????|??pH?C?????|??qH?C?????|??rH?C?????|??sH?C?????tH?P??@?????x@?]C?pD?OQ?~A?yE?Ad?OaAiB?jH?QX?oH?t??u??`EAcZ?N@?aG?@??CI?G@?C??@??Om@[H?_??@A????e??uH?p[?oK?vH?y@?AC?cB?iB?jB?QJ?sW?|??wH?C?????|??xH?C?????|??yH?C?????|??zH?C?????z??{H?C?????z??|H?C?????|??}H?B?????|??~H?C?????|???I?C?????|??@I?C?????|??AI?C?????|??BI?C?????|??CI?C?????|??DI?C?????g??@B?@L?WN?EI?P??@C????g??FI?aB?_N?GI?HI?AB????`A?II?a??CF?g??z@?aA?GD??@?j??Q@?[g?k??l??AU?gM?k??p??qD?Ka?|??JI?C?????d??FA?pK@wd?R??KI?`E?CfALI?_??@A????b??MI?Q@??[?d??NI?QF?WT?e??OI?qy?oL?R??PI?a@?GGAw@?dD?@H?cL@{D?eA?QA?SJ?QI?eA?QC?WV@~A?RI?a@?cU@~A?SI?QD??XA|??TI?C?????d??y@?PK?GD?\H?y@?`L?[f?CA?UI?@B?_X?CA?y@?PI?sM?|??VI?C?????|??WI?C?????NB?[D?`??cO?XI?YI?`V?OJ?ZI?|E?a??oE?sB?[I?qM?wA?A??\I?B?????|??]I?C?????jF?O@?aG?oI?~??C??`~Cwy?^I?P??@@????~??_I?P??wy?`I?C??@A????~??aI?`??{x??G?bI?`d?oB@{F?cI?QJ?sE?d??FA?Px?Wd?}B?V??@L?{w?dI?_??@C????b??eI?@@?c\?fI?_??AA????b??gI?QK?{Z?d??hI?a_?SS?d??iI?aA?w_?d??iI?qI?O`?CA?DA?a@??O?nB?C??EN?KC?TE?UE?pJ?[Z?~??C??P`?Kp?NC?jI?B?????SA?UA?QU?C]?oE?aF?A`?gS?bF?HB?A@?{A?bF?cF?A?????NG?kI?B?????GA?IA?@J?GY?p@?PH?pN?KC?p@?JG?p@?sC?lI?mI?`B?k??nI?oI?pA?WB?pI?qI?P@?WH?pI?qI?PB?kH?pI?qI?`L?cI?rI?O@?AB?SI?~??C??@pCGy?uB?sI?p??[H?NC?tI?B?????RF?V??@??SC@g??h??`??CE?g??uI?`A?wE?aE?O@?P@?w\@~A?O@?`??[P?~A?lF?PA?_T?~A?vI?QP?sV?oE?\D?`m@cM?hF?wI?QG?sR?d??y@?pg?WK?x@?xI?PQ?[W?yI?C??@A????x@?zI?`@?WW?{I?y@?pB?SM?|I?}I?P??[M@|I?~I?`??cP@|I?~I?@??{P@w@?v@?@e?wg?`??K@?QF?WQ?w@?dD?PL?kL@?J?OA?Q??O_@k??{@?AE?w_?@J?AJ?Q@?sN?NC?HB?B?????|??BJ?C?????NB?rB?Pf?cJ?NB?CJ?aL?sL?[E?]E?AU?oO?aC?DJ?QL?O]?XI?YI?pG?gI?dE?uG?`E?cO@dE?GH?PH?CF?EJ?GH?`j?Cc?DB?FJ?PZ?wi?w@?HH?P@??_?~??@G?pB?om?xB?IH?`C?kN?JH?KH?@@??B?JH?GJ?@?????LB?BE?Q@?s`?LB?BE?qJ?_c?K??CE?AP??\?d??c??@??SV??G?@G?AH?S?@AG?|D?AA?sL?_E?}D?QA?Ge?hC?O@?@@?sD?jC?kC?P@?wC@lC?O@?P??_y?fB?jE?pE?WQAiB?jE?PH?OK?|??HJ?B?????hF?wI?PG?sR?kF?mF?`L?w[?A??IJ?B?????K??sC?@??kU?MA?O@?pB?KE?JJ?eA?aE?{KAKJ?y@?q@?_CALJ?y@?aB?gAALJ?QA?QG?[BAGC?HC?A??KP?IC?JC?Q@?G^?`A?bA?@]?KG?}E?|E?@??Gq?i@?C??AB????j@?k@?q??oB?j@?Q??q??CD?l@?m@?aD?wB?MJ?NJ?a??CB?_E?wE?qD?_b?_E?JG?QA?GT?E??F??eE?GE@MA?O@?P??CE?MA?OJ?PC?SG?SA?O@?`???Q@SA?PJ?PW?[a?SA?QJ?AC?cW?sE?tE?AN?[W?d??_A?af?gP?d??FA?@??Wb?uC?MB?pW?oa?RJ?P??AC????e??SJ?aG??[?tC?wC?aJ?Wq?R??T??QB?K^?j@?m@?`Q?oB?TJ?UJ?P@?[@?VJ?UJ?PD?kF?TE?mC?`^?[Y?TE?WJ?pC?KJ?VE?PF?P@?w]?lB?QF?@B??~?lB?cG?`D?Ge?XJ?YJ?`A?O\?x??ZJ????kHB|??[J?C?????}@?C??@?????[E?]E?QL?_O?aC?\J?AH?CY?|??]J?C?????MD?QD?`A@SQBMD?e@?qG?_?B`A?aA?@V?OQ?j@?m@?PP?oB?YF?V@?p@????Z@?^J?P?????_J?`J?@B?__?`??J@?PK?[W?aJ?|A?P@?cA?aJ?y@?PC?sA?bJ?y@?@D?KB?NC?cJ?B?????RJ?P??@C????e??SJ?`G??[?tC?wC?`J?Wq?dJ?P??@?????TE?WJ?`@?{I?VE?kB?@??GS?I??C??aG?sK?A??eJ?B?????nB?C??`P?OC?qF?OA?@??_G?VA?_??@?????`??K@?PF?WQ?EA?C??pAAgl?}E?|E?p@?Gq?}E?~E?@G?OM??F?@F?P??C\BxB?yF?`^?cK?xB?fJ?pA?[O?JH?gJ?@@?OB?oE?hJ?@?????E??F??EV??F@MD?QD?pz?wPBMD?iJ?ap??[BfB?jJ?QI?_hAiB?kJ?q@?Co?NC?lJ?B?????NB?rB?po?oJ?PB?mJ?PE?_P?DB?IB?@W?ox?LB?nJ?AE?cd?[E?ND?@`?oF?[E?oJ?AY?gN?|??pJ?C?????|??qJ?C?????|??rJ?C?????|??sJ?C?????|??tJ?C?????|??uJ?C?????|??vJ?C?????|??wJ?C?????|??xJ?C?????|??yJ?C?????|??zJ?C?????|??{J?C?????|??|J?C?????TE?UE?pE?KZ?}J?~J?PY?[d@?K?ED?p@?g^?v??y??P@?ST?GA?IA?@??GW?NC?@K?B?????LB?MB?Qf?Cb?N@?O@?@X?KE?R??]A?@??CH@Y??Z??QC?kH?E??Z??QN?sS@TE?mC?a^?[Y?oE?\D?pR@cL?bF?AK?A@?GC?BK?CK?A?????NG?DK?B?????EK?P??@?????[E?\E?As?GS?iB?^E?AL?cZ?EC?FC?@C?WO?EC?FC?Al?KQ?b??XA?@??SW?hC?O@?A@?sD?`??K@?aC?SQ?`??FK?q@?ST?dE?lE?pS?GM@DB?BA?pL?Gl?DB?cE?@L?gm?dE?eE?pM?GN@w@?ZD?`E?c_?~??ZD?@I?cl?}J?~J?`d?Ge@lB?mB?`^??i?GK?HK?@D?KN?_E?BG?pu?wf?`A?aA?PO??Q?{E?|E?`??KJ?}E?|E?`F?[c?}E?IK?@A?oj@}E?IK?@B?Wj@w@?v@?@??ce?AB?@@?`F?kC?`A?II?Q@?CF?JK?bD?A@?SI?e??f??ay?O^?R??KK?q??SPAR??LK?aL?[v?PB?`C?PP?KG?MK?NK?@??kC?|??OK?C?????|??PK?C?????
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1666007538449;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "java.lang.Thread", "run", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "jdk.internal.net.http.common.SequentialScheduler$SchedulableTask", "jdk.internal.net.http.common.SequentialScheduler$CompleteRestartableTask", "jdk.internal.net.http.common.SequentialScheduler$LockingRestartableTask", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$238.0x0000000800d9c130", "jdk.internal.net.http.Http1AsyncReceiver", "flush", "jdk.internal.net.http.Http1Response$HeadersReader", "tryAsyncReceive", "jdk.internal.net.http.Http1Response$Receiver", "accept", "handle", "java.util.concurrent.CompletableFuture", "complete", "postComplete", "java.util.concurrent.CompletableFuture$UniApply", "tryFire", "java.util.concurrent.CompletableFuture$UniCompletion", "claim", "jdk.internal.net.http.HttpClientImpl$DelegatingExecutor", "execute", "java.util.concurrent.CompletableFuture$Completion", "postFire", "java.util.concurrent.CompletableFuture$UniCompose", "jdk.internal.net.http.MultiExchange$$Lambda$210.0x0000000800d89c00", "apply", "jdk.internal.net.http.MultiExchange", "lambda$responseAsync0$4", "jdk.internal.net.http.Exchange", "readBodyAsync", "jdk.internal.net.http.Http1Exchange", "jdk.internal.net.http.Http1Response", "readBody", "java.net.http.HttpHeaders", "firstValueAsLong", "java.util.stream.LongPipeline", "findFirst", "java.util.stream.AbstractPipeline", "evaluate", "java.util.stream.FindOps$FindOp", "evaluateSequential", "wrapAndCopyInto", "wrapSink", "getTask", "java.util.concurrent.SynchronousQueue", "poll", "java.util.concurrent.SynchronousQueue$TransferStack", "transfer", "java.util.concurrent.locks.LockSupport", "parkNanos", "jdk.internal.misc.Unsafe", "park", "libasyncProfiler.so", "LockTracer::UnsafeParkHook", "libjvm.so", "jni_GetObjectClass", "jdk.internal.net.http.HttpClientImpl$SelectorManager", "java.util.stream.ReferencePipeline", "forEach", "java.util.stream.ForEachOps$ForEachOp$OfRef", "java.util.stream.ForEachOps$ForEachOp", "copyInto", "java.util.HashMap$KeySpliterator", "forEachRemaining", "/usr/lib/libc.so.6", "java.util.concurrent.CompletableFuture$AsyncSupply", "jdk.internal.net.http.MultiExchange$$Lambda$209.0x0000000800d89780", "lambda$responseAsync0$2", "responseAsyncImpl", "responseAsync", "responseAsyncImpl0", "establishExchange", "jdk.internal.net.http.ExchangeImpl", "get", "jdk.internal.net.http.Http2ClientImpl", "getConnectionFor", "jdk.internal.net.http.Http2Connection", "keyFor", "keyString", "java.lang.invoke.LambdaForm$MH.0x0000000800d92800", "linkToTargetMethod", "java.lang.invoke.LambdaForm$MH.0x0000000800d92000", "invoke", "java.lang.invoke.LambdaForm$MH.0x0000000800c90800", "java.lang.invoke.DirectMethodHandle$Holder", "invokeStatic", "java.lang.StringConcatHelper", "prepend", "java.lang.Integer", "getChars", "uniHandleStage", "uniHandle", "jdk.internal.net.http.ExchangeImpl$$Lambda$220.0x0000000800d94000", "java.util.concurrent.ForkJoinWorkerThread", "java.util.concurrent.ForkJoinPool", "scan", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.test.kovalenko.shards.MyServerBase$$Lambda$199.0x0000000800d155a0", "ok.dht.test.kovalenko.shards.MyServerBase", "lambda$handleRequest$0", "one.nio.http.HttpServer", "handleRequest", "RequestHandler0_handle", "ok.dht.test.kovalenko.shards.MyServiceBase", "ok.dht.test.kovalenko.LoadBalancer", "balance", "proxyRequest", "ok.dht.test.kovalenko.ServiceClient", "getJavaNet", "jdk.internal.net.http.HttpClientFacade", "sendAsync", "jdk.internal.net.http.HttpClientImpl", "jdk.internal.net.http.HttpRequestImpl", "<init>", "firstValue", "copyIntoWithCancel", "forEachWithCancel", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$274.0x0000000800da7778", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber", "requestMore", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$WriteSubscription", "jdk.internal.net.http.Http1Exchange$Http1Publisher$Http1WriteSubscription", "request", "jdk.internal.net.http.common.SequentialScheduler", "runOrSchedule", "jdk.internal.net.http.Http1Exchange$Http1Publisher$WriteTask", "getOutgoing", "java.util.concurrent.ConcurrentLinkedDeque", "pollFirst", "unlink", "unlinkLast", "handleGet", "ok.dht.test.kovalenko.dao.LSMDao", "ok.dht.test.kovalenko.dao.aliases.MappedFileDiskSSTableStorage", "java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapValueIterator", "next", "java.util.concurrent.ConcurrentSkipListMap$SubMap$SubMapIter", "advance", "descend", "java.util.concurrent.ConcurrentSkipListMap", "findNear", "findPredecessor", "jdk.internal.net.http.Exchange$$Lambda$243.0x0000000800d9cee8", "lambda$responseAsyncImpl0$10", "checkFor407", "jdk.internal.net.http.Exchange$$Lambda$217.0x0000000800d8ad98", "lambda$responseAsyncImpl0$9", "sendHeadersAsync", "thenCompose", "uniComposeStage", "jdk.internal.net.http.Http1Exchange$$Lambda$256.0x0000000800da4b20", "lambda$sendHeadersAsync$4", "jdk.internal.net.http.Http1Request", "headers", "collectHeaders0", "collectHeaders1", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet", "iterator", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1", "java.util.TreeMap$EntrySet", "not_walkable_Java", "I2C/C2I adapters", "SharedRuntime::fixup_callers_callsite", "CodeHeap::find_blob_unsafe", "ok.dht.test.kovalenko.dao.LSMDao$MemoryStorage", "ok.dht.test.kovalenko.dao.aliases.MemorySSTableStorage", "OptoRuntime::new_instance_C", "InstanceKlass::allocate_instance", "MemAllocator::allocate", "MemAllocator::Allocation::notify_allocation_jvmti_sampler", "JvmtiSampledObjectAllocEventCollector::~JvmtiSampledObjectAllocEventCollector", "JvmtiObjectAllocEventCollector::generate_call_for_allocated", "JvmtiExport::post_sampled_object_alloc", "ObjectSampler::SampledObjectAlloc", "Profiler::recordSample", "CallTraceStorage::put", "awaitWork", "parkUntil", "jdk.internal.net.http.common.HttpHeadersBuilder", "build", "of", "headersOf", "java.util.TreeMap", "java.net.http.HttpHeaders$$Lambda$203.0x0000000800d82a10", "lambda$headersOf$1", "java.lang.Iterable", "jdk.internal.net.http.AsyncTriggerEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$232.0x0000000800d99f10", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription", "handleSubscribeEvent", "jdk.internal.net.http.SocketTube$SocketFlowTask", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$230.0x0000000800d99ab0", "read", "handlePending", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadSubscription", "signalOnSubscribe", "jdk.internal.net.http.Http1AsyncReceiver$Http1TubeSubscriber", "onSubscribe", "one.nio.http.HttpSession", "sendResponse", "one.nio.http.Request", "getHeader", "JNIEnv_::CallStaticObjectMethod", "AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ul, G1BarrierSet>, ", "thread_native_entry", "Thread::call_run", "JavaThread::run", "CompileBroker::compiler_thread_loop", "CompileBroker::invoke_compiler_on_method", "C2Compiler::compile_method", "Compile::Compile", "Compile::Optimize", "Compile::remove_speculative_types", "Compile::Code_Gen", "Matcher::match", "Matcher::find_shared", "PhaseChaitin::Register_Allocate", "PhaseChaitin::gather_lrg_masks", "RegMask::is_misaligned_pair", "PhaseOutput::Output", "PhaseOutput::init_scratch_buffer_blob", "MemoryService::track_memory_pool_usage", "java.lang.String", "equalsIgnoreCase", "regionMatches", "java.lang.StringLatin1", "regionMatchesCI", "lock", "java.util.concurrent.locks.AbstractQueuedSynchronizer", "acquire", "one.nio.server.SelectorThread", "one.nio.net.Session", "process", "processRead", "processHttpBuffer", "one.nio.util.Utf8", "isAsciiString", "sun.nio.ch.SelectorImpl", "select", "lockAndDoSelect", "sun.nio.ch.EPollSelectorImpl", "doSelect", "InterpreterRuntime::frequency_counter_overflow", "InterpreterRuntime::frequency_counter_overflow_inner", "CompilationPolicy::event", "java.util.concurrent.CompletableFuture$UniHandle", "PhaseIterGVN::optimize", "ConNode::hash", "Matcher::xform", "Matcher::match_tree", "PhaseIFG::init", "IndexSet::initialize", "Method::from_compiled_entry_no_trampoline", "jdk.internal.net.http.ConnectionPool", "purgeExpiredConnectionsAndReturnNextDeadline", "java.time.Instant", "now", "java.time.Clock", "currentInstant", "jdk.internal.misc.VM", "getNanoTimeAdjustment", "JVM_GetNanoTimeAdjustment", "libc.so.6", "__clock_gettime", "vdso", "__vdso_clock_gettime", "jvmti_GetClassSignature", "JvmtiEnv::GetClassSignature", "InstanceKlass::signature_name", "lambda$get$0", "createExchangeImpl", "thenApply", "uniApplyStage", "uniApplyNow", "jdk.internal.net.http.ExchangeImpl$$Lambda$239.0x0000000800d9c5e0", "lambda$createExchangeImpl$2", "h2Upgrade", "setH2Upgrade", "getSettingsString", "getClientSettings", "getParameter", "jdk.internal.net.http.common.Utils", "getIntegerNetProperty", "java.security.AccessController", "doPrivileged", "executePrivileged", "jdk.internal.net.http.common.Utils$$Lambda$146.0x0000000800cae6b0", "lambda$getIntegerNetProperty$13", "sun.net.NetProperties", "getInteger", "java.util.Properties", "getProperty", "java.util.concurrent.ConcurrentHashMap", "offer", "java.util.concurrent.SynchronousQueue$TransferStack$SNode", "tryMatch", "unpark", "pthread_cond_signal", "jdk.internal.net.http.common.SequentialScheduler$TryEndDeferredCompleter", "handlePendingDelegate", "jdk.internal.net.http.Http1Response$BodyReader", "jdk.internal.net.http.ResponseContent$FixedLengthBodyParser", "jdk.internal.net.http.Http1Response$Http1BodySubscriber", "onComplete", "jdk.internal.net.http.ResponseSubscribers$ByteArraySubscriber", "java.util.concurrent.CompletableFuture$UniWhenComplete", "uniWhenComplete", "jdk.internal.net.http.ResponseSubscribers$$Lambda$295.0x0000000800dacfc0", "jdk.internal.net.http.ResponseSubscribers", "lambda$getBodyAsync$2", "externalSubmit", "externalPush", "signalWork", "waitingGet", "managedBlock", "unmanagedBlock", "java.util.concurrent.CompletableFuture$Signaller", "block", "Symbol::as_C_string", "jvmti_GetCurrentThread", "/usr/lib/ld-linux-x86-64.so.2", "requestForKeyJavaNet", "requestJavaNet", "java.net.URI", "create", "java.net.URI$Parser", "parse", "parseHierarchical", "parseAuthority", "parseServer", "parseInt", "java.util.ArrayList", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$264.0x0000000800da5d18", "lambda$run$3", "handleEvent", "jdk.internal.net.http.SocketTube$SocketFlowEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadEvent", "signalEvent", "eventUpdated", "writeResponse", "write", "one.nio.net.Session$ArrayQueueItem", "one.nio.net.NativeSocket", "libonenio.210fea54.so", "Java_one_nio_net_NativeSocket_write", "hasOutgoing", "isEmpty", "peekFirst", "purgeTimeoutsAndReturnNextDeadline", "ok.dht.test.kovalenko.dao.aliases.MappedFileDiskSSTable", "ok.dht.test.kovalenko.dao.comparators.ByteBufferComparator", "lessThan", "compare", "java.nio.ByteBuffer", "compareTo", "java.nio.BufferMismatch", "mismatch", "jdk.internal.misc.ScopedMemoryAccess", "vectorizedMismatch", "vectorizedMismatchInternal", "jdk.internal.util.ArraysSupport", "requestFilters", "jdk.internal.net.http.AuthenticationFilter", "jdk.internal.net.http.AuthenticationFilter$Cache", "java.util.AbstractSequentialList", "java.util.AbstractList", "listIterator", "java.util.LinkedList", "java.util.LinkedList$ListItr", "node", "registerTimer", "java.util.TreeSet", "add", "put", "addEntryToEmptyMap", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$234.0x0000000800d9a800", "startSubscription", "signalReadable", "onNext", "asyncReceive", "Unsafe_Unpark", "itable stub", "Java_one_nio_net_NativeSocket_read", "jni_SetByteArrayRegion", "SafepointMechanism::process_if_requested_with_exit_check", "jvmti_Deallocate", "JvmtiEnv::Deallocate", "os::free", "MemAllocator::allocate_inside_tlab_slow", "G1CollectedHeap::allocate_new_tlab", "G1CollectedHeap::attempt_allocation_slow", "MutatorAllocRegion::retire", "G1CollectedHeap::retire_mutator_alloc_region", "G1CollectionSet::add_eden_region", "G1Policy::predict_region_non_copy_time_ms", "AbsSeq::davg", "java.util.concurrent.LinkedBlockingQueue", "take", "java.util.concurrent.locks.ReentrantLock", "lockInterruptibly", "java.util.concurrent.locks.ReentrantLock$Sync", "interrupted", "__libc_malloc", "jdk.internal.net.http.Http1HeaderParser", "resumeOrSecondCR", "addHeaderFromString", "toLowerCase", "java.util.HashMap", "computeIfAbsent", "java.util.Collections$UnmodifiableMap", "entrySet", "resumeReadEvent", "jdk.internal.net.http.SocketTube", "resumeEvent", "retrieveProxy", "sun.net.spi.DefaultProxySelector", "sun.net.spi.DefaultProxySelector$3", "java.lang.System", "hashCode", "tryFlushCurrent", "writeAvailable", "java.nio.channels.SocketChannel", "sun.nio.ch.SocketChannelImpl", "sun.nio.ch.IOUtil", "addEntry", "jdk.internal.net.http.Http1Response$$Lambda$288.0x0000000800da1d18", "onFinished", "jdk.internal.net.http.HttpConnection", "closeOrReturnToCache", "returnToPool", "putConnection", "getNode", "entryIndex", "fixAfterInsertion", "readResumeStatusLine", "java.lang.StringBuilder", "append", "java.lang.AbstractStringBuilder", "ensureCapacityInternal", "java.util.Arrays", "copyOf", "jni_CallStaticObjectMethodV", "jni_invoke_static", "JavaCalls::call_helper", "ThreadShadow::clear_pending_exception", "java.util.concurrent.ForkJoinPool$WorkQueue", "topLevelExec", "java.util.concurrent.ForkJoinTask", "doExec", "exec", "pthread_mutex_lock", "Unsafe_Park", "one.nio.net.NativeSelector", "epollWait", "vtable stub", "unknown_Java", "unlock", "release", "java.util.concurrent.CompletableFuture$UniRelay", "checkChar", "checkChars", "charAt", "JavaThread::is_Java_thread", "java_lang_Thread::get_thread_status", "checkRequestMore", "java.lang.invoke.Invokers$Holder", "java.lang.invoke.LambdaForm$MH.0x0000000800d02800", "java.lang.invoke.LambdaForm$MH.0x0000000800d01800", "java.lang.Long", "jbyte_disjoint_arraycopy", "ld-linux-x86-64.so.2", "__tls_get_addr", "readAvailable", "readIntoNativeBuffer", "sun.nio.ch.SocketDispatcher", "read0", "Interpreter", "cfree", "isLatin1", "checkOpen", "sun.nio.ch.Util", "getTemporaryDirectBuffer", "java.lang.ThreadLocal", "java.lang.ThreadLocal$ThreadLocalMap", "getEntry", "getEntryAfterMiss", "os::stack_shadow_pages_available", "JNIHandles::resolve_external_guard", "canContinueParsing", "one.nio.net.NativeSelector$2", "hasNext", "handleParsedRequest", "CompiledMethod::is_compiled", "resumeOrEndHeaders", "oopDesc::address_field", "jdk.internal.net.http.MultiExchange$$Lambda$212.0x0000000800d8a090", "jdk.internal.net.http.ConnectionPool$ExpiryList", "processEvents", "processReadyEvents", "sun.nio.ch.SelectionKeyImpl", "translateAndUpdateReadyOps", "translateReadyOps", "oopDesc::is_a", "jdk.internal.net.http.HttpClientImpl$SelectorAttachment", "register", "java.util.HashSet", "putVal", "unipush", "jdk.internal.net.http.MultiExchange$$Lambda$259.0x0000000800da51e8", "lambda$responseAsyncImpl$6", "responseFilters", "response", "getCache", "java.util.WeakHashMap", "hash", "java.lang.Object", "JVM_IHashCode", "ObjectSynchronizer::FastHashCode", "libnio.so", "fdval", "__recv", "ParseGenerator::generate", "Parse::Parse", "Parse::do_all_blocks", "Parse::do_one_block", "Parse::do_one_bytecode", "Parse::do_call", "PredictedCallGenerator::generate", "Compile::call_generator", "InlineTree::ok_to_inline", "ciMethod::get_flow_analysis", "ciTypeFlow::do_flow", "ciTypeFlow::flow_types", "ciTypeFlow::df_flow_types", "BoolNode::bottom_type", "PhaseOutput::fill_buffer", "jmpCon_shortNode::emit", "createHttp1Exchange", "getConnection", "signalNext", "Java_one_nio_net_NativeSelector_epollWait", "GraphKit::record_profiled_return_for_speculation", "ciMethod::return_profiled_type", "ciMethodData::data_from", "PhaseCFG::do_global_code_motion", "PhaseCFG::global_code_motion", "PhaseCFG::schedule_late", "PhaseCFG::insert_anti_dependences", "MachNode::adr_type", "MachNode::get_base_and_disp", "PhaseChaitin::build_ifg_physical", "PhaseChaitin::remove_bound_register_from_interfering_live_ranges", "IndexSetIterator::advance_and_next", "PhaseOutput::BuildOopMaps", "OopFlow::make", "ResourceObj::operator new", "registerCleanupTrigger", "connectFlows", "LibraryIntrinsic::generate", "LibraryCallKit::try_to_inline", "LibraryCallKit::inline_Class_cast", "LibraryCallKit::load_klass_from_mirror_common", "PhaseValues::uncached_makecon", "PhaseIdealLoop::optimize", "PhaseIdealLoop::build_and_optimize", "PhaseIdealLoop::build_loop_late", "PhaseIdealLoop::build_loop_late_post_work", "ProjNode::is_uncommon_trap_if_pattern", "TypeNode::bottom_type", "PhaseOutput::install", "ciEnv::register_method", "nmethod::new_nmethod", "Klass::is_klass", "PreserveExceptionMark::PreserveExceptionMark", "jdk.internal.net.http.ConnectionPool$CleanupTrigger", "subscribe", "registerEvent", "wakeup", "sun.nio.ch.EventFD", "set", "JNI_ArgumentPusher::JNI_ArgumentPusher", "pthread_cond_wait", "nmethod::is_zombie", "ThreadsListHandle::cv_internal_thread_to_JavaThread", "curServiceUrl", "java.util.HashMap$KeySet", "java.util.HashMap$KeyIterator", "java.util.HashMap$HashIterator", "TypeInstPtr::add_offset", "TypeInstPtr::make", "ciInstanceKlass::is_instance_klass", "java.util.TreeMap$EntryIterator", "java.util.TreeMap$PrivateEntryIterator", "nextEntry", "successor", "jdk.internal.net.http.Http1Response$$Lambda$279.0x0000000800da2910", "jdk.internal.net.http.Http1Exchange$Http1Publisher", "sun.nio.ch.EPoll", "wait", "greaterThan", "java.util.Base64$Encoder", "encodeToString", "encode", "encode0", "encodeBlock", "jdk.internal.net.http.Http1Response$$Lambda$287.0x0000000800da16c8", "lambda$readBody$3", "PhaseCFG::implicit_null_check", "setHeader", "java.lang.String$CaseInsensitiveComparator", "compareToCI", "GangWorker::run", "GangWorker::loop", "G1EvacuateRegionsBaseTask::work", "G1EvacuateRegionsTask::scan_roots", "G1RemSet::scan_heap_roots", "G1ScanHRForRegionClosure::scan_heap_roots", "G1ParScanThreadState::trim_queue_to_threshold", "void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>", "void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>", "jdk.internal.net.http.Http1Response$$Lambda$296.0x0000000800dad1f8", "lambda$readHeadersAsync$0", "jdk.internal.net.http.Response", "SharedRuntime::complete_monitor_locking_C", "ObjectSynchronizer::enter", "ObjectMonitor::enter", "JvmtiExport::post_monitor_contended_entered", "LockTracer::MonitorContendedEntered", "LockTracer::recordContendedLock", "jvmti_GetStackTrace", "JvmtiEnv::GetStackTrace", "JvmtiEnvBase::get_stack_trace", "JavaThread::last_java_vframe", "vframe::new_vframe", "frame::sender", "frame::frame", "CodeCache::find_blob", "java.net.http.HttpHeaders$$Lambda$271.0x0000000800da7090", "lambda$headersOf$0", "jdk.internal.net.http.Http1Request$$Lambda$273.0x0000000800da7520", "test", "lambda$collectHeaders0$1", "RegionNode::pinned", "completeAsync", "jdk.internal.net.http.Exchange$$Lambda$278.0x0000000800da26c8", "lambda$sendRequestBody$7", "getResponseAsync", "readHeadersAsync", "thenApplyAsync", "java.util.TreeMap$KeySet", "keyIterator", "getFirstEntry", "PreserveExceptionMark::~PreserveExceptionMark", "lockingScheduler", "AllocTracer::send_allocation_in_new_tlab", "ObjectSampler::is_created", "one.nio.http.Response", "toBytes", "one.nio.util.ByteArrayBuilder", "length", "unknown", "os::javaTimeNanos", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$268.0x0000000800da67c8", "lambda$run$5", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$263.0x0000000800da5af0", "lambda$run$2", "resetInterestOps", "interestOps", "jdk.internal.net.http.Exchange$$Lambda$258.0x0000000800da4fb0", "lambda$responseAsyncImpl0$8", "jdk.internal.net.http.Exchange$$Lambda$216.0x0000000800d8ab50", "sendRequestBody", "sendBodyAsync", "appendToOutgoing", "_pthread_cleanup_push", "Java_sun_nio_ch_SocketDispatcher_read0", "ok.dht.test.kovalenko.utils.HashUtils", "getMurmur128Hash", "com.google.common.hash.AbstractHasher", "putString", "com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher", "putBytes", "java.nio.HeapByteBuffer", "selectNow", "epoll_wait", "allValues", "getEntryUsingComparator", "offerLastTemporaryDirectBuffer", "getAddress", "jdk.internal.net.http.HttpRequestImpl$$Lambda$223.0x0000000800d96548", "lambda$getAddress$5", "java.net.InetSocketAddress", "java.net.InetAddress", "getByName", "getAllByName", "java.util.TreeMap$KeyIterator", "java.util.stream.Sink$ChainedReference", "begin", "JavaThreadParkedState::JavaThreadParkedState", "parseRequest", "isValidValue", "jdk.internal.net.http.SocketTube$InternalReadPublisher", "signalSubscribe", "set0", "pthread_mutex_unlock@plt", "jshort_disjoint_arraycopy", "java.util.concurrent.ConcurrentSkipListMap$Values", "java.util.concurrent.ConcurrentSkipListMap$ValueIterator", "java.util.concurrent.ConcurrentSkipListMap$Iter", "one.nio.http.PathMapper", "find", "updateTables", "doGet", "cpr", "jdk.internal.net.http.Http1Response$$Lambda$289.0x0000000800dac000", "lambda$readBody$1", "ok.dht.test.kovalenko.dao.utils.PoolKeeper", "submit", "java.util.concurrent.AbstractExecutorService", "signalNotEmpty", "java.util.concurrent.locks.AbstractQueuedSynchronizer$Node", "getAndUnsetStatus", "getAndBitwiseAndInt", "Parker::park", "isValidName", "ThreadsListHandle::ThreadsListHandle", "newInvokeSpecial", "java.lang.invoke.DirectMethodHandle", "allocateInstance", "jdk.internal.net.http.ResponseTimerEvent", "jdk.internal.net.http.TimeoutEvent", "pthread_mutex_trylock", "jdk.internal.net.http.HttpConnection$TrailingOperations$$Lambda$292.0x0000000800dac928", "jbyte_arraycopy", "clearInterrupt", "reset", "drain", "parseHostname", "substring", "newString", "pthread_cond_timedwait", "addHeader", "dropSubscription", "readResumeHeader", "Compiler::compile_method", "Compilation::Compilation", "Compilation::compile_method", "Compilation::compile_java_method", "Compilation::build_hir", "IR::IR", "IRScope::IRScope", "GraphBuilder::GraphBuilder", "GraphBuilder::iterate_all_blocks", "GraphBuilder::iterate_bytecodes_for_block", "GraphBuilder::access_field", "GraphBuilder::append_with_bci", "ValueMap::find_insert", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject", "await", "java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode", "__errno_location", "writev", "sun.nio.ch.FileDispatcherImpl", "writev0", "Java_sun_nio_ch_FileDispatcherImpl_writev0", "jdk.internal.net.http.Exchange$$Lambda$297.0x0000000800dad430", "responseAsync0", "java.util.concurrent.locks.ReentrantLock$NonfairSync", "tryAcquire", "putStringAt", "java.util.Optional", "whenComplete", "uniWhenCompleteStage", "one.nio.util.URLEncoder", "decode", "WatcherThread::run", "WatcherThread::sleep",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(' + value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
