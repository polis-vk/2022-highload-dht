<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <style>
        body {
            margin: 0;
            padding: 4px 8px 24px;
            background-color: #ffffff;
            overflow-y: scroll
        }

        h1 {
            margin: 5px 0 0 0;
            font-size: 18px;
            font-weight: normal;
            text-align: center
        }

        header {
            margin: -24px 0 5px 0;
            line-height: 24px
        }

        button {
            font: 12px sans-serif;
            cursor: pointer
        }

        p {
            margin: 5px 0 5px 0
        }

        a {
            color: #0366d6
        }

        #hl {
            position: absolute;
            display: none;
            overflow: hidden;
            white-space: nowrap;
            pointer-events: none;
            background-color: #ffffe0;
            outline: 1px solid #ffc000;
            height: 15px
        }

        #hl span {
            padding: 0 3px 0 3px
        }

        #status {
            overflow: hidden;
            white-space: nowrap
        }

        #match {
            overflow: hidden;
            white-space: nowrap;
            display: none;
            float: right;
            text-align: right
        }

        #reset {
            cursor: pointer
        }

        #canvas {
            width: 100%;
            height: 300px
        }

        .selectionPart {
            position: absolute;
            display: none;
            pointer-events: none;
            box-sizing: border-box;
        }

        .sel {
            background-color: #dada0040
        }

        .act {
            background-color: #00da0040
        }

        .dif {
            background-color: #00dada40
        }

        .top {
            border-top: .1px solid #000
        }

        .left {
            border-left: .1px solid #000
        }

        .bottom {
            border-bottom: .1px solid #000
        }

        .right {
            border-right: .1px solid #000
        }

        #info-tooltip {
            display: none;
            position: absolute;
            top: 100px;
            right: 32px;
            width: 204px;
            border: 1px solid #666666;
            background: #ffffe0;
            border-radius: 8px;
            padding: 4px
        }

        #heatmap-height-line, #heatmap-info {
            text-decoration: #0366d6 dashed underline;
            cursor: pointer;
            font-family: monospace
        }

        #heatmap-info {
            cursor: help
        }

        #heatmap-info:hover + #info-tooltip {
            display: block
        }

        .colortip {
            width: 100px;
            box-sizing: border-box;
            padding: 4px;
            background: linear-gradient(var(--c1), var(--c2))
        }


    </style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none">
        <pre id="heatmap-height-line"> 1 sec : 20 ms </pre>
    </div>

    <div autofocus id='heatmap-canvas-container' style="width: 100%; position: relative">
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div class='selectionPart top bottom act' id='middleActive'><span></span></div>
        <div class='selectionPart top left bottom act' id='leftActive'><span></span></div>
        <div class='selectionPart top right bottom act' id='rightActive'><span></span></div>
        <div class='selectionPart right' id='leftMiddleActive'><span></span></div>
        <div class='selectionPart left' id='rightMiddleActive'><span></span></div>

        <div class='selectionPart top bottom sel' id='middleSelection'><span></span></div>
        <div class='selectionPart top left bottom sel' id='leftSelection'><span></span></div>
        <div class='selectionPart top right bottom sel' id='rightSelection'><span></span></div>
        <div class='selectionPart right' id='leftMiddleSelection'><span></span></div>
        <div class='selectionPart left' id='rightMiddleSelection'><span></span></div>

        <div class='selectionPart top bottom dif' id='middleDiff'><span></span></div>
        <div class='selectionPart top left bottom dif' id='leftDiff'><span></span></div>
        <div class='selectionPart top right bottom dif' id='rightDiff'><span></span></div>
        <div class='selectionPart right' id='leftMiddleDiff'><span></span></div>
        <div class='selectionPart left' id='rightMiddleDiff'><span></span></div>
    </div>

    <div id="heatmap-info"
         style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">
    BOr^AbCgDrHgJbKjLoOxRaTmUlVw[_\k]sgB????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????H?G?G@OG?G?Q?????H??HHHA???PAGIH???????G????H?@@??H???I?@A?@G?@?GH?GH??G?GGG??HP@?G??O?P@??G????@?@???????G??HHG@H?P??@@O@?????G@???G??G?@@GG?H?@@?G@AH?@G?PG????G?G??G????@??@@?G???GG??PGG??H@@??@?H?@AI??@G?G??AH??G?G@?A??G??PG?G?PG??H??@?GG?GG?@@?H?GGAO??G??B???@A?GH?GA@GG@?G?@H@??@G@GG@??G?@@@?G??O?G@G@@????@??O?G@@@@@A@H@?@??A?G??G@AB??G????HA?G@@@G??P@@A?H@HA??@@?GG??OH??G?A??@H??@?G??@?@??G??HAAH??????GHI?H?@G?@O?@@??@?H?G@??@????GG?@?@AG????@@?????G????????G?@???GG?@@?PG??????AGA?HH?@GG??@@?AA?@GA@?PG???H@@?HG?@?HP??GH@GG??G@@??G?@G??AOG?GA????G???GGG?@?H??GIGGG?JH??H@?@G??@????AG????????A???@?AHG????GGH@??@`@?HG??????@?O?G?G???@?GH???@?H???G??@??HG???G??@?@?@P?G?HGG?@@P?H?G@GG????GO????@?AOH@@G?GAAIG@?H??@@B?@???????@H?`G@?@G?GHG@G?G?@?O@??GOH???@B??????G?G??@G?@??H?A?@??G@@?@???A??G?HH??@@GHG?G@?GG???@IG?@O@@?G?@G@HG?G?@G?@??H?G@?G?????OP?????@GO?@G?G@HGHBG?@@?@??X??WG?@??O??G?IG?G??G????@?@X?H?G@GG???GHG@HO?G?G@G@@???@@@O@?G?I@@????GAG?@@??GI?@?@H?H@@A???G?@G@?@??@??@?@?H??G?@HG??G?@??@GGH?????????GG?H@??@?@???????????H@A??OG@GH?AG@?@??A?G@?GGG@GG??????H?O?G???GAGHPP?@?GH?????OAA@?@B?G?????G?G?A??@?G??@@?KG?R???@?GG???@@G??@G??O@????HGGG?GGH@HH@G?@?@GG@?@G@H??@??H@???@@??I?@G@@??@G@H???OG??G???G?G?@PG???@?G@??H?H??@???@@G@H?O?G?G????@@??G?GH?GA?H?G@???G??HO?H?O@O?@HH?@???G?@@@GG@@G?@H?H???O@G?O?@@G@H?@??H??@?????G?Q@??G???G@??H??@??@G??H??@H?OO???G@HG???@?HO???HG?@GH??G???@?I@???GGH??@@?GO?@?HGG@?H?AHA@?????H?G?G??G@@??AG?A@HG????W??B????????GH??GH?@@O?@@?@G??@HGGG?GnsAnsAstA`tA`fBivAkmBk~A`~Af|AteBdxAqnB|nBkfCkkCewAfhBupBuyAywBp~BkeCtcBjhBc_CrlB`tBxuBufCsxApcBrfBeuBfuBmvB}vAxdBbfBoiB`lBbnBepBfpBzwBf|Bo`CvdCssAbxAk{Az{A{~AocBkfBhjBemBgmBlmBynBxtBswBa|Bo|BdaCvgCupC`xCttAxuAfyApzA{{Ad}Aq}Aa`Br`BfcBcdBldBmeBueBbhBvhBjjB|jBouBpuB_vBgwB_xBnzBo{Ba~Bd_Cl_C~`CgaCocCwdC~eCmhCtrCkuCz{C_|CtsAjuAvuAvvA~vA`wAwwArxAmzA|zAe{As{Al|Av|Ad_BhaBzaBmcBsgB~gB{mBinBdoBvtBqvBuvB}wBhzBrzBzzBg{Br{Bu{Bx{B`~Bz~Bp_Cz_Cu`CjbC}bCgcChdCahCzhCiiC_mClmCgqCosCxsCytCkzCm|C|}Co~Cv_DysA|sAatAitAotAutAytAztA{tA}tA`uApuAzuA~uA_vAbvAdvAgvAjvAmvArvAyvAzvAbwAmwAtwAxwA}wA`xAexAkxAvxA`yAdyAiyA|yAizAnzArzAu{Aw{Ab|Ap|Aw|A`}Au}Ay}A}}An~Ao~Az~A__Be_Bf_Bd`Bf`Bh`B~`BaaBeaBwaBmbBxbBicBzcBgdBhdBpdB_eBgeBkeBlfBsfBbgBggBlgBmhBohBwhB{hBciBeiBziB|iB_jB`jBfjBsjBzkBalBvlBamBomBsmBzmB~mB_nBenBhnBnnBrnBunB`pBbpBhpBjpBzpB_qBeqBjqByqB~qBgrB|rB}rB`sBksB|sBbtBctBiuB|vBhwBvxBxxBbyByyB{yB~yB_zBezBpzBqzBl{Bt{B|{B`|Bm|Br|Bt|Be}Bj}Bq}Bs}Bn~Bs~Bu~Bx~Ba_Cm_Cn_Ci`Ct`Cx`C{`CfbCubCncCpdCpeCyeCmfCtfCkhCqhCxhCfiCpiCsiC~iC`jC~jCokComCvmC~mCanCjnCwnC`oCaoCpoCxoC_pCyqCfrC_vCnvCqvChwCnwCpwCtwCywCxyC{yC_zCazCd{Ct{Cf}C{}C__DfaDosAqsArsAusAvsAwsAxsAzsA}sA~sA_tActAdtAetAftAgtAhtAktAltAmtAntAptAqtArtAwtAxtA|tA~tA_uAbuAcuAeuAfuAguAhuAiuAkuAluAmuAnuAouAquAruAtuAuuAwuAyuA{uA}uA`vAavAcvAfvAhvAlvAnvAovApvAqvAsvAtvAuvAwvAxvA|vA_wAawAcwAdwAfwAhwAiwAkwAlwAnwAowApwAswAuwAvwAywAzwA{wA|wA~wA_xAaxAcxAfxAhxAixAjxAmxAoxApxAqxAwxAxxAyxAzxA{xA}xA~xA_yAbyAcyAeyAgyAhyAjyAkyAlyAmyAoyAqyAryAsyAtyAvyAxyAyyAzyA{yA~yA_zA`zAazAbzAdzAezAfzAhzAjzAkzAlzAozAqzAszAtzAuzAvzAwzAxzAyzAzzA{zA}zA~zA_{Ab{Ac{Ad{Af{Ah{Ai{Aj{Al{An{Ao{Ap{Aq{Ar{At{Av{Ax{Ay{A}{A~{A_|A`|Aa|Ad|Ae|Ag|Ai|Aj|Ak|Am|An|Ao|Ar|As|At|Au|Ax|Ay|Az|A{|A}|A_}Aa}Ac}Af}Ag}Ah}Aj}Ak}An}Ap}As}At}Aw}Ax}A{}A|}A~}A_~Aa~Ac~Ad~Af~Ag~Ah~Ai~Aj~Al~Ar~As~At~Au~Aw~Ax~Ay~A|~A}~A~~A`_Ba_Bb_Bc_Bh_Bi_Bk_Bl_Bm_Bn_Bo_Bp_Bq_Br_Bt_Bv_Bw_Bx_By_B{_B}_Bb`Be`Bg`Bi`Bj`Bk`Bl`Bm`Bn`Bo`Bq`Bs`Bu`Bv`Bw`Bx`Bz`B{`B}`B_aB`aBbaBcaBdaBfaBgaBiaBkaBmaBnaBpaBraBsaBtaBuaBvaBxaByaB{aB}aBcbBebBfbBgbBhbBibBkbBobBpbBqbBrbBtbBwbB|bBacBdcBecBjcBkcBlcBncBucBycB|cB~cB`dBbdBedBjdBkdBndBodBrdBsdBvdBwdBzdB|dB}dB~dB`eBaeBbeBceBdeBeeBfeBieBleBneBqeBreBseBweBxeByeBzeB{eB|eB~eBdfBefBifBjfBofBpfBqfBufBvfBwfBxfByfB{fB|fB}fB~fB`gBagBdgBegBfgBhgBigBkgBmgBngBpgBqgBrgBugBvgBxgB{gB|gB}gBahBdhBehBlhBnhBphBqhBrhBshBthBuhByhBzhB}hB_iBaiBgiBhiBiiBjiBkiBliBpiBqiBriBsiBtiBuiBviBwiBxiB{iB~iBbjBcjBijBkjBmjBojBqjBrjBtjBvjBwjBxjByjBzjB{jB~jB_kBakBckBdkBekBfkBhkBikBkkBmkBokBpkBskBukBvkBxkBykB{kB|kB}kB_lBclBdlBflBglBhlBilBjlBklBllBolBqlBtlBwlBylBzlB{lB|lB}lB~lB`mBbmBhmBnmBpmBrmBumBvmBymBanBdnBfnBgnBknBmnBtnBvnBwnBxnB{nBaoBeoBgoBhoBioBjoBkoBloBmoBnoBpoBroBsoBuoBvoBxoByoB{oB|oB_pBapBcpBdpBmpBnpBopBppBrpBspBtpBvpBxpBypB{pB}pBaqBbqBcqBdqBfqBhqBiqBkqBnqBoqBpqBqqBtqBuqBvqBxqB{qB|qB}qB`rBarBbrBcrBdrBfrBkrBmrBnrBorBqrBrrBsrBurBvrBzrB{rB_sBasBbsBdsBesBhsBisBjsBlsBmsBnsBosBpsBrsBssBtsBusBwsBxsBysBzsB{sB}sB~sB_tBdtBetBgtBhtBjtBmtBotBptBrtBttBwtBytB{tB}tB~tB_uBauBbuBcuBduBkuBluBmuBnuBsuBuuBvuBwuByuB{uB|uB}uB~uB`vBbvBcvBfvBgvBhvBivBkvBnvBrvBtvBwvBxvBzvB}vB~vB`wBbwBcwBewBmwBowBqwBrwBtwBwwBxwB|wB`xBbxBdxBexBgxBhxBixBkxBlxBnxBoxBpxBrxBsxBtxBuxBzxB{xB|xB}xB~xB_yB`yBcyBdyBeyBfyBgyBiyBjyBkyBlyBmyBpyBqyBryBtyBuyBvyBwyB}yBazBbzBdzBfzBgzBizBkzBmzBozBtzBxzB}zB~zB`{Ba{Bc{Be{Bf{Bh{Bj{Bm{Bn{Bq{Bw{Bz{B{{B~{B_|Bc|Be|Bh|Bi|Bk|Bn|Bp|Bs|Bv|Bw|By|Bz|B{|B}|B~|B_}B`}Bb}Bc}Bg}Bh}Bi}Bm}Bn}Bo}Bp}Bt}Bv}Bw}By}Bz}B{}B|}B}}B~}B_~Bd~Bf~Bg~Bh~Bj~Bl~Bt~By~B|~B~~B__C`_Cb_Cf_Cg_Cj_Ck_Co_Cq_Cs_Cu_Cw_Cx_C{_C|_C}_C~_C_`Ca`Cb`Cc`Cf`Ch`Cj`Ck`Cn`Cw`Cz`C}`C_aC`aCaaCbaCeaChaCjaClaCmaCoaCpaCqaCsaCuaCvaCwaCxaCzaC|aC~aC_bC`bCabCbbCebChbCibClbCmbCobCrbCsbCtbCxbCybCzbC|bC_cCacCfcCicCkcCmcCpcCrcCscCvcCwcCxcCycC`dCadCbdCcdCedCfdCgdCjdCkdCmdCndCqdCsdCudCzdC|dC}dC~dC_eC`eCbeCgeCieCjeCleCoeCqeCreCseCueCveCweCxeC_fC`fCafCcfCefChfCofCqfCrfCsfCxfCyfCzfC{fC|fC~fC`gCbgCdgCegCfgCggChgCigCjgClgCmgCngCogCpgCrgCsgCugC~gC_hCbhCchCehCfhCghChhCihClhCohCphCrhCthCvhCwhCyhC|hC}hC~hC_iC`iCciCdiCgiCmiCniCoiCriCuiCviCwiCxiCziC{iC}iCbjCdjCgjCkjCljCmjCojCpjCtjCwjCyjC{jC|jC}jC`kCbkCdkCekCfkCjkCmkCqkCrkCtkCukCvkCwkCxkCykCzkC{kC|kC}kC_lC`lCblCdlCglChlCjlCklCmlCnlColCslCtlCylC{lC~lCamCcmCemCgmChmCkmCmmCsmCymC{mC|mC_nCdnCenCgnChnCinClnCnnCpnCrnCunCvnCxnCznC|nC~nCcoCeoCfoCgoCjoCmoCqoCtoCvoC{oC}oC`pCapCcpCdpCfpCgpChpCipCjpCkpCmpCnpCppCqpCrpCvpCxpCypCzpC_qC`qCaqCbqCcqCdqChqCjqCkqClqCnqCoqCtqCvqC{qC`rCarCbrCdrCirCkrClrCnrCorCprCqrCurCwrCyrC{rC`sCcsCfsCgsChsCjsCksClsCmsCrsCtsCvsCwsC`tCatCbtCctCetCftCgtCitCktCltCmtCntCqtCrtCvtCwtC{tC|tCduCfuCiuCluCmuCouCsuCtuCuuCvuCwuCzuC|uC}uC~uCavCfvCgvChvCjvClvCmvCovCsvCtvCuvCwvCyvCzvC{vC}vC~vC_wC`wCfwCjwCmwCowCqwCswCwwC{wC}wCaxCbxCcxCdxCgxChxCkxClxCnxCoxCuxCvxCzxC{xC}xC~xC`yCayCbyCdyCiyClyCqyCryCsyCtyC~yC`zCbzChzCizClzCnzCozCqzCzzC{zC|zCa{Ci{Ck{Cl{Cm{Cr{Cu{Cw{Cy{C|{C`|Cd|Ci|Cl|Cn|Cq|Cr|Cs|Cv|Cw|C{|C~|C`}Ca}Cc}Ce}Cj}Ck}Cl}Cm}Co}Cp}Cv}C~}Cb~Ce~Cf~Ch~Ck~Cl~Cm~Cp~Cu~Cz~C}~Ca_Dc_De_Dh_Dj_Dk_Dl_Do_Dq_Dt_Dx_D|_D~_De`Df`Dg`Dk`Dl`D}`DcaDgaDhaDsaDtaD{aD|aD}aDgbDibDlbDsbDxbDybDzbD{bDicDmcDhdDmdD{dD|dDfeDoeDqeDseDueDweD~fD`gDpsA{sAbtAjtAvtAauAduAsuA|uAevAkvA{vAgwAjwAqwArwAgxAlxAnxAtxAuxA|xAayAnyApyAwyA}yAczAgzA`{Aa{Ag{Am{A|{Ac|Ah|Aq|A||A~|Ab}Ae}Ai}Al}Am}Ao}Ar}Av}Az}Ab~Ae~Am~Ap~Aq~Av~Ag_Bj_Bs_Bu_Bz_B|_B~_B_`B``Bc`Bp`Bt`By`B|`BjaBlaBoaBqaB|aB~aB_bB`bBabBbbBdbBjbBlbBnbBsbBubBvbBybBzbB{bB}bB~bB_cB`cBbcBccBgcBhcBqcBrcBscBvcBwcBxcB{cB}cB_dBadBddBfdBidBmdBqdBtdBudBydB{dBheBjeBoeBpeBveB}eB_fBafBcfBffBgfBhfBmfBnfBtfBzfB_gBcgBjgBogBtgBwgBygBzgB_hB`hBchBghBhhBihBkhBxhB|hB~hB`iBbiBdiBfiBmiBniByiB}iBajBdjBejBgjBljBnjBpjBujB}jB`kBbkBgkBjkBlkBnkBqkBrkBtkBwkB~kBblBelBmlBnlBplBslBulBxlB_mBcmBdmBfmBimBjmBmmBqmBtmBwmBxmB|mB}mB`nBcnBjnBlnBonBpnBsnBznB}nB~nB_oB`oBboBcoBfoBooBqoBtoBwoBzoB}oB~oBgpBipBkpBlpBqpBwpB|pB~pB`qBgqBlqBmqBrqBsqBwqBzqB_rBerBhrBirBjrBlrBprBtrBwrBxrByrB~rBcsBfsBgsBqsBvsBatBftBitBktBltBntBqtBstButBztB|tB`uBguBhuBjuBquBruBtuBzuBavBdvBevBjvBlvBovBpvBsvBvvByvB{vB_wBawBdwBfwBiwBjwBkwBlwBnwBpwBuwBvwB{wB~wBaxBcxBfxBjxBmxBqxBwxByxBayBhyBnyBoyBsyBxyBzyB|yB`zBczBjzBlzBszBuzBvzBwzByzB{zB|zB_{Bb{Bd{Bi{Bk{Bp{Bs{Bv{By{B}{Bb|Bd|Bg|Bj|Bl|Bq|Bu|Bx|B||Ba}Bd}Bf}Bk}Bl}Br}Bu}Bx}Bb~Bc~Be~Bi~Bk~Bm~Bo~Bq~Br~Bv~Bw~B{~B}~Be_Ch_Ci_Cr_Ct_Cv_Cy_C``Cd`Ce`Cg`Cl`Cm`Cp`Cq`Cr`Cs`Cv`Cy`C|`CcaCfaCiaCkaCnaCraCtaCyaC{aC}aCcbCdbCgbCkbCnbCpbCqbCvbCwbC{bC~bC`cCbcCccCdcCecChcCjcClcCqcCtcCucCzcC{cC|cC}cC~cC_dCddCidCldCodCrdCtdCxdCydC{dCaeCceCdeCeeCfeCheCmeCneCteCzeC{eC|eC}eCbfCdfCffCgfCifCjfClfCnfCpfCvfCwfC}fC_gCagCcgCkgCqgCtgCwgCxgCygCzgC{gC|gC}gC`hCdhCjhCnhCshCuhC{hCaiCbiCeiChiCjiCkiCliCqiCtiCyiC|iC_jCajCcjCejCfjChjCijCjjCnjCqjCrjCsjCujCvjCxjCzjC_kCakCckCgkChkCikClkCnkCpkCskC~kCalCclCelCflCilCllCplCqlCrlCulCvlCwlCxlCzlC|lC}lC`mCbmCdmCfmCimCjmCnmCpmCqmCrmCtmCumCwmCxmCzmC}mC`nCbnCcnCfnCknCmnConCqnCsnCtnCynC{nC}nC_oCboCdoChoCioCkoCloCnoCooCroCsoCuoCwoCyoCzoC|oC~oCbpCepClpCopCspCtpCwpC{pC|pC}pC~pCeqCfqCiqCmqCpqCqqCrqCsqCuqCwqCxqCzqC|qC}qC~qC_rCcrCerCgrChrCjrCmrCrrCsrCvrCxrCzrC|rC}rC~rC_sCasCbsCdsCesCisCnsCpsCqsCssCusCysCzsC{sC|sC}sC~sC_tCdtChtCjtCotCptCstCttCutCxtCztC}tC~tC_uC`uCauCbuCcuCeuCguChuCjuCnuCpuCquCruCxuCyuC{uC`vCbvCcvCdvCevCivCkvCpvCrvCvvCxvC|vCawCbwCcwCdwCewCgwCiwCkwClwCrwCuwCvwCxwCzwC|wC~wC_xCexCfxCixCjxCmxCpxCqxCrxCsxCtxCwxCxxCyxC|xC_yCcyCeyCfyCgyChyCjyCkyCmyCnyCoyCpyCuyCvyCwyCyyCzyC|yC}yCczCdzCezCfzCgzCjzCmzCpzCrzCszCtzCuzCvzCwzCxzCyzC}zC~zC_{C`{Cb{Cc{Ce{Cf{Cg{Ch{Cj{Cn{Co{Cp{Cq{Cs{Cv{Cx{C{{C}{C~{Ca|Cb|Cc|Ce|Cf|Cg|Ch|Cj|Ck|Co|Cp|Ct|Cu|Cx|Cy|Cz|C||C}|C_}Cb}Cd}Cg}Ch}Ci}Cn}Cq}Cr}Cs}Ct}Cu}Cw}Cx}Cy}Cz}C}}C_~C`~Ca~Cc~Cd~Cg~Ci~Cj~Cn~Cq~Cr~Cs~Ct~Cv~Cw~Cx~Cy~C{~C|~C~~C`_Db_Dd_Df_Dg_Di_Dm_Dn_Dp_Dr_Ds_Du_Dw_Dy_Dz_D{_D}_D_`D``Da`Db`Dc`Dd`Dh`Di`Dj`Dm`Dn`Do`Dp`Dq`Dr`Ds`Dt`Du`Dv`Dw`Dx`Dy`Dz`D{`D|`D~`D_aD`aDaaDbaDdaDeaDiaDjaDkaDlaDmaDnaDoaDpaDqaDraDuaDvaDwaDxaDyaDzaD~aD_bD`bDabDbbDcbDdbDebDfbDhbDjbDkbDmbDnbDobDpbDqbDrbDtbDubDvbDwbD|bD}bD~bD_cD`cDacDbcDccDdcDecDfcDgcDhcDjcDkcDlcDncDocDpcDqcDrcDscDtcDucDvcDwcDxcDycDzcD{cD|cD}cD~cD_dD`dDadDbdDcdDddDedDfdDgdDidDjdDkdDldDndDodDpdDqdDrdDsdDtdDudDvdDwdDxdDydDzdD}dD~dD_eD`eDaeDbeDceDdeDeeDgeDheDieDjeDkeDleDmeDneDpeDreDteDveDxeDyeDzeD{eD|eD}eD~eD_fD`fDafDbfDcfDdfDefDffDgfDhfDifDjfDkfDlfDmfDnfDofDpfDqfDrfDsfDtfDufDvfDwfDxfDyfDzfD{fD|fD}fD_gDagDbgDcgDdgDegDfgDggDhgDigDjgDkgDlgDmgDngDogDpgDqgDrgDsgDtgDugDvgDwgDxgDygDzgD{gD|gDu`@??????@???@@?@?????@?rBG????F?N??A????????????????jAG??@??E????E?@q@N@@?QnA??jA^@oB???A?????sQ@?@eAAQ?@?yB???@~D?Q?@?t@w@UbF?JG@D?iAuFCe@????He@?FQ??GC?ND??D??E?@@?qA?????z@eA?u@uFJ?s@??@??FqA?h@??cG?Q?Eh@???@?wA?E??RtKH?`CZF?F?a@?@??Fv[?oB{@????@^p@?oBtA?Ne@?mGh@???????^?P?w@?AxA????U?cCACkHf@}@?rGJ?E??^?????lCfHE?gH^?wHu@?a@CNjA?xb@??a@J???~BDJF????NHC{@p@nA_@?}]QWWt@}K?~A@?A??b\AcCrG?pHA???_@?qb@?tAvAZUu@rA?nC????E?HD??AqA?jC??A?jAtS??w@nTp@???xA?_@md@m@@Q?E@Uib@kV@w@?cC?Ah@?h@HsCz@}@LHF?wADeHCN?aH?RTeAF@PF?f@f@}Aj\??s_@@?~@iH?G?_h@?wPAEzH?t@????@e@}A}A?Fq@C?L?~@~@Ph@de@A??Plc@??A?@he@?ni@rB??rA?nArA?Hch@RJN?_A??LEmC?qe@?_B{@@wB@D???a@}FyBW?J?AlCnCwB?q@lP?`BP??f@xh@lW?xFa@?vC??RkH?^D??n_@}@RyBwGu@Wa@Tm@?Aaa@D?jCF?`A{@p@@??t@Pkb@?D?w@dBfH?Qt@AGgIZpHsC??QmCTw_@HGTfl@GpCUe@?gH@??q@mG?|F?rB?s@fk@vAJ?Fl@GDLRtA_i@?xC?`C@C?~@@?vA??@`m@}F~BDm@C_Ate@wA?uh@mh@@Nz@C?_\@WeI{@an@bm@s@?dB?`G??~A`AD@m@?zk@?fCZyUQeBm@rA?AL?q@CL?_J?P?zn@jMLaJCwGvG_AbBcIJeH?aAAeB?z@??{F?cGLNHaAcc@HbFfC_BpC_BqE?J~A??AtAfo@`BdB????`S|F?G??GWl@UsC@ZJ?D?ga@~@AZ?L|k@~A??GU_AR??C???qAiA?pC|C{F__@s@?f@CgB??s@CC?xAPa@EtI}@dp@_@bB??aA_A|g@fBD?@?mp@lC`A?mm@?E~BF?q[?hUTtR?bp@?RA@mCeB?@?Gjj@pa@?u@|SbBwImb@?}@~CvA^HqE?dB?jk@fCfBAU??nk@@vCeAxAT`RsI??gB?nChJ??xC@?fJC??L??p@Wrd@@pq@?vG?gBiA?iH?eIzH?z@?jJ}CwB?sI?i`@?aHtIgI??@@?wI@JfJxF|o@H?vCC?e@?D?~DcIfBwH?@}Cm@l@AfB??~o@?`Bl@D~_@CT`A???xq@kq@`C@~C?fT?TDR?~C?aAlJpp@`BhJ?fr@@?FP`JkJTT?kJL_d@{m@Efd@l@xC_DwAW_a@{`@?Jsa@AWC@~k@R|CZE_D???AaALjJ@`Ga[gq@P?_@og@_@PH?_JlJ?eBEnA_D_@NHbBl@D?`AD?ZGaJoq@Ujo@jCf@?}A?gB?@}C_B|C??`JiA???A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?RmJBnJS?T?U?V?W?X?Y?Z?[?\?]?^?_@?`@?a@?b@?c@?d@cDC?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@?o@?p@?q@?r@?s@?t@?u@n@v@?w@?x@?y@lKE?z@?{@?|@?}@bADn@FpJHrJJaDL?~@?_A?`A?aA?bA?cA?dA?eA?fA?gAbAe@fKi@hDk@?hAjDiA?jA?kA?lA?mA?nA?oA?pAuKEhBGqJIsJK?qAjBaAcArA?sA?tA?uA?vA?wA?xA?yA?zA?{A?|A?}A?~A?_B?`B?aB?bB?cB?dB?eB?fB?gBbASxJUzJW|JYdDhB?iB?jB?kB?lB?mBsDFvKItDLxK_AeLbA{KdA?nB?oB?pB?qB?rB?sB?tB?uB?vB?wB?xB?yB?zB?{B?|B?}ByLGcLJaDqAzDrAgLtAhLvA?~B?_C?`C?aC?bC?cC?dCeMHwKKdL`AzKbA?rAhMuAiLwAkByAlL{A?eC?fC?gCnDh@gDj@?hC?iC?jC?kC?lC?mC?nC?oC?pC?qC?rC?sCtMi@~KhApDjA?tC?uC?vC?wC?xCdKd@\ItDqAgMsAuDuAoMxAkLzAvD|A?yC?zC?{C?|CbNc@nDf@eKh@aEk@gKm@hKo@kD}C?~C?_D?`D?aD?bD?cD?dD?eD?fD?gD?hD?iD?jD?kD?lD?mD?nD?oD?pDfDqD?rD?sD?tD?uD?vD?wD?xD?yD?zD?{DcD|D?}D?~D?_E?`E?aEcNJfM`A`ErAnMvAjLxAgN{AwDbEb@`B?cEnLbB?dE?eE?fE?gE?hEiOKtJ~@yK`A`EcAmDnBnBpB}LrB_MtB|DiE?jE?kExLd@rLTyJV{JX}JZ?lE?mE?nE?oE?pE?qE?rE?sE?tE?uE?vE?wE?xE?yE?zEwLmBzOUsLX|OlEtB{E?|E?}E?~E?_F?`FfALzL`AtOdA|KaF?bF?cF?dFfAqAdNtA_EwApMzAvDeFfPlBgA~@sOaAcAcAmDeA?aFoPfF?gF?hFqP`AjOsAeNvAlOyAqM|A?bEb@iF?jFoEaAfLsAxPwArP{AnO_BlBcEhEdEiEkF?lF?mF?nF\oFjBpF?qF}Mj@iDhA~MrF?sFb@tF?uFbAvF?wF?xF?yF?zF?{F?|FfDh@gD}F?~F?_Gr@Dn@`GcAaG?bGuDcG?dG?eG?fG?gG|PbAmMsA}PxAmO|AzP_B_QaBmBcBxDhG?iGtQrAkOwA~P|A?jG?kG?lG?mGhPV{OYdDlEtBnE_PpEkErE?nGb@oG?pGhQwFiQyFkQ{Fr@e@oD}FnQ_GoQE?`GqQbGvBqG?rGkBsGvJQ|QsAuQyApEbE{PjFaRWtLZ}OmE?{EjPtG?uG?vG?wGdRxFjQzFsE|FlQi@?}FfR|FoJEgRbA?aGrQtA?cG?xGkByG?zGoRXiPmEqR|EmE{G?|GrEk@_Lm@?iA?}GiB~G?_Hr@`H?aH?bHlDcH?dH?eH?fH?gH?hH?iHpBjH?kH?lH?mH?nHaShApD}GcS_HeSaHgSEhBcHhSeHxBoHo@pHIqH?rH?sH?tH?uHgAvHdApHIwH~RYbRmE~OoE`PqE?xH?yH?zH?{HlSm@bSjAqD|HaLnAbLpAmRtA_E~BiM}H?~HsMd@zSuAfNyApE}AmL_BlBaBmBdEiEfErOhE\_I}RzGkAvAyPzAdE`Ib@aI?bIhA_AzDcAuPaF?cI?dIdPwE?eI?fI?gI?hI?iI?jI?kI?lIwSZpRnEcRqE_FmI?nIlAlEtBoI?pI?qIcFmE_S}EkPrI?sI?tI?uIyDlB]wA}QbEb@vI?wIgAxIrS|B?yIuNhDvNjDxNlDzNnD|NpD~NrD?zI?{I?|I?}I?~I?_J?`JySiA`LrFeQ_BlBaJyQdB?hG{QgBmAnEgTrEaPtEcPvEuBxEePzEgPd@fFjAqDlA?bJ?cJ?dJ?eJ?fJ?gJ?hJ?iJ?jJvS|B?kJ]~B?lJ?mJ}ToExSnJ?oJtEpJ?qJ?rJhOaElA[~J]`KsJ?tJ?uJ?vJ?wJmTxAvQ}A`F`B`QeE?kFbQmFfF}GmS|F?`HfSbH}EdHiSfHjSxJ?yJ?zJhF\_K{J?|J?}J?~J?_KyT`JoArF{T`B?aJ~SeEqOgEiFyAnR_BxQbBoLdB|TiGoA`K?aK{SgC?bK?cK?dK?eK?fK?gK?hK?iKjF]?{J?jK?kKaVzAdEyChN{CjNxCpA{AwD}AoUaBgFhGO|AwQ`BoOaBmBlK?mK?nK?oK?pK?qK?rK?sK?tK?uKaT`AmPnBvOqB~LsB`MuBaMwB}DvKaFwK?xK?yK?zK?{KmAoIhTqI{B{JzU}J|U_K?|KzB}KsPmBkMcC~UsFsBaJgFeBqLgBlNg@oDj@iDl@jDn@iKp@?}CpN_D?~K?_L?`L?aL?bL?cL?dL?eL?fLmA{ErRgL?hLoFaAtPdAnPiLd@_C?}HeVd@OeF~Vd@?jLgEkL?lL?mL?nL?oL?pL?qL?rLsUu@n@~GdS|FtUaHoSF?cHqSfH?sLr@tL?uL?vL?wLIxLtWE?~GuW`HuUEpSdHwUsLsAyL?zL?pHI{LuRyFwE|FzE}FxRDpQbAzRbGvBdGvEfG}W~G~WaHwWcHyWsLsA|L?}LdA~L?_M?`M{MsCiUpEkEaMbDbM?cMcFdM?eM?fMVbEsBcEhElKoVnKpVpKrVaDsNcDfEeDmWbA{LeAnEiLOgMeDhM?iMoXqE_FjM?kM?lM?mMaWh@mNl@dWo@kDq@jKs@?nM?oMV}A`FpM{WwLIqMcY~AsBaBlFfEVyClV|CkNd@yXcAuOoB{DrMlRReY_B}SbBpOeE`VhE{BsM?tM?uMfYdA|LoB{DqBwVtB|DvBbMxBcMzBdM|B~FeAnEvM?wM?xM{B^aK`@bKb@rX_BbVlKtXoKqVqKrNbDpBdDtNfDvF|EmE~E?rI?yMlTmB}B}EjTsI?zMrYd@fUhJgU{M?|M?pJjUrJv@zCiN|CXrE?}M?~M|BaF?vM?_N?`N?aNrF|J{U~JkF_JzTd@v@bN?cN?dN?eN?fN?gN?hN?iN?jN~FnBvVrBjEuB?iExOkEzX`@?hM{Xc@hX_HnSbHvUeHxBsLsAkNbDOfZ|FvWbHgZfHzW|F?tL?lN?mN?nN?oNpXcM`W_B?oGXxH?pNdG~EqYsIdFqN?rN?sNyDtNg@`BnVbBcVeB\uNkRPwJRpTiDwNkDyNmD{NoD}Ne@?qDqBvN?wNBxNjZ`H_XFxWdHaX|FgGyN?zN?{NV|N?}N?~N?_OnWzEaZoBjYrBjE`O?aOxDeB}Xi@hDbO?cOc@dOy@eO?fOoAtC_NvCaNxCe[j@cWm@oNp@fW~CeE~KiW`LsFgO?hO?iO?jO?kOKlO?mOnGlBb[pBwOsBpFiE?nO?oO?pO?qOlMdCqGqBkYrOc[dBpLfBlGaHiXsOnBtOrZcEsXmKnFoKbGrK?uO?vO?wO}BtGsRxOh[jFtZxA?sGVyO?zOc@{OdXzFvRe@xE|OtE|F{EF?}O?~O?_P?`P?aP?bP|[aBmFmKnFcPbUdJdUfJiGjM|XdP?eP?fP?gP?hP?iP?jPs[mBuY{CmVc@KbF?kP?lP~EmPtVtKoGk@nNn@eW}CgW~KpGaL?gOn[iOp[kOc\{FeRh@mQ~F?nP?oPdZhMeZd@iGpP?qPk\bBgYkFrUnFx@`BpUkF_ClKnYpKvXbDpYeDrEhCuMjCbElCdAnCyMpCzMrC|Md@oAkA?rPYsPjGrIkTtI?qNoZsNy@tPsVsKuVuKXnJ?uP?vPXwP?xP}ByPo@zPyF`MnXd@aG_@eDa@cKc@d]mKl\cJcUeJeUnFqF{P?|Pg@iFv]nKuXqKo]tKn]rKx\uKpA}Py@sEbPuEaFxE?~P?_Qz[bH}EsOnB`Q?aQ{]oKbGaDwXdDObQwYbI`]iMc]aBmFhDw]dJn\nFOcQ?dQ?eQXaMvZjDqTmDxZpDeFzI?fQ?gQ?hQ?iQYfF?jQ?kQ?lQ?mQw[rBbZnQ?oQ?pQd^c@g@tFgQjFy\l@~Xp@?qQ?rQ?sQu\d@`@lAaUcJx]fJe^bBb]lFcQnF~EsHsSuHq^m@k[q@`Yt@iBv@nKx@pKu@n@z@rK|@j@tQvLkBv@uQ?vQ?wQ?xQ}\|FeX|Od\DlD}OuGyQ?zQ?{Q?`QhA|Q?}Q?~Q?_R?`R?aR?bRp^uFd@cR?dRsTe@bWbO?eRBfRg[fOpAgR?hRjWcL?iR?jRwFkRv^n@z\~CeElR?mR|VwJlAnR?oR?pR?qR?rRk_@dR~Gh@aEbO?sR?tR?uR?vR?wRx_@oRy_@qR{_@d@V`IfQuF?xRj@yR?zR?{R?|Rt[pOu[cCqFpIiT_B?tF_`@_B?pMdY|B?qMa^E`XeHhZ|FgGlNhG}Rc@~R}^vQ~^xQdCF{ZeHxB_S?`Sm^sBpFaS?bSxY}J{V|KeGiJ?{MsYpJtY`Ep]xP``@cC|]sK`_@e@xEcSBdS_CcBd[fBj`@tB?`Ox[eByGsIdFuIqZpAeCcHjX|F}ZzNhCdH|ZtLlZmNmZoNc`@eS?fS?gS?hS?iSuAuP?jS?kS?lS?mSo\kM?dPp\fPr\hPt\jPfVcKgVnShVhKjVd@_WdCb^pKe]cDxXfDt_@_QKoS?pSv_@|Ku_@o@_Yr@kKt@x^w@oKy@iBz@{^}@~]NuJPhYtMiYd@v\|CKqS?rSeCsS?tS?uS_CdEaQlFiCeHg`@tL?vS?wSg@xS?yS?zSlH{S?|S?}ShA~Sc@_ThH`T?aT?bT?cT?dT?eT?fT?gT?hT?iTb`@|R`@|H?yRa`@{Rq`@h@~\_GyE`GhRtA|EdGvEjT?kT?lTj@mArDoA`a@qKoYcDnHfHkZtLv`@nNnZN?bMKvM?mT?nTqHrK}[vO~`@dK?oT?pT?qTuLjBtHuO~[wOzArOg^eQo^d@zAuB?aSk`@d@l`@~JkF|Ki@xSra@zSx@pMdHqMlb@_K}Ud@bCcBs`@gBbHrT?sT?tTaCaO~a@i@wRcSk@uTaGsJlUuJnUwJj@vTvH|KKwTpP{Di^kDwZnD~GqDqBzIuT|IwT~I`@xTKyT?zTzB{Tub@kB?tNi@`B_VbBsZfBy@nGvb@wJYcFxGuO?|T?}Tr`@dBy[gBO~TyGyMr[mOY_U?`UgCtIl]rNpZkB_c@pAvH_JtGsG{AvTyAiF|BaUma@RsH_NvPhFa]qPv@}N?bU?cU?dU?eU\fU?gU?hUzQiG{HqNm]kBjFiUr]_M?jU?kUx@tFyb@lDrToDkGqDqBsD`OuD?lUwE|MfGqJkU`EyHhG}G}Qe_@_Rg_@aRi_@rC?mU?nU?oU?pUSgH?qUka@xCeO}DfO_E|BfA\rUBsUlAhBgb@kB`d@c@kCeK?tU?uU?vUgAwUuZQ}b@zTfAxUhd@Ra\zOd@yU?zUva@bTwa@dTya@fT{a@hT}a@{Rhb@vOrb@}F?|O_]oPoH|SX{U?|Uia@Qnd@|Uod@RlGz@?}U?~U?_VX`VBaVqc@zB?zPs]rCXbV?cVpb@sTmAdV?eV?fV?gVtHsKj@bJm\eJg]iCvMkCwMmCxMoCcEqC{AyR?hV?iV?jV`@rP`@kV_[}N`[_Oob@dB?lVBmVSsLsAuLdHxLld@wOca@p@l[_DhWnV?oV?pV?qV?rV?sVbClKgEnK?cPyd@fJVtV?uV?vVBwVj@xV?yV?zViFsGed@d@S{VB|VK}Vwd@tKoCqUeb@wOrCzRrC~V?_W?`WqC~Fa_@EyRaG{RcGuEaW?bW?cWjd@zUbd@gAd`@qIu^tHce@|Fu`@{NoCxJxUzJi[uC`NwCg@vIad@~DgO`Ej_@jFpe@uKhc@jFna@eEqUlFk@dW?eW?fW?gW?hW?iWze@tL?yN?jW?kWlX_MmXrCuAoJt]`@mYc@v@lWvYxCgf@{Cw\d@aB}C{\_L?mW?nW?oW?pW?qW?rWOsW?tW?uWo@vW}c@sCrChV~d@jV`IuOrFjK|e@vCj[c@wf@wCz]jFre@{R~b@_QnHwW?xW?yW?zW?{W[kNqC|Ove@|W?}WS~WyYcNzYeN|YgN~YiN`ZkBdC|W`c@aJlFkF`e@zEx@iF|AvB?_X}DyBo@{BI}BaBqQr^sQzf@_GyEFf\~O?yQd_@{Q?tOac@_Bf`@vL|W|BdItNzA`Ot`@fB|_@oDkGh@_H`X?aXYbXlg@dQh^nFqHaDc^eDxe@_Be`@uF}HfKjHiKgd@xA`\Pi@iF[yN~Z{N~HbMScX?dXr@eX?fXrHbMyApMKgXh\aPqg@bDf]fDtg@jFp_@hRq_@iR|AiEcZmBaBq@w^u@mKw@fa@u@z^{@sK}@eChX?iX?jXhHfSx`@hSm`@{Mn`@qJzc@aEcd@iB|^lB|@kXBlX}g@r@da@u@~g@x@y^EqK{@]mXBnX{GgFid@xAsg@QoHoX?pXlf@pWnf@rWiIdXvg@fXxg@cM}e@_Eeg@rQs^iQzd@jCbEqXzZmCcX|B?xNeGrX?sXzb@rD?tX?uX?vX?wXxc@pJo`@aElIpXkh@qWof@nFja@uMyHeBg@pMuCpMcBxX?yX?zX?{Xtc@uFbCdE_TgEnGtNzF|X?}XhC~XbXpHI_YmHtSdC`GcA`Y?aYfc@Plh@|F?eXwg@oN[uL]bYkCnSjHcY?dY?eYIpA}h@yX~h@{Xne@Pjc@bUkc@dU{h@vLjg@qM{AbJke@nFdi@uSfAfYc@gYq]zBtd@_Mdf@sCif@~Cm[nVee@pVfe@rVoGbOm_@mCMfRag@bB?lKje@cPwb@dFoTzBMyIua@bI_^tE~TwElEyE|HnU~c@pU_IhG`@hYsb@nFxi@zEuc@mDj^e@yZrD_OtDaOlUth@qJ|f@dN{YfN}YhN_ZjNzh@fBzFeMqXpAue@_G_b@bAgXtAab@aW?iY?jY?kYbOyDdO{Dsd@zPyFjUsc@pAnIdEoa@mFOlY?mY_j@|F{E`G`b@cG|RxAjh@Rri@_DqNrK~e@eW_f@gWaf@iWi@tFjIbLtFnYsh@oYh]mC|d@pCk]sCgj@DfXaGaIqGjRxA?yGvFpYdAqYud@sCqGrMmc@gUnc@dBdVgBd@rYBsYYtY?uYoIuE`^~P`i@eExIfEkAvYc@wYdh@jBoIxY?yYli@QuHaOyj@dBtGyGcBwBcg@zB_G}Btj@gEjG_F{j@zGyf@NiCzYiZPtf@iV_e@bI~i@gBha@bMvh@oWmf@qWsGgLbg@jFoWhD?kLpWmLqWoLrWqL`@{YlHpSba@wJnb@vLfg@|Fe\}OuG_Pzg@bPuI~KpG|Y?}Y{g@cDkCoTfb@~Y?_Z?`Z?aZ?bZ?cZ?dZtb@tJmUvJ[lNhGnNrHOpk@pT?eZci@|B?fZiCgZBhZwCeRbIfEKiZsj@vE_UjZxk@wElE~Pnj@Ewe@bGiRkZBlZSmZ~HO`g@}WcHzRtCiFck@cMuCtFnh@`EOeCrMgC`l@aEpf@tWqf@zB?vWsf@d@yi@nDmIsDwc@lUzi@rJhCsO{[P|AaSyI~Yqk@`Z?nZ?oZ`k@Owj@yYhf@|CqCcSk@pZ?qZxf@xCbh@|Myc@rJ[rZ?sZyk@xE`UlBzGdQqh@sXmItXrh@vX?oYmj@nCj]qCmk@_Ljf@tZ?uZzI|Wlj@cLr_@jRbe@mCMmVgl@xCsk@uJik@mR{i@eN}f@hN}i@kBdIlBel@_Zrk@nZul@fN|i@iN_g@lBhAvZaC~M_IeBy@}Mjb@nFgCzMbHpRz_@rR|@wZBxZvd@cVvk@gEhIzNic@`N?yZ?zZkk@wL{GjQ?{Z?|ZpA}Zaj@jYbj@xDcOzD}H~Z?_[|@vPie@hDf^eJyl@gN~f@jN~j@hEkj@uFfm@hNvl@lBlk@Db_@~Ohg@zQ|GtO`IsKki@zXnIcBoc@gBk@`[]a[Bb[im@EhB}Oc_@zQ|G`Qec@`Jcj@_Mrc@kUng@pDzEj@?bOti@pHIfR}Gc[rl@c@uAd[?e[aBf[?g[?h[?i[?j[?k[il@qZhi@eX?l[Bm[jl@c@ej@eEtl@_JoEn[pItNse@_Woh@sQy]|Pkl@pJ}IfXwl@mB{c@iGxIkFle@yVme@tNmHo[?p[ah@iSsGuG?xOrIfM|j@xBlY{BtCtF{CyZkAq[xj@Rhn@xAoj@zGsm@e@l_@sR`Hr[am@hEd@s[?t[bc@kBin@sGeh@s@aYoMff@a@u]d@zI`Ghj@qG?kZum@d@{I`M{e@yJmn@b@yCyEgh@mCMnXgi@Qak@Ndb@cMOu[?v[pc@rNdc@tNcl@oDvc@rD?vNph@pHIxNwCsRkn@xM{k@Pcn@d@wF`Cpi@zPdj@kUYkPk@dP|`@gPs\iPij@fW`f@hWvn@sNcm@|Bjn@h@_HsR`HuR}_@wRei@bA?`Yfi@uS|n@ePq\gP}n@jPbIkF?w[?x[gk@rLrm@d@Ky[pn@zJok@dD}l@fBvj@kBSz[?{[rn@zE{CaN]|[dQ`A?pFii@RzB}[~l@kBhk@_Qo_@jFnn@bA`j@cGuEeG?jTbb@lTxGsK{f@Noi@zBMgYvf@kKhF~[sWrL?_\dg@|B?`\dG{Gmi@wLdn@gBpIlB~Id@uj@zBMwYeJlByAaIsD|Wqn@c@al@uWrf@bR{HuIxd@cJt^nFom@Fgg@yQfItOzAa\mg@gBbJt@ea@x@fh@z@rg@yA?b\?c\ml@sZto@zBbl@bR{Cd\?e\_o@kBpd@}Uqd@_Vdm@_[cJlBgJ~Mkg@pAgm@jFln@tNso@d@sn@Rqo@|Gjm@tKtCoGp`@dCko@aGaIxGk@lMh`@wQ_p@bGvBxG[f\Bg\lo@bMOh\?i\?j\eo@mM_n@`W|@k\eJtNxHtNhh@hFdo@lFuo@}Opm@{Qig@PyC~PzCmWkf@oWdk@rW{l@xAon@rC_k@`Frj@uYoFn[wk@lP{o@mBfp@~Og\`Pi\bPnm@`PgJaOzC`LsFbLtFdLkWfLqj@hU`o@qMep@mFwn@pDk^{IvT}IxT_J_l@uFuSmCMwHjIgO?l\o[jOta@zBM_Td@lJfn@vGek@hLho@gBtm@uScb@nA?m\fj@mYai@pAji@gKiViK|l@bIxHlB~n@gW[vS\n\?o\?p\yCjZ{p@~Hop@dBx@xSyh@d@wm@g[xm@i[|Ik[sl@vJio@kBdJpFkm@{XcHhVuf@bIuIlRbn@oNbk@QuH~M]q\?r\aq@r\iJ|Yip@sCyg@vLgo@eDen@lFVjG~QlG{IjUhIjWbf@mC?~Lpj@d@`p@tA|Es\Bt\[|LkXmCfq@_Mqi@d@np@dB|m@d@}o@pAzCu\?v\kIw\?x\hl@mCMdSap@y\o@z\cEkU`D{\?|\S}\?~\?_]I`]kp@d@cq@fDrp@e@qIsDdl@zFsE|Mll@`Ezo@~Uxp@mBdq@a]_RmGco@fP}`@iPoChHkScDfEb]?c]i@oG_q@qFlId]?e]?f]?g]~IpAcBh]}j@{B`h@gSy`@iS}m@kFxo@Rhq@cG?qGvIyGbq@d@iq@}Lcf@jUbJnMbYd@S_Sye@uHao@i@f[sRbo@vRcp@xAaCdQvm@e[qp@nFhm@iNzl@mBvp@m\la@rSlm@dB{AmArDm\yq@jNno@qLgc@kBVi]Bj]|h@vLcJtNug@cMzj@eBsq@_Vuq@qGvIsG?k]Bl]tq@xBgn@|Byp@hWqq@qD{b@{Isp@~Ixl@m]fGn]?o]lq@x\uAp]pg@wRoe@mCM|V{q@rL`q@Nih@sG_m@qReq@kWwq@kUiJaL|\hOup@kOmo@pHIgY|Hq]pBr]?s]?t]?u]?v]?w]lp@yQfI`Q|p@gCyo@z\nq@pAKcIbTvEuBeIcTgIdTiIeTkIgp@_Qar@Obi@zLM_Y}k@jFtk@mNw`@NKx]?y]mq@zB?z\cr@rR~q@yBpo@}BuCiFjp@Pem@xA`r@Rvi@oU}Il[~p@h[ym@j[zm@fJrIz]`Dv\_r@rDtTfQl^hQwp@hK|@jSz`@lSro@}WgC{]qa@ySyn@QyIqTdd@tNkIjEyOmBdr@mCjq@`Mhp@nWwh@rWui@pHIyI}q@mCMl]`n@iQvo@b\wo@uShr@zI|b@}Itp@`JsHwMae@~Nir@~L~m@P|AnQn^pQnl@oDxn@tXol@oYpl@oC}d@rCwC`Xlr@pDeFtXmr@kC{d@nCql@rCbr@Pzq@kBkr@fQ?|]?}]un@hES~]?_^gr@i[|I`^?a^}p@hGvq@mCjr@rCwi@iG}VzEdJn[{n@lPkAb^jBn[ef@_Grq@aE|c@~Qf_@`Rh_@bR|q@lBzG~Mkd@cTxa@eTza@gT|a@iTtn@bMoo@zB_G`\i@pM`Dc^?d^?e^?f^si@sVzp@g^?h^?i^?j^?k^?l^qr@e^rr@qVge@sVor@e@qItXpr@lCi]oCnr@sCiIm^uk@n^er@zQqm@aQ`TxAyAoGcBo^xVvEuBwKyVyKzV{KYp^Bq^?r^
</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">
    @??A??B?????B??C??pA?Cs?D??C??P@?kf?E??F??@V??F@G??C??PM?sm@H??I??@R?w^?J??K??PY?wF@L??M??@A????N??O??P??ST?N??P??@X?_X?Q??R??`??OV?Q??P??@C?oV?Q??S??PO?k\?Q??T??pa?kT?H??U??p??SPAH??V??PB?Gv?W??X??P??WA?W??X??@??SD?W??A??A?????Y??C??pH?_O?Z??[??@@?k`?\??C??@B????]??^??p??oB?]??_??p??CD?`??a??PG?GC?b??a??`@????c??_??`@?[E?d??e??`C?S@?d??f??pN?KC?d??g??p@?sC?h??i??`B?k??j??k??@A?WB?l??m??PD?gn@l??n??`A?cr?l??o??@E?CN@p??q??P??C\Br??A??A?????s??C??`B?WM?t??C??P@?[H?u??v??`g?kT?t??C??P??SH?w??C??`G?sK?x??C??@@????y??z??`p?cM?{??|??`A?wm?}??~??PD?Oe?{??_??p@??l?{??_??`S?Wp??@?~??P@?C`??@?~??`N@?e?@@?A@?`??WW?@@?v??pK?KT?B@?A@?@D?oV?H??v??p@?KEAC@?K??@L?cs?H??D@?PM?{t?E@?~??PA????F@?G@?pB?GG@H@?K??`Y?Wg?I@?M??PB????N??J@?P??KU?K@?A??A?????Q??T??pX?[T?L@?M@?@U?GE?H??_??p??OQAH??N@?`L?Wz?H??O@?`M?Wy?P@?M??@C????L@?Q@?@@?GE?L@?R@?`x??H?L@?S@?@??CI?T@?A??A?????U@?|??pH?oh?U@?_??p@?se?U@?_??@W?Gj?V@?W@?@d?wF?V@?X@?PQ?{Q?V@?Y@?p]??P?l??Z@?PB?{RB[@?Z@?pj??\?l??A??A?????Q??S??pQ?o\?\@?M??@C????Q??]@?@@?o\?Q??^@?@j?OX?_@?M??@B????Q??`@?P??_\?T@?a@?Pz?SO?H??b@?p??SOAH??c@?`[?KI@d@?M??@A????T@?e@?PN?KP?f@?g@?`q?WR?f@?h@?`E?WE?i@?j@?p@?gC?k@?l@?@B?OL?k@?m@?`I??N?n@?o@?@F?GO@p@?~??@E????k@?q@?`^?GO?n@?r@?@@?W`?n@?r@?@u?or?n@?s@?@??sn?t@?A??A?????d??e??p??O@?u@?v@?`N?GG?l??w@?`@?_fAl??w@?PI?_hA[@?x@?@C?Co?p??y@?PI?wmBL@?R@?pz?CH?H??z@?p??_FAH??{@?PE?Wh?H??|@?PR?oi?}@?M??@A????L@?~@?P??GH?Q???A?@C?sR?@A?AA?`G?SQ?BA?CA?P??GL?BA?DA?pP?sO?BA?v@?`??oL?EA?FA?`??S^?GA?HA?`@????IA?JA?P?????KA?LA?@B?__?MA?A??A?????T@?a@?@L?[M?NA?OA?P[??E?V@?OA?@C?[B?PA?A??A?????QA?C??pl?[p?RA?SA?@??Kz?TA?A??A?????f@?g@?`H?oP?UA?OA?`??[F?VA?OA?@B?_D?y??z??@N@KO?y??WA?@P?wS?XA?YA?`P?ob?ZA?[A?@B?ke?\A?[A?`S?cl?GA?HA?P@????]A?^A?PG????_A?^A?pD????`A?aA?PB????bA?cA?p@?k\?bA?dA?pC?w]?eA?fA?pK?{T@V@?W@?@`?oF?V@?gA?@Y?gN?UA?hA?`??WN?VA?hA?p@?Gq?VA?iA?@G?OM?f@?h@?pV?[F?f@?jA?@[?OK?UA?hA?`??KJ?VA?hA?PD?Wc??@?~??`K@{d?kA?C??@@????NA?lA?pS?s_?mA?nA?@N?[W?k@?oA?`A?GD?pA?qA?P@?[g?rA?sA?@U?gM?tA?uA?P@?WH?vA?M@?@?????wA?A??A?????QA?C??puCWy?RA?o@?`J?[]@xA?~??@A????QA?yA?p??Wy?QA?zA?@D?K|?{A?_??P@?sN?|A?}A?`C?sz?\A?~A?@@?Wo??B?@B?`@??O??B?@B?`T?{Q?AB?C??`G?SJ?BB?C??@@????\A?CB?ptBct?XA?DB?P@?s`?XA?DB?pJ?_c?y??EB?@M?k[?FB?GB?`??K|?FB?HB?`??Cu?FB?IB?@@?kT?FB?JB?@??GR?KB?A??A?????E??F??`E?GE@E??LB?@`?SA@MB?NB?pA?[w?OB?PB?PT?KV?OB?QB?@@?_S?RB?A??A?????f@?h@?PT??F?SB?o@?P@?C`@k@?q@?p]?GO?TB?q??P??oA@UB?VB?pG?oI?TB?l@?`G?K@@WB?A??A?????BA?CA?pC?WL?XB?YB?pB?gT?l??OA?`L?OX?d??e??PY?o@?d??ZB?pN?WD?[B?\B?PD??B?]B?^B?`@?SG?_B?^B?@@?[d?_B?^B?pA?{d?_B?^B?PG?Cf?@A?OA?p}?cG?@A?`B?@@?wQ?aB?bB?`x?cL?cB?dB?P@?wR?cB?eB?PF?_o?fB?C??P??gL?fB?C??@Q?gM?UA?gB?@C?S[?[B?\B?P@??B?[B?hB?p@?KC?[B?iB?`A?[C?jB?kB?P@?_w?jB?OA?PA?{e?lB?A??A?????L@?S@?`@?CI?T@?OA?@t?gK?y??OA?PE?[I?FB?OA?`@?Oo?f@?g@?`r?[R?y??OA?`H?gI??B?mB?@??_X??B?A??A?????k@?m@?@??sM?n@?A??A?????UB?VB?`F?oI?RA?nB?@A?CV?p??q??`@?cXBoB?A??A?????N??P??p\?[Z?H??N@?@F?Oz?pB?A??A?????V@?W@?@f?{F?V@?qB?pK?wS?k@?m@?`C?wM?rB?OA?P??sG?sB?C??@@????tB?YA?`@?oW?uB?YA?Pb?{^?vB?[A?PV?[m??B?@B?`@?GP??B?@B?`V?CR?wB?xB?`E?sH?yB?C??@~?wj?T@?zB?Px?Wd?H??{B?`E?CfApB?K??@L?{w?|B?M??@C????Q??}B?@@?c\?~B?M??@A????Q???C?PK?{Z?T@?@C?@]?OS?AC?BC?@??KI?CC?A??A?????n@?r@?`B?Cp?n@?DC?@A?co?f@?h@?`[??G?f@?EC?`E?KI?FC?SA?@??gP?GC?A??A?????@A?OA?pY?GF?k@?m@?pA?wM?rB?A??A?????Q???C?@O?C[?Q??HC?`B?G]?H??c@?PB?GH@[B?iB?PB?[C?IC?JC?P@?CR?KC?OA?PD?cB?i@?A??A?????Q???C?`M??[?H??c@?@F?SH@J??A??A?????jB?kB?@??_w?jB?A??A?????U@?_??@i?[j?H@?K??PU?Gg?LC?MC?pE?ob?NC?C??`??G]?H@?K??Pc?sg?H??OC?@O?We?PC?M??@A????N??QC?PL?CU?Q??RC?@H?cJ?T@?RC?@I?_V?NA?SC?p_?gX?k@?TC?@D?CE?UC?qA?P@?[`?tA?uA?@D?WH?VC?M@?P??SM?VC?M@?PC?{M?WC?l@?@??KF?WC?A??A?????NA?SC?@u?w]?`A?JA?P?????XC?A??A?????QA?C??`eCwx?YC?ZC?pB?g@@pA?[C?P@?WI?\C?A??A?????Q??T??pd?CU?]C?A??A?????_B?^B?pb?[g?N??OA?po?SJ?Q??OA?PD?oD?^C?A??A?????V@?X@?@s?GS?V@?OA?PA?KB?UA?OA?p??gE?N??P??`Z?cX?f@?h@?PN?gE?k@?m@?`D?{M?RA?A??A?????T@?OA?pg?WK?@A?_C?PQ?[W?`C?C??@A????@A?aC?`@?WW?bC?OA?pB?SM?cC?dC?P??[M@cC?eC?`??cP@cC?eC?@e@CU@cC?fC?@t?{]@gC?A??A?????N??OA?P@?[D?hC?A??A?????[B?\B?PB??B?KC?j@?pI?kL?iC?OA?pI?KB?jB?OA?pC?{e?lB?W@?@Z?[EBlB?jC?PK?KHBlB?kC?Pf??LBk@?m@?@N?[O?k@?A??A?????Q??T??``?kT?lC?A??A?????\A?CB?`gACs?mC?nC?Pl?gJ@oC?pC?PD?w@@qC?M@?@?????EA?pC?p??CQ?rC?sC?@C?kU?tC?OA?`@??C?PA?o@?`Q?sW@V@?Y@?Pb?CP?RA?uC?@D?K\?RA?uC?p@?W[?RA?vC?p@?ON?RA?vC?@L?{M?QA?C??PBASs?wC?_??@@?WB?xC?C??@@????tB?yC?p`?OW?sB?A??A?????NA?OA?pU?wD?{??A??A?????_B?^B?@e?wg?N??R??PF?WQ?E??xB?PN?sS@MB?GB?pC?ku?OB?PB?@^@sX?j??k??pA?WB?zC?{C?P@?WH?zC?{C?@@?kH?rC?|C?@??_X?tC?A??A?????k@?TC?pB?CE?pA?}C?P@??M?~C?A??A?????h??i??P@?k???D?@D?@A?cB?AD?OA?p??_D?zC?OA?p??[E?zC?OA?pD?cF?V@?W@?@Z?cF?V@?BD?pP?oJ?CD?C??pS?WC?DD?ED?@U?wL?FD?GD?PJ?sC?FD?HD?Pf?cJ?FD?ID?`L?sL?JD?CB?@A?SG?JD?CB?`C?gG?JD?KD?P??sJ??D?@D?@??cB?AD?A??A?????k@?q@?@L?WN?LD?o@?`F?kC?MD?~??@C????k@?ND?`B?_N?OD?PD?@B????f@?QD?`??CF?k@?oA?P@?GD?RD?SD?p@?[m?TD?SD?P@?SC?UD?A??A?????EA?FA?p@?S^?MA?C??@A????EA?VD?`??W^?WD?XD?PG?CG?YD?ZD?pD?cB@YD?A??A?????rC?sC?PA?kU?V@?BD?@N?kJ?mA?nA?`[?sW?[D?\D?@A?kH?[D?\D?pH?cI?[D?]D?PK?CL?mC?^D?`E?cO@mC?_D?PH?CF?`D?_D?@D??b?ZA?OA?`A?Od?aD?A??A?????IC?JC?@??CR?KC?A??A?????T@?OA?@M?SD?QA?C??`~Cwy?bD?~??@@????QA?cD?P??wy?dD?C??@A????QA?eD?`??{x?YC?fD?`@?OA@gD?SA?p@?wI?hD?SA?@??[|?iD?A??A?????NA?SC?@r?WY?jD?C??@D????NA?kD?pa?o[?GA?HA?PA????lD?JA?P?????mD?A??A?????NA?kD?@P?SZ?GA?HA?p@????nD?A??A?????NA?kD?PD?_Y?oD?OA?@G?GC?pD?^A?PD????`A?aA?pA????bA?qD?PN?SY?_B?^B?Pg?wg?H??V??@F?Sv?C@?A??A?????d??ZB?`O?WD?rD?sD?`D?k@?tD?OA?PF?_D?f@?g@?`v?cR?l??n??@H?{r?l??uD?p@?Oz?N??OA?pP?WI?_B?vD?@@?gJ@wD?xD?@??cA?yD?A??A?????B@?A@?@B?oV?B@?zD?@A?{U?k@?m@?PH??N?p@?A??A?????H??|@?P??{h?h??i??pC?k??zC?g??pF?cN?AD?{D?@Y?{I?T@?OA?PK?GD?|D?OA?pG?Sf?}D?A??A?????lB?W@?PT?OEBlB?jC?ph?GIBtB?yC?@b?OW?wB?xB?PC?kH?@A?OA?ps?CG?i@?~D?@??oB?|D?OA?`L?[f??B?mB?@B?_X??B?OA?P@?gL?f@?jA?`W?GK??E?PD?`A????@E?AE?`B?cC?BE?PD?@A????EA?CE?@@?oO?DE?PD?P@????EE?FE?`???D?GE?PD?@@????EA?HE?@D??K?NA?kD?@c?o[?NA?kD?pe??]?mA?IE?P@?SE?JE?uC?PF?gD?H??U??`???H?N??OA?PD?gE?lB?kC?@_?sKBlB?KE?pz?wPBlB?LE?`p??[B[@?x@?p@?Co?N??P??P^?S[?\A?CB?PvBCu?\A?ME?pJ?gm?NE?A??A?????NA?kD?PQ?SZ?oD?OE?@I?gF??@?A??A?????f@?h@?pX?oF?f@?jA?PA?wJ?PE?SA?@??{P@QE?A??A?????@A?AA?`A?KQ?i@?~D?pD?wB?y??z??@L?WL?y??RE?`K?OV?SE?A??A?????@A?OA?Pl?wF?i@?OA?P@?cA?mC?^D?pF?gO@TE?_D?`??G`?mC?UE?P@?GG?tB?UE?@P?kQ?uB?A??A?????T@?OA?pq?gK?y??A??A?????XB?YB?`@?gT?QA?C??pnACu?[D?VE?@C?WO?[D?VE?pF?WP?@A?AA?PH?SQ?N??QC?@O?GU?H??{@?`F?[h?RD?SD?P??[m?TB?WE?p@?go?XE?A??A?????KC?OA?PE?cB?f@?h@?@C?OE?@E?YE?p@?cC??E?A??A?????T@?zB?pK@wd?ZE?M??@A????Q??[E?P@??[?T@?\E?`J?cT?yD?uC?`??WT?yD?IB?P@?GH?]E?A??A?????k@?ND?@E?cN?wD?xD?pJ?sA?^E?_E?`F??]?^E?`E?`C?c]?aE?bE?`@?Ci?aE?cE?pK?sj?aE?dE?PK?Sl?eE?A??A?????y??OA?PD?[I?FB?A??A?????YC?ZC?@@?c@@H??{B?PC?CfAG??A??A?????N??OA?`m?SJ?Q??A??A?????V@?X@?PO?wQ?y??OA?pR?oJ?@A?OA?Po??G?N??R??`C?SQ?N??fE?p@?ST?_B?^B?p_?[g?N??A??A?????[B?iB?P@?[C?gE?hE?`B????KC?j@?`H?kL?iC?A??A?????T@?e@?PD?_O?fB?C??`K?gM?UA?A??A?????H??{@?@H?_h?H@?A??A?????f@?g@?@V?OQ?f@?g@?`b?wQ?i@?~D?P@?oB?RA?OA?`A?oH?mC?nC?pe?OJ@oC?hA?`J?GB@tC?iE?@??sG?jE?A??A??????B?mB?PA?_X?w??OA?PA?{J?kE?OA?P@?WQ?lE?A??A?????BA?CA?PB?SL?XB?mE?PA?GY?XB?A??A??????@?~??`z?_d?jE?iE?P??OH?jE?nE?@??KG?V@?Y@?`R?kO?f@?jA?@@?wJ?SB?oE?@C?c^@n@?oE?`B?wG@pE?A??A?????T@?\E?PF?WT?NA?qE?py?oL?H??rE?`@?GGAL@?M@?PL?sD?BA?sE?`B?GE?tE?uE?pE?k`?tE?vE?pR?{b?wE?HA?p@????xE?^A?pX????`A?aA?`A????NA?OA?`b?KE?y??_D?`X?OZ?y??RE?`I?{U?yE?A??A?????T@?e@?`F??P?T@?^D?@K?_L?`D?_D?`A??b?ZA?A??A?????V@?OA?P@?KB?mA?nA?@V?kW?mA?zE?@B?kJ?d??e??@t?wA?FD?{E?@W?GN?FD?|E?`??cO?tD?}E?`N?CJ?~E?OA?`@?GA?y??RE?@P?_W??F?OA?P??wG?@F?OA?PA?OA?}D?OA?P@?WA?AF?A??A?????QA?C??@u@Ks?V@?Y@?p_??P?PA?BF?`F@?L@PA?JB?@??su@CF?A??A?????JE?uC?@E?gD?DF?A??A?????NA?SC?@i?CY?EF?A??A?????BA?CA?`@?KL?FF?GF?@@?wG?T@?zB?pv?Wd?HF?A??A?????[D?VE?@E?SP?IF?JF?`E?[Y?yD?KF?P@?w|?LF?OA?`A?S}?MF?A??A?????N??fE?PE?[U?H??NF?p??kSAH??OF?@F?gA@PF?A??A?????FD?HD?@o?oJ?T@?OA?@l?[K?mA?QF?pJ?{N?T@?OA?@J?GD?|D?A??A?????RF?M??@B????N??SF?PK?WY?W??TF?@??GB?NA?kD?P??_Y?oD?A??A?????k@?m@?PO?[O?UF?VF?pA?[[@SB?A??A?????mA?QF?pG?wN?[D?QF?pD?{G?WF?A??A?????L@?M@?pS?CE?P@?A??A?????IF?JF?`B?CY?QA?C??@`Bcv?XF?bB?pF?sG?XF?YF?`I?CG?ZF?[F?@r?[G?ZF?\F?PZ?KK?XF?]F?PY?KR?gD?uC?@A?sL?PA?r@?PA?Ge?PA?^F?@M?Sf?AC?BC?P@?KI?CC?OA?`??KI?AC?OA?P@?cF?|D?OA?pD?Of?vB?A??A?????FD?HD?@A@sK?FD?_F?PD??H?]??a??PG?SB?FD?|E?pA?gO?DD?`F?P??WH?aF?A??A?????wD?xD?@J?sA?V@?Y@?@I?KO?T@?OA?PH?wC?V@?X@?@q?CS?T@?OA?pm?cK?f@?A??A?????V@?BD?pO?oJ?gD?WE?@??kU?bF?A??A?????f@?g@?@G?oP?y??OA?@P??J?cF?A??A?????L@?S@?PA?CI?dF?SA?P@?_i@eF?OA?PC?ci@pE?SA?@??oR@fF?A??A?????N??P??pN?_W?_B?gF?pC?GK@rB?uC?@A?{N?d??g??`??sC?bA?qD?`U?gY?bA?x@?`@?KW?y??EB?@P??\?QA?C??@iCwx?pA?o@?p??Od?hF?iF?P@?_C?jF?A??A?????k@?TC?P@?CE?N??P??`[?cX?kF?A??A?????FD?ID?@T?wL?u@?OA?@O?[D?lF?A??A?????Q??T??@f?CU?Q??S??PS?s\?NA?OA?``?GE?U@?mF?`@?{g?_B?^B?pq?_h?H??nF?`@?{PAoF?M??@A????NA?pF?PT?kK?qF?A??A?????_B?^B?@f?wg?rF?A??A?????_B?^B?@E?Cf?@A?A??A?????[B?\B?@E?CB?H??M@?pA?_@AH??sF?`F?st@tF?A??A?????PA?BF?`q?OK@uF?M??@@????V@?vF?@??CP?V@?X@?pn??S?QA?C??pgCwx?wF?A??A?????[D?\D?`??kH?xF?yF?@??KP?zF?{F?@S?{_?xF?|F?pE?oS?xF?kB?pH?{X?xF?A??A?????f@?h@?`M?kE?mA?}F?PI?oT?EA?~F?P??GJ??G?A??A?????V@?Y@?PS?kO?l??@G?pA?o[B[@?@G?@P?Sd?NA?SC?Px?O^?AG?A??A?????T@?OA?pO?[D?PA?BF?PM?wI@PA?BG?P`?wj?CG?A??A?????T@?@C?`_?SS?T@?DG?P??w_?EG?A??A?????wD?xD?@I?sA?FG?GG?pE?wLAHG?IG?P@?kS?JG?IG?P??CF?^E?KG?PC?WH?^E?A??A?????oD?OE?`K?gF??@?OA?PG?S`?f@?jA?p^?SK?[D?\D?p`?cJ?[D?LG?p@?SN?PA?M@?`??oa?PA?MG?pD?_b?PA?g??PA?GT?WF?NG?P??cE?f@?g@?@F?kP?f@?OG?@K?gN?f@?PG?PJ?[L?QG?^A?@S????T@?RC?PE?SV?RG?M??P?????SG?TG?@??ki?UG?VG?p@?sA@B@?OA?P@?gS?J??K??pb?GG@WG?A??A?????NA?SC?`y?O^?BA?DA?`G?{N?y??RE?PM?_W??F?A??A?????y??OA?PM?{I?NA?SC?Pv?w]?F@?XG?PU?oF@YG?C??@B????F@?ZG?@B?wF@T@?OA?Pb?GK?[G?M??@A????Q??\G?`@?G]?Q??]G?`U??c?N??fE?pA?ST?PC?A??A?????T@?a@?P{?SO?^G?A??A?????[D?QF?`M?CH?[D?_G?`??_L?\A?[A?pL?Gl?`G?C??@@????\A?aG?pR?gj?\A?CB?PW?Wp?\A?bG?PB@[y?ZA?cG?@M?gg?XA?UE?p^?{a?BA?DA?@@?cN?FF?OA?`??wD?FF?OA?PA?cD?dG?A??A?????rD?sD?@??k@?tD?A??A?????N??QC?pM?CU?I@?A??A?????kF?M??@B????N??eG?pE?oZ?T@?a@?@u??O?JD?KD?`E??K?fG?gG?@D????hG?JA?@A????Q??S??`P?k\?\@?A??A?????V@?X@?@M?sQ?T@?DG?`A?w_?T@?DG?@G?K`?FB?uC?`??{|?f@?g@?Pw?cR?rC?|C?@@?SZ?`D?_D?`Z?_b?TE?UE?`??S_?[B?hB?`??KC?iG?^A?PD????NA?OA?PW?wD?jG?A??A?????y??OA?PJ?sI?XA?A??A?????Q??`@?`@?_\?|B?A??A?????aB?bB?@u?cL?fB?A??A?????Q??RC?PJ?gJ?V@?X@?@p?CS?[D?]D?@??wK?TE?A??A?????]??a??`Q?oB?kG?lG?P@?[@?mG?lG?pB?gF?mG?nG?`@?GE?Y??OA?p@?_H?oG?pG?@B?KY?Z??A??A?????]??a??PP?oB?\??A??A?????Q??RC?@I?cJ?qG?A??A?????T@?OA?PG?wC?fB?C??`L?gM?Q??HC?PA?G]?[G?A??A?????NA?SC?@\?_X?mG?nG?@??GE?Y??A??A?????wD?xD?PH?sA?rG?A??A?????NA?kD?pT?W[?{??mF?P??Km?[D?LG?P??ON?sG?tG?@??sV?L@?M@?@X?KE?N??fE?@D?WT?uG?A??A??????B?OA?PF?oM?u??A??A?????w??OA?P@?{J?kE?A??A?????T@?e@?Pe?cP?FD?ID?pM?wL?u@?A??A?????wD?xD?`M?wA?T@?a@?@y?OO?d@?A??A?????BA?sE?Pp?oF?N??R??@@?OQ?vG?A??A??????@?~??@|?_d?@@?DB?P@?cQ?@@?DB?PF?wV?B@?DB?P@?_S?B@?DB?`E?OU?RA?wG?pK?Wi?F@?ZG?p@?wF@E@?A??A?????H??N@?PB?Cz?N??SF?`??sX?N??xG?PB?ON?Q??`@?PC?g\?@F?OA?P@?OA?NA?OA?PQ?sD?U@?A??A?????f@?g@?@y?gR?TB?l@?@??oq?QA?C??P|Bgw?yG?SA?@@?CU?T@?OA?PZ??K?NA?SC?pZ?WX?@@?OA?P@?kQ?T@?a@?`|?OQ?V@?BD?`c?OK?d??f??PE?GC?QA?C??`kC{x?dD?A??A?????@A?AA?pD?OQ?]C?M??@A????Q??zG?@E?oU??B?OA?PI?sM?s??A??A?????NA?kD?@C?_Y?kA?A??A?????f@?g@?PU?OQ?f@?{G?`R??N?YD?gB?`D?g[?N??fE?@C?WT?|D?_D?`V?Cg?[@?Z@?PX?S[?N??P??PK?[W?|G?l@?@??cA?|G?A??A?????T@?a@?pH?[M?NA?A??A?????Q???C?PL?{Z?ZE?A??A?????[D?\D?`k?wJ?IF?uC?@Z?_W?XB?YB?`??cT?XB?n??PA?OQ?f@?{G?PS??N?QG?^A?@c????IF?uC?`W?_W?}G?A??A?????NA?SC?pp?WY?~G?HA?@B?????H?JA?P?????jD?A??A?????f@?EC?@[?wI?@H?M@?@?????VC?A??A?????[D?_G?PH?sL?IF?AH?pC??X?BH?CH?`??[R?yD?CH?P@?_u?BA?DA?@V?GP?f@?h@?@S??F?OD?A??A?????QA?C??@yCgy?DH?A??A?????mG?lG?PD?kF?EH?GB?`F?cX?FH?A??A?????N??R??@??OQ?pA?o@?`@?Od?jF?uA?p??sI?GH?uA?p??WH?rA?HH?PA?K^?rA?IH?pD?Ka?\C?JH?@??gI?KH?A??A?????T@?OA?`D?cC?LH?A??A?????tD?OA?pA?WD?lB?jC?@Z?oHBoC?hA?PK?GB@mC?MH?PJ?OK@NA?SC?`Y?WX?@@?A??A?????RA?wG?P??wh?WB?nB?pA?Sf?Q??`@?pA?c\?IF?uC?pA?KV?xF?NH?PW?_t?xF?OH?p??{u?xF?NH?pK?Cy?|G?l@?P@?cA?|G?OA?PC?sA?PH?OA?@E?KB?xF?NH?`??Op?QH?RH?PC??D@xF?NH?p??{K?F@?XG?@T?oF@YG?A??A?????BA?DA?pC?kN?y??OA?PG?cI?x??A??A?????
</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span
        id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span
        id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, ALLOC</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status'
      style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
    // Copyright 2020 Andrei Pangin
    // Licensed under the Apache License, Version 2.0.
    'use strict';
    let root, rootLevel, px, pattern;
    let reverse = true;
    const levels = Array(0);
    for (let h = 0; h < levels.length; h++) {
        levels[h] = [];
    }

    const canvas = document.getElementById('canvas');
    let c = canvas.getContext('2d');
    const hl = document.getElementById('hl');
    const status = document.getElementById('status');

    const canvasWidth = canvas.offsetWidth;
    let canvasHeight = canvas.offsetHeight;
    canvas.style.width = canvasWidth + 'px';
    canvas.width = canvasWidth * (devicePixelRatio || 1);
    canvas.height = canvasHeight * (devicePixelRatio || 1);
    if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
    c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

    const palette = [
        [0xb2e1b2, 20, 20, 20],
        [0x50e150, 30, 30, 30],
        [0x50cccc, 30, 30, 30],
        [0xe15a5a, 30, 40, 40],
        [0xc8c83c, 30, 30, 10],
        [0xe17d00, 30, 30, 0],
        [0xcce880, 20, 20, 20],
    ];

    function getColor(p) {
        const v = Math.random();
        return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
    }

    function f(level, left, width, type, title, inln, c1, int) {
        levels[level].push({
            left: left, width: width, color: getColor(palette[type]), title: title,
            details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
        });
    }

    function samples(n) {
        return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
    }

    function pct(a, b) {
        return a >= b ? '100' : (100 * a / b).toFixed(2);
    }

    function findFrame(frames, x) {
        let left = 0;
        let right = frames.length - 1;

        while (left <= right) {
            const mid = (left + right) >>> 1;
            const f = frames[mid];

            if (f.left > x) {
                right = mid - 1;
            } else if (f.left + f.width <= x) {
                left = mid + 1;
            } else {
                return f;
            }
        }

        if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
        if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

        return null;
    }

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
            c.fillStyle = '#ffffff';
            c.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        root = newRoot || levels[0][0];
        rootLevel = newLevel || 0;
        px = canvasWidth / root.width;

        const x0 = root.left;
        const x1 = x0 + root.width;

        if (minLevel === 0) {
            marked.length = 0;
        }

        function mark(f) {
            return marked[f.left] >= f.width || (marked[f.left] = f.width);
        }

        function totalMarked() {
            let total = 0;
            let left = 0;
            Object.keys(marked).sort(function (a, b) {
                return a - b;
            }).forEach(function (x) {
                if (+x >= left) {
                    total += marked[x];
                    left = +x + marked[x];
                }
            });
            return total;
        }

        function drawFrame(f, y, alpha) {
            if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
                c.fillRect((f.left - x0) * px, y, fw, 15);

                if (fw >= 21) {
                    const chars = Math.floor(fw / 7);
                    const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
                    c.fillStyle = '#000000';
                    c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
                }

                if (alpha) {
                    c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    c.fillRect((f.left - x0) * px, y, fw, 15);
                }
            }
        }

        for (let h = minLevel; h < levels.length; h++) {
            const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
            const frames = levels[h];
            for (let i = 0; i < frames.length; i++) {
                drawFrame(frames[i], y, h < rootLevel);
            }
        }

        return totalMarked();
    }

    canvas.onmousemove = function () {
        const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
        if (h >= 0 && h < levels.length) {
            const f = findFrame(levels[h], event.offsetX / px + root.left);
            if (f) {
                hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
                hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
                hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
                hl.firstChild.textContent = f.title;
                hl.style.display = 'block';
                let details = f.details || '';
                canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
                canvas.style.cursor = 'pointer';
                canvas.onclick = function () {
                    if (f !== root) {
                        render(f, h);
                        canvas.onmousemove();
                    }
                };
                status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
                return;
            }
        }
        canvas.onmouseout();
    }

    canvas.onmouseout = function () {
        hl.style.display = 'none';
        status.textContent = '\xa0';
        status.style.display = 'none';
        canvas.title = '';
        canvas.style.cursor = '';
        canvas.onclick = '';
    }

    window.onkeydown = function () {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function () {
        search(false);
    }


    class DataBuffer {
        data;
        pos = 0;

        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 1000000000;
    let startMs = 1666003060262;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all", "", "java.lang.Thread", "run", "java.util.concurrent.ThreadPoolExecutor$Worker", "java.util.concurrent.ThreadPoolExecutor", "runWorker", "java.util.concurrent.CompletableFuture$AsyncSupply", "java.util.concurrent.CompletableFuture", "postComplete", "java.util.concurrent.CompletableFuture$UniCompose", "tryFire", "jdk.internal.net.http.MultiExchange$$Lambda$209.0x0000000800d89780", "apply", "jdk.internal.net.http.MultiExchange", "lambda$responseAsync0$2", "responseAsyncImpl", "jdk.internal.net.http.Exchange", "responseAsync", "responseAsyncImpl0", "establishExchange", "whenComplete", "uniWhenCompleteStage", "jdk.internal.net.http.common.MinimalFuture", "newIncompleteFuture", "java.util.concurrent.FutureTask", "java.util.concurrent.Executors$RunnableAdapter", "call", "ok.dht.test.kovalenko.shards.MyServerBase$$Lambda$201.0x0000000800d157c8", "ok.dht.test.kovalenko.shards.MyServerBase", "lambda$handleRequest$0", "handle", "one.nio.http.HttpServer", "handleRequest", "RequestHandler0_handle", "ok.dht.test.kovalenko.shards.MyServiceBase", "ok.dht.test.kovalenko.LoadBalancer", "balance", "curServiceUrl", "hash", "ok.dht.test.kovalenko.utils.HashUtils", "getMurmur128Hash", "com.google.common.hash.AbstractHasher", "putString", "java.lang.String", "getBytes", "encode", "encodeUTF8", "java.util.Arrays", "copyOf", "byte[]", "jdk.internal.net.http.common.SequentialScheduler$SchedulableTask", "jdk.internal.net.http.common.SequentialScheduler$CompleteRestartableTask", "jdk.internal.net.http.common.SequentialScheduler$TryEndDeferredCompleter", "complete", "jdk.internal.net.http.common.SequentialScheduler$LockingRestartableTask", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$238.0x0000000800d9c130", "jdk.internal.net.http.Http1AsyncReceiver", "flush", "jdk.internal.net.http.Http1Response$BodyReader", "tryAsyncReceive", "jdk.internal.net.http.Http1Response$Receiver", "accept", "jdk.internal.net.http.ResponseContent$FixedLengthBodyParser", "jdk.internal.net.http.Http1Response$Http1BodySubscriber", "onComplete", "jdk.internal.net.http.ResponseSubscribers$ByteArraySubscriber", "java.util.concurrent.CompletableFuture$UniWhenComplete", "uniWhenComplete", "jdk.internal.net.http.ResponseSubscribers$$Lambda$295.0x0000000800dacfc0", "jdk.internal.net.http.ResponseSubscribers", "lambda$getBodyAsync$2", "java.util.concurrent.CompletableFuture$UniApply", "jdk.internal.net.http.MultiExchange$$Lambda$298.0x0000000800dad668", "lambda$responseAsync0$3", "jdk.internal.net.http.HttpResponseImpl", "jdk.internal.net.http.ExchangeImpl", "get", "uniHandleStage", "uniHandle", "jdk.internal.net.http.ExchangeImpl$$Lambda$220.0x0000000800d94000", "lambda$get$0", "createExchangeImpl", "createHttp1Exchange", "jdk.internal.net.http.Http1Exchange", "jdk.internal.net.http.Http1Response$HeadersReader", "jdk.internal.net.http.Http1HeaderParser", "parse", "resumeOrSecondCR", "addHeaderFromString", "toLowerCase", "java.lang.StringLatin1", "jdk.internal.net.http.Exchange$$Lambda$243.0x0000000800d9cee8", "lambda$responseAsyncImpl0$10", "checkFor407", "jdk.internal.net.http.Exchange$$Lambda$217.0x0000000800d8ad98", "lambda$responseAsyncImpl0$9", "sendHeadersAsync", "thenCompose", "uniComposeStage", "jdk.internal.net.http.Http1Exchange$$Lambda$258.0x0000000800da4fa8", "lambda$sendHeadersAsync$4", "jdk.internal.net.http.Http1Request", "headers", "collectHeaders0", "jdk.internal.net.http.common.HttpHeadersBuilder", "build", "java.net.http.HttpHeaders", "of", "headersOf", "java.util.TreeMap", "forEach", "java.net.http.HttpHeaders$$Lambda$203.0x0000000800d82a10", "lambda$headersOf$1", "put", "addEntry", "java.util.TreeMap$Entry", "one.nio.http.Request", "getParameter", "substring", "newString", "copyOfRange", "thenApply", "uniApplyStage", "uniApplyNow", "jdk.internal.net.http.ExchangeImpl$$Lambda$239.0x0000000800d9c5e0", "lambda$createExchangeImpl$2", "h2Upgrade", "jdk.internal.net.http.HttpRequestImpl", "setH2Upgrade", "jdk.internal.net.http.Http2ClientImpl", "getSettingsString", "getClientSettings", "jdk.internal.net.http.common.Utils", "getIntegerNetProperty", "java.lang.invoke.Invokers$Holder", "linkToTargetMethod", "java.lang.invoke.LambdaForm$DMH.0x0000000800ca0000", "newInvokeSpecial", "java.lang.invoke.DirectMethodHandle", "allocateInstance", "jdk.internal.net.http.common.Utils$$Lambda$146.0x0000000800cae6b0", "jdk.internal.net.http.Http1Response", "<init>", "java.util.HashMap", "jdk.internal.net.http.HttpClientImpl$SelectorManager", "java.util.ArrayList", "iterator", "java.util.ArrayList$Itr", "java.lang.StringBuilder", "java.lang.AbstractStringBuilder", "checkRequestMore", "jdk.internal.net.http.Http1AsyncReceiver$Http1TubeSubscriber", "requestMore", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadSubscription", "request", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription", "java.lang.invoke.LambdaForm$MH.0x0000000800d02800", "invoke", "java.lang.invoke.LambdaForm$MH.0x0000000800c0d000", "java.lang.invoke.DirectMethodHandle$Holder", "invokeStatic", "java.lang.StringConcatHelper", "newArrayWithSuffix", "newArray", "jdk.internal.misc.Unsafe", "allocateUninitializedArray", "readResumeHeader", "append", "ensureCapacityInternal", "collectHeaders1", "jdk.internal.net.http.Http1Response$$Lambda$288.0x0000000800da1d18", "onFinished", "jdk.internal.net.http.HttpConnection", "closeOrReturnToCache", "firstValue", "java.util.stream.ReferencePipeline", "findFirst", "java.util.stream.AbstractPipeline", "evaluate", "java.util.stream.FindOps$FindOp", "evaluateSequential", "java.util.stream.FindOps$FindSink$OfRef$$Lambda$14.0x80000001d", "java.util.stream.FindOps$FindSink$OfRef", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$262.0x0000000800da5660", "lambda$run$3", "handleEvent", "jdk.internal.net.http.SocketTube$SocketFlowEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadEvent", "signalEvent", "signalReadable", "jdk.internal.net.http.common.SequentialScheduler", "runOrSchedule", "jdk.internal.net.http.SocketTube$SocketFlowTask", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$230.0x0000000800d99ab0", "read", "onNext", "asyncReceive", "java.util.concurrent.ConcurrentLinkedDeque", "offer", "offerLast", "linkLast", "newNode", "java.util.concurrent.ConcurrentLinkedDeque$Node", "getTask", "java.util.concurrent.SynchronousQueue", "poll", "java.util.concurrent.SynchronousQueue$TransferStack", "transfer", "snode", "java.util.concurrent.SynchronousQueue$TransferStack$SNode", "java.util.Collections$UnmodifiableMap", "java.util.List", "java.util.ImmutableCollections", "listCopy", "java.util.ImmutableCollections$List12", "java.util.Base64$Encoder", "encodeToString", "proxyRequest", "ok.dht.test.kovalenko.ServiceClient", "getJavaNet", "jdk.internal.net.http.HttpClientFacade", "sendAsync", "jdk.internal.net.http.HttpClientImpl", "retrieveProxy", "sun.net.spi.DefaultProxySelector", "select", "java.security.AccessController", "doPrivileged", "executePrivileged", "sun.net.spi.DefaultProxySelector$3", "toString", "requestForKeyJavaNet", "requestJavaNet", "java.net.URI", "create", "java.net.URI$Parser", "lockingScheduler", "toArray", "java.lang.Object[]", "java.util.concurrent.CompletableFuture$UniHandle", "resumeOrEndHeaders", "java.util.TreeSet", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$270.0x0000000800da7090", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$WriteSubscription", "jdk.internal.net.http.Http1Exchange$Http1Publisher$Http1WriteSubscription", "jdk.internal.net.http.HttpClientImpl$DelegatingExecutor", "execute", "jdk.internal.net.http.Http1Exchange$Http1Publisher$WriteTask", "getOutgoing", "completeAsync", "jdk.internal.net.http.Exchange$$Lambda$261.0x0000000800da5898", "lambda$responseAsyncImpl0$8", "jdk.internal.net.http.Exchange$$Lambda$216.0x0000000800d8ab50", "sendRequestBody", "sendBodyAsync", "jdk.internal.net.http.Http1Exchange$Http1BodySubscriber", "completeSubscriber", "jdk.internal.net.http.Http1Exchange$Http1BodySubscriber$1", "addEntryToEmptyMap", "collectCookies", "java.util.ImmutableCollections$AbstractImmutableList", "java.util.ImmutableCollections$ListItr", "wrapForUpgrade", "java.net.http.HttpRequest", "newBuilder", "jdk.internal.net.http.HttpRequestBuilderImpl", "java.util.concurrent.CompletableFuture$UniCompletion", "claim", "java.util.concurrent.CompletableFuture$Completion", "postFire", "jdk.internal.net.http.MultiExchange$$Lambda$210.0x0000000800d89c00", "lambda$responseAsync0$4", "readBodyAsync", "readBody", "firstValueAsLong", "java.util.stream.LongPipeline", "java.util.stream.FindOps$FindSink$OfLong", "java.util.OptionalLong", "jdk.internal.net.http.Http1Response$$Lambda$293.0x0000000800dacb60", "jdk.internal.net.http.HttpClientImpl$SelectorAttachment", "events", "filter", "java.util.stream.ReferencePipeline$2", "jdk.internal.net.http.Exchange$$Lambda$242.0x0000000800d9cca0", "jdk.internal.net.http.Exchange$ConnectionAborter", "getAddress", "jdk.internal.net.http.HttpRequestImpl$$Lambda$223.0x0000000800d96548", "lambda$getAddress$5", "java.net.InetSocketAddress", "java.net.InetAddress", "getByName", "getAllByName", "getAllByName0", "java.net.InetAddress[]", "java.util.concurrent.atomic.AtomicInteger", "jdk.internal.net.http.ImmutableHttpRequest", "parseHierarchical", "parseAuthority", "jdk.internal.net.http.Exchange$$Lambda$241.0x0000000800d9ca68", "jdk.internal.net.http.SocketTube", "readAvailable", "jdk.internal.net.http.SocketTube$SliceBufferSource", "getBuffer", "jdk.internal.net.http.PlainHttpConnection$$Lambda$228.0x0000000800d98720", "java.nio.ByteBuffer", "allocate", "java.nio.HeapByteBuffer", "add", "grow", "jdk.internal.net.http.AsyncTriggerEvent", "jdk.internal.net.http.SocketTube$InternalWriteSubscriber$$Lambda$234.0x0000000800d9a800", "startSubscription", "com.google.common.hash.AbstractStreamingHashFunction$AbstractStreamingHasher", "putBytes", "wrap", "mapToLong", "java.util.stream.ReferencePipeline$5", "com.google.common.hash.Murmur3_128HashFunction", "newHasher", "com.google.common.hash.Murmur3_128HashFunction$Murmur3_128Hasher", "readStatusLineFeed", "one.nio.server.SelectorThread", "one.nio.net.Session", "process", "one.nio.http.HttpSession", "processRead", "processHttpBuffer", "parseRequest", "one.nio.util.Utf8", "toAsciiString", "java.lang.Iterable", "java.net.http.HttpHeaders$$Lambda$272.0x0000000800da72b8", "lambda$headersOf$0", "jdk.internal.net.http.Http1Request$$Lambda$274.0x0000000800da7748", "test", "lambda$collectHeaders0$1", "java.util.Collection", "stream", "java.util.stream.StreamSupport", "java.util.stream.ReferencePipeline$Head", "lambda$getIntegerNetProperty$13", "sun.net.NetProperties", "getInteger", "java.lang.Integer", "valueOf", "jdk.internal.net.http.ConnectionPool", "returnToPool", "registerCleanupTrigger", "connectFlows", "subscribe", "jdk.internal.net.http.SocketTube$InternalReadPublisher", "java.util.concurrent.atomic.AtomicReference", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$267.0x0000000800da6590", "lambda$run$5", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$259.0x0000000800da51f0", "lambda$run$2", "resetInterestOps", "java.util.HashSet", "java.util.HashMap$KeySet", "java.util.HashMap$KeyIterator", "jdk.internal.net.http.Http1Response$$Lambda$287.0x0000000800da16c8", "lambda$readBody$3", "java.lang.invoke.LambdaForm$DMH.0x0000000800d81400", "jdk.internal.net.http.Http1Response$$Lambda$291.0x0000000800dac6f0", "jdk.internal.net.http.Http1Response$$Lambda$289.0x0000000800dac000", "jdk.internal.net.http.ResponseContent", "java.lang.invoke.LambdaForm$MH.0x0000000800c90000", "simpleConcat", "ok.dht.test.kovalenko.utils.HttpUtils", "toOneNio", "one.nio.http.Response", "encodeASCII", "filterChain", "jdk.internal.net.http.FilterFactory", "getFilterChain", "java.util.LinkedList", "join", "makeHash", "jdk.internal.net.http.Http1Exchange$Http1Publisher", "jdk.internal.net.http.common.Demand", "setHeader", "java.util.function.BiPredicate$$Lambda$271.0x0000000800dc4000", "java.util.function.BiPredicate", "lambda$and$0", "jdk.internal.net.http.common.Utils$$Lambda$164.0x0000000800d044a0", "lambda$static$12", "java.util.function.Predicate$$Lambda$154.0x0000000800d40000", "java.util.function.Predicate", "lambda$negate$1", "jdk.internal.net.http.common.Utils$$Lambda$153.0x0000000800caf698", "lambda$static$5", "addTrailingOperation", "jdk.internal.net.http.HttpConnection$TrailingOperations", "parseServer", "parseHostname", "resumeReadEvent", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$269.0x0000000800da6e58", "getBodyParser", "java.util.ImmutableCollections$MapN$1", "java.util.ImmutableCollections$MapN$MapNIterator", "handlePendingDelegate", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$248.0x0000000800d9f2f8", "jdk.internal.net.http.ConnectionPool$CleanupTrigger", "onSubscribe", "purgeExpiredConnectionsAndReturnNextDeadline", "spliterator", "java.util.AbstractList$RandomAccessSpliterator", "and", "jdk.internal.net.http.Exchange$$Lambda$278.0x0000000800da26c8", "lambda$sendRequestBody$7", "getResponseAsync", "java.util.LinkedList$Node", "java.lang.reflect.Constructor", "newInstance", "newInstanceWithCaller", "java.lang.reflect.AccessibleObject", "checkAccess", "verifyAccess", "slowVerifyAccess", "java.lang.ref.WeakReference", "responseAsync0", "java.lang.invoke.DelegatingMethodHandle$Holder", "reinvoke_L", "asReadOnlyBuffer", "java.nio.HeapByteBufferR", "java.util.concurrent.locks.ReentrantLock", "java.util.concurrent.locks.ReentrantLock$NonfairSync", "withoutPadding", "duplicate", "entrySet", "java.util.TreeMap$EntrySet", "readHeadersAsync", "thenApplyAsync", "getConnectionFor", "jdk.internal.net.http.Http2Connection", "keyFor", "keyString", "java.lang.invoke.LambdaForm$MH.0x0000000800d92800", "java.lang.invoke.LambdaForm$MH.0x0000000800d92000", "jdk.internal.net.http.Http1AsyncReceiver$$Lambda$247.0x0000000800d9f0c0", "checkOpen", "sendResponse", "writeResponse", "toBytes", "one.nio.util.ByteArrayBuilder", "jdk.internal.net.http.Http1AsyncReceiver$Http1AsyncDelegateSubscription", "jdk.internal.net.http.AbstractSubscription", "java.util.concurrent.atomic.AtomicLong", "computeIfAbsent", "java.util.HashMap$Node", "jdk.internal.net.http.HttpConnection$TrailingOperations$$Lambda$292.0x0000000800dac928", "jdk.internal.net.http.Http1Response$ClientRefCountTracker", "jdk.internal.net.http.frame.SettingsFrame", "toByteArray", "jdk.internal.net.http.Http1Exchange$$Lambda$275.0x0000000800da7db8", "jdk.internal.net.http.ConnectionPool$ExpiryList", "purgeUntil", "descendingIterator", "java.util.LinkedList$DescendingIterator", "java.util.LinkedList$ListItr", "exceptionallyCompose", "uniComposeExceptionallyStage", "java.util.concurrent.CompletableFuture$UniComposeExceptionally", "getConnection", "jdk.internal.net.http.MultiExchange$$Lambda$263.0x0000000800da5ad0", "lambda$responseAsyncImpl$6", "completedFuture", "java.util.Collections", "unmodifiableMap", "jdk.internal.net.http.ConnectionPool$CacheKey", "sun.nio.ch.SelectorImpl", "lockAndDoSelect", "sun.nio.ch.EPollSelectorImpl", "doSelect", "processEvents", "processReadyEvents", "putVal", "handleParsedRequest", "write", "one.nio.net.Session$ArrayQueueItem", "java.util.HashMap$KeySpliterator", "java.util.concurrent.atomic.AtomicBoolean", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet", "java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1", "java.util.TreeMap$EntryIterator", "registerTimer", "java.util.stream.ForEachOps", "makeRef", "java.util.stream.ForEachOps$ForEachOp$OfRef", "jdk.internal.net.http.MultiExchange$$Lambda$265.0x0000000800da5d18", "java.lang.String[]", "start", "whenCompleteAsync", "jdk.internal.net.http.Http1Response$$Lambda$279.0x0000000800da2910", "lambda$readHeadersAsync$0", "jdk.internal.net.http.Response", "jdk.internal.net.http.HttpClientImpl$$Lambda$213.0x0000000800d8a2b0", "waitingGet", "java.util.concurrent.CompletableFuture$Signaller", "jdk.internal.net.http.Http1HeaderParser$$Lambda$281.0x0000000800da2fa8", "lambda$addHeaderFromString$0", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$257.0x0000000800da4d70", "java.time.Instant", "now", "java.time.Clock", "currentInstant", "ofEpochSecond", "contextRestricted", "CONTEXT_RESTRICTED", "jdk.internal.net.http.common.Utils$$Lambda$273.0x0000000800da74f0", "trim", "jdk.internal.net.http.Http1Response$$Lambda$296.0x0000000800dad1f8", "resize", "java.util.HashMap$Node[]", "appendToOutgoing", "jdk.internal.net.http.Http1Exchange$DataPair", "java.lang.Class", "getConstructor", "jdk.internal.reflect.ReflectionFactory", "copyConstructor", "java.lang.reflect.ReflectAccess", "copy", "putConnection", "getNode", "hashCode", "requestURI", "getPathAndQuery", "java.lang.invoke.LambdaForm$MH.0x0000000800c0fc00", "java.net.http.HttpResponse$BodyHandlers$$Lambda$204.0x0000000800d83650", "java.net.http.HttpResponse$BodyHandlers", "lambda$ofByteArray$12", "java.net.http.HttpResponse$BodySubscribers", "ofByteArray", "java.util.concurrent.CompletableFuture$UniRelay", "getBodyAsync", "jdk.internal.net.http.ResponseSubscribers$$Lambda$294.0x0000000800dacd98", "lambda$getBodyAsync$3", "jdk.internal.net.http.Exchange$$Lambda$280.0x0000000800da2b58", "lambda$wrapForUpgrade$11", "checkForUpgradeAsync", "jdk.internal.net.http.Http1Exchange$$Lambda$260.0x0000000800da5418", "findConnection", "jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription$$Lambda$232.0x0000000800d99f10", "handleSubscribeEvent", "handlePending", "signalOnSubscribe", "int[]", "lambda$responseAsyncImpl$7", "java.lang.invoke.LambdaForm$MH.0x0000000800d80000", "invokeExact_MT", "java.lang.invoke.LambdaForm$DMH.0x0000000800da9800", "java.lang.invoke.LambdaForm$MH.0x0000000800c0c000", "jdk.internal.net.http.Http1Response$$Lambda$246.0x0000000800d9e810", "ok.dht.test.kovalenko.dao.utils.PoolKeeper", "submit", "java.util.concurrent.AbstractExecutorService", "newTaskFor", "java.util.concurrent.Executors", "callable", "jdk.internal.net.http.Exchange$$Lambda$297.0x0000000800dad430", "java.lang.Class[]", "jdk.internal.net.http.PlainHttpConnection", "cacheKey", "jdk.internal.net.http.MultiExchange$$Lambda$211.0x0000000800d89e48", "jdk.internal.net.http.MultiExchange$CancelableRef", "addAll", "responseFilters", "sun.nio.ch.Util$2", "lambda$establishExchange$3", "hostString", "jdk.internal.net.http.ResponseTimerEvent", "jdk.internal.net.http.ConnectionPool$ExpiryEntry", "java.lang.invoke.LambdaForm$MH.0x0000000800da8c00", "java.lang.invoke.LambdaForm$DMH.0x0000000800da8400", "java.util.stream.FindOps$FindSink$OfLong$$Lambda$284.0x0000000800dc7878", "remove", "java.util.AbstractList", "listIterator", "jdk.internal.net.http.HttpClientImpl$SelectorManager$$Lambda$266.0x0000000800da6160", "java.util.concurrent.LinkedBlockingQueue", "java.util.concurrent.LinkedBlockingQueue$Node", "java.util.stream.ForEachOps$ForEachOp", "wrapAndCopyInto", "wrapSink", "opWrapSink", "java.util.stream.ReferencePipeline$2$1", "java.lang.Object", "listOf", "plus", "plusSeconds", "jdk.internal.net.http.TimeoutEvent", "java.time.Duration", "addTo",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function () {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while (performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots,] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount + ")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 + ')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) + ')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(' + value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function () {
        });

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ', ' 1 min : 1 sec ', ' 5 min : 5 sec ', ' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function () {
            });
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();

        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }

        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function () {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function () {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total = heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };


    init();
    // FIXME search(/*highlight:*/);
</script>
</body>
</html>
